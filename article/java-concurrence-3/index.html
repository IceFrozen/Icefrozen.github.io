<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          JAVA多线程之常见的并发工具类(1) - 西木 | Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/article/java-concurrence-3/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">

    <link rel="stylesheet" href="/css/search.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script>hljs.initHighlightingOnLoad();</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/archive.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#JAVA" title="JAVA">JAVA</a>
                            
                              <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
                            
                        </div>
                        <h1>JAVA多线程之常见的并发工具类(1)</h1>
                        <h2 class="subheading">并发工具类举例</h2>
                        <span class="meta">
                            Posted by Jason Lee on
                            2020-05-03
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">木西笔记</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2><span id="概诉">概诉</span></h2>
<p>本文会对java JUC 下的并发包做一个统一的讲解，针对于源码分析环境，需要取查看博主的另外一个系列——<a href="https://icefrozen.github.io/tags/#%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">多线程</a>，这里对细节不在深入。</p>
<ul>
<li>
<p><strong>Semaphore</strong> 信号量是一类经典的同步工具。信号量通常用来限制线程可以同时访问的（物理或逻辑）资源数量。</p>
</li>
<li>
<p><strong>CountDownLatch</strong> 一种非常简单、但很常用的同步辅助类。其作用是在完成一组正在其他线程中执行的操作之前,允许一个或多个线程一直阻塞。</p>
</li>
<li>
<p><strong>CyclicBarrier</strong> 一种可重置的多路同步点，在某些并发编程场景很有用。它允许一组线程互相等待，直到到达某个公共的屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。</p>
</li>
<li>
<p><strong>Phaser</strong> 一种可重用的同步屏障，功能上类似于<code>CyclicBarrier和CountDownLatch</code>，但使用上更为灵活。非常适用于在多线程环境下同步协调分阶段计算任务（Fork/Join框架中的子任务之间需同步时，优先使用Phaser）</p>
</li>
<li>
<p><strong>Exchanger</strong> 允许两个线程在某个汇合点交换对象，在某些管道设计时比较有用。Exchanger提供了一个同步点，在这个同步点，一对线程可以交换数据。每个线程通过exchange()方法的入口提供数据给他的伙伴线程，并接收他的伙伴线程提供的数据并返回。当两个线程通过Exchanger交换了对象，这个交换对于两个线程来说都是安全的。Exchanger可以认为是 SynchronousQueue 的双向形式，在运用到遗传算法和管道设计的应用中比较有用。</p>
</li>
</ul>
<h2><span id="详解">详解</span></h2>
<h1><span id="countdownlatch">CountDownLatch</span></h1>
<h2><span id="功能">功能</span></h2>
<p>等待多线程完成的的同步工具，其作用是在完成一组正在其他线程中执行的操作之前,允许一个或多个线程一直阻塞，在AQS的相关博文中有详细的分析。<a href="https://icefrozen.github.io/article/Java-AQS2/" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)CountDownLatch的分析来解读AQS的共享功能</a></p>
<h2><span id="举例">举例</span></h2>
<p>启动10个线程，当10个线程都执行完毕之后才能继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threads.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) result += j;</span><br><span class="line">            <span class="comment">// 线程执行完毕result 之后，计数器 -1 如果-1 后latch 值还是 &gt; 0 则阻塞</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":finsh result:"</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// CountDownLatch 保证 只有在所有的线程执行完毕之后，才能执行 也就是 CountDownLatch  的值为 0</span></span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"end latch"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="详解">详解</span></h2>
<p>CountDownLatch的核心 其实就两个方法:await和countDown，我们先来看CountDownLatch的构造方法。</p>
<h3><span id="构造方法">构造方法</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当 status 不为0 则返回失败，根据AQS 的特性，一旦获取失败，则进入等待队列。</span></span><br><span class="line">       <span class="comment">// 具体的 要参考 AQS 的实现</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> c = getState();</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">       <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法中我们看到，CountDownLatch 也是AQS的应用之一，里面的sync变量就是CountDownLatch核心组件了。CountDownLatch 中的核心方法均是围绕着Sync（AQS）组件进行的。</p>
<h3><span id="await-方法">await 方法</span></h3>
<p>CountDownLatch的await方法的作用是使得线程阻塞，当然，阻塞是有条件的。只有Sync的值为0的时候，才会唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取共享锁</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 依赖于 获取共享锁，如果是 返回获取失败，则表示 需要加锁，在构造函数的时候，将status 设置成了一个具体的值，</span></span><br><span class="line">        <span class="comment">// 所以在调用 await 的时候，线程阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里加入的都是共享锁的Node</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="countdown-方法">countDown 方法</span></h3>
<p>释放锁，本质是stats - 1 先去释放，如果释放成功，去唤醒所有的共享锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 可以看到，这里如果 tryReleaseShared 释放成功，以为这status == 0 </span></span><br><span class="line">        <span class="comment">// 释放所有的共享Node</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="cyclicbarrier">CyclicBarrier</span></h1>
<h2><span id="功能">功能</span></h2>
<p>一种可重置的多路同步点，在某些并发编程场景很有用。它允许一组线程互相等待，直到到达某个公共的屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 <em>CyclicBarrier</em> 很有用。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。<br>
看下图：</p>
<p><img src="/article/java-concurrence-3/java-concurrence-3-125404.png" alt></p>
<h2><span id="举例">举例</span></h2>
<p>一下例子，表示只有所有的线程都执行完成之后，才能继续进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTestCyclicBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threads.length, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"============ wake up all ============"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">": await"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">": wake up wait:"</span> + (System.currentTimeMillis() - l));</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="详解">详解</span></h2>
<h3><span id="构造函数">构造函数</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，当前屏障是否被破坏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实现的Lock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition用来实现wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** 等待的屏障数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* 到达屏障要执行的Runnable */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment">     * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment">     * generation or when broken.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从CyclicBarrier的成员来看，它本质上是基于ReentrantLock独占锁实现，通过Lock和Condition的结合，在加上计数器来实现。它的核心方法是await()。</p>
<h3><span id="核心await-方法">核心await 方法</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">/**获取CyclicBaerrier的内部锁*/</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">/**获取锁*/</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**存储当前的Generation*/</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">/**判断当前的屏障是否被破坏，如果破坏则抛出BrokenBarrierException异常*/</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">/**判断当前线程是否被interrupted，如果被打断，则breakBarrier破坏屏障*/</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/**记录当前屏障等待个数*/</span> </span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 最后一个预留到达屏障的线程</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="comment">/**执行barrierCommand指令*/</span></span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">/**执行下一个Generation*/</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">/**如果barrierCommand执行失败，进行屏障破坏处理*/</span></span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程不是最后一个到达的线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)<span class="comment">///调用Condition的await()方法阻塞</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)<span class="comment">///调用Condition的awaitNanos()方法阻塞</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">/**如果当前线程被中断，则判断是否有其他线程已经使屏障破坏。若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程*/</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，核心的思想就是先判断当前执行的线程是否到达了最后一个屏障，如果到达最后一个屏障：“判断barrierCommand是否为空，不为空执行barrierCommand任务，接着执行nextGeneration方法。在nextGeneration方法中通过Condition的signalAll唤醒其它阻塞的线程开始继续执行。”</p>
<h1><span id="semaphore">Semaphore</span></h1>
<h2><span id="功能">功能</span></h2>
<p>Semaphore管理着一组许可（permit）,许可的初始数量可以通过构造函数设定，操作时首先要获取到许可，才能进行操作，操作完成后需要释放许可。如果没有获取许可，则阻塞到有许可被释放。如果初始化了一个许可为1的Semaphore，那么就相当于一个不可重入的互斥锁</p>
<p>Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。</p>
<h2><span id="举例">举例</span></h2>
<p>洗手间是有10个槽位，在同一时刻，只能为10个人提供该服务。<code>Semaphore</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSemaphore</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">10</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; washRoom= <span class="keyword">new</span> HashMap&lt;&gt;(solt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        washRoom.put(i, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是有10个槽位，所以每次是能有10个线程执行</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(solt);</span><br><span class="line">    Runnable r  = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有获取到坑位，则阻塞</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="keyword">int</span> name = Integer.parseInt(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> index = name % <span class="number">10</span>;</span><br><span class="line">            List&lt;String&gt; list = washRoom.get(index);</span><br><span class="line">            list.add(name + <span class="string">""</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt * <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.setName(i + <span class="string">""</span>);</span><br><span class="line">        threads[i] =  thread;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(washRoom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="详解">详解</span></h2>
<h3><span id="构造函数">构造函数</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="acquire">acquire</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="release">release</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 Semaphore 的本质是一个基于 AQS的共享锁的方法，这里不做具体的分析。</p>
<h1><span id="phaser">Phaser</span></h1>
<h2><span id="功能">功能</span></h2>
<table>
<thead>
<tr>
<th>同步器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CountDownLatch</td>
<td>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归0后，所有等待的线程继续执行</td>
</tr>
<tr>
<td>CyclicBarrier</td>
<td>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</td>
</tr>
<tr>
<td>Phaser</td>
<td>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>phase(阶段)<br>
我们知道，在CyclicBarrier中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。Phaser也有栅栏，在Phaser中，栅栏的名称叫做<strong>phase(阶段)</strong>，在任意时间点，Phaser只处于某一个phase(阶段)，初始阶段为0，最大达到<strong>Integerr.MAX_VALUE</strong>，然后再次归零。当所有<strong>parties参与者都到达后，phase值会递增</strong>。</p>
</li>
<li>
<p>parties(参与者)<br>
parties(参与者)其实就是CyclicBarrier中的参与线程的概念。CyclicBarrier中的参与者在初始构造指定后就不能变更，而Phaser既可以在初始构造时指定参与者的数量，也可以中途通过register、bulkRegister、arriveAndDeregister等方法注册/注销参与者。</p>
</li>
<li>
<p>arrive(到达) / advance(进阶)<br>
Phaser注册完parties（参与者）之后，参与者的初始状态是unarrived的，当参与者到达（arrive）当前阶段（phase）后，状态就会变成arrived。当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生进阶（advance）——也就是phase值+1。</p>
</li>
</ul>
<h2><span id="举例">举例</span></h2>
<h3><span id="example1">Example1</span></h3>
<p>有时候我们希望所有线程到达指定点后再同时开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> solt = <span class="number">3</span>;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行开始任务:"</span> + phaser.getPhase());</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase:"</span> + i + <span class="string">"="</span> + phaser.getPhase());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 注册solt个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        phaser.register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用</span></span><br><span class="line">    <span class="comment">//phaser.bulkRegister(solt);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample1-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> registeredParties = phaser.getRegisteredParties();</span><br><span class="line">    <span class="keyword">int</span> arrivedParties = phaser.getArrivedParties();</span><br><span class="line">    System.out.println(<span class="string">"registeredParties:"</span> + registeredParties);</span><br><span class="line">    System.out.println(<span class="string">"arrivedParties:"</span> + arrivedParties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PhaserTestExample1-0: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-1: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-2: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-2: 执行完任务，当前phase:1=1</span><br><span class="line">PhaserTestExample1-1: 执行完任务，当前phase:1=1</span><br><span class="line">PhaserTestExample1-0: 执行完任务，当前phase:1=1</span><br><span class="line">registeredParties:3</span><br><span class="line">arrivedParties:0</span><br></pre></td></tr></table></figure>
<p>以上示例中，创建了3个线程，并通过 <code>register</code> 或者 <code>bulkRegister</code>，方法注册Phaser的参与者数量为3。当某个线程调用<code>arriveAndAwaitAdvance</code> 方法后，<code>arrive</code>数量会加1，如果数量没有满足总数（参与者数量3），当前线程就是一直等待，当最后一个线程到达后，phase(阶段) 会 + 1， 然后所有线程都会继续往下执行。</p>
<blockquote>
<p>注意：arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考awaitAdvanceInterruptibly方法。</p>
</blockquote>
<h3><span id="example2">Example2</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//注册主线程,当外部条件满足时,由主线程打开开关</span></span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":任务准备"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + i + <span class="string">""</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    phaser.bulkRegister(solt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample2-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部条件:等待用户输入命令</span></span><br><span class="line">    System.out.println(<span class="string">"Press ENTER to continue"</span>);</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    reader.readLine();</span><br><span class="line">    <span class="comment">// 放开阀门 主线程打开了开关</span></span><br><span class="line">    phaser.arriveAndDeregister();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> registeredParties = phaser.getRegisteredParties();</span><br><span class="line">    <span class="keyword">int</span> arrivedParties = phaser.getArrivedParties();</span><br><span class="line">    System.out.println(<span class="string">"registeredParties:"</span> + registeredParties);</span><br><span class="line">    System.out.println(<span class="string">"arrivedParties:"</span> + arrivedParties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PhaserTestExample2-0:任务准备</span><br><span class="line">PhaserTestExample2-2:任务准备</span><br><span class="line">Press ENTER to continue</span><br><span class="line">PhaserTestExample2-1:任务准备</span><br><span class="line">[输入回车]</span><br><span class="line">PhaserTestExample2-1: 执行完任务，当前phase =1</span><br><span class="line">PhaserTestExample2-0: 执行完任务，当前phase =1</span><br><span class="line">PhaserTestExample2-2: 执行完任务，当前phase =1</span><br><span class="line">registeredParties:3</span><br><span class="line">arrivedParties:0</span><br></pre></td></tr></table></figure>
<p>由于 Phaser 设置的阶段为1 当所有线程到达的时候，发现是阶段到达的阶段是0，不是1，于是所有线程继续等待，当执行 arriveAndDeregister 的时候，所有已经执行到0的阶段参与者都+1， 发现自己到达的阶段和 Phaser 一直，则运行。以上示例中，只有当用户按下回车之后，任务才真正开始执行。这里主线程Main相当于一个协调者，用来控制开关打开的时机，arriveAndDeregister方法不会阻塞，该方法会将到达数加1，同时减少一个参与者数量，最终返回线程到达时的phase值。</p>
<h3><span id="example3">Example3</span></h3>
<p>通过Phaser控制任务的执行轮数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">            <span class="comment">//如果返回 True 则Phaser结束</span></span><br><span class="line">            <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= solt  || registeredParties == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    phaser.bulkRegister(solt);</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123; <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">            <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample3-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------PHASE[<span class="number">0</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br><span class="line">---------------PHASE[<span class="number">1</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">---------------PHASE[<span class="number">2</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br></pre></td></tr></table></figure>
<p>以上示例中，我们在创建Phaser对象时，覆写了onAdvance方法，这个方法类似于CyclicBarrier中的barrierAction任务。<br>
也就是说，当最后一个参与者到达时，会触发onAdvance方法，入参phase表示到达时的phase值，registeredParties表示到达时的参与者数量，返回true表示需要终止Phaser。</p>
<p>我们通过phase + 1 &gt;= repeats ，来控制阶段（phase）数的上限为2（从0开始计），最终控制了每个线程的执行任务次数为repeats次。如果返回 True 则Phaser结束</p>
<h3><span id="example4">Example4</span></h3>
<p>Phaser支持分层功能，我们先来考虑下如何用利用Phaser的分层来实现高并发时的优化，在示例三中，我们其实创建了10个线程，然后10个线程共用一个Phaser对象，如下图：</p>
<p><img src="/article/java-concurrence-3/java-concurrence-3-1615185688374.png" alt></p>
<p>如果任务数继续增大，那么同步产生的开销会非常大，利用Phaser分层的功能，我们可以限定每个Phaser对象的最大使用线程（任务数），如下图：</p>
<p><img src="/article/java-concurrence-3/java-concurrence-3-1615185703185.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASKS_PER_PHASER = <span class="number">4</span>;      <span class="comment">// 每个Phaser对象对应的工作线程（任务）数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">                <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Tasker[] taskers = <span class="keyword">new</span> Tasker[<span class="number">10</span>];</span><br><span class="line">        build(taskers, <span class="number">0</span>, taskers.length, phaser);       <span class="comment">// 根据任务数,为每个任务分配Phaser对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskers.length; i++) &#123;          <span class="comment">// 执行任务</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(taskers[i]);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Tasker[] taskers, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Phaser phaser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &gt; TASKS_PER_PHASER) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i += TASKS_PER_PHASER) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">                build(taskers, i, j, <span class="keyword">new</span> Phaser(phaser));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; ++i)</span><br><span class="line">                taskers[i] = <span class="keyword">new</span> Tasker(i, phaser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tasker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        Tasker(<span class="keyword">int</span> i, Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">            <span class="keyword">this</span>.phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!phaser.isTerminated()) &#123;   <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">                <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务, index:"</span> + <span class="keyword">this</span>.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---------------PHASE[0],Parties[3] ---------------</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">---------------PHASE[1],Parties[3] ---------------</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">---------------PHASE[2],Parties[3] ---------------</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br></pre></td></tr></table></figure>
<h2><span id="详解">详解</span></h2>
<p>由于Phaser的实现过于复杂，本篇章不做详解，又想去请看Phaser的源码分析</p>
<h1><span id="exchanger">Exchanger</span></h1>
<h2><span id="功能">功能</span></h2>
<p>Exchanger类允许在2个线程间定义同步点，当2个线程到达这个点，他们相互交换数据类型，使用第一个线程的数据类型变成第二个的，然后第二个线程的数据类型变成第一个的</p>
<h2><span id="举例">举例</span></h2>
<p>以下的例子，将两个线程间的线程名交换，交换之前阻塞状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchangerTestExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String myName = Thread.currentThread().getName();</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(myName + <span class="string">" want to exchange data and i waiting"</span>);</span><br><span class="line">            String hisName = exchanger.exchange(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(myName + <span class="string">": "</span> + hisName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"exchangerTestExample-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exchangerTestExample-1 want to exchange data and i waiting</span><br><span class="line">[...]</span><br><span class="line">exchangerTestExample-0 want to exchange data and i waiting</span><br><span class="line">exchangerTestExample-0: exchangerTestExample-1</span><br><span class="line">exchangerTestExample-1: exchangerTestExample-0</span><br></pre></td></tr></table></figure>
<p>根据上面的输出，我们得出结论，当第一个线程阻塞在 <code>exchanger.exchange(Thread.currentThread().getName())</code> 方法中，因为 exchanger 没有数据因而线程阻塞，当第二个线程执行到 相同的位置的时候，发现里面有数据，则立刻交换，并且唤醒第一个线程。</p>
<h2><span id="详解">详解</span></h2>
<p>Exchanger 是一种无锁算法</p>
<h3><span id="构造">构造</span></h3>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除非当前线程被中断，否则一直等待另一个线程到达这个交换点，然后将交换的数据	x传输给它，并收到另一个线程传过来的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 和上一个方法功能基本一样，只不过这个方法增加了等待超时时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure>
<h3><span id="participant-和-node">Participant 和 Node</span></h3>
<p>Participant 是将 Node 封装成了  ThreadLocal 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Node 结构如下</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;                  <span class="comment">// arena的下标，多个槽位的时候利用</span></span><br><span class="line">    <span class="keyword">int</span> bound;                  <span class="comment">// 上一次记录的Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> collides;               <span class="comment">// 在当前bound下CAS失败的次数；</span></span><br><span class="line">    <span class="keyword">int</span> hash;                   <span class="comment">// 用于自旋；</span></span><br><span class="line">    Object item;                <span class="comment">// 这个线程的当前项，也就是需要交换的数据；</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;      <span class="comment">//做releasing操作的线程传递的项；</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked;     <span class="comment">//挂起时设置线程值，其他情况下为null；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们讲几个概念</p>
<ul>
<li>index：arena的下标，多个槽位的时候利用；</li>
<li>bound：上一次记录的Exchanger.bound；</li>
<li>collides：在当前bound下CAS失败的次数；</li>
<li>hash：伪随机数，用于自旋；</li>
<li>item：这个线程的当前项，也就是需要交换的数据；</li>
<li>match：交换的数据；</li>
<li>parked：挂起时设置线程值，其他情况下为null；</li>
</ul>
<p>我们现阶段先对这个几个有个印象，接下来我们详细分析一下交换的过程。</p>
<h3><span id="exchange-方法">exchange 方法</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// NULL_ITEM 是一个替代的对象，这里可以简单理解为默认值</span></span><br><span class="line">    <span class="comment">// 主要是因为 slotExchange 和  arenaExchange 并没有做非空的判断</span></span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">        (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// disambiguates null return</span></span><br><span class="line">        (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Elimination array; null until enabled (within slotExchange).</span></span><br><span class="line"><span class="comment"> * Element accesses use emulation of volatile gets and CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br></pre></td></tr></table></figure>
<p>我们看到这里有几个核心点</p>
<ol>
<li>slotExchange 方法</li>
<li>arenaExchange 方法</li>
<li>arena 是干什么用的。</li>
</ol>
<p>看到这，我们首先解决几个核心属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Participant participant;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node slot;</span><br></pre></td></tr></table></figure>
<p>为什么会有 arena数组槽? slot为单个槽，arena为数组槽, 他们都是Node类型。在这里可能会感觉到疑惑，slot作为Exchanger交换数据的场景，应该只需要一个就可以了啊?</p>
<p>为何还多了一个Participant 和数组类型的arena呢?</p>
<p>一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是Exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争是才会生成arena数组。 那么怎么将Node与当前线程绑定呢？<br>
Participant，Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中记录在arena中的下标index。</p>
<p>根据逻辑，我们可以知道，当arena 为空或者 <code>slotExchange</code> 为空的时候，执行 <code>arenaExchange</code> 方法。当我们第一次调用exchange 方法的时候，必然 arena 为空。我们往下看，看看 <code>slotExchange</code> 究竟干甚了什么？</p>
<h3><span id="slotexchange">slotExchange</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程node对象</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();  </span><br><span class="line">    <span class="comment">// 若果线程被中断，就直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="comment">// 将slot值赋给q</span></span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line">            <span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里表示当前线程是以第一个线程进来交换数据</span></span><br><span class="line">            <span class="comment">// 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程</span></span><br><span class="line">            <span class="comment">// 将需要交换的数据先存放在当前线程变量p中 </span></span><br><span class="line">            <span class="comment">// 这里将 第一个想成的Node 放到了 solt 当中</span></span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot</span></span><br><span class="line">            <span class="comment">// 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="comment">// 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，</span></span><br><span class="line">    <span class="comment">// 等待其它线程交换数据然后唤醒当前线程</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot</span></span><br><span class="line">    <span class="comment">// 如果另一个线程 将p.match 设置上，这里就可以跳出自选了</span></span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 下面的逻辑主要是自旋等待，直到spins递减到0为止</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// h 表示一个随机数 这样计算似的 h 可以在正负当中来回摆动 概率是1：1</span></span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 让出cpu</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果slot ！= p 证明已经有一个线程准备搞好了，这时候需要回到 while 判断match 是否存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="comment">// 此处表示未设置超时或者时间未超时 需要将本线程阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 给p挂机线程的值赋值</span></span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                <span class="comment">// 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arena不为null则v为null,其它为超时则v为超时对象TIMED_OUT，并且跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序首先通过participant获取当前线程节点Node。检测是否中断，如果中断return null，等待后续抛出InterruptedException异常。
<ul>
<li>
<p>如果slot不为null，则进行slot消除，成功直接返回数据V，否则失败，则创建arena消除数组。 (如果slot不为null 则证明第一个进入交换区的线程已经准备好数据也就是拿到了q,然后让将自己的q 赋值给match， 然后惊醒slot消除)</p>
</li>
<li>
<p>如果slot为null，但arena不为null，则返回null，进入arenaExchange逻辑。 (arena 不为null 的逻辑在solt 不为null 且赋值 <strong><em>U.compareAndSwapObject(this, SLOT, q, null)</em></strong> 失败),证明一瞬间 SLOT 发生了金正，改变了原来的非Q的状态。</p>
</li>
<li>
<p>如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入spin+block(自旋+阻塞)模式。</p>
</li>
<li>
<p>在自旋+阻塞模式中，首先取得结束时间和自旋次数。如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋(改自旋使用当前节点中的hash，并改变之)和退让。当自旋数为0后，假如slot发生了改变(slot != p)则重置自旋数并重试。</p>
</li>
<li>
<p>否则假如：当前未中断&amp;arena为null&amp;(当前不是限时版本或者限时版本+当前时间未结束)：阻塞或者限时阻塞。假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：不限时版本：置v为null；限时版本：</p>
</li>
<li>
<p>如果时间结束以及未中断则TIMED_OUT；否则给出null(原因是探测到arena非空或者当前线程中断)。 match不为空时跳出循环。</p>
</li>
</ul>
</li>
</ul>
<h3><span id="arenaexchange">arenaExchange</span></h3>
<p>此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据。</p>
<p>Exchanger最复杂的地方就是它的多槽位交换（arenaExchange），我们先看下，什么时候会触发多槽位交换？</p>
<p>单槽交换（slotExchange）中有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">    <span class="comment">// 将slot值赋给q</span></span><br><span class="line">    <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line">        <span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Object v = q.item;</span><br><span class="line">            q.match = item;</span><br><span class="line">            Thread w = q.parked;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(w);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">        <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">            arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果在单槽交换中，同时出现了多个配对线程竞争修改slot槽位，导致某个线程CAS修改slot失败时，就会初始化arena多槽数组，后续所有的交换都会走arenaExchange,多槽交换方法arenaExchange的整体流程和slotExchange类似，主要区别在于它会根据当前线程的数据携带结点Node中的index字段计算出命中的槽位。如果槽位被占用，说明已经有线程先到了，之后的处理和slotExchange一样；<br>
如果槽位有效且为null，说明当前线程是先到的，就占用槽位，然后按照：spin-&gt;yield-&gt;block这种锁升级的顺序进行优化的等待，等不到配对线程就会进入阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timed 为true表示设置了超时时间，ns为&gt;0的值，反之没有设置超时时间</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">arenaExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">        Node[] a = arena;</span><br><span class="line">        <span class="comment">// 获取当前线程中的存放的node</span></span><br><span class="line">        Node p = participant.get();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p.index;;) &#123;                      <span class="comment">// access slot at i</span></span><br><span class="line">            <span class="keyword">int</span> b, m, c; <span class="keyword">long</span> j;                       <span class="comment">// j is raw array offset</span></span><br><span class="line">            Node q = (Node)U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; U.compareAndSwapObject(a, j, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;                     <span class="comment">// release</span></span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.item = item;                         <span class="comment">// offer</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, <span class="keyword">null</span>, p)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> end = (timed &amp;&amp; m == <span class="number">0</span>) ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">                    Thread t = Thread.currentThread(); <span class="comment">// wait</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = p.hash, spins = SPINS;;) &#123;</span><br><span class="line">                        Object v = p.match;</span><br><span class="line">                        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">                            p.item = <span class="keyword">null</span>;             <span class="comment">// clear for next use</span></span><br><span class="line">                            p.hash = h;</span><br><span class="line">                            <span class="keyword">return</span> v;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>; <span class="comment">// xorshift</span></span><br><span class="line">                            <span class="keyword">if</span> (h == <span class="number">0</span>)                <span class="comment">// initialize hash</span></span><br><span class="line">                                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp;          <span class="comment">// approx 50% true</span></span><br><span class="line">                                     (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                                Thread.yield();        <span class="comment">// two yields per wait</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) != p)</span><br><span class="line">                            spins = SPINS;       <span class="comment">// releaser hasn't set match yet</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; m == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                 (!timed ||</span><br><span class="line">                                  (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">                            U.putObject(t, BLOCKER, <span class="keyword">this</span>); <span class="comment">// emulate LockSupport</span></span><br><span class="line">                            p.parked = t;              <span class="comment">// minimize window</span></span><br><span class="line">                            <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">                            p.parked = <span class="keyword">null</span>;</span><br><span class="line">                            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                                 U.compareAndSwapObject(a, j, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (m != <span class="number">0</span>)                <span class="comment">// try to shrink</span></span><br><span class="line">                                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ - <span class="number">1</span>);</span><br><span class="line">                            p.item = <span class="keyword">null</span>;</span><br><span class="line">                            p.hash = h;</span><br><span class="line">                            i = p.index &gt;&gt;&gt;= <span class="number">1</span>;        <span class="comment">// descend</span></span><br><span class="line">                            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">if</span> (timed &amp;&amp; m == <span class="number">0</span> &amp;&amp; ns &lt;= <span class="number">0L</span>)</span><br><span class="line">                                <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                            <span class="keyword">break</span>;                     <span class="comment">// expired; restart</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.item = <span class="keyword">null</span>;                     <span class="comment">// clear offer</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.bound != b) &#123;                    <span class="comment">// stale; reset</span></span><br><span class="line">                    p.bound = b;</span><br><span class="line">                    p.collides = <span class="number">0</span>;</span><br><span class="line">                    i = (i != m || m == <span class="number">0</span>) ? m : m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                         !U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ + <span class="number">1</span>)) &#123;</span><br><span class="line">                    p.collides = c + <span class="number">1</span>;</span><br><span class="line">                    i = (i == <span class="number">0</span>) ? m : i - <span class="number">1</span>;          <span class="comment">// cyclically traverse</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = m + <span class="number">1</span>;                         <span class="comment">// grow</span></span><br><span class="line">                p.index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="总结">总结</span></h3>
<h2><span id="参考">参考</span></h2>
<ul>
<li><a href="https://blog.csdn.net/luoyoub/article/details/80635652" target="_blank" rel="noopener">JUC五种常见同步工具类总结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38012490" target="_blank" rel="noopener">Java并发编程——CyclicBarrie</a></li>
<li><a href="https://segmentfault.com/a/1190000015979879" target="_blank" rel="noopener">Java多线程进阶（二二）—— J.U.C之synchronizer框架：Phaser</a></li>
<li><a href="https://blog.csdn.net/qq_38293564/article/details/80564183" target="_blank" rel="noopener">Java并发编程之Exchanger详解</a></li>
<li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html" target="_blank" rel="noopener">JUC工具类: Exchanger详解</a></li>
</ul>

        
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/java-concurrence-2-1/" data-toggle="tooltip" data-placement="top" title="JAVA多线程之Atomic和LongAddr类（2）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/java-concurrence-2/" data-toggle="tooltip" data-placement="top" title="JAVA多线程之Atomic和LongAddr类（1）">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="alipay_url"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="wechatpay_url"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">概诉</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">详解</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">CountDownLatch</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">举例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">构造方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">await 方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">countDown 方法</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">CyclicBarrier</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">举例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">构造函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">核心await 方法</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">Semaphore</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">举例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">构造函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">acquire</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">release</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">Phaser</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">举例</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Example1</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Example2</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">Example3</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">Example4</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">详解</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">Exchanger</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">举例</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">构造</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">Participant 和 Node</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">exchange 方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">slotExchange</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">arenaExchange</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">参考</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#JAVA" title="JAVA">JAVA</a>
                        
                          <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a.toc-nav-text',function(a){
            document.getElementById(a.target.innerText.replace(/\s/g,'').replace(/\./g,'-').toLowerCase()).scrollIntoView(true);
            document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/u/2028033763">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/IceFrozen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jason Lee 2022 
                    <br>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="#">JasonLess</a> | 
                    <!-- <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="#" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Custom Theme search -->
<script src="/js/search.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- search code -->

    <script type="text/javascript">      
      var search_path = "search.xml";
      if (search_path.length == 0) {
          search_path = "search.xml";
      }
      var path = "/" + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
    </script>
 

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>
