<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          JAVA多线程之Atomic和LongAddr类（1） - 西木 | Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/article/java-concurrence-2/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">

    <link rel="stylesheet" href="/css/search.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script>hljs.initHighlightingOnLoad();</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/archive.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
                            
                        </div>
                        <h1>JAVA多线程之Atomic和LongAddr类（1）</h1>
                        <h2 class="subheading">Atomic类详解</h2>
                        <span class="meta">
                            Posted by Jason Lee on
                            2020-05-03
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">西木凌萧</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2><span id="概述">概述</span></h2>
<h2><span id="atomic与longaddr解决什么问题">Atomic与LongAddr解决什么问题</span></h2>
<p>解决变量赋值的原子性问题。 底层采用的是CAS的自旋的方式来实现的。CAS会有ABA和性能的问题，Atomic 采用版本号的方式来解决ABA的问题。ABA问题是否会对业务产生影响，还需要业务方自己评估，大部分情况下比如一些非金融业务系统中，ABA不会对业务造成影响。<br>
至于性能问题，CAS自旋的方式确实会造成一些CPU的空转，因为严格意义上来说CAS不能算是锁，所以说CAS的也有适用范围。</p>
<p>自旋操作适用于线程竞争力度大，线程执行时间比较短的情况。这种情况下，CAS自旋空转的等待时间表少，如线程运行时间比较长，最好的方式还是使用重量级的锁，比如说 synchronized AQS等重量级的锁。</p>
<h2><span id="atomic类与longaddr类简单对比">Atomic类与LongAddr类简单对比</span></h2>
<p>我们来看一个实例程序 分别来计算 <code>synchronized</code>,<code>Atomic</code>,<code>LongAdder</code> 运行N秒，累加数量的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例： 同时运行5秒，检查谁的次数最多</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Atomic方式</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong acount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// LongAdder 方式  （jdk1.8,新计数器）</span></span><br><span class="line">    <span class="keyword">private</span> LongAdder lacount = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    <span class="comment">// 运行时间，毫秒数</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> time=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 同步代码块的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"SyncThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + count);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    acount.incrementAndGet(); <span class="comment">// acount++;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"AtomicThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + acount.incrementAndGet());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLongAdder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    lacount.increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"LongAdderThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + lacount.sum());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdderDemo demo = <span class="keyword">new</span> LongAdderDemo();</span><br><span class="line">        demo.testSync();</span><br><span class="line">        demo.testAtomic();</span><br><span class="line">        demo.testLongAdder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看耗时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832099</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832100</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832101</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309048936</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309098061</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309356235</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从耗时就可以看出来，在相同的时间内，LongAddr执行的效率最高，可以是sync关键字的2倍，是Atomic的1.5倍左右。<br>
本次的数据仅在这个测试用例中生效。每个单元的执行效率还是要根据具体的业务来看。</p>
</blockquote>
<h2><span id="类图">类图</span></h2>
<p><img src="/article/java-concurrence-2/java-concurrence-2-211756.png" alt></p>
<h2><span id="atomic-详解">Atomic 详解</span></h2>
<h2><span id="atomic-家族概述">Atomic 家族概述</span></h2>
<ul>
<li><strong>AtomicBoolean</strong>  boolean 类型的atomic类</li>
<li><strong>AtomicInteger</strong>  Integer 类型 atomic 类</li>
<li><strong>AtomicIntegerArray</strong>  List元素为Integer ，且元素支持原子更新的类</li>
<li><strong>AtomicIntegerFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新</li>
<li><strong>AtomicLong</strong>    Long类型的atomic类</li>
<li><strong>AtomicLongArray</strong> List元素为Long ，且元素支持原子更新的类</li>
<li><strong>AtomicLongFieldUpdater</strong>   基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新</li>
<li><strong>AtomicMarkableReference</strong> 是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。</li>
<li><strong>AtomicReference</strong> 提供了一个可以原子读写的对象引用变量</li>
<li><strong>AtomicReferenceArray</strong>  List元素为引用类型 ，且元素支持原子更新的类</li>
<li><strong>AtomicReferenceFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile object 字段进行原子更新</li>
<li><strong>AtomicStampedReference</strong> 是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。</li>
</ul>
<h2><span id="atomic-详解">Atomic 详解</span></h2>
<p>下面我们来具体分析一下 <code>AtomicInteger</code> 这个类<br>
AtomicInteger 的核心字段一共有三个</p>
<ol>
<li>unsafe 对象</li>
<li>value 值</li>
<li>valueOffset在对象中的偏移量</li>
</ol>
<p>方法如下图：</p>
<p><img src="/article/java-concurrence-2/java-concurrence-2-102243.png" alt></p>
<ul>
<li>Unsafe 更新值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// atomic 具体的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>几个核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unsafe 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 省略其他</span></span><br></pre></td></tr></table></figure>
<p>从这个方法就能看出，其实Atomic其实调用的是Unsafe类中的 <code>do while</code> 代码块来实现CAS交换的，而<code>Unsafe</code>中这个方法<code>compareAndSwapInt</code>是一个Native的方法。</p>
<p>unsafe对象在类初始化的时候，已经将<code>Atomic</code> 中用于存放直的value 的偏移量生成 <code>valueOffset</code>， 用于更新操作。<br>
再在更新的时候，调用 <code>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</code> 方法，意思是，将本类的<code>valueOffset</code>的偏移量更新成<code>update</code>值，如果<code>this</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。</p>
<p>我们来看一下OpenJDK中的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a> 方法</p>
<ul>
<li>CAS底层原理</li>
</ul>
<p>CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//openjdk-jdk8u源码：/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>compareAndSwapInt</code> 和  compareAndSwapLong 实现是在 <code>Unsafe_CompareAndSwapInt</code> 和 <code>Unsafe_CompareAndSwapLong</code><br>
下面我们深入到 <code>Unsafe_CompareAndSwapInt</code> 中去。</p>
<h3><span id="unsafe_compareandswapint-方法">Unsafe_CompareAndSwapInt 方法</span></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  <span class="comment">// p是取出的对象</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// addr是p中offset处的地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();   <span class="comment">// &gt;1 = true</span></span><br><span class="line">  <span class="comment">// __asm__说明是ASM汇编，__volatile__禁止编译器优化</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">                    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">                    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">                    : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br><span class="line"><span class="string">  return exchange_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp</span></span><br><span class="line"><span class="string">static inline bool is_MP() &#123;</span></span><br><span class="line"><span class="string">    assert(_processor_count &gt; 0, "</span>invalid processor count<span class="string">");</span></span><br><span class="line"><span class="string">    // 我们可以利用 -XX:-AssumeMP 这个参数关闭多核运行状态 </span></span><br><span class="line"><span class="string">    return _processor_count &gt; 1 || AssumeMP;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">static int _processor_count;              // number of processors</span></span><br></pre></td></tr></table></figure>
<p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌汇编模板</span></span><br><span class="line"><span class="comment">// 第1行：汇编语句</span></span><br><span class="line">asm ( assembler template</span><br><span class="line">     <span class="comment">// 第2行：输出参数，以','分割</span></span><br><span class="line">      : <span class="function">output <span class="title">operands</span>               <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">     <span class="comment">// 第3行：输入参数，以','分割</span></span></span><br><span class="line"><span class="function">      : input <span class="title">operands</span>                <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">      : list of clobbered registers   </span></span><br><span class="line"><span class="function">        <span class="params">(optional)</span>   </span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>对照下面的源码，关键字<code>asm</code>和<code>__asm__</code>用于说明随后的字符串是内联汇编代码块。<code>volatile</code> 或 <code>__volatile__</code> 是可选的，可以将它们添加到 <code>asm</code> 后面，禁止某些编译器的优化。其实，<code>asm</code>和<code>__asm__</code>几乎是相同的，惟一的区别是，当预处理程序宏中使用内联汇编时，<code>asm</code>在编译过程中可能会引发警告，<code>volatile</code>也是同样的道理。因此Atomic::cmpxchg函数中汇编指令部分源码可以作如下解读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义表达的意思，后面再说</span></span><br><span class="line"><span class="comment">// 第1行：表示汇编指令 cmpxchgl</span></span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">    <span class="comment">// 输出参数，"=a"表示把数据保存到eax寄存器中，"="表示这类操作数是只写的</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 这里的意思就是把 exchange_value的值保存到CPU的eax寄存器当中 (输出参数)</span></span></span><br><span class="line"><span class="function">    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">    // 输入参数："</span>r<span class="string">"表示任意寄存器，"</span>a<span class="string">"表示eax寄存器</span></span><br><span class="line"><span class="string">    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">    // 这里列出需要使用的寄存器：cc表示汇编代码将改变条件寄存器，memory表示有内存被修改</span></span><br><span class="line"><span class="string">    // 前面也提到过，这里仅列出指令改变的寄存器，输入输出使用的寄存器不放入其中，因此'a'不需要放到这儿</span></span><br><span class="line"><span class="string">    // 如果汇编指令修改了eax而输入输出没有用到eax，那么就需要在这儿加上'a'</span></span><br><span class="line"><span class="string">     : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>cmpxchgl %1,(%3)</code> 中的 %1 和 %3 中的数字表示参数列表：[&quot;=a&quot; (exchange_value),“r” (exchange_value),“a” (compare_value),“r” (dest), “r” (mp)] 的下标，这里指的是<code>&quot;r&quot; (exchange_value)</code> 和 <code>&quot;r&quot; (dest)</code></p>
<ul>
<li>compare_value 表示 期望内存中的值，即旧值</li>
<li>exchange_value 表示 更新后的值，即新值</li>
<li>dest 表示 java对象对应属性的内存地址， (dest) 获取地址dest指向的值</li>
</ul>
<p><code>cmpxchg</code>指令即交换比较指令，让目标操作数先和AL，AX，EAX寄存器中的值进行比较：</p>
<ul>
<li>如果相等，将源操作数直接装载到目标操作数，并将寄存器标志位ZF(zero flag)置为1</li>
<li>如果不相等，将目标操作数转载到AL，AX，EAX寄存器，并将ZF清0</li>
</ul>
<p>那上面的代码中哪一个是源操作数，哪一个是目标操作数？这又涉及到汇编语言编程风格的问题，在DOS/Windows下的汇编语言采用Intel风格，而Unix和Linux系统中，更多采用的是AT&amp;T风格，这两者在语法格式上有很大不同，具体到操作数，有如下区别：</p>
<ul>
<li>AT&amp;T 汇编格式：指令 源操作数 目标操作数</li>
<li>Intel汇编格式：指令 目标操作数 源操作数</li>
</ul>
<p>还有一个需要注意的区别就是：操作数的字长。</p>
<ul>
<li>AT&amp;T 汇编格式：由操作符的最后一个字母决定，后缀b、w、l分别表示操作数为字节(byte,8bit)、字(word,16bit)、长字(long,32bit)</li>
<li>Intel汇编格式：用byte ptr、word ptr等前缀来表示，比如：mov al, byte ptr val</li>
</ul>
<p>那么表达式其实就是<code>cmpxchgl exchange_value ,dest</code>。<br>
EAX寄存器中存的是&quot;a&quot; (compare_value)， 也就是<code>cmpxchgl</code>中l表示的寄存器的值也就是期望值，目标操作数是<code>dest</code>指向的值，即内存中存储的值，源操作数是<code>exchange_value</code>，即新值。将期望内存中的值与实际内存值比较，如果相等，则把<code>exchange_value</code>新值装载到dest内存中，并把新值写入<code>EAX</code>中；如果不相等，把<code>dest</code>地址的实际值放入EAX中。</p>
<blockquote>
<p>而C/C++内联汇编的特性架起了这样一座桥梁：一边是C语言，一边是汇编语言，在汇编中可以接收C传过来的参数，并且汇编指令也可以把值写入C语言变量中。</p>
</blockquote>
<p><code>LOCK_IF_MP</code> 是内联函数，定位如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>
<p><code>os::is_MP</code>判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p>
<ul>
<li><strong>cmp $0, #mp</strong>
<ul>
<li>cmp是比较命令，两个操作数：$0表示立即操作数0，理解为常量。</li>
<li>mp为参数，从<code>%4</code>处引用而来，而<code>%4</code>表示 <code>&quot;r&quot;(mp)</code>，即把<code>mp</code>的值存储到任意寄存器。mp如何来？看函数代码的第一句：<code>int mp = os::is_MP()</code>，用于判断是否是多处理器机器, mp 如果为false（表示单核） 那就是0</li>
</ul>
</li>
<li>je lf;
<ul>
<li>je为跳转指令，当ZF=1时，跳转到指定位置，这里表示跳转到标签1</li>
</ul>
</li>
<li>lock :表示Lock前缀</li>
<li>1<br>
表示标签，类似于goto语句 <code>1: cmpxchgl %1,(%3)</code></li>
</ul>
<p>这里便于大家理解，写一个伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmp(var1, var2) &#123;</span><br><span class="line">    zf ;</span><br><span class="line">    <span class="keyword">if</span> (var1 == var2) &#123;</span><br><span class="line">        zf = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zf = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zf</span><br><span class="line">&#125;</span><br><span class="line">zf = cmp(<span class="number">0</span>, mp)  <span class="comment">// zf 标志位 </span></span><br><span class="line"><span class="keyword">if</span> (zf == <span class="number">1</span>) &#123;</span><br><span class="line">    goto:<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lock();</span><br><span class="line">    goto:<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译过来就是，如果是在多处理器上运行则先添加<code>LOCK#</code>前缀后，再执行cmpxchgl命令，如果是单处理器，则直接执行 <code>cmpxchgl</code> 命令。那为什么在多处理器机器上要先添加<code>LOCK#</code>前缀。</p>
<h3><span id="lock前缀">Lock前缀</span></h3>
<p>Lock前缀指令导致在执行指令期间，声言处理器的LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存（因为它会锁住总线，导致其他CPU不能访问总线，也就不能访问系统内存，在Intel486和Pentium处理器中都是这种策略）。</p>
<blockquote>
<p>在最近的处理器里，LOCK# 信号一般不锁总线，而是锁缓存，因为锁总线开销的比较大。在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK# 信号。相反，它会锁定这块区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上的处理器缓存的内存区域数据。</p>
</blockquote>
<p>由于我们操作的是count这个值，这个变量是用<code>volatile</code> 变量修饰的，所以保证了线程见的可见性。关于<code>volatile</code> 变量的细节，我会单独另一篇文章讨论。</p>
<p>下面我们来总结一下：<br>
<strong>当执行CAS操作的时候，我们先判断机器的核数，如果是多核CPU,则调用 lock cmpxchgl 这个汇编执行，lock执行会根据cpu的型号和架构，来选择总线锁还是缓存锁，来实行原子更新。更新之后，由于更新的值为<code>volatile</code> 变量修饰，（JVM层面规定是内存屏障），强制其他核心从主内存当中读值。这样以来就实现了原子更新</strong>。</p>
<h3><span id="unsafe_compareandswaplong-方法">Unsafe_CompareAndSwapLong 方法</span></h3>
<p>在 <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a>  的源码中，Int 和 Long 的swap 略有不同。我们来看一下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapLong"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">p</span> <span class="params">(THREAD, JNIHandles::resolve(obj))</span></span>;</span><br><span class="line">  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));</span><br><span class="line">  <span class="keyword">if</span> (VM_Version::supports_cx8())</span><br><span class="line">    <span class="keyword">return</span> (jlong)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    jboolean success = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 不支持，则直接锁住对象</span></span><br><span class="line">    <span class="function">ObjectLocker <span class="title">ol</span><span class="params">(p, THREAD)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (*addr == e) &#123; *addr = x; success = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>可以看到，如果不支持<code>cx8</code>，那么就需要用到<code>ObjectLocker</code>锁，那么什么 <code>VM_Version::supports_cx8()</code> 的底层实现又是什么呢？篇幅应县个，这里不做详细的分析，源代码在：在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/vm_version.hpp" target="_blank" rel="noopener">vm_version.hpp</a>里</p>
<p>底层则是判断CUP 是否支持 <code>CMPXCHG8B</code> 指令，简单来说就是CUP是否支持对寄存器的8字节的比较。在早期的CUP一般不支持，现代的CPU一般都在会支持。</p>
<h2><span id="atomicreference-类">AtomicReference 类</span></h2>
<p>这个类主要负责对于引用类型的赋值，他的核心代码很简单就是讲原来的<code>compareAndSwapInt</code> 换成了 <code>compareAndSwapObject</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// unsafe类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span> </span>&#123;</span><br><span class="line">    Object var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getObjectVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapObject(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照既定的惯例，我们来找到<code>compareAndSwapObject</code> 的native方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapObject"</span>);</span><br><span class="line">  oop x = JNIHandles::resolve(x_h); <span class="comment">// 新值</span></span><br><span class="line">  oop e = JNIHandles::resolve(e_h); <span class="comment">// 预期值</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// 在内存中的具体位置</span></span><br><span class="line">  HeapWord* addr = (HeapWord *)index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 调用了另一个方法</span></span><br><span class="line">  oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果返回的res等于e，则判定满足compare条件（说明res应该为内存中的当前值），但实际上会有ABA的问题</span></span><br><span class="line">  jboolean success  = (res == e); </span><br><span class="line">  <span class="keyword">if</span> (success) </span><br><span class="line">    <span class="comment">// success为true时，说明此时已经交换成功（调用的是最底层的cmpxchg指令）</span></span><br><span class="line">    <span class="comment">// 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作，配合垃圾收集器</span></span><br><span class="line">    update_barrier_set((<span class="keyword">void</span>*)addr, x); </span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p><code>compareAndSwapObject</code> 方法其实比较的就是两个 <code>Java Object</code> 的地址，如果相等则将新的地址（Java Object）赋给该字段。</p>
<p>我们看一下atomic_compare_exchange_oop 在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/oops/oop.inline.hpp" target="_blank" rel="noopener">oop.inline.hpp</a>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> oop <span class="title">oopDesc::atomic_compare_exchange_oop</span><span class="params">(oop exchange_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">volatile</span> HeapWord *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                oop compare_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">bool</span> prebarrier)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseCompressedOops) &#123; </span><br><span class="line">      <span class="comment">// 如果使用了压缩普通对象指针(CompressedOops)，有一个重新编解码的过程</span></span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((narrowOop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// encode exchange and compare value from oop to T</span></span><br><span class="line">    narrowOop val = encode_heap_oop(exchange_value); <span class="comment">// 新值</span></span><br><span class="line">    narrowOop cmp = encode_heap_oop(compare_value); <span class="comment">// 预期值</span></span><br><span class="line">    <span class="comment">// 这里调用了  cmpxchg 方法</span></span><br><span class="line">    narrowOop old = (narrowOop) Atomic::cmpxchg(val, (narrowOop*)dest, cmp); </span><br><span class="line">    <span class="keyword">return</span> decode_heap_oop(old);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((oop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里表示 执行cmpxchg的汇编指令采用 支持 </span></span><br><span class="line">    <span class="keyword">return</span> (oop)Atomic::cmpxchg_ptr(exchange_value, (oop*)dest, compare_value); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  cmpxchg_ptr 的汇编指令集 和 cmpxchg 不同的是 采用了 cmpxchgq 指令</span></span><br><span class="line">__asm__ __volatile__ (LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgq %1,(%3)"</span></span><br><span class="line">                         : <span class="string">"=a"</span> (exchange_value)</span><br><span class="line">                         : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><br><span class="line">                         : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br><span class="line">    <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="atomicstampedreference-与-atomicmarkablereference">AtomicStampedReference 与  AtomicMarkableReference</span></h2>
<p>上面的普通的CAS操作都会有ABA的问题，其根本原因在于在CAS操作过程中，操作者不知道被操作的只中途是否发生过改变，那么解决方案就很自然，当改变一个只，就给这个值附上一个版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法, 传入引用和戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期值并且 当前版本戳等于预期版本戳, 将更新新的引用和新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期引用, 将更新新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptStamp</span><span class="params">(V expectedReference, <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置当前引用的新引用和版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>
<p>我们来看用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(str1,<span class="number">1</span>);</span><br><span class="line">reference.compareAndSet(str1,str2,reference.getStamp(),reference.getStamp()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>当我们比较时候，不仅要传递<code>expected</code> 和<code>new</code> 值，还要去传递版本戳，我们来看一下他的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>AtomicStampedReference</code> 可以知道，引用变量中途被更改了几次。有时候，我们并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 <code>AtomicMarkableReference。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="atomicreferenceatomicstampedreference与-atomicmarkablereference-的区别">AtomicReference，AtomicStampedReference与 AtomicMarkableReference 的区别</span></h2>
<table>
<thead>
<tr>
<th>类</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AtomicReference</strong></td>
<td>通过volatile和Unsafe提供的CAS函数实现原子操作。 <br>自旋+CAS的无锁操作保证共享变量的线程安全.value是volatile类型，这保证了：当某线程修改value的值时，其他线程看到的value的值都是最新的值，即修改之后的volatile的值通过CAS设置value<br>这保证了：某线程池通过CAS函数（如compareAndSet函数）设置value时，它的操作时原子性的，即线程在操作vu略时不会被中断。<br> 但是CAS操作可能存在ABA问题</td>
</tr>
<tr>
<td><strong>AtomicStampedReference</strong></td>
<td>构造方法中initialStamp（时间戳）用来唯一标识引用变量，在构造器内部，实例化了一个Pair对象，Pair对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现ABA的问题。</td>
</tr>
<tr>
<td><strong>AtomicMarkableReference</strong></td>
<td>AtomicStampedReference 时间戳 只有true 和false</td>
</tr>
</tbody>
</table>
<h2><span id="fieldupdater">FieldUpdater</span></h2>
<p><code>FieldUpdater</code> 包含了<br>
<code>AtomicIntegerFieldUpdater</code>, <code>AtomicLongFieldUpdater</code> 和 <code>AtomicReferenceFieldUpdater</code> 这3个修改类的成员的原子类型的原理和用法相似</p>
<p>以 AtomicIntegerFieldUpdater 为例来分析一下特性及其源码</p>
<h2><span id="特性">特性</span></h2>
<p><code>AtomicIntegerFieldUpdater</code> 可以对指定&quot;类的 <code>volatile int</code> 类型的成员&quot;进行原子更新。它是基于反射原理实现的。<br>
<code>AtomicIntegerFieldUpdater</code> 以下几个限制</p>
<ul>
<li>（1）字段必须是 <strong>volatile</strong> 类型</li>
<li>（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li>
<li>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</li>
<li>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</li>
<li>（5）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</li>
</ul>
<h2><span id="实例代码">实例代码</span></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater aifu = AtomicIntegerFieldUpdater.newUpdater(Student.class, "number");</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> compareAndSet = aifu.compareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.weakCompareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.set(student, <span class="number">1</span>);</span><br><span class="line">        aifu.lazySet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.get(student);</span><br><span class="line">        aifu.getAndSet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndIncrement(student);</span><br><span class="line">        aifu.getAndDecrement(student);</span><br><span class="line">        aifu.getAndAdd(student, <span class="number">1</span>);</span><br><span class="line">        aifu.incrementAndGet(student);</span><br><span class="line">        aifu.decrementAndGet(student);</span><br><span class="line">        aifu.addAndGet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndUpdate(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.updateAndGet(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.getAndAccumulate(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.accumulateAndGet(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AtomicIntegerFieldUpdaterDemo 必须能够访问  number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Student</code> number 是private 修饰的，则会抛出 <code>$Student with modifiers &quot;private volatile&quot;</code> 异常</p>
<p>如果我们将<code>Student</code> 放到其他包下，则会抛出 <code>Atomic can not access a member of class {your bean} with modifiers &quot;volatile</code></p>
<h2><span id="源码分析">源码分析</span></h2>
<p>AtomicIntegerFieldUpdater 和  AtomicLongFieldUpdater 实现类有些不同<br>
FieldUpdater 都继承与  AtomicXXFieldUpdater类，这些类提供了CAS的基本方法。</p>
<p>这是AtomicLongFieldUpdater<br>
<img src="/article/java-concurrence-2/java-concurrence-2-141202.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 AtomicIntegerFieldUpdater 底层用的是  AtomicIntegerFieldUpdaterImpl 实现<br>
而  AtomicLongFieldUpdater 底层用的是 CASUpdater 或者 LockedUpdater</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicLongFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                           String fieldName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (AtomicLong.VM_SUPPORTS_LONG_CAS)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CASUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CASUpdater</code> 和  <code>LockedUpdater</code> 区别就在于 是否支持  cmpxchg 源操作数为64个bit的CPU 原语言。我们从这个指令就可以看出 除了long和double类型, Java基本数据类型都是的简单读写都是原子的.</p>
<p><code>LockedUpdater</code> 与 <code>CASUpdater</code> 的区别在于核心的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CASUpdater </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">return</span> U.compareAndSwapLong(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LockedUpdater </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> v = U.getLong(obj, offset);</span><br><span class="line">                <span class="keyword">if</span> (v != expect)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                U.putLong(obj, offset, update);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了 <code>CASUpdater</code> 是直接调用 <code>compareAndSwapLong</code> 方法 而 <code>LockedUpdater</code> 则是通过加锁的方式实现 CAS</p>
<h2><span id="参考">参考</span></h2>
<ul>
<li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li>
<li><a href="https://www.hicsc.com/post/2020031059" target="_blank" rel="noopener">007 番外：JVM CAS机制的实现原理</a></li>
<li><a href="https://chriswhocodes.com/hotspot_options_jdk8.html" target="_blank" rel="noopener">VM Options Explorer - JDK8 HotSpot</a></li>
<li><a href="https://crowhawk.github.io/2018/02/10/volatile/" target="_blank" rel="noopener">Java volatile 关键字底层实现原理解析</a></li>
<li><a href="https://www.zhihu.com/question/65372648" target="_blank" rel="noopener">cas做了锁了总线或缓存行还是volatile做了锁总线或缓存行?</a></li>
<li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp" target="_blank" rel="noopener">os.hpp</a></li>
<li><a href="https://blog.csdn.net/qqqqq1993qqqqq/article/details/75211993" target="_blank" rel="noopener">并发实战——原子类AtomicReference及底层源码CompareAndSwapObject分析</a></li>
</ul>

        
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/java-concurrence-2-1/" data-toggle="tooltip" data-placement="top" title="JAVA多线程之Atomic和LongAddr类（2）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/tcpip-4-SSL-TLS-3/" data-toggle="tooltip" data-placement="top" title="TCP/IP系列(4)-SSL/TSL详解(3)">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="alipay_url"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="wechatpay_url"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">概述</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Atomic与LongAddr解决什么问题</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Atomic类与LongAddr类简单对比</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">类图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">Atomic 详解</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Atomic 家族概述</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">Atomic 详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">Unsafe_CompareAndSwapInt 方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">Lock前缀</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">Unsafe_CompareAndSwapLong 方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">AtomicReference 类</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">AtomicStampedReference 与  AtomicMarkableReference</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">AtomicReference，AtomicStampedReference与 AtomicMarkableReference 的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">FieldUpdater</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">特性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">实例代码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">源码分析</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">参考</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a.toc-nav-text',function(a){
            document.getElementById(a.target.innerText.replace(/\s/g,'').replace(/\./g,'-').toLowerCase()).scrollIntoView(true);
            document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/u/2028033763">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/IceFrozen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jason Lee 2020 
                    <br>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="#">JasonLess</a> | 
                    <!-- <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="#" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Custom Theme search -->
<script src="/js/search.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- search code -->

    <script type="text/javascript">      
      var search_path = "search.xml";
      if (search_path.length == 0) {
          search_path = "search.xml";
      }
      var path = "/" + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
    </script>
 

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>
