<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Redis系列之集群搭建 - 西木 | Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/article/distributed-redis-advanced/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">

    <link rel="stylesheet" href="/css/search.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script>hljs.initHighlightingOnLoad();</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/archive.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                        </div>
                        <h1>Redis系列之集群搭建</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Jason Lee on
                            2020-12-04
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">西木凌萧</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2><span id="redis集群模式">Redis集群模式</span></h2>
<h2><span id="redis-主从集群">Redis 主从集群</span></h2>
<ul>
<li>(1) 读写分离<br>
在redis主从架构中，Master节点负责处理写请求，Slave节点只处理读请求。对于写请求少，读请求多的场景，例如电商详情页，通过这种读写分离的操作可以大幅提高并发量，通过增加redis从节点的数量可以使得redis的QPS达到10W+。</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052712952.png" alt></p>
<ul>
<li>(2) 主从同步<br>
Master节点接收到写请求并处理后，需要告知Slave节点数据发生了改变，保持主从节点数据一致的行为称为主从同步，所有的Slave都和Master通信去同步数据也会加大Master节点的负担，实际上，除了主从同步，redis也可以从从同步，我们在这里统一描述为主从同步。</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052723735.png" alt></p>
<h3><span id="redis-主从集群原理">Redis 主从集群原理</span></h3>
<ol>
<li>主从同步原理</li>
</ol>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052862511.png" alt></p>
<ol start="2">
<li>命令传播</li>
</ol>
<p>主从服务器为了保持一致，当主服务接受写操作的时候，将会同步给从服务器，保证两个服务器回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</p>
<ol start="3">
<li>复制功能缺陷（SYNC)缺陷<br>
在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</li>
</ol>
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
</ul>
<p>每次执行SYNC命令，主从服务器需要执行以下动作：<br>
1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。<br>
2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。<br>
3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。<br>
因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。</p>
<p>要理解这一情况，请看表15-2展示的断线后重复制例子。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053237800.png" alt></p>
<p>上面给出的例子可能有一点理想化，因为在主从服务器断线期间，主服务器执行的写命令可能会有成百上千个之多，而不仅仅是两三个写命令。但总的来说，主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的。</p>
<ol start="4">
<li>复制功能缺陷（PSYNC)缺陷</li>
</ol>
<p>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：</p>
<ul>
<li>
<p>·其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</p>
</li>
<li>
<p>·而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p>
</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053765461.png" alt></p>
<p>在了解了PSYNC命令的由来，以及部分重同步的工作方式之后，是时候来介绍一下部分重同步的实现细节了。</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053957940.png" alt></p>
<p>考虑以下这个例子：主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从服务器A断线了，那么主服务器传播的数据将只有从服务器B和从服务器C能收到</p>
<p>在这之后，主服务器、从服务器B和从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053987185.png" alt></p>
<p>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器将复制加压缓冲区的数据协会到从服务器当中。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607054010960.png" alt></p>
<blockquote>
<p>Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。<br>
复制积压缓冲区的最小大小可以根据公式second<em>write_size_per_second来估算：<br>
·其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。<br>
·而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。<br>
例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。<br>
为了安全起见，可以将复制积压缓冲区的大小设为2</em>second*write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理。<br>
至于复制积压缓冲区大小的修改方法，可以参考配置文件中关于repl-backlog-size选项的说明。</p>
</blockquote>
<ul>
<li>PSYNC命令的执行流程</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607054028716.png" alt></p>
<h3><span id="redis-主从集群搭建">Redis 主从集群搭建</span></h3>
<ul>
<li>
<ol>
<li>目录结构</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]<span class="comment"># </span></span><br><span class="line"><span class="comment">#root 目录下</span></span><br><span class="line">redis</span><br><span class="line">├── confs</span><br><span class="line">│   ├── 6379</span><br><span class="line">│   │   ├── dump.rdb</span><br><span class="line">│   │   ├── redis_6379.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   ├── 6380</span><br><span class="line">│   │   ├── redis_6380.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   ├── 6381</span><br><span class="line">│   │   ├── dump.rdb</span><br><span class="line">│   │   ├── redis_6381.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   └── redis.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol start="2">
<li>修改配置文件</li>
</ol>
</li>
</ul>
<p>在配置之后，我们可以关闭防火墙。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0                                <span class="comment"># 监听外网端口</span></span><br><span class="line">port 6379                                   <span class="comment"># 端口</span></span><br><span class="line">pidfile /root/redis/confs/6379/redis_6379.pid   <span class="comment">#pid 文件</span></span><br><span class="line">logfile <span class="string">"/root/redis/confs/6379/redislog.log"</span>   <span class="comment">#日志文件</span></span><br><span class="line">daemonize yes  <span class="comment">#后台启动</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol start="3">
<li>启动服务器</li>
</ol>
</li>
</ul>
<p>在三个目录下分别执行下，然后启动服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 6380]<span class="comment"># pwd</span></span><br><span class="line">/root/redis/confs/6380</span><br><span class="line">[root@CentOS7 6380]<span class="comment"># redis-server ./redis.conf</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<ol start="4">
<li>执行主从命令</li>
</ol>
</li>
</ul>
<p>在6380 和 6381 执行一下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 6380]<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 192.168.100.10 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6379 日志如下</span></span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Slave 192.168.100.10:6380 asks <span class="keyword">for</span> synchronization</span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Partial resynchronization not accepted: Replication ID mismatch (Slave asked <span class="keyword">for</span> <span class="string">'33469ac4d687096890a7b2b238f2d54104618166'</span>, my replication IDs are <span class="string">'f9730ab8455c298502f5d876da0b47ae8c016cb2'</span> and <span class="string">'0000000000000000000000000000000000000000'</span>)</span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Starting BGSAVE <span class="keyword">for</span> SYNC with target: disk</span><br><span class="line">18217:M 04 Dec 11:19:23.212 * Background saving started by pid 18331</span><br><span class="line">18331:C 04 Dec 11:19:23.216 * DB saved on disk</span><br><span class="line">18331:C 04 Dec 11:19:23.217 * RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">18217:M 04 Dec 11:19:23.308 * Background saving terminated with success</span><br><span class="line">18217:M 04 Dec 11:19:23.309 * Synchronization with slave 192.168.100.10:6380 succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment">## 6380 or 8381 日志如下：</span></span><br><span class="line"></span><br><span class="line">18247:S 04 Dec 11:19:23.208 * Connecting to MASTER 192.168.100.10:6379</span><br><span class="line">18247:S 04 Dec 11:19:23.209 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">18247:S 04 Dec 11:19:23.210 * Non blocking connect <span class="keyword">for</span> SYNC fired the event.</span><br><span class="line">18247:S 04 Dec 11:19:23.210 * Master replied to PING, replication can <span class="built_in">continue</span>...</span><br><span class="line">18247:S 04 Dec 11:19:23.211 * Trying a partial resynchronization (request 33469ac4d687096890a7b2b238f2d54104618166:1).</span><br><span class="line">18247:S 04 Dec 11:19:23.213 * Full resync from master: e2b2649c877aa6ff55ead56cf96e398975ee71aa:0</span><br><span class="line">18247:S 04 Dec 11:19:23.213 * Discarding previously cached master state.</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: receiving 4573 bytes from master</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Loading DB <span class="keyword">in</span> memory</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure>
<p>主从结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    6379  master </span><br><span class="line">    /   \</span><br><span class="line">6380     6381  slaver</span><br></pre></td></tr></table></figure>
<p>当集群完成主从之后，从服务器只允许读数据，不允许写数据。</p>
<ol start="5">
<li>wait 命令（扩展，redis-3.0新增）</li>
</ol>
<p>wait 提供两个参数，第一个参数是从节点的数量 m，第二个参数是时间 t，以毫秒<br>
为单位。它表示等待 wait 指令之前的所有写操作同步到 n 个子节点 (也就是确保<br>
m 个子节点的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到<br>
N 个从库同步完成达成一致。<br>
假设此时某个子节点与主节点网络断开，wait 指令第二个参数时间 t = 0，主从同步无法继续<br>
进行，wait 指令会永远阻塞，redis 服务器将丧失可用性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name jason</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">wait</span> 2 5000</span><br><span class="line">(<span class="built_in">integer</span>) 2  <span class="comment"># 同步2个实例</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="redis-哨兵集群">redis 哨兵集群</span></h2>
<h3><span id="sentinel-的作用">Sentinel 的作用</span></h3>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p>
<p><strong>Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。</strong></p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309468097.png" alt></p>
<h3><span id="sentinel-的故障迁移">Sentinel 的故障迁移</span></h3>
<ul>
<li>用双环图案表示的是当前的主服务器server1。</li>
<li>用单环图案表示的是主服务器的三个从服务器server2、server3以及server4。</li>
<li>server2、server3、server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器。</li>
</ul>
<p>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如图所示（下线的服务器用虚线表示）。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309666481.png" alt></p>
<p>当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：</p>
<ul>
<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li>
<li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li>
<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li>
</ul>
<p>举个例子，图16-3展示了Sentinel系统将server2升级为新的主服务器，并让服务器server3和server4成为server2的从服务器的过程。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309710885.png" alt></p>
<p>之后，如果server1重新上线的话，它将被Sentinel系统降级为server2的从服务器，如图所示。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309728173.png" alt></p>
<h3><span id="sentinel-实现原理">Sentinel 实现原理</span></h3>
<ol>
<li>创建网络连接</li>
</ol>
<p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。</p>
<p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：</p>
<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li>
<li>另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道。</li>
</ul>
<blockquote>
<p>在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失__sentinel__:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息。<br>
另一方面，除了订阅频道之外，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。因为Sentinel需要与多个实例创建多个网络连接，所以Sentinel使用的是异步连接。</p>
</blockquote>
<ol start="2">
<li>Sentinel 可以监控多个master</li>
</ol>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310052529.png" alt></p>
<ol start="3">
<li>获取主服务器信息</li>
</ol>
<p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310084959.png" alt></p>
<p>通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面的信息：</p>
<ul>
<li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色；</li>
<li>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个&quot;slave&quot;字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li>
<li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。</li>
</ul>
<ol start="4">
<li>获取从服务器连接</li>
</ol>
<p>在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令，并获得类似于以下内容的回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">...</span><br><span class="line">run_id:32be0699dd27b410f7c90dada3a6fab17f97899f</span><br><span class="line">...</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">slave_repl_offset:11887</span><br><span class="line">slave_priority:100</span><br><span class="line"># Other sections</span><br></pre></td></tr></table></figure>
<p>根据INFO命令的回复，Sentinel会提取出以下信息：</p>
<ul>
<li>从服务器的运行ID run_id。</li>
<li>从服务器的角色role。</li>
<li>主服务器的IP地址master_host，以及主服务器的端口号master_port。</li>
<li>主从服务器的连接状态master_link_status。</li>
<li>从服务器的优先级slave_priority。</li>
<li>从服务器的复制偏移量slave_repl_offset。</li>
</ul>
<ol start="5">
<li>向主服务器和从服务器发送信息<br>
在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>这条命令向服务器的__sentinel__:hello频道发送了一条信息，信息的内容由多个参数组成：</p>
<ul>
<li>其中以s_开头的参数记录的是Sentinel本身的信息，各个参数的意义如表16-2所示。</li>
<li>而m_开头的参数记录的则是主服务器的信息，各个参数的意义如表所示。如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310307757.png" alt></p>
<ol start="6">
<li>接收来自主服务器和从服务器的频道信息</li>
</ol>
<p>Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息</p>
<p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p>
<p>举个例子，假设现在有sentinel1、sentinel2、sentinel3三个Sentinel在监视同一个服务器，那么当sentinel1向服务器的__sentinel__:hello频道发送一条信息时，所有订阅了__sentinel__:hello频道的Sentinel（包括sentinel1自己在内）都会收到这条信息，如图1所示。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310519310.png" alt></p>
<p>当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</p>
<p>·如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理。</p>
<p>·相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</p>
<ol start="7">
<li>创建连向其他Sentinel的命令连接</li>
</ol>
<p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络：Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310619469.png" alt></p>
<blockquote>
<p><strong>Sentinel之间不会创建订阅连接</strong> Sentinel在连接主服务器或者从服务器时，会同时创建命令连接和订阅连接，但是在连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。</p>
</blockquote>
<blockquote>
<p>这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</p>
</blockquote>
<h3><span id="sentinel-故障迁移和选主流程">Sentinel 故障迁移和选主流程</span></h3>
<ol>
<li>发送监控命令</li>
</ol>
<p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310765757.png" alt></p>
<ol start="2">
<li>命令回复</li>
</ol>
<p>实例对PING命令的回复可以分为以下两种情况：</p>
<ul>
<li>有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种。</li>
<li>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</li>
</ul>
<ol start="3">
<li>
<p>检查客观下线状态<br>
当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p>
</li>
<li>
<p>确定下线状态</p>
</li>
</ol>
<p>Sentinel使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure>
<p>命令询问其他Sentinel是否同意主服务器已下线</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311285144.png" alt></p>
<p>当一个Sentinel（目标Sentinel）接收到另一个Sentinel（源Sentinel）发来的SENTINEL is-master-down-by命令时，目标Sentinel会分析并取出命令请求中包含的各个参数，并根据其中的主服务器IP和端口号，检查主服务器是否已下线，然后向源Sentinel返回一条包含三个参数的Multi Bulk回复作为SENTINEL is-master-down-by命令的回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &lt;down_state&gt;</span><br><span class="line">2) &lt;leader_runid&gt;</span><br><span class="line">3) &lt;leader_epoch&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311309721.png" alt></p>
<ol start="5">
<li>其他Sentinel 确认下线状态</li>
</ol>
<p>根据其他Sentinel发回的SENTINEL is-master-down-by-addr命令回复，Sentinel将统计其他Sentinel同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量时， 那么该Sentinel就会认为主服务器已经进入客观下线状态。</p>
<ol start="6">
<li>选主流程（Raft算法）</li>
</ol>
<p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。</p>
<ul>
<li>所有Sentinel 选举地位平等</li>
<li>头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次</li>
<li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改</li>
<li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</li>
<li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝</li>
<li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</li>
<li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311786666.png" alt></p>
<ol start="7">
<li>故障迁移</li>
</ol>
<p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：</p>
<ul>
<li>1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</li>
<li>2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。</li>
<li>3）将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ul>
<ol start="8">
<li>选出新的主服务器</li>
</ol>
<p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。<br>
领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：</p>
<ul>
<li>1）删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。</li>
<li>2）删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。</li>
<li>3）删除所有与已下线主服务器连接断开超过down-after-milliseconds<em>10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds</em>10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。</li>
<li>之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。</li>
<li>如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并选出其中偏移量最大的从服务器（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。</li>
<li>最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。</li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312133265.png" alt></p>
<p>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了。</p>
<p>例如，在图16-22展示的例子中，领头Sentinel会一直向server2发送INFO命令，当server2返回的命令回复从：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">...</span><br><span class="line"># Other sections</span><br><span class="line">...</span><br><span class="line">变为：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">...</span><br><span class="line"># Other sections</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>的时候，领头Sentinel就知道server2已经成功升级为主服务器了。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312162448.png" alt></p>
<ol start="9">
<li>修改从服务器的复制目标</li>
</ol>
<p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送SLAVEOF命令来实现。</p>
<p>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让它们复制新的主服务器server2的例子。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312437938.png" alt></p>
<p>server3和server4成为server2的从服务器之后，各个服务器以及领头Sentinel的样子</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312469029.png" alt></p>
<ol start="10">
<li>将旧的主服务器变为从服务器</li>
</ol>
<p>当server1重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312499922.png" alt></p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312505178.png" alt></p>
<h3><span id="sentinel-的搭建过程">Sentinel 的搭建过程</span></h3>
<ol>
<li>Sentinel 配置说明<br>
redis-sentinel.conf配置项说明如下：</li>
</ol>
<table>
<thead>
<tr>
<th>配置项目</th>
<th>配置说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>sentinel监听端口，默认是26379，可以修改。</td>
<td></td>
</tr>
<tr>
<td>sentinel monitor <master-name> <ip> <redis-port> <quorum></quorum></redis-port></ip></master-name></td>
<td>告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效。master-name只能包含英文字母，数字，和“.-_”这三个字符需要注意的是master-ip 要写真实的ip地址而不要用回环地址（127.0.0.1）。</td>
<td>sentinel monitor mymaster 192.168.0.5 6379 2</td>
</tr>
<tr>
<td>sentinel auth-pass <master-name> <password></password></master-name></td>
<td>设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</td>
<td>sentinel auth-pass mymaster 0123passw0rd</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds <master-name> <milliseconds></milliseconds></master-name></td>
<td>这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒</td>
<td>sentinel down-after-milliseconds mymaster 30000</td>
</tr>
<tr>
<td>sentinel parallel-syncs <master-name> <numslaves></numslaves></master-name></td>
<td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</td>
<td>sentinel parallel-syncs mymaster 1</td>
</tr>
<tr>
<td>sentinel failover-timeout <master-name> <milliseconds></milliseconds></master-name></td>
<td><div>failover-timeout 可以用在以下这些方面： <br>1. 同一个sentinel对同一个master两次failover之间的间隔时间。<br>2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。<br>3. 当想要取消一个正在进行的failover所需要的时间。  <br>4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。 </div></td>
<td>sentinel failover-timeout mymaster1 20000</td>
</tr>
<tr>
<td>sentinel notification-script <master-name> <script-path></script-path></master-name></td>
<td>sentinel的notification-script和reconfig-script是用来配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：<br>若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10<br>若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。<br>如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。<br>一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。<br>通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</td>
<td>sentinel notification-script mymaster /var/redis/notify.sh</td>
</tr>
<tr>
<td>sentinel client-reconfig-script <master-name> <script-path></script-path></master-name></td>
<td>当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下参数将会在调用脚本时传给脚本:<master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>目前<state>总是“failover”, <role>是“leader”或者“observer”中的一个。 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的。这个脚本应该是通用的，能被多次调用，不是针对性的。</role></state></to-port></to-ip></from-port></from-ip></state></role></master-name></td>
<td>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 搭建集群</span><br><span class="line"></span><br><span class="line">文件位置</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">.</span><br><span class="line">├── 16379</span><br><span class="line">│   ├── redis_sentinel_16379.pid</span><br><span class="line">│   ├── redis_sentinel_log.log</span><br><span class="line">│   └── sentinel.conf</span><br><span class="line">├── 16380</span><br><span class="line">│   ├── redis_sentinel_16380.pid</span><br><span class="line">│   ├── redis_sentinel_log.log</span><br><span class="line">│   └── sentinel.conf</span><br><span class="line">└── 16381</span><br><span class="line">    ├── redis_sentinel_16381.pid</span><br><span class="line">    ├── redis_sentinel_log.log</span><br><span class="line">    └── sentinel.conf</span><br></pre></td></tr></table></figure>
<p>配置文件模板 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 16379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /root/redis/confs/sentinel/16379/redis_sentinel_16379.pid</span><br><span class="line">logfile &quot;/root/redis/confs/sentinel/16379/redis_sentinel_log.log&quot;</span><br><span class="line">dir ./</span><br><span class="line">sentinel monitor mymaster 192.168.100.10 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<p>分别启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ./sentinel.conf <span class="comment">#16379/sentinel.conf</span></span><br></pre></td></tr></table></figure>
<p>=</p>
<ol start="3">
<li>查看<br>
故障转移后 client 怎么知道新的master地址？sentinel 就像是一个服务注册中心，可以请求 sentinel 获取当前的 master 信息。</li>
</ol>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# redis-cli -p 16379 sentinel get-master-addr-by-name mymaster</span><br><span class="line">1) &quot;192.168.100.10&quot;</span><br><span class="line">2) &quot;6379&quot;</span><br></pre></td></tr></table></figure>
<p>client 使用的 Redis 客户端需要支持 sentinel，那么就可以自动拿到 master 的地址了。</p>
<h2><span id="redis-集群模式">redis 集群模式</span></h2>
<p>哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。<br>
Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p>
<h3><span id="槽位">槽位</span></h3>
<p>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p>
<p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。<br>
当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607667695339.png" alt></p>
<ul>
<li>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点当其它主节点，.</li>
<li>ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</li>
<li>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</li>
</ul>
<h3><span id="在集群中执行命令">在集群中执行命令</span></h3>
<p>在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p>
<ul>
<li>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</li>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>图展示了这两种情况的判断流程。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607667862191.png" alt></p>
<h3><span id="重新分片">重新分片</span></h3>
<p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。<br>
重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。</p>
<p>redis-trib对集群的单个槽slot进行重新分片的步骤如下(如果重新分片涉及多个槽，那么redis-trib将对每个给定的槽分别执行上面给出的步骤)：</p>
<ul>
<li>1）redis-trib对目标节点发送CLUSTER SETSLOT<slot>IMPORTING&lt;source_id&gt;命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</slot></li>
<li>2）redis-trib对源节点发送CLUSTER SETSLOT<slot>MIGRATING&lt;target_id&gt;命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</slot></li>
<li>3）redis-trib向源节点发送CLUSTER GETKEYSINSLOT<slot><count>命令，获得最多count个属于槽slot的键值对的键名（key name）。</count></slot></li>
<li>4）对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE&lt;target_ip&gt;&lt;target_port&gt;&lt;key_name&gt;0<timeout>命令，将被选中的键原子地从源节点迁移至目标节点。</timeout></li>
<li>5）重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。每次迁移键的过程如图所示。</li>
<li>6）redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT<slot>NODE&lt;target_id&gt;命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点</slot></li>
</ul>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668216367.png" alt></p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668240201.png" alt></p>
<h3><span id="复制与故障转移">复制与故障转移</span></h3>
<p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<p>举个例子，对于包含7000、7001、7002、7003四个主节点的集群来说，我们可以将7004、7005两个节点添加到集群里面，并将这两个节点设定为节点7000的从节点</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668429906.png" alt></p>
<p>表记录了集群各个节点的当前状态，以及它们正在做的工作。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668451733.png" alt></p>
<p>如果这时，节点7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点——节点7004和节点7005中选出一个节点作为新的主节点，这个新的主节点将接管原来节点7000负责处理的槽，并继续处理客户端发送的命令请求。</p>
<p>例如，如果节点7004被选中为新的主节点，那么节点7004将接管原来由节点7000负责处理的槽0至槽5000，节点7005也会从原来的复制节点7000，改为复制节点7004，如图17-33所示（图中用虚线包围的节点为已下线节点）。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668567214.png" alt></p>
<p>如果在故障转移完成之后，下线的节点7000重新上线，那么它将成为节点7004的从节点，如图所示。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668597356.png" alt></p>
<h3><span id="故障转移">故障转移</span></h3>
<p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果节点7001向节点7000发送了一条PING消息，但是节点7000没有在规定的时间内，向节点7001返回一条PONG消息，么节点7001就会让节点7000进入了疑似下线状态，状态有三种<br>
<strong>在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。</strong></p>
<p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</p>
<p>举个例子，对于图17-38所示的下线报告来说，主节点7002和主节点7003都认为主节点7000进入了下线状态，并且主节点7001也认为主节点7000进入了疑似下线状态（代表主节点7000的结构打开了REDIS_NODE_PFAIL标识），综合起来，在集群四个负责处理槽的主节点里面，有三个都将主节点7000标记为下线，数量已经超过了半数，所以主节点7001会将主节点7000标记为已下线，并向集群广播一条关于主节点7000的FAIL消息，如图17-39所示。</p>
<p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668873309.png" alt></p>
<h3><span id="总结">总结</span></h3>
<p>故障转移，当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p>
<ul>
<li>1）复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li>
<li>3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ul>
<p>选举新的主节点新的主节点是通过选举产生的。以下是集群选举新的主节点的方法：</p>
<ul>
<li>1）集群的配置纪元是一个自增计数器，它的初始值为0。</li>
<li>2）当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li>
<li>3）对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>4）当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>5）如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>6）每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li>
<li>7）如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>
<li>8）因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li>
<li>9）如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ul>
<h3><span id="集群搭建">集群搭建</span></h3>
<ol>
<li>目录结构</li>
</ol>
<table>
<thead>
<tr>
<th>端口</th>
<th>主从</th>
<th>复制节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>7000</td>
<td>主</td>
<td>7003</td>
</tr>
<tr>
<td>7001</td>
<td>主</td>
<td>7004</td>
</tr>
<tr>
<td>7002</td>
<td>主</td>
<td>7005</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 7000</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7001</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7002</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7003</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7004</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7005</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── redis_7000.pid</span><br><span class="line">├── redis_7001.pid</span><br><span class="line">├── redis_7002.pid</span><br><span class="line">├── redis_7003.pid</span><br><span class="line">├── redis_7004.pid</span><br><span class="line">├── redis_7005.pid</span><br><span class="line">├── redislog_7000.log</span><br><span class="line">├── redislog_7001.log</span><br><span class="line">├── redislog_7002.log</span><br><span class="line">├── redislog_7003.log</span><br><span class="line">├── redislog_7004.log</span><br><span class="line">└── redislog_7005.log</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 端口号 其他配置参见其他章节这里只保留集群模式</span><br><span class="line"># 开启集群模式</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置，配置文件首次启动自动生成</span><br><span class="line"># 这里只需指定文件名即可，集群启动成功后会自动在data目录下创建</span><br><span class="line">cluster-config-file &quot;nodes-6379.conf&quot;</span><br><span class="line"># 请求超时，设置10秒</span><br><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]# redis-server ./700&#123;0,1,2,3,4,5&#125;/redis.conf</span><br></pre></td></tr></table></figure>
<p>登录7000 查看集群信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; CLIENT info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:1</span><br><span class="line">cluster_size:0</span><br><span class="line">cluster_current_epoch:0</span><br><span class="line">cluster_my_epoch:0</span><br><span class="line">cluster_stats_messages_sent:0</span><br><span class="line">cluster_stats_messages_received:0</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>组成集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@CentOS7 cluster]<span class="comment"># redis-cli -p 7001</span></span><br><span class="line">127.0.0.1:7001&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; CLUSTER MEET 127.0.0.1 700</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7002</span></span><br><span class="line">127.0.0.1:7002&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7003</span></span><br><span class="line">127.0.0.1:7003&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7003&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7004</span></span><br><span class="line">127.0.0.1:7004&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7004&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7005</span></span><br><span class="line">127.0.0.1:7005&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7005&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:0</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:45</span><br><span class="line">cluster_stats_messages_pong_sent:50</span><br><span class="line">cluster_stats_messages_meet_sent:1</span><br><span class="line">cluster_stats_messages_sent:96</span><br><span class="line">cluster_stats_messages_ping_received:44</span><br><span class="line">cluster_stats_messages_pong_received:46</span><br><span class="line">cluster_stats_messages_meet_received:6</span><br><span class="line">cluster_stats_messages_received:96</span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) CLUSTERDOWN Hash slot not served</span><br><span class="line">127.0.0.1:7000&gt;</span><br></pre></td></tr></table></figure>
<p>查看节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; CLUSTER nodes</span><br><span class="line">14bd4c6a0d82425637d10ac11238426bbf7d5e9f 127.0.0.1:7000@17000 myself,master - 0 1607679088000 1 connected</span><br><span class="line">8e1da11c7da154ed2515c6a9b683ebb58d23618d 127.0.0.1:7002@17002 master - 0 1607679093630 2 connected</span><br><span class="line">f52ae1c178ef712d7c5eac2f4112fba924013dc6 127.0.0.1:7003@17003 master - 0 1607679094631 3 connected</span><br><span class="line">7c33f7bb44fb9d93a74cc3264604d67ff6866df6 127.0.0.1:7004@17004 master - 0 1607679093000 4 connected</span><br><span class="line">2e25473d824a0598cd56b4ce846f099593bfd867 127.0.0.1:7005@17005 master - 0 1607679094000 5 connected</span><br><span class="line">fca142b994747c432858c131c97d6e36f597d0af 127.0.0.1:7001@17001 master - 0 1607679092000 0 connected</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>设立主从</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER REPLICATE &lt;node_id&gt; 分别在 7003 7004 7005 执行</span><br><span class="line">得到如下配置</span><br><span class="line"></span><br><span class="line">8e1da11c7da154ed2515c6a9b683ebb58d23618d 127.0.0.1:7002@17002 master - 0 1607680045949 2 connected</span><br><span class="line">14bd4c6a0d82425637d10ac11238426bbf7d5e9f 127.0.0.1:7000@17000 master - 0 1607680045000 1 connected</span><br><span class="line">fca142b994747c432858c131c97d6e36f597d0af 127.0.0.1:7001@17001 master - 0 1607680048957 0 connected</span><br><span class="line">2e25473d824a0598cd56b4ce846f099593bfd867 127.0.0.1:7005@17005 slave 8e1da11c7da154ed2515c6a9b683ebb58d23618d 0 1607680047000 5 connected</span><br><span class="line">f52ae1c178ef712d7c5eac2f4112fba924013dc6 127.0.0.1:7003@17003 slave 14bd4c6a0d82425637d10ac11238426bbf7d5e9f 0 1607680048000 3 connected</span><br><span class="line">7c33f7bb44fb9d93a74cc3264604d67ff6866df6 127.0.0.1:7004@17004 myself,slave fca142b994747c432858c131c97d6e36f597d0af 0 1607680043000 4 connected</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>配置槽位</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000 cluster addslots &#123;0..5460&#125;</span></span><br><span class="line">OK</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7001 cluster addslots &#123;5461..10000&#125;</span></span><br><span class="line">OK</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7002 cluster addslots &#123;10001..16383&#125;</span></span><br><span class="line"><span class="comment"># 查看槽位</span></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:1481</span><br><span class="line">cluster_stats_messages_pong_sent:1455</span><br><span class="line">cluster_stats_messages_meet_sent:1</span><br><span class="line">cluster_stats_messages_sent:2937</span><br><span class="line">cluster_stats_messages_ping_received:1449</span><br><span class="line">cluster_stats_messages_pong_received:1482</span><br><span class="line">cluster_stats_messages_meet_received:6</span><br><span class="line">cluster_stats_messages_received:2937</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>查看</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单击模式 登录</span></span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli  -p 7000 </span></span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001  <span class="comment"># 返回错误</span></span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> 1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> 1 1 </span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001 </span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001</span><br><span class="line">127.0.0.1:7000&gt;</span><br><span class="line"><span class="comment"># 集群模式登录</span></span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -c -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">-&gt; Redirected to slot [9842] located at 127.0.0.1:7001</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2>
<ul>
<li><a href="https://www.jianshu.com/p/f0e042b95249" target="_blank" rel="noopener">010.Redis 主从架构搭建及原理详解</a></li>
<li><a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></li>
</ul>

        
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/lvs-1/" data-toggle="tooltip" data-placement="top" title="负载均衡（1）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/Net-wrok-DNS-1/" data-toggle="tooltip" data-placement="top" title="DNS服务">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="alipay_url"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="wechatpay_url"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Redis集群模式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Redis 主从集群</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Redis 主从集群原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Redis 主从集群搭建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">redis 哨兵集群</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">Sentinel 的作用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">Sentinel 的故障迁移</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">Sentinel 实现原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">Sentinel 故障迁移和选主流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">Sentinel 的搭建过程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">redis 集群模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">槽位</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">在集群中执行命令</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">重新分片</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">复制与故障转移</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">故障转移</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.6.</span> <span class="toc-nav-text">总结</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.7.</span> <span class="toc-nav-text">集群搭建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">参考</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a.toc-nav-text',function(a){
            document.getElementById(a.target.innerText.replace(/\s/g,'').replace(/\./g,'-').toLowerCase()).scrollIntoView(true);
            document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/u/2028033763">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/IceFrozen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jason Lee 2021 
                    <br>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="#">JasonLess</a> | 
                    <!-- <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="#" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Custom Theme search -->
<script src="/js/search.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- search code -->

    <script type="text/javascript">      
      var search_path = "search.xml";
      if (search_path.length == 0) {
          search_path = "search.xml";
      }
      var path = "/" + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
    </script>
 

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>
