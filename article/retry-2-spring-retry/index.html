<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Spring-Retry 源码分析 - 西木 | Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/article/retry-2-spring-retry/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">

    <link rel="stylesheet" href="/css/search.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script>hljs.initHighlightingOnLoad();</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/archive.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#源码分析" title="源码分析">源码分析</a>
                            
                              <a class="tag" href="/tags/#Spring" title="Spring">Spring</a>
                            
                        </div>
                        <h1>Spring-Retry 源码分析</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Jason Lee on
                            2020-07-29
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">西木凌萧</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>前面我们用自己的代理模式完成一些重试的操作，接下来我们将分析一下 <code>SpringRetry</code> 的实现方式<code>spring-retry</code> 项目实现了重试和熔断功能，目前已用于SpringBatch、Spring Integration等项目</p>
<h2><span id="详解">详解</span></h2>
<h1><span id="quickstart">QuickStart</span></h1>
<p>我们首先来看一下使用。<br>
首先我们引入使用,这里我们使用的是<code>1.3</code>版本</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.retry/spring-retry --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * spring-retry1.3.x版本开始提供建造者模式支持了，可</span></span><br><span class="line"><span class="comment">         * RetryTemplate template = RetryTemplate.builder()</span></span><br><span class="line"><span class="comment">                .maxAttempts(5)</span></span><br><span class="line"><span class="comment">                .customPolicy(new SimpleRetryPolicy()).build();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">// 设置重试策略</span></span><br><span class="line">        SimpleRetryPolicy simpleRetryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        simpleRetryPolicy.setMaxAttempts(<span class="number">5</span>);</span><br><span class="line">        template.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        Object result = template.execute(</span><br><span class="line">                <span class="keyword">new</span> RetryCallback&lt;Object, Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 第一次请求，不算重试， 所以第一次请求时，context.getRetryCount()值为0</span></span><br><span class="line">                        System.out.println(context.getRetryCount());</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span> + (context.getRetryCount() + <span class="number">1</span>) + <span class="string">"次调用失败!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"走recover逻辑了! \t异常类是"</span> + lastThrowable.getClass().getName()</span><br><span class="line">                                + <span class="string">"\t异常信息是"</span> + lastThrowable.getMessage();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下调用结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">走recover逻辑了! 	异常类是java.lang.RuntimeException	异常信息是第<span class="number">5</span>次调用失败!</span><br></pre></td></tr></table></figure>
<h1><span id="详解">详解</span></h1>
<h2><span id="类关系">类关系</span></h2>
<p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596005961.png" alt></p>
<h2><span id="概念详解">概念详解</span></h2>
<ul>
<li>
<p><strong>RetryOperations</strong> 和 <strong>RetryTemplate</strong><br>
RetryOperations定义了重试的API，RetryTemplate提供了模板实现，线程安全的，同于Spring 一贯的API风格，RetryTemplate将重试、熔断功能封装到模板中，提供健壮和不易出错的API供大家使用。</p>
</li>
<li>
<p><strong>RetryCallback</strong> 和 <strong>RecoverCallback</strong><br>
通过RetryCallback定义需重试的业务服务，当重试超过最大重试时间或最大重试次数后可以调用RecoveryCallback进行恢复，比如返回假数据或托底数据。</p>
</li>
<li>
<p><strong>RetryPolicy</strong><br>
当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p>
</li>
<li>
<p><strong>RetryListener</strong>和<strong>RetryStatistics</strong><br>
RetryListener实现拦截器模式,这里主要用于统计等，当然也可以用户自定义拦截器。</p>
</li>
<li>
<p><strong>BackOff</strong> ：补偿值，一般指失败后多久进行重试的延迟值。</p>
</li>
<li>
<p><strong>Sleeper</strong> ：暂停应用的工具，通常用来应用补偿值。</p>
</li>
<li>
<p><strong>RetryContext</strong> ：重试上下文，代表了能被重试动作使用的资源。</p>
</li>
<li>
<p><strong>RetryState</strong> ：重试状态，通常包含一个重试的键值。</p>
</li>
</ul>
<h2><span id="分解详解">分解详解</span></h2>
<h3><span id="retryoperations"><strong>RetryOperations</strong></span></h3>
<ul>
<li>首先看一下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryOperations</span> </span>&#123;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RetryState retryState)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E, ExhaustedRetryException</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            RetryState retryState)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，new 出一个 <code>RetryTemplate</code> 对象后，核心是在 <code>template.execute()</code>,传递一个 <code>RetryCallback</code>，内部执行我们需要重试的具体方法。</p>
<p>这里我们看到 <code>RetryOperations</code> 具体定义了 <code>execute</code> 方法，用于去执行我们的相关逻辑。这里我们看到了有个 <code>RetryState</code> 对象，这里的主要是重试的状态，这个我们暂且略过，我们先来看一下<strong>重试策略</strong></p>
<h3><span id="retrypolicy">RetryPolicy</span></h3>
<p>那什么时候需重试？<code>spring-retry</code>是当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p>
<ol>
<li><strong>接口</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//是否需要重试</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// retry 生命周期函数</span></span><br><span class="line">	<span class="function">RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 记录异常</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重试接口定义了四个接口，具体的重试策略就是通过具体的实现类来完成的。<br>
<img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596007673.png" alt></p>
<ol start="2">
<li><strong>重试策略</strong><br>
重试策略有哪些呢？spring-retry提供了如下重试策略。</li>
</ol>
<ul>
<li><strong>NeverRetryPolicy</strong> ：只允许调用RetryCallback一次，不允许重试；</li>
<li><strong>AlwaysRetryPolicy</strong> ：允许无限重试，直到成功，此方式逻辑不当会导致死循环；</li>
<li><strong>SimpleRetryPolicy</strong> ：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</li>
<li><strong>TimeoutRetryPolicy</strong> ：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</li>
<li><strong>MaxAttemptsRetryPolicy</strong>： 简单重试策略，仅通过重试次数判断是否能够重试，不推荐使用。</li>
<li><strong>CircuitBreakerRetryPolicy</strong> ：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate，稍后详细介绍该策略；</li>
<li><strong>CompositeRetryPolicy</strong> ：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</li>
</ul>
<p>接下来我们分析一下<code>SimpleRetryPolicy</code> 类的基本实现。</p>
<ol start="3">
<li><strong>构造函数</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量，重试次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_ATTEMPTS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 实际重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maxAttempts;</span><br><span class="line"><span class="comment">// 错误分类器 classify包作为retry的辅助类，主要应用于RetryPolicy的canRetry()方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件</span></span><br><span class="line"><span class="keyword">private</span> BinaryExceptionClassifier retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryPolicy</span><span class="params">(<span class="keyword">int</span> maxAttempts, Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; retryableExceptions,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> traverseCauses, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	<span class="keyword">this</span>.maxAttempts = maxAttempts;</span><br><span class="line">	<span class="keyword">this</span>.retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(retryableExceptions, defaultValue);</span><br><span class="line">	<span class="keyword">this</span>.retryableClassifier.setTraverseCauses(traverseCauses);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单介绍一下 <code>retryableClassifier</code> 这个成员<br>
<code>classify</code> 包作为retry的辅助类，主要应用于 <code>RetryPolicy</code> 的 <code>canRetry()</code> 方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件,现在只要知道他是 用于分类的就好了。</p>
<ol start="4">
<li><strong>函数实现</strong></li>
</ol>
<ul>
<li>canRetry</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">	Throwable t = context.getLastThrowable();</span><br><span class="line">	<span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; <span class="keyword">this</span>.maxAttempts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于识别 这个异常时时我们需要的异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">retryForException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.retryableClassifier.classify(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看看出，当异常使我们需要重试的异常且次数小于制定重试次数的时候，进行重试。<code>getLastThrowable</code> 是重试上下文中捕获的最后的异常类型</p>
<ul>
<li>open</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryContext(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open 这个方法用于协调资源，是重试一开始的时候会被主流程调用，这里主要是new了一个<br>
<code>SimpleRetryContext上</code>下文。 所以我们如果想继续了解 这个重试策略，就要简单了解一下 <code>RetryContext</code> 上下文了。</p>
<ol start="5">
<li><strong>SimpleRetryContext</strong><br>
我们首先来看一下 <code>SimpleRetryContext</code> 这个类的定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>SimpleRetryContext</code> 紧紧就是一个 <code>RetryContextSupport</code> 实现。我们再来看这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryContextSupport</span> <span class="keyword">extends</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">RetryContext</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RetryContext parent;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminate = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Throwable lastException;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RetryContextSupport</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//... 一些 getset 方法</span></span><br><span class="line">    <span class="comment">// 用于记录异常</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lastException = throwable;</span><br><span class="line">		<span class="keyword">if</span> (throwable != <span class="keyword">null</span>)</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AttributeAccessorSupport</code> 就是一个属性类，让继承他的类可以实现增加属性。</li>
<li><code>RetryContext</code> 定义一些状态和属性以及  <code>AttributeAccessorSupport</code> 实现的接口方法。具体的代码不贴了，想了解的可以去翻阅源码。</li>
</ul>
<ul>
<li><strong>异常记录</strong><br>
SimpleRetryPolicy 的异常注册其实是注册到了context中。当我们捕获了异常，就会将异常封装到这个上下文中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleRetryPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line">	SimpleRetryContext simpleContext = ((SimpleRetryContext) context);</span><br><span class="line">	simpleContext.registerThrowable(throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="retrytemplate">RetryTemplate</span></h3>
<p>到此基本的概念就讲完了。接下来先看下RetryTemplate主要流程实现：</p>
<p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596191348.png" alt></p>
<p>我来看一下几个关键的成员变量</p>
<ol>
<li><strong>成员变量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GLOBAL_STATE = <span class="string">"state.global"</span>;</span><br><span class="line"><span class="comment">// 回退策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> BackOffPolicy backOffPolicy = <span class="keyword">new</span> NoBackOffPolicy();</span><br><span class="line"><span class="comment">// 重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 重试的监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryListener[] listeners = <span class="keyword">new</span> RetryListener[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 重试上下文</span></span><br><span class="line"><span class="keyword">private</span> RetryContextCache retryContextCache = <span class="keyword">new</span> MapRetryContextCache();</span><br><span class="line"><span class="comment">// ？</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> throwLastExceptionOnExhausted;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>核心方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">   <span class="comment">//重试策略</span></span><br><span class="line">   RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">   <span class="comment">//退避策略</span></span><br><span class="line">   BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">   <span class="comment">//重试上下文，当前重试次数等都记录在上下文中</span></span><br><span class="line">   RetryContext context = open(retryPolicy, state);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同步管理器注册context 用于将context链接成一个context链儿</span></span><br><span class="line">   RetrySynchronizationManager.register(context);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拦截器模式，执行RetryListener#open</span></span><br><span class="line">      <span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// .... running 必须问true 否则 抛出异常，代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get or Start the backoff context...</span></span><br><span class="line">		BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">		Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">			backOffContext = (BackOffContext) resource;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">			backOffContext = backOffPolicy.start(context);</span><br><span class="line">			<span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">				context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否可以重试执行</span></span><br><span class="line">      <span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//执行RetryCallback回调</span></span><br><span class="line">            lastException = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常</span></span><br><span class="line">            lastException = e;</span><br><span class="line">            <span class="comment">//异常时，要进行下一次重试准备</span></span><br><span class="line">            <span class="comment">//遇到异常后，注册该异常的失败次数</span></span><br><span class="line">            registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">            <span class="comment">//执行RetryListener#onError</span></span><br><span class="line">            doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">            <span class="comment">//如果可以重试，执行退避算法，比如休眠一小段时间后再重试</span></span><br><span class="line">            <span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    backOffPolicy.backOff(backOffContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">                    lastException = e;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//state != null &amp;&amp; state.rollbackFor(context.getLastThrowable())</span></span><br><span class="line">            <span class="comment">//在有状态重试时，如果是需要执行回滚操作的异常，则立即抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果是有状态重试，且有GLOBAL_STATE属性，则立即跳出重试终止；当抛出的异常是非需要执行回滚操作的异常时，才会执行到此处，CircuitBreakerRetryPolicy会在此跳出循环；</span></span><br><span class="line">         <span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      exhausted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//重试失败后，如果有RecoveryCallback，则执行此回调，否则抛出异常</span></span><br><span class="line">      <span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//清理环境</span></span><br><span class="line">      close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">      <span class="comment">//执行RetryListener#close，比如统计重试信息</span></span><br><span class="line">      doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">      <span class="comment">//RetrySynchronizationManager 清空</span></span><br><span class="line">      RetrySynchronizationManager.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到上述代码，感觉很头疼，我们来提几个问题。</p>
<ol>
<li><code>MapRetryContextCache</code> 是干啥用的？</li>
<li><code>RetryContext context = open(retryPolicy, state)</code>中open 方法和state是什么;</li>
<li><code>RetrySynchronizationManager.register(context)</code>; 为什么要注册这个？</li>
<li><code>BackOffContext</code> 是干什么用的</li>
<li><code>状态重试</code>和<code>回滚操作</code>是什么意思？</li>
</ol>
<p>接下来我们来逐一分解这些流程。</p>
<h3><span id="有状态or无状态">有状态or无状态</span></h3>
<ul>
<li>
<p><strong>无状态重试</strong>，是在一个循环中执行完重试策略，即重试上下文保持在一个线程上下文中，在一次调用中进行完整的重试策略判断。非常简单的情况，如远程调用某个查询方法时是最常见的无状态重试。</p>
</li>
<li>
<p><strong>有状态重试</strong>，有两种情况需要使用有状态重试，事务操作需要回滚或者熔断器模式。事务操作需要回滚场景时，当整个操作中抛出的是数据库异常 DataAccessException，则不能进行重试需要回滚，而抛出其他异常则可以进行重试，可以通过 <code>RetryState</code> 实现：</p>
</li>
</ul>
<p>我们来具体看一下 <code>RetryState</code> 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryState</span> </span>&#123;</span><br><span class="line">	<span class="comment">//状态缓存使用的key</span></span><br><span class="line">	<span class="function">Object <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 强制刷新状态</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isForceRefresh</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//判定当前的异常是否需要回归，默认是true.</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">rollbackFor</span><span class="params">(Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最简单的情况下，重试只是一个while循环，<code>RetryTemplate</code> 可以一直尝试，直到成功或失败。RetryContext包含一些状态来决定是重试还是中止，但是这个状态位于堆栈上，不需要将它存储在全局的任何位置，因此我们将此称为无状态重试。无状态重试和有状态重试之间的区别包含在RetryPolicy的实现中（<code>RetryTemplate</code>可以同时处理这两种情况），在无状态重试中，回调总是在重试失败时在同一个线程中执行。</p>
<p>当我出现数据库事务性的失败的时候，我们需要回滚，这样我们会在整个 <code>template</code> 中加上try catch 代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前状态的名称，当把状态放入缓存时，通过该key查询获取</span></span><br><span class="line">Object key = <span class="string">"mykey"</span>;</span><br><span class="line"><span class="comment">//是否每次都重新生成上下文还是从缓存中查询，即全局模式（如熔断器策略时从缓存中查询）</span></span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//对DataAccessException进行回滚</span></span><br><span class="line">BinaryExceptionClassifier rf =</span><br><span class="line">        <span class="keyword">new</span> BinaryExceptionClassifier(Collections.&lt;Class&lt;? extends Throwable&gt;&gt;singleton(DataAccessException<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh, rf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// state 提出来，可以保证status 在多个 template 的exectue中可以共享一些数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = template.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchDataAccessException(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, () -&gt; <span class="string">"default"</span>, state);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(DataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 执行回滚操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些情况下，无状态重试是不够的，因为重新抛出和回滚必然会离开<code>RetryOperations.execute()</code>方法，并可能丢失堆栈上的上下文。</p>
<p>为了避免丢失它，我们必须引入一种存储策略，将它从堆栈中取出并（至少）放入堆存储中，为此，Spring Retry提供了一种存储策略 <code>RetryContextCache</code>，可以将其注入 <code>RetryTemplate</code> 。<code>RetryContextCache</code> 的默认实现在内存中，使用一个简单的Map，它有一个严格执行的最大容量，以避免内存泄漏，但它没有任何高级缓存功能，如生存时间。如果需要，应该考虑注入具有这些特性的Map，在集群环境中对多个进程的高级使用可能还会考虑使用某种集群缓存实现<code>RetryContextCache</code>（不过，即使在集群环境中，这也可能是多余的）。</p>
<p><code>RetryOperations</code> 的部分职责是在失败的操作在新执行中返回时识别它们（通常封装在新事务中），为了促进这一点，Spring Retry提供了 <code>RetryState</code> 抽象，这与 <code>RetryOperations</code> 中的特殊 <code>execute</code> 方法一起工作。识别失败操作的方法是跨重试的多个调用标识状态，要标识状态，用户可以提供 <code>RetryState</code> 对象，该对象负责返回标识该项的唯一键，标识符用作<code>RetryContextCache</code> 中的键。</p>
<p>了解这个之后，我们可以来分析解决了 <code>RetryState</code> 的问题，我们来分析一下open 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RetryContext <span class="title">open</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    Object key = state.getKey();</span><br><span class="line">    <span class="keyword">if</span> (state.isForceRefresh()) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is no cache hit we can avoid the possible expense of the</span></span><br><span class="line">    <span class="comment">// cache re-hydration.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// The cache is only used if there is a failure.</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RetryContext context = <span class="keyword">this</span>.retryContextCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RetryException(<span class="string">"Inconsistent state for failed item: no history found. "</span></span><br><span class="line">                    + <span class="string">"Consider whether equals() or hashCode() for the item might be inconsistent, "</span></span><br><span class="line">                    + <span class="string">"or if you need to supply a better ItemKeyGenerator"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The cache could have been expired in between calls to</span></span><br><span class="line">        <span class="comment">// containsKey(), so we have to live with this:</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a clean slate for state that others may be inspecting</span></span><br><span class="line">    context.removeAttribute(RetryContext.CLOSED);</span><br><span class="line">    context.removeAttribute(RetryContext.EXHAUSTED);</span><br><span class="line">    context.removeAttribute(RetryContext.RECOVERED);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码我们可以了解到， 当 state 为空的时候，证明是无状态重试，那么在exectue的时候，优先执行open方法，open 方法又去执行了 <code>doOpenInternal</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RetryContext <span class="title">doOpenInternal</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    RetryContext context = retryPolicy.open(RetrySynchronizationManager.getContext());</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setAttribute(RetryContext.STATE_KEY, state.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">        registerContext(context, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doOpenInternal</code> 方法是调用的  policy 的 open 方法，也就是 <code>simplePolicy</code> 的open 方法，<br>
<code>simplepolicy</code> 的方法就是创建一个 context。 另外在创建的 时候传入了一个父类 <code>context</code><br>
那么 <code>RetrySynchronizationManager</code> 是在什么时候注册的呢？</p>
<p>实在从上面的代码看到，是在 <code>open</code> 方法结束之后，注册的，也就是说，如果同一个线程可如果多次重试，那么 <code>context</code> 是会保留的下来的，是一个链式结构。</p>
<p>在多个Context 之间可以共享 <code>state</code> 而这个 state 可以放到外边，多个<code>template</code> 可以共享一个<code>state</code><br>
当我们的 <code>state</code> 状态设置成 不强制刷新，则会从 <code>this.retryContextCache</code> 中去寻找相关<code>key</code>对应的<code>context</code>用来复用，这样一来就实现了 多个<code>context</code> 共享一个 <code>state</code>.</p>
<hr>
<h3><span id="回退策略">回退策略</span></h3>
<p>重试时的退避策略是什么？是立即重试还是等待一段时间后重试，比如是网络错误，立即重试将导致立即失败，最好等待一小段时间后重试，还要防止很多服务同时重试导致DDos。</p>
<p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596171720.png" alt></p>
<ul>
<li>
<p><strong>NoBackOffPolicy</strong> ：无退避算法策略，即当重试时是立即重试；</p>
</li>
<li>
<p><strong>FixedBackOffPolicy</strong> ：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒；</p>
</li>
<li>
<p><strong>UniformRandomBackOffPolicy</strong> ：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒；</p>
</li>
<li>
<p><strong>ExponentialBackOffPolicy</strong> ：指数退避策略，需设置参数 <code>sleeper、initialInterval、maxInterval</code>和<code>multiplier，initialInterval</code>指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，<code>multiplier</code>指定乘数，即下一次休眠时间为当前休眠时间*multiplier；</p>
</li>
<li>
<p><strong>ExponentialRandomBackOffPolicy</strong> ：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.retry.backoff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line">	<span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"><span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"><span class="comment">//退避策略：固定时间退避策略</span></span><br><span class="line">FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line"><span class="comment">// 每次重试间隔5000</span></span><br><span class="line">backOffPolicy.setBackOffPeriod(<span class="number">5000</span>); </span><br><span class="line">template.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">String result = template.execute(context -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们继承图可以看到，固定时间的退避策略继承了 <code>StatelessBackOffPolicy</code> 无状态的退避策略，无状态的退避策略的start 方法 返回null<br>
从template 的流程中看到，退避策略一旦出了问题，会直接抛出异常，中断重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatelessBackOffPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BackOffContext <span class="title">start</span><span class="params">(RetryContext status)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="熔断策略">熔断策略</span></h3>
<p>熔断策略解决的是 当我们随意组合了重试策略，比如说一直重试的时候，保护系统的一种机制，可以根据重试时间来中断重拾，这种中断方式会根据实际请求的来动态调整，我们来看使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">CircuitBreakerRetryPolicy retryPolicy =</span><br><span class="line">        <span class="comment">// 这里使用了 一直重试</span></span><br><span class="line">        <span class="keyword">new</span> CircuitBreakerRetryPolicy(<span class="keyword">new</span> AlwaysRetryPolicy());</span><br><span class="line"><span class="comment">// 超时时间5s</span></span><br><span class="line">retryPolicy.setOpenTimeout(<span class="number">5000</span>);</span><br><span class="line">retryPolicy.setResetTimeout(<span class="number">5000</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object key = <span class="string">"circuit"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh);</span><br><span class="line">        String result = template.execute(<span class="keyword">new</span> RetryCallback&lt;String, RuntimeException&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> RecoveryCallback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, state);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说是全局模式呢？我们配置了isForceRefresh为false，则在获取上下文时是根据key “circuit”从缓存中获取，从而拿到同一个上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object key = <span class="string">"circuit"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key,isForceRefresh);</span><br><span class="line"><span class="comment">//如下RetryTemplate代码说明在有状态模式下，不会在循环中进行重试。</span></span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熔断器策略配置代码，<code>CircuitBreakerRetryPolicy</code> 需要配置三个参数：</p>
<ul>
<li><code>delegate</code>：是真正判断是否重试的策略，当重试失败时，则执行熔断策略；</li>
<li><code>openTimeout</code>：openWindow，配置熔断器电路打开的超时时间，当超过openTimeout之后熔断器电路变成半打开状态（主要有一次重试成功，则闭合电路）；</li>
<li><code>resetTimeout</code>：timeout，配置重置熔断器重新闭合的超时时间。</li>
</ul>
<p>断熔断器电路是否打开的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line">   <span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">   <span class="keyword">if</span> (!retryable) &#123;<span class="comment">//重试失败</span></span><br><span class="line">      <span class="comment">//在重置熔断器超时后，熔断器器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="comment">//当在熔断器打开状态时，熔断器电路打开，立即熔断</span></span><br><span class="line">         <span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//重试成功</span></span><br><span class="line">      <span class="comment">//在熔断器电路半打开状态时，断路器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line">   <span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从如上代码可看出spring-retry的熔断策略相对简单：</p>
<ul>
<li>当重试失败，且在熔断器打开时间窗口[0,openWindow) 内，立即熔断；</li>
<li>当重试失败，且在指定超时时间后(&gt;timeout)，熔断器电路重新闭合；</li>
<li>在熔断器半打开状态[openWindow, timeout] 时，只要重试成功则重置上下文，断路器闭合。</li>
</ul>
<h2><span id="总结">总结</span></h2>
<p>从template 的流程我们可以看出spring 工程师的设计思想。<br>
1、 核心是一个 while(retry) {} 的循环<br>
2、 增加了 listener 等监听机制<br>
3、 在 retry 的前后加入了 接口用来实现不同的重试策略<br>
4、 在不同的重试策略中，加入了重试的退避策略<br>
5、 在不同的策略中和重试主流程中加入了 status 状态用于共享数据。</p>
<p>我们根据这些机制的不断组合，可以实现更多的重试机制。 核心代码不是很多，也很好理解。</p>
<h2><span id="参考">参考</span></h2>
<ul>
<li><a href="https://developer.aliyun.com/article/92899" target="_blank" rel="noopener">spring-retry重试与熔断详解—《亿级流量》内容补充</a></li>
<li><a href="https://segmentfault.com/a/1190000019932970" target="_blank" rel="noopener">Spring 指南（spring-retry）</a></li>
</ul>

        
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/java-cms-gc-2/" data-toggle="tooltip" data-placement="top" title="Java垃圾回收详解(5)">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/java-concurrence-2-1/" data-toggle="tooltip" data-placement="top" title="JAVA多线程之Atomic和LongAddr类（2）">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="alipay_url"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="wechatpay_url"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">详解</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">QuickStart</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number"></span> <span class="toc-nav-text">详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">类关系</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">概念详解</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">分解详解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">RetryOperations</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">RetryPolicy</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">RetryTemplate</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">有状态or无状态</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">回退策略</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">熔断策略</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">总结</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">参考</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#源码分析" title="源码分析">源码分析</a>
                        
                          <a class="tag" href="/tags/#Spring" title="Spring">Spring</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a.toc-nav-text',function(a){
            document.getElementById(a.target.innerText.replace(/\s/g,'').replace(/\./g,'-').toLowerCase()).scrollIntoView(true);
            document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/u/2028033763">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/IceFrozen">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jason Lee 2021 
                    <br>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="#">JasonLess</a> | 
                    <!-- <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="#" >
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Custom Theme search -->
<script src="/js/search.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- search code -->

    <script type="text/javascript">      
      var search_path = "search.xml";
      if (search_path.length == 0) {
          search_path = "search.xml";
      }
      var path = "/" + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');
    </script>
 

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>
