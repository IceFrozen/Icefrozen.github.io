<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入JVM字节码(1)</title>
      <link href="/article/bytecode-analysis/"/>
      <url>/article/bytecode-analysis/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>作为一个Java开发者，对技术的追求而不仅仅停留在会用API，会写基本功能上，要想在技术上有更高的造诣，就需要深入到原理层面去认识代码运行的机制。因此，本文从class字节码文件的结构入手，一步步来解剖二进制字节码的内部工作原理，这对深入理解JVM的运行机制大有裨益，同时，对于想要使用BCEL来动态改变Class字节码指令的工作也很有帮助(示例：<a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">JVM Class字节码之三-使用BCEL改变类属性</a>)。</p><h2><span id="class文件">Class文件</span></h2><p>Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。</p><p>Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><p>class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。</p><h2><span id="class文件的结构">Class文件的结构</span></h2><p>一个典型的class文件分为：<code>MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes</code>这十个部分，用一个数据结构可以表示如下：</p><p><img src="/article/bytecode-analysis/bytecode-analysis-1552027989197.png" alt></p><p>下面对class文件中的每一项进行详细的解释：</p><h3><span id="magic">magic</span></h3><p>在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： <code>0XCAFEBABE</code> 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是 <code>0XCAFEBABE，</code> 那么就说明它不是class文件， 不能被JVM识别。</p><h3><span id="minor_version-和-major_version">minor_version 和 major_version</span></h3><p>紧接着魔数的四个字节是class文件的此版本号和主版本号。<br>随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。具体的版本号变迁这里不再讨论， 需要的读者自行查阅资料。</p><h3><span id="constant_pool">constant_pool</span></h3><p>在class文件中， 位于版本号后面的就是常量池相关的数据项。</p><p>常量池是class文件中的一项非常重要的数据。<br>常量池中存放了<code>文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符</code>。</p><p>对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的<code>this_class, super_class, field_info, attribute_info</code>等。</p><p>另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外，常量池中各个项也会相互引用。</p><p>常量池是一个类的结构索引，其它地方对“对象”的引用可以通过索引位置来代替，我们知道在程序中一个变量可以不断地被调用，要快速获取这个变量常用的方法就是通过索引变量。这种索引我们可以直观理解为“<code>内存地址的虚拟</code>”。我们把它叫静态池的意思就是说这里维护着经过编译“梳理”之后的相对固定的数据索引，它是站在整个JVM（进程）层面的共享池。</p><p>class文件中的项<strong>constant_pool_count</strong>的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， <strong>没有间隙的依次排放</strong>。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的<strong>索引为1</strong>, 而不为0,<br><strong>如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项</strong>。class文件中的每一种数据项都有自己的类型， 相同的道理，常量池中的每一种数据项也有自己的类型。 常量池中的数据项的类型如下表：</p><p><img src="/article/bytecode-analysis/bytecode-analysis-1597212567599.png" alt></p><p>每个数据项叫做一个<strong>XXX_info</strong>项，比如，一个常量池中一个<strong>CONSTANT_Utf8</strong>类型的项，就是一个<strong>CONSTANT_Utf8_info</strong> 。除此之外， 每个info项中都有一个标志值（tag），这个标志值表明了这个常量池中的info项的类型是什么， 从上面的表格中可以看出，一个CONSTANT_Utf8_info中的tag值为1，而一个CONSTANT_Fieldref_info中的tag值为9 。</p><p>Java程序是动态链接的， 在动态链接的实现中， 常量池扮演者举足轻重的角色。 除了存放一些字面量之外， 常量池中还存放着以下几种符号引用：</p><ul><li>1） 类和接口的全限定名</li><li>2） 字段的名称和描述符</li><li>3） 方法的名称和描述符</li></ul><p>我们有必要先了解一下class文件中的特殊字符串， 因为在常量池中， 特殊字符串大量的出现，这些特殊字符串就是上面说的全限定名和描述符。对于常量池中的特殊字符串的了解，可以参考此文档：<a href="http://www.jb51.net/article/116313.htm" target="_blank" rel="noopener">Java class文件格式之特殊字符串_动力节点Java学院整理</a></p><h2><span id="access_flag">access_flag</span></h2><p>保存了当前类的访问权限</p><h2><span id="this_cass">this_cass</span></h2><p>保存了当前类的全局限定名在常量池里的索引</p><h2><span id="super-class">super class</span></h2><p>保存了当前类的父类的全局限定名在常量池里的索引</p><h2><span id="interfaces">interfaces</span></h2><p>保存了当前类实现的接口列表，包含两部分内容:</p><ul><li><code>interfaces_count</code> 指的是当前类实现的接口数目。</li><li><code>interfaces[]</code> 是包含interfaces_count个接口的全局限定名的索引的数组</li></ul><h2><span id="fields">fields</span></h2><p>保存了当前类的成员列表，包含两部分的内容：</p><ul><li><code>fields_count</code>是类变量和实例变量的字段的数量总和。</li><li><code>fileds[]</code>是包含字段详细信息的列表。</li></ul><h2><span id="methods">methods</span></h2><p>保存了当前类的方法列表，包含两部分的内容：</p><ul><li><code>methods_count</code>是该类或者接口显示定义的方法的数量。</li><li><code>method[]</code>是包含方法信息的一个详细列表。</li></ul><h2><span id="attributes">attributes</span></h2><p>包含了当前类的attributes列表，class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息,包含两部分内容：<br>class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。</p><ul><li><code>attributes_count</code>指的是 <code>attributes</code> 列表中包含的<code>attribute_info</code>的数量。</li><li><code>attributes[attributes_count]</code>   attributes列表</li></ul><p>属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。</p><ul><li>如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；</li><li>如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；</li><li>如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</li></ul><h2><span id="通过示例代码来手动分析class文件">通过示例代码来手动分析class文件</span></h2><p>上面大致讲解了一下class文件的结构，这里，我们拿一个class文件做一个简单的分析。</p><h2><span id="编译java文件">编译Java文件</span></h2><p>我们在这里新建一个java文件，ByteCodeShow.java，具体内容如下：(这里加上行数，后边会用到)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>| <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeShow</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>|     <span class="keyword">private</span> <span class="keyword">int</span> test;</span><br><span class="line"><span class="number">5</span>|     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">6</span>|          <span class="keyword">return</span> test;</span><br><span class="line"><span class="number">7</span>|     &#125;</span><br><span class="line"><span class="number">8</span>| &#125;</span><br></pre></td></tr></table></figure><p>然后再通过javac命令将此java文件编译成class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&gt; java -version</span><br><span class="line"></span><br><span class="line">java version <span class="string">"1.8.0_261"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_261-b12)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.261</span>-b12, mixed mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$&gt; javac ByteCodeShow.java</span></span><br></pre></td></tr></table></figure><blockquote><p>注意我这里用的是<code>1.8.0_261</code> 版本</p></blockquote><p>编译之后的class文件十六进制结果如下所示，得到：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597216042924.png" alt><br>接下来我们就按照class文件的格式来分析上面的一串数字，还是按照之前的顺序来：</p><h2><span id="java文件字节码详解">Java文件字节码详解</span></h2><h3><span id="1-magic">1.  magic:</span></h3><p><code>CA FE BA BE</code> ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件</p><h3><span id="2-version字段">2. version字段：</span></h3><p><code>00 00 00 34</code>，前两个字节00是<code>minor_version</code>，后两个字节<code>0034</code>是<code>major_version</code>字段，对应的十进制值为<code>52</code>，也就是说当前class文件的主版本号为52，次版本号为0。下表是jdk 1.6 以后对应支持的 Class 文件版本号：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597217583447.png" alt></p><h3><span id="3-量池constant_pool">3. 量池，constant_pool:</span></h3><p>紧接着 version 字段下来的两个字节是：<code>00 12</code>代表常量池里包含的常量数目，因为字节码的常量池是从1开始计数的，这个常量池包含17(十进制为18)个（<code>0x0012-1</code>）常量。constant_pool:接下来就是分析这17个常量:</p><p>首先我们用<code>jclasslib bytecode viewer</code> 打开class 文件，来看一下这个class的常量分布。<br><img src="/article/bytecode-analysis/bytecode-analysis-1597220717605.png" alt></p><h4><span id="1-第一个变量-0a-00-04-00-0e">1. 第一个变量: <code>0A 00 04 00 0E</code></span></h4><p>首先，紧接着<code>constant_pool_count</code>的第一个字节：<code>0A</code>（<code>tag=10</code>）根据上面的表格表示 <code>CONSTANT_Methodref_info</code> 对类中声明方法的一个引用。<br>其结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">     u1 tag;             <span class="comment">//u1表示占一个字节 表示该方法所属的类在常量池里的索引</span></span><br><span class="line">     u2 class_index;    <span class="comment">//u2表示占两个字节 表示该方法的名称和类型的索引。常量池里的变量的索引从1开始。</span></span><br><span class="line">     u2 name_and_type_index;    <span class="comment">//u2表示占两个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示如下：</p><ul><li>0A    ：  tag  10表示这是一个<code>CONSTANT_Methodref_info</code>结构</li><li>00 04 ： class_index 指向常量池中第4个常量所表示的类</li><li>00 0E ： name_and_type_index 指向常量池中第14个常量所表示的方法</li></ul><h4><span id="2-第二个变量09-00-03-00-0f">2. 第二个变量<code>09 00 03 00 0F</code></span></h4><p>接着是第二个常量，它的<code>tag</code>是09，根据上面的表格可知，这表示的是一个<code>CONSTANT_Fieldref</code>的结构，它的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>09 :tag</li><li>00 03 :指向常量池中第3个常量所表示的类</li><li>00 0F :指向常量池中第15个常量所表示的变量</li></ul><h4><span id="3-第三个变量-07-00-10">3. 第三个变量 <code>07 00 10</code></span></h4><p>tag为<code>07</code>表示是一个<code>CONSTANT_Class</code>变量，这个变量的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">     u1 tag;         <span class="comment">// 07</span></span><br><span class="line">     u2 name_index;  <span class="comment">// 00 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了tag字段以外，还有一个name_index的值为<code>00 10</code>，即是指向常量池中第16个常量所表示的Class名称。</p><h4><span id="4-第四个变量07-00-11">4. 第四个变量<code>07 00 11</code></span></h4><p>同上，也是一个<code>CONSTANT_Class</code>变量，不过，指向的是第17个常量所表示的Class名称。</p><h4><span id="5-第五个变量-01-00-04-74-65-73-74">5. 第五个变量 <code>01 00 04 74 65 73 74</code></span></h4><p>tag为1，表示这是一个CONSTANT_Utf8结构，这种结构用UTF-8的一种变体来表示字符串，结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 length;     <span class="comment">//  length表示该字符串的字节数</span></span><br><span class="line">     u1 bytes[length];<span class="comment">//bytes字段包含该字符串的二进制表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>01 :tag  1表示这是一个CONSTANT_Utf8结构</li><li>00 04 :表示这个字符串的长度是4字节,也就是后面的四个字节74 65 73 74</li><li>74 65 73 74 :通过ASCII码表转换后，表示的是字符串<code>test</code><br>接下来的8个变量都是字符串，这里就不具体分析了。</li></ul><h4><span id="6-第十四个常量-0c-00-07-00-08">6. 第十四个常量 <code>0C 00 07 00 08</code></span></h4><p>tag为<code>0c</code>，表示这是一个<code>CONSTANT_NameAndType</code>结构，这个结构用来描述一个方法或者成员变量。具体结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">     u1 tag; </span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name_index表示的是该变量或者方法的名称，这里的值是0007，表示指向第7个常量，即是<code>&lt;init&gt;</code>。</li><li><code>descriptor_index</code>指向该方法的描述符的引用，这里的值是0008，表示指向第8个常量，即是<code>()V</code>，由前面描述符的语法可知，这个方法是一个无参的，返回值为void的方法。</li></ul><p>综合两个字段，可以推出这个方法是<code>void &lt;init&gt;()</code>。也即是指向这个NameAndType结构的Methodref的方法名为<code>void &lt;init&gt;()</code>，也就是说第一个常量表示的是<code>void &lt;init&gt;()</code>方法，这个方法其实就是此类的默认构造方法。</p><h4><span id="7-第十五个常量0c-00-05-00-06">7. 第十五个常量<code>0C 00 05 00 06</code></span></h4><p>也是一个<code>CONSTANT_NameAndType</code>，表示的方法名为<code>int test</code>，第2个常量引用了这个<code>NameAndType</code>，所以第二个常量表示的是<code>int test()</code>方法。</p><h4><span id="8-第16和17个常量也是字符串可以按照前面的方法分析">8. 第16和17个常量也是字符串，可以按照前面的方法分析。</span></h4><h4><span id="9-完整的常量池">9.  <strong>完整的常量池</strong></span></h4><p>最后，通过以上分析，完整的常量池如下：</p><table><thead><tr><th>序号</th><th>编码</th><th>长度</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>00 12</td><td>2</td><td>长度</td><td>常量池的数目 18-1=17</td></tr><tr><td>1</td><td>0A 00 04 00 0E</td><td>5</td><td>CONSTANT_Methodref_info</td><td>指向第4和第14个常量表示： 方法：java.lang.Ojbect void <init>()</init></td></tr><tr><td>2</td><td>09 00 03 00 0F</td><td>5</td><td>CONSTANT_Fieldref</td><td>指向第3和第15个常量表示： com.classLoader.ByteCodeShow int test() &lt;test:i&gt;</td></tr><tr><td>3</td><td>07 00 10</td><td>3</td><td>CONSTANT_Class_info</td><td>16个常量表示： com.classLoader.ByteCodeShow</td></tr><tr><td>4</td><td>07 00 11</td><td>3</td><td>CONSTANT_Class_info</td><td>17个常量表示： java.lang.Ojbect</td></tr><tr><td>5</td><td>01 00 04 74 65 73 74</td><td>7</td><td>CONSTANT_Utf8_info</td><td>4个字符串，4个byte数组：表示 字符串test</td></tr><tr><td>6</td><td>01 00 01 49</td><td>4</td><td>CONSTANT_Utf8_info</td><td>1个字符串 表示 I</td></tr><tr><td>7</td><td>01 00 06 3C 69 6E 69 74 3E</td><td>9</td><td>CONSTANT_Utf8_info</td><td>字符串: &lt;init&gt;</td></tr><tr><td>8</td><td>01 00 03 28 29 56</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串 ()V<init></init></td></tr><tr><td>9</td><td>01 00 04 43 6F 64 65</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串：Code</td></tr><tr><td>10</td><td>01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65</td><td>18</td><td>CONSTANT_Utf8_info</td><td>字符串：LineNumberTable</td></tr><tr><td>11</td><td>01 00 03 28 29 49</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串：()I</td></tr><tr><td>12</td><td>01 00 0A 53 6F 75 72 63 65 46 69 6C 65</td><td>13</td><td>CONSTANT_Utf8_info</td><td>字符串：SourceFile</td></tr><tr><td>13</td><td>01 00 11 42 79 74 65 43 6F 64 65 53 68 6F 77 2E 6A 76 61</td><td>20</td><td>CONSTANT_Utf8_info</td><td>ByteCodeShow.java</td></tr><tr><td>14</td><td>0C 00 07 00 08</td><td>5</td><td>CONSTANT_NameAndType_info</td><td>引用第7 第8个变量：&lt;init&gt; ()V</td></tr><tr><td>15</td><td>0C 00 05 00 06</td><td>5</td><td>CONSTANT_NameAndType_info</td><td>引用第5 第6个变量：test I</td></tr><tr><td>16</td><td>01 00 1C 63 6F 6D 2F 63 6C 61 73 73 4C 6F 61 64 65 72 2F 42 79 74 65 43 6F 64 65 53 68 6F 77</td><td>31</td><td>CONSTANT_Utf8_info</td><td>字符串：com/classLoader/ByteCodeShow</td></tr><tr><td>17</td><td>01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</td><td>19</td><td>CONSTANT_Utf8_info</td><td>字符串：java/lang/Object</td></tr></tbody></table><p>通过这样分析其实非常的累，我们只是为了了解class文件的原理才来一步一步分析每一个二进制字节码。JDK提供了现成的工具可以直接解析此二进制文件，即javap工具(在JDK的bin目录下)，我们通过javap命令来解析此class文件：</p><p><code>javap -v -p -s -sysinfo -constants ByteCodeShow.class</code></p><p>解析得到的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$&gt; javap -v -p -s -sysinfo -constants ByteCodeShow<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Classfile</span> ... /<span class="title">src</span>/<span class="title">main</span>/<span class="title">java</span>/<span class="title">com</span>/<span class="title">classLoader</span>/<span class="title">ByteCodeShow</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-8-12</span>; size <span class="number">292</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">950e1f</span>3fd392c0f658144989ddee2453</span><br><span class="line">  Compiled from <span class="string">"ByteCodeShow.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">classLoader</span>.<span class="title">ByteCodeShow</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#14         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#15         // com/classLoader/ByteCodeShow.test:I</span><br><span class="line">   #3 = Class              #16            // com/classLoader/ByteCodeShow</span><br><span class="line">   #4 = Class              #17            // java/lang/Object</span><br><span class="line">   #5 = Utf8               test</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               ()I</span><br><span class="line">  #12 = Utf8               SourceFile</span><br><span class="line">  #13 = Utf8               ByteCodeShow.java</span><br><span class="line">  #14 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #15 = NameAndType        #5:#6          // test:I</span><br><span class="line">  #16 = Utf8               com/classLoader/ByteCodeShow</span><br><span class="line">  #17 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> test;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.classLoader.ByteCodeShow();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field test:I</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"ByteCodeShow.java"</span></span><br></pre></td></tr></table></figure><p>关于此表每一项的详细分析，可以参考国外的这一篇文档：<a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a><br>关于此表中Method操作指令<code>aload_1,getfield,ireturn</code>的作用，可以参考云溪社区的这篇文章：<br><a href="https://yq.aliyun.com/articles/7242?spm=5176.100239.blogcont7243.8.3d63c7fjRFN0C" target="_blank" rel="noopener">JVM Class详解之二 Method字节码指令</a></p><p>接下来继续看其他的字段。</p><h3><span id="4-access_flagu200-21">4. access_flag(u2:00 21)</span></h3><p><code>00 21</code>这两个字节的数据表示这个变量的访问标志位，JVM对访问标示符的规范如下：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597224177466.png" alt></p><p>这个表里面无法直接查询到 <code>0021</code>这个值，原因是0021=0020+0001，也就是表示当前class的 <code>access_flag</code> 是<code>ACC_PUBLIC|ACC_SUPER</code>。<code>ACC_PUBLIC</code>和代码里的<code>public</code> 关键字相对应。<code>ACC_SUPER</code>表示当用<code>invokespecial</code>指令来调用父类的方法时需要特殊处理。</p><h3><span id="5-this_classu20003">5. this_class(u2:0003)</span></h3><p><code>00 03</code>, <code>this_class</code>指向<code>constant pool</code>的索引值，该值必须是<code>CONSTANT_Class_info</code>类型，这里是3，即指向常量池中的第三项，即是<code>com.classLoader.ByteCodeShow</code>。</p><h3><span id="6-super_classu20004">6. super_class(u2:0004)</span></h3><p><code>00 04</code>:super_class存的是父类的名称在常量池里的索引，这里指向第四个常量，即是“java/lang/Object”。</p><h3><span id="7-interfaces">7. interfaces</span></h3><p><code>interfaces</code>包含<code>interfaces_count和interfaces[]</code>两个字段。因为这里没有实现接口，所以就不存在<code>interfces</code>选项，所以这里的interfaces_count为0（0000），所以后面的内容也对应为空。</p><h3><span id="8-fields">8. fields</span></h3><ul><li>00 01 :fields count    //表示成员变量的个数，此处为1个</li><li>00 02 00 05 00 06 00 00  : //成员field_info 变量的结构</li></ul><p>每个成员变量对应一个<code>field_info</code>结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">     u2 access_flags;      <span class="comment">//0002</span></span><br><span class="line">     u2 name_index;        <span class="comment">//0005</span></span><br><span class="line">     u2 descriptor_index;  <span class="comment">//0006</span></span><br><span class="line">     u2 attributes_count;  <span class="comment">//0000</span></span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>access_flags为0002，即是<code>ACC_PRIVATE</code></p></li><li><p>name_index指向常量池的第五个常量，为“test”</p></li><li><p>descriptor_index指向常量池的第6个常量为“I”<br>三个字段结合起来，说明这个变量是”private int test”。</p></li><li><p>接下来的是<code>attribute</code>字段，用来描述该变量的属性，因为这个变量没有附加属性，所以<code>attributes_count</code>为0，<code>attribute_info</code>为空。</p></li></ul><h3><span id="9-methods">9. methods</span></h3><p><code>00 02 00 01 00 07 00 08 00 01 00 09 ...</code><br>最前面的2个字节是<code>method_count</code></p><ul><li><p>method_count：<code>00 02</code>，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个<code>&lt;init&gt;</code>方法，这个是类的默认构造方法。</p></li><li><p>method_info</p></li></ul><p>接下来的内容是两个<code>method_info</code>结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags; </span><br><span class="line">     u2 name_index;      </span><br><span class="line">     u2 descriptor_index; </span><br><span class="line">     u2 attributes_count; </span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>00 01 00 07 00 08 00 01</code> method:<br>前三个字段和field_info一样，可以分析出第一个方法是“public void ()”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">01</span> ACC_PUBLIC</span><br><span class="line"><span class="number">00</span> <span class="number">07</span>  &lt;init&gt;</span><br><span class="line"><span class="number">00</span> <span class="number">08</span>  V()</span><br></pre></td></tr></table></figure><ul><li>attribute_info</li></ul><p>接下来是<code>attribute</code>字段，也即是这个方法的附加属性，这里的<code>attributes_count =1</code>，也即是有一个属性。<br>每个属性的都是一个<code>attribute_info</code>结构，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index; <span class="comment">// 00 09</span></span><br><span class="line">     u4 attribute_length;     <span class="comment">// 00 00 00 1D</span></span><br><span class="line">     u1 info[attribute_length];  <span class="comment">// 表示 attribute 具体info</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 预定义了部分 <code>attribute</code>，但是编译器自己也可以实现自己的<code>attribute</code>写入class文件里，供运行时使用。不同的<code>attribute</code>通过<code>attribute_name_index</code>来区分。JVM规范里对以下attribute进行了很多的预定义：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597226853638.png" alt></p><p>这里的<code>attribute_name_index</code>值为0009，表示指向第9个常量，即是<code>Code</code>。<code>Code Attribute</code>的作用是保存该方法的结构如所对应的字节码，具体的结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">     u2 attribute_name_index; </span><br><span class="line">     u4 attribute_length;  </span><br><span class="line">     u2 max_stack;       </span><br><span class="line">     u2 max_locals;     </span><br><span class="line">     u4 code_length;    </span><br><span class="line">     u1 code[code_length];    </span><br><span class="line">     u2 exception_table_length;  </span><br><span class="line">     &#123; </span><br><span class="line">          u2 start_pc;        </span><br><span class="line">          u2 end_pc;          </span><br><span class="line">          u2 handler_pc;      </span><br><span class="line">          u2 catch_type;      </span><br><span class="line">     &#125; exception_table[exception_table_length];</span><br><span class="line">     u2 attributes_count;    </span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>attribute_length</code>表示<code>attribute</code>所包含的字节数，这里为<code>0000001D</code>，即是39个字节，不包含<code>attribute_name_index</code>和<code>attribute_length</code>字段。</li><li><code>max_stack</code> 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里是0001</li><li><code>max_locals</code> 表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里是0001.</li><li>code_length表示该方法的所包含的字节码的字节数以及具体的指令码。  这里的字节码长度为<code>00000005</code>，即是后面的5个字节 <code>2A B7 00 01 B1</code>为对应的字节码指令的指令码。</li></ul><p>参照下表可以将上面的指令码翻译成对应的助记符：</p><table><thead><tr><th>指令编号</th><th>具体指令命令</th></tr></thead><tbody><tr><td>2a</td><td>aload_0</td></tr><tr><td>b7</td><td>invokespecial</td></tr><tr><td>00</td><td>nop</td></tr><tr><td>01</td><td>aconst_null</td></tr><tr><td>b1</td><td>return</td></tr></tbody></table><p>这即是该方法被调用时，虚拟机所执行的字节码</p><ul><li><p><code>exception_table</code>:这里存放的是处理异常的信息。每个<code>exception_table</code>表项由<code>start_pc，end_pc</code>，<code>handler_pc</code>，<code>catch_type</code>组成。</p></li><li><p><code>start_pc和end_pc</code>：表示在code数组中的从<code>start_pc</code>到<code>end_pc</code>处（包含<code>start_pc</code>，不包含<code>end_pc</code>）的指令抛出的异常会由这个表项来处理;</p></li><li><p><code>handler_pc</code>：表示处理异常的代码的开始处。<code>catch_type</code>表示会被处理的异常类型，它指向常量池里的一个异常类。当<code>catch_type</code>为0时，表示处理所有的异常，这个可以用来实现<code>finally</code>的功能。</p></li></ul><p>不过，这段代码里没有异常处理，所以<code>exception_table_length</code>为0000，所以我们不做分析。</p><p>接下来是该方法的附加属性，<code>attributes_count</code>为0001，表示有一个附加属性。</p><ul><li>attribute_name_index为<code>000A</code>，指向第十个常量，为<code>LineNumberTable</code>。这个属性用来表示<code>code</code>数组中的字节码和<code>java</code>代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数。<code>LineNumberTable</code>的结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 line_number_table_length;</span><br><span class="line">     &#123; u2 start_pc;</span><br><span class="line">     u2 line_number;</span><br><span class="line">&#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两个字段分别表示这个<code>attribute</code>的名称是<code>LineNumberTable</code>以及长度为<code>00000006</code>。接下来的<code>0001</code>表示<code>line_number_table_length</code>，表示<code>line_number_table</code>有一个表项，其中<code>start_pc</code>为 <code>00 00</code>，<code>line_number</code>为 <code>00 03</code>，表示第3行代码从code的第0个指令码开始。<br>我们第3行的代码恰好是定义这个类的类名</p><p>后面的内容是第二个方法，具体就不再分析了。</p><h3><span id="10-attributes">10. attributes</span></h3><p>最后剩下的内容是<code>attributes</code>，这里的<code>attributes</code>表示整个class文件的附加属性，不过结构还是和前面的<code>attribute</code>保持一致。<code>00 01</code>表示有一个attribute。<br>Attribute结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index为000c，指向第12个常量，为<code>SourceFile</code>，说明这个属性是Source</li><li>attribute_length为00000002</li><li>sourcefile_index为000d，表示指向常量池里的第13个常量，为<code>ByteCodeShow.java</code>。<br>这个属性表明当前的class文件是从ByteCodeShow文件编译而来。</li></ul><p>好，让我们完整的感受一下字节码的全貌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE     &gt; magic</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span>     &gt; minor_version : major_version </span><br><span class="line"><span class="number">00</span> <span class="number">12</span>           &gt; constant_pool_count = <span class="number">17</span></span><br><span class="line">---------  constant_pool ----- </span><br><span class="line">[<span class="number">1</span>]: <span class="number">0</span>A <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">0</span>E    </span><br><span class="line">[<span class="number">2</span>]: <span class="number">09</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">0F</span>     </span><br><span class="line">[<span class="number">3</span>]: <span class="number">07</span> <span class="number">00</span> <span class="number">10</span> </span><br><span class="line">[<span class="number">4</span>]: <span class="number">07</span> <span class="number">00</span> <span class="number">11</span> </span><br><span class="line">[<span class="number">5</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> </span><br><span class="line">[<span class="number">6</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">49</span> </span><br><span class="line">[<span class="number">7</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E </span><br><span class="line">[<span class="number">8</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> </span><br><span class="line">[<span class="number">9</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> </span><br><span class="line">[<span class="number">10</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>C <span class="number">65</span> </span><br><span class="line">[<span class="number">11</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">49</span> </span><br><span class="line">[<span class="number">12</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>A <span class="number">53</span> <span class="number">6F</span> <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> <span class="number">69</span> <span class="number">6</span>C <span class="number">65</span> </span><br><span class="line">[<span class="number">13</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">11</span> <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">53</span> <span class="number">68</span> <span class="number">6F</span> <span class="number">77</span> <span class="number">2</span>E <span class="number">6</span>A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> </span><br><span class="line">[<span class="number">14</span>]: <span class="number">0</span>C <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> </span><br><span class="line">[<span class="number">15</span>]: <span class="number">0</span>C <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">06</span>  </span><br><span class="line">[<span class="number">16</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>C <span class="number">63</span> <span class="number">6F</span> <span class="number">6</span>D <span class="number">2F</span> <span class="number">63</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">4</span>C <span class="number">6F</span> <span class="number">61</span> <span class="number">64</span> <span class="number">65</span> <span class="number">72</span> <span class="number">2F</span> <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">53</span> <span class="number">68</span> <span class="number">6F</span> <span class="number">77</span> </span><br><span class="line">[<span class="number">17</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2F</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">6</span>E <span class="number">67</span> <span class="number">2F</span> <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> </span><br><span class="line">---------  constant_pool end ----- </span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">21</span> &gt; access_flag (ACC_PUBLIC|ACC_SUPER)</span><br><span class="line"><span class="number">00</span> <span class="number">03</span> &gt; this_class (constant pool[<span class="number">3</span>] = com.classLoader.ByteCodeShow)</span><br><span class="line"><span class="number">00</span> <span class="number">04</span> &gt; super_class (constant pool[<span class="number">4</span>] = java.lang.Object)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> &gt; interfaces (empty)</span><br><span class="line">----------------- fields -------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; fields count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">---fields.field_info[<span class="number">1</span>] (<span class="keyword">private</span> <span class="keyword">int</span> test)------</span><br><span class="line"><span class="number">00</span> <span class="number">02</span> &gt; access_flags (ACC_PRIVATE)</span><br><span class="line"><span class="number">00</span> <span class="number">05</span> &gt; name_index (constant pool[<span class="number">5</span>] = test)</span><br><span class="line"><span class="number">00</span> <span class="number">06</span> &gt; descriptor_index(constant pool[<span class="number">6</span>] = I)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> &gt; attributes_count</span><br><span class="line"></span><br><span class="line">(field_info[<span class="number">1</span>].attribute_info empty)</span><br><span class="line"></span><br><span class="line">---field_info[<span class="number">1</span>] end ------</span><br><span class="line"></span><br><span class="line">----------fields end ------------------</span><br><span class="line"></span><br><span class="line">--------- methods --------------:</span><br><span class="line"><span class="number">00</span> <span class="number">02</span>  &gt; method_count</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">1</span>](<span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()) -----------</span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; access_flags(ACC_PUBLIC)</span><br><span class="line"><span class="number">00</span> <span class="number">07</span> &gt; name_index(constant pool[<span class="number">7</span>]=&lt;init&gt;)</span><br><span class="line"><span class="number">00</span> <span class="number">08</span> &gt; descriptor_index (constant pool[<span class="number">8</span>]=V())</span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; attributes_count </span><br><span class="line">--------methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute) -------------</span><br><span class="line"><span class="number">00</span> <span class="number">09</span>           &gt; attribute_name_index(constant pool[<span class="number">8</span>]=Code [Code_attribute])</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1</span>D     &gt; attribute_length(<span class="number">39</span>)</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>           &gt; max_stack</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>           &gt; max_locals</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>     &gt; code_length</span><br><span class="line"><span class="number">2</span>A B7 <span class="number">00</span> <span class="number">01</span> B1  &gt; code</span><br><span class="line"><span class="number">00</span> <span class="number">00</span>           &gt; exception_table_length</span><br><span class="line">------ exception_table_length empty -----------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; attributes_count(methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute).attributes)</span><br><span class="line">---------- methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute).attributes</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">0</span>A       &gt; attribute_name_index(constant pool[<span class="number">10</span>]=LineNumberTable)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> &gt; attribute_length</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>       &gt; line_number_table_length</span><br><span class="line"><span class="number">00</span> <span class="number">00</span>       &gt; start_pc</span><br><span class="line"><span class="number">00</span> <span class="number">03</span>       &gt; line_number</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">1</span>](<span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()) end -----------</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">2</span>](<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span>) -----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 01 &gt; <span class="title">access_flags</span><span class="params">(ACC_PUBLIC)</span></span></span><br><span class="line"><span class="function">00 05 &gt; <span class="title">name_index</span><span class="params">(constant pool[<span class="number">5</span>]=tes)</span></span></span><br><span class="line"><span class="function">00 0B &gt; <span class="title">descriptor_index</span> <span class="params">(constant pool[<span class="number">11</span>]=I)</span></span></span><br><span class="line"><span class="function">00 01 &gt; attributes_count </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods.method_info[2].attribute_info[1]<span class="params">(Code_attribute)</span> -------------</span></span><br><span class="line"><span class="function">00 09           &gt; <span class="title">attribute_name_index</span><span class="params">(constant pool[<span class="number">8</span>]=Code [Code_attribute])</span></span></span><br><span class="line"><span class="function">00 00 00 1D     &gt; <span class="title">attribute_length</span><span class="params">(<span class="number">39</span>)</span></span></span><br><span class="line"><span class="function">00 01           &gt; max_stack</span></span><br><span class="line"><span class="function">00 01           &gt; max_locals</span></span><br><span class="line"><span class="function">00 00 00 05     &gt; code_length</span></span><br><span class="line"><span class="function">2A B4 00 02 AC  &gt; code</span></span><br><span class="line"><span class="function">00 00           &gt; exception_table_length</span></span><br><span class="line"><span class="function">------ exception_table_length empty -----------</span></span><br><span class="line"><span class="function">00 01 &gt; <span class="title">attributes_count</span><span class="params">(methods.method_info[<span class="number">2</span>].attribute_info[<span class="number">1</span>](Code_attribute)</span>.attributes)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---------- methods.method_info[2].attribute_info[1]<span class="params">(Code_attribute)</span>.attributes</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 0A       &gt; <span class="title">attribute_name_index</span><span class="params">(constant pool[<span class="number">10</span>]=LineNumberTable)</span></span></span><br><span class="line"><span class="function">00 00 00 06 &gt; attribute_length</span></span><br><span class="line"><span class="function">00 00       &gt; line_number_table_length</span></span><br><span class="line"><span class="function">00 00       &gt; start_pc</span></span><br><span class="line"><span class="function">00 06       &gt; line_number</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods.method_info[2] end ----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods end ----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 01  &gt; attributes count</span></span><br><span class="line"><span class="function">-------------- attributes[1]<span class="params">(SourceFile)</span> -------------</span></span><br><span class="line"><span class="function">00 0C       &gt; attribute_name_index</span></span><br><span class="line"><span class="function">00 00 00 02 &gt; attribute_length</span></span><br><span class="line"><span class="function">00 0D       &gt; <span class="title">sourcefile_index</span><span class="params">(constant pool[<span class="number">13</span>]=SourceFile)</span></span></span><br></pre></td></tr></table></figure><p>来看一下可视化的形式</p><ul><li>一般信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235336051.png" alt></li></ul><ul><li><p>字段信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235378949.png" alt></p></li><li><p>方法信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235407217.png" alt><br><img src="/article/bytecode-analysis/bytecode-analysis-1597235437611.png" alt></p></li><li><p>属性信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235452547.png" alt></p></li></ul><h2><span id="字节码修改技术">字节码修改技术</span></h2><p>对<code>Java Class</code>字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。那通过了解字节码，我们可以做些什么呢？</p><p>其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节。</p><ul><li><p><code>ASM</code> 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p></li><li><p>目前字节码修改技术有ASM，javassist，cglib，BCEL等。cglib就是基于封装的Asm. Spring 就是使用cglib代理库。关于cglib的使用介绍，可以参考：<a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></p></li><li><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p></li></ul><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="http://blog.jamesdbloom.com/JavaCodeToByteCode_PartOne.html" target="_blank" rel="noopener">Java Code to Byte Code</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li><li><a href="http://www.cnblogs.com/paddix/p/5282004.html" target="_blank" rel="noopener">从字节码层面看“HelloWorld”</a></li><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM官网</a></li><li><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></li><li><a href="http://blog.csdn.net/danchu/article/details/70238002" target="_blank" rel="noopener">CGLIB(Code Generation Library)详解</a></li><li><a href="http://blog.csdn.net/anhuidelinger/article/details/8947791" target="_blank" rel="noopener">JVM之字节码——Class文件格式</a></li><li><a href="https://yq.aliyun.com/articles/7241?spm=5176.100239.blogcont7243.7.3d63c7fjRFN0C#" target="_blank" rel="noopener">云溪社区–JVM Class详解之一</a></li><li><a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">云溪社区–JVM Class字节码之三-使用BCEL改变类属性</a></li><li><a href="http://blog.csdn.net/yczz/article/details/14497897" target="_blank" rel="noopener">国外翻译文章：Java 编程的动态性，用 BCEL 设计字节码</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(4)</title>
      <link href="/article/java-cms-gc/"/>
      <url>/article/java-cms-gc/</url>
      
        <content type="html"><![CDATA[<h2><span id="cms-垃圾回收器简介">CMS 垃圾回收器简介</span></h2><p>由于上一篇博文已经详细介绍了，这里就不在赘述，有兴趣可以围观一下<a href="https://icefrozen.github.io/article/Java-garbage-collection-analysis-2/" target="_blank" rel="noopener">Java垃圾回收详解(2)<br>GC方式介绍</a></p><p>这里做一个简单的回顾:</p><ul><li><p>获取最短回收停顿时间为目标的多线程并发收集器</p></li><li><p>cms 只会回收老年代和永久带（1.8开始为元数据区，需要设置- <code>CMSClassUnloadingEnabled</code>, <strong>不会收集年轻带</strong>；</p></li><li><p>cms 是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到<strong>92%</strong>；</p></li></ul><h2><span id="cms-过程详解">CMS 过程详解</span></h2><h2><span id="cms收集器的7个阶段">CMS收集器的7个阶段：</span></h2><ul><li><p>初始标记（CMS initial mark）</p></li><li><p>并发标记（CMS concurrent mark）</p></li><li><p>并发预清理（CMS concurrent-preclean）</p></li><li><p>并发可取消的预清理 （CMS concurrent-abortable-preclean）</p></li><li><p>重新标记（CMS remark）</p></li><li><p>并发清除（CMS concurrent sweep）</p></li><li><p>并发重置（CMS concurrent-reset）</p></li><li><p>流程大致如下<br><img src="/article/java-cms-gc/1552636690413java-cms-gc_.png" alt></p></li></ul><ul><li>具体过程如下<br><img src="/article/java-cms-gc/1552636737931java-cms-gc_.png" alt></li></ul><h2><span id="cms-阶段详解">CMS 阶段详解</span></h2><h3><span id="初始标记idling阶段">初始标记（Idling）阶段</span></h3><p>这是CMS中两次stop-the-world事件中的一次。这一步的作用是标记存活的对象，有两部分：</p><ol><li>标记老年代中所有的<code>GC Roots</code>对象，如下图节点1；</li><li>标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；<br><img src="/article/java-cms-gc/1552640918028java-cms-gc_.png" alt></li></ol><p>在Java语言里，可作为<a href="https://icefrozen.github.io/article/Java-garbage-collection-analysis-3/" target="_blank" rel="noopener">GC Roots对象</a>的包括如下几种：</p><ol><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；</li><li>方法区中的类静态属性引用的对象 ；</li><li>方法区中的常量引用的对象 ；</li><li>本地方法栈中JNI的引用的对象；</li></ol><p><strong><em>为了加快此阶段处理速度，减少停顿时间，可以开启初始标记并行化，<code>-XX:+CMSParallelInitialMarkEnabled</code>，同时调大并行标记的线程数，线程数不要超过cpu的核数</em></strong></p><h3><span id="并发标记-initialmarking阶段">并发标记 （InitialMarking）阶段</span></h3><p>从“初始标记”阶段标记的对象开始找出所有存活的对象,也就是从<code>GC_ROOTS</code> 触发，标记所有存活对象，由于第一次的结果，所以这次的标记并<strong>不需要STW</strong>。</p><p><strong>因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的</strong>。</p><p>否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；<br>并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；</p><p>如下图所示，也就是节点1、2、3，最终找到了节点4和5。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。<br><img src="/article/java-cms-gc/1552641393363java-cms-gc_.png" alt><br>最后将6标记为存活,如下图所示：<br><img src="/article/java-cms-gc/1552641923916java-cms-gc_.png" alt></p><ul><li><strong>Card Table 是什么</strong></li></ul><blockquote><p>HotSpot 的一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p></blockquote><h3><span id="预清理-precleaning-阶段">预清理 （Precleaning） 阶段</span></h3><p>通过参数 <code>CMSPrecleaningEnabled</code> 选择关闭该阶段，默认启用，主要做两件事情：</p><ol><li><p>处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象。</p></li><li><p>在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty，然后扫描这些dirty card</p></li></ol><h3><span id="可中断的预清理abortablepreclean阶段">可中断的预清理（AbortablePreclean）阶段</span></h3><p>该阶段发生是有前提的：</p><ul><li><p>CMS 由于是在老年代垃圾扫描，但是大部分的老年代对象都是被 <code>GC_ROOTS</code> 引用的，如上图的 current obj 这个对象，虽然在老年代，但是其引用还是在年轻带，并且在并发标记阶段，也有可能老年代的某些对象别重新被新生代的对象重新引用。所以在gc的时候<strong>不仅需要扫描老年代也需要扫描新生代确定 <code>GC_ROOTS</code></strong> 。</p></li><li><p>全量的扫描新生代和老年代会不会很慢？肯定会,CMS 号称是停顿时间最短的GC，如此长的停顿时间肯定是不能接受的。 生代Eden区的内存使用量大于参数<code>CMSScheduleRemarkEdenSizeThreshold</code> 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。</p></li><li><p>如果新生代很多，超过了上述的阈值,如果在扫描新生代前进行一次Minor GC，那么在下一阶段remard的时候，新生代的对象会很少，从而节省很多时间。</p></li><li><p>CMS 有两个参数：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMSScheduleRemarkEdenSizeThreshold</span><br><span class="line">CMSScheduleRemarkEdenPenetration</span><br></pre></td></tr></table></figure><p>默认值分别是2M、50%。两个参数组合起来的意思是预清理后，eden空间使用超过2M时启动可中断的并发预清理（<code>CMS-concurrent-abortable-preclean</code>），直到eden空间使用率达到50%时中断，进入remark阶段。</p><ul><li><p>如果能在可中止的预清理阶段发生一次 Minor GC,那就万事大吉、天下太平了。 这里有一个小问题,可终止的预清理要执行多长时间来保证发生一次Minor GC?答案是没法保证。道理很简单，因为垃圾回收是JVM自动调度的,什么时候进行GC我们控制不了。但此阶段总有一个执行时间吧？是的。</p></li><li><p>CMS提供了一个参数<code>CMSMaxAbortablePrecleanTime</code> ，默认为5S。只要到了5S，不管发没发生Minor GC，有没有到<code>CMSScheduleRemardEdenPenetration</code>都会中止此阶段，进入remark。如果在5S内还是没有执行Minor GC怎么办？CMS提供<code>CMSScavengeBeforeRemark</code>参数，使remark前强制进行一次Minor GC。</p></li></ul><p>这样做利弊都有。好的一面是减少了remark阶段的停顿时间;坏的一面是Minor GC后紧跟着一个remark pause。如此一来，停顿时间也比较久。</p><p>我们来结合日志来看一下这个阶段<br>CMS日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7688.150</span>: [CMS-concurrent-preclean-start]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.186</span>: [CMS-concurrent-preclean: <span class="number">0.034</span>/<span class="number">0.035</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.186</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.465</span>: [GC <span class="number">7688.465</span>: [ParNew: <span class="number">1040940</span>K-&gt;<span class="number">1464</span>K(<span class="number">1044544</span>K), <span class="number">0.0165840</span> secs] <span class="number">1343593</span>K-&gt;<span class="number">304365</span>K(<span class="number">2093120</span>K), </span><br><span class="line"></span><br><span class="line"><span class="number">0.0167509</span> secs]<span class="number">7690.093</span>: [CMS-concurrent-abortable-preclean: <span class="number">1.012</span>/<span class="number">1.907</span> secs]  <span class="number">7690.095</span>: [GC[YG occupancy: <span class="number">522484</span> K (<span class="number">1044544</span> K)]</span><br><span class="line"></span><br><span class="line"><span class="number">7690.095</span>: [Rescan (parallel) , <span class="number">0.3665541</span> secs]<span class="number">7690.462</span>: [weak refs processing, <span class="number">0.0003850</span> secs] [<span class="number">1</span> CMS-remark: <span class="number">302901</span>K(<span class="number">1048576</span>K)] <span class="number">825385</span>K(<span class="number">2093120</span>K), <span class="number">0.3670690</span> secs]</span><br></pre></td></tr></table></figure><p>7688.186启动了可终止的预清理，在随后的三秒内启动了Minor GC，然后进入了Remark阶段.实际上为了减少remark阶段的STW时间</p><h3><span id="重新标记finalmarking">重新标记（FinalMarking）</span></h3><p>这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。<br>这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做cms的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:当此阶段耗时较长的时候，可以加入参数<code>-XX:+CMSScavengeBeforeRemark</code>，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间。<br>由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。</p><p>另外，还可以开启并行收集：-XX:+CMSParallelRemarkEnabled</p><h3><span id="并发清理-cms-concurrent-sweep">并发清理 （ CMS-concurrent-sweep ）</span></h3><p>这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。注意这个阶段会产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。</p><h3><span id="并发重置-cms-concurrent-reset">并发重置 （ CMS-concurrent-reset ）</span></h3><p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p><h2><span id="cms-调优">CMS 调优</span></h2><h2><span id="cms-jvm-参数">CMS JVM 参数</span></h2><table><thead><tr><th>参数名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>-XX:+<code>PrintCommandLineFlags</code></td><td style="text-align:left">打印出启动参数行</td></tr><tr><td>-XX:+<code>UseConcMarkSweepGC</code></td><td style="text-align:left">参数指定使用CMS垃圾回收器</td></tr><tr><td>-XX:+<code>UseCMSInitiatingOccupancyOnly</code></td><td style="text-align:left">命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过 <code>CMSInitiatingOccupancyFraction</code> 的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。</td></tr><tr><td>-XX:<code>CMSInitiatingOccupancyFraction</code>=80</td><td style="text-align:left">参数指定CMS垃圾回收器在老年代达到80%的时候开始工作，如果不指定那么默认的值为92%</td></tr><tr><td>-XX:+<code>CMSClassUnloadingEnabled</code></td><td style="text-align:left">开启永久带（jdk1.8以下版本）或元数据区（jdk1.8及其以上版本）收集，如果没有设置这个标志，一旦永久代或元数据区耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC</td></tr><tr><td>-XX:+<code>UseParNewGC</code></td><td style="text-align:left">使用cms时默认这个参数就是打开的，不需要配置，cms只回收老年代，年轻带只能配合Parallel New或Serial回收器；</td></tr><tr><td>-XX:+<code>CMSParallelRemarkEnabled</code></td><td style="text-align:left">减少Remark阶段暂停的时间，启用并行Remark，如果Remark阶段暂停时间长，可以启用这个参数  用于重新标记阶段是否采用多线程并行执行</td></tr><tr><td>-XX:+CMSScavengeBeforeRemark</td><td style="text-align:left">若Remark阶段暂停时间太长，可以启用这个参数，在Remark执行之前，先做一次ygc。因为这个阶段，年轻带也是cms的gcroot，cms会扫描年轻带指向老年代对象的引用，如果年轻带有大量引用需要被扫描，会让Remark阶段耗时增加</td></tr><tr><td>-XX:<code>CMSFullGCsBeforeCompaction</code>=0 <br>-XX:+<code>UseCMSCompactAtFullCollection</code></td><td style="text-align:left">两个参数是针对cms垃圾回收器碎片做优化的，CMS是不会移动内存的， 运行时间长了，会产生很多内存碎片， 导致没有一段连续区域可以存放大对象，出现<code>promotion failed</code>、<code>concurrent mode failure</code>, 导致fullgc，启用<code>UseCMSCompactAtFullCollection</code> 在FULL GC的时候， 对年老代的内存进行压缩。<code>-XX:CMSFullGCsBeforeCompaction=0</code> 则是代表多少次FGC后对老年代做压缩操作，默认值为0，代表每次都压缩, 把对象移动到内存的最左边，可能会影响性能,但是可以消除碎片,这两个错误会在后面的章节中详细介绍</td></tr><tr><td>-XX:+<code>CMSConcurrentMTEnabled</code> <br> -XX:<code>ConcGCThreads</code>=4</td><td style="text-align:left">定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。如果未设置这个参数，JVM会根据并行收集器中的<code>-XX:ParallelGCThreads</code>参数的值来计算出默认的并行CMS线程数,此字段如果不清楚的情况下不要设置<br><code>ParallelGCThreads = (ncpus &lt;=8 ? ncpus : 8+(ncpus-8)*5/8)</code>(ncpus为cpu个数)<br><code>ConcGCThreads =(ParallelGCThreads + 3)/4</code></td></tr><tr><td>-XX:+<code>ExplicitGCInvokesConcurrent</code> <br>-XX:+<code>ExplicitGCInvokesConcurrentAndUnloadsClasses</code></td><td style="text-align:left">开启foreground CMS GC，CMS gc 有两种模式，background和foreground，正常的cms gc使用background模式，就是我们平时说的cms gc；当并发收集失败或者调用了System.gc()的时候，就会导致一次full gc，这个fullgc是不是cms回收，而是Serial单线程回收器，加入了参数<code>-XX:+ExplicitGCInvokesConcurrent</code>后，执行full gc的时候，就变成了CMS foreground gc，它是并行full gc，只会执行cms中stop the world阶段的操作，效率比单线程Serial full GC要高；需要注意的是它只会回收old，因为cms收集器是老年代收集器；而正常的Serial收集是包含整个堆的，加入了参数<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>,代表永久带也会被cms收集；</td></tr><tr><td>-XX:+CMSParallelInitialMarkEnabled</td><td style="text-align:left">初始标记阶段是否采用多线程并行执行</td></tr><tr><td>- -XX:+PrintGCDetails</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCCause</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCTimeStamps</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCDateStamps</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -Xloggc:…/logs/gc.log</td><td style="text-align:left">日志详细打印参数</td></tr></tbody></table><h2><span id="日志分析">日志分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [GC (CMS Final Remark)</span><br><span class="line">  [YG occupancy: <span class="number">199103</span> K (<span class="number">306688</span> K)]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [Rescan (parallel) , <span class="number">0.0027865</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.293</span>-<span class="number">0800</span>: <span class="number">6.966</span>: [weak refs processing, <span class="number">0.0000397</span> secs]</span><br><span class="line">  2017-07-27T10:42:56.294-0800: 6.966: [class unloading, 0.0004163 secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.294</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub symbol table, <span class="number">0.0006806</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.295</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub string table, <span class="number">0.0001862</span> secs]</span><br><span class="line">  [<span class="number">1</span> CMS-remark: <span class="number">1569615</span>K(<span class="number">1756416</span>K)]</span><br><span class="line">  <span class="number">1768718</span>K(<span class="number">2063104</span>K),</span><br><span class="line"><span class="number">0.0043575</span> secs]</span><br><span class="line">[Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [GC (CMS Final Remark（最终标记阶段，标记老年代中所有存活的对象，包括在此前的并发标记过程中创建/修改的引用）)</span><br><span class="line">  [YG occupancy: <span class="number">199103</span> K（当前年轻代的使用量） (<span class="number">306688</span> K（年轻代总大小）)]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [Rescan (parallel) , <span class="number">0.0027865</span> secs]（在程序暂停时重新进行扫描，以完成存活对象的标记。此时 Rescan 是并行执行的）</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.293</span>-<span class="number">0800</span>: <span class="number">6.966</span>: [weak refs processing, <span class="number">0.0000397</span> secs]（第一个子阶段，处理弱引用）</span><br><span class="line">  2017-07-27T10:42:56.294-0800: 6.966: [class unloading, 0.0004163 secs]（第二个子阶段，卸载不使用的类）</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.294</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub symbol table, <span class="number">0.0006806</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.295</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub string table, <span class="number">0.0001862</span> secs]（最后一个子阶段，清理持有 <span class="class"><span class="keyword">class</span> 级别 <span class="title">metadata</span> 的符号表，以及内部化字符串对应的 <span class="title">string</span> <span class="title">tables</span>）</span></span><br><span class="line">  [1 CMS-remark: 1569615K(1756416K)]（此阶段完成后老年代的使用量和总容量）</span><br><span class="line">  <span class="number">1768718</span>K(<span class="number">2063104</span>K),（此阶段完成后整个堆内存的使用量和总容量）</span><br><span class="line"><span class="number">0.0043575</span> secs]</span><br><span class="line">[Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><h2><span id="cms-gc-分析">CMS gc 分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/第一步 初始标记 这一步会停顿</span><br><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: <span class="number">299570</span>K(<span class="number">307200</span>K)] <span class="number">323315</span>K(<span class="number">491520</span>K), <span class="number">0.0026208</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.345</span>: CMS_Initial_Mark                 [      <span class="number">10</span>          <span class="number">0</span>              <span class="number">1</span>    ]      [     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>    ]  <span class="number">0</span>   </span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0028494</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步 并发标记</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.012</span>/<span class="number">0.012</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步 预清理</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.001</span>/<span class="number">0.001</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步 可被终止的预清理</span></span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第五步 重新标记</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 72704 K (184320 K)][Rescan (parallel) , 0.0009069 secs][weak refs processing, 0.0000083 secs][class unloading, 0.0002626 secs][scrub symbol table, 0.0003789 secs][scrub string table, 0.0001326 secs][1 CMS-remark: 299570K(307200K)] 372275K(491520K), 0.0017842 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] </span><br><span class="line">         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.360</span>: CMS_Final_Remark                 [      <span class="number">10</span>          <span class="number">0</span>              <span class="number">1</span>    ]      [     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>    ]  <span class="number">0</span>   </span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0018800</span> seconds</span><br><span class="line"><span class="comment">//第六步 清理</span></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.007</span>/<span class="number">0.007</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第七步 重置</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.002</span>/<span class="number">0.002</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p>CMS 的处理流程讲完了，由于篇幅有些长，分一下章节，下次会围绕CMS 的后续问题 展开一些讨论 欢迎阅读。</p><hr><h2><span id="参考">参考:</span></h2><p><a href="http://120.52.51.16/www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf" target="_blank" rel="noopener">垃圾回收统一理论</a><br><a href="http://www.math.grin.edu/~rebelsky/Courses/CS302/99S/Presentations/GC/" target="_blank" rel="noopener">Introduction to Garbage Collection</a><br><a href="https://hllvm-group.iteye.com/group/topic/38223" target="_blank" rel="noopener">R大：并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为? </a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为? </a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(6)</title>
      <link href="/article/java-cms-gc-log/"/>
      <url>/article/java-cms-gc-log/</url>
      
        <content type="html"><![CDATA[<h2><span id="定位gc日志中stw时间较长的行为">定位GC日志中STW时间较长的行为</span></h2><h4><span id="打印所有stw停顿">打印所有STW停顿</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCApplicationStoppedTime和-XX:+PrintGCApplicationConcurrentTime</span><br></pre></td></tr></table></figure><h4><span id="找出所有暂停时间超过阈值的地方如下">找出所有暂停时间超过阈值的地方，如下：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;match($0,/.*stopped:(.*)seconds,/,a);if(a[1]&gt;0.5) print $0&#125;&apos; /data1/proxy_web_release/gclogs/gc.log.20170617_015811</span><br></pre></td></tr></table></figure><h2><span id="gc-常见问题">GC 常见问题</span></h2><h3><span id="promotion-failed">promotion failed</span></h3><p>GC日志中有时候会发现如下类似的带有“promotion failed”的日志，伴随着这类日志一般都会有较长的STW暂停时间，因此也会对线上应用造成较大影响。接下来对“promotion failed”这种GC异常情况进行一下分析：<br>一个常见的promotion failed的gc日志示例：</p><p><code class="hljs css">2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:20</span><span class="hljs-class">.381</span>+0800: 77708<span class="hljs-class">.486</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-06-17T23:33:20.382+0800: 77708.487: [ParNew (promotion failed): 3774912K-&gt;3679034K(3774912K), 0.2991519 secs]</span>2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:20</span><span class="hljs-class">.681</span>+0800: 77708<span class="hljs-class">.786</span>: <span class="hljs-attr_selector">[CMS: 3270027K-&gt;3522738K(6291456K), 1.9341892 secs]</span> 6332035<span class="hljs-tag">K-</span>&gt;3522738<span class="hljs-tag">K</span>(10066368<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 71553K-&gt;71553K(1116160K)]</span>, 2<span class="hljs-class">.2340311</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=5.61 sys=0.06, real=2.24 secs]</span><br>2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:22</span><span class="hljs-class">.616</span>+0800: 77710<span class="hljs-class">.721</span>: <span class="hljs-tag">Total</span> <span class="hljs-tag">time</span> <span class="hljs-tag">for</span> <span class="hljs-tag">which</span> <span class="hljs-tag">application</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">were</span> <span class="hljs-tag">stopped</span>: 2<span class="hljs-class">.2411722</span> <span class="hljs-tag">seconds</span>, <span class="hljs-tag">Stopping</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">took</span>: 0<span class="hljs-class">.0002553</span> <span class="hljs-tag">seconds</span><br></code></p><p>young gc 在2017-06-17T23:33:20.382触发，young gc过程花费时间为0.2991519 s，回收前后整个young区占用内存从3774912K变为3679034K。随后触发了一次Full GC来对整个堆进行STW的回收，年老代GC回收花了1.9341892 s，回收后年老代空间从3270027K变成3522738K（整个年轻代对象都promote到年老代去了），整个JVM堆空间从6332035K降低到3522738K。整个Full GC花费的时间是 2.24s（业务线程暂停时间）。</p><h4><span id="promotion-failed发生的场景">promotion failed发生的场景</span></h4><p>young GC时，对象需要从年轻代提升到年老代，但年老代可用空间由于各种原因存放不下这些对象，这时会抛出promotion failed，然后触发一次Full GC来对年老代和永久代（metaspace）进行回收，所以发生promotion failed时是会暂停业务线程引起停顿的，需要特别留意。</p><h4><span id="什么情况下对象会从年轻代往年老代提升呢">什么情况下对象会从年轻代往年老代提升呢？</span></h4><ul><li>年轻代中对象到达一定年龄的对象在minor gc时会向年老代提升。</li><li>minor gc时一个survivor空间无法装下所有年轻代存活的对象时，部分未到达年龄的对象也会向年老代提前提升。</li></ul><h4><span id="young-gc的悲观策略">Young GC的“悲观策略”</span></h4><p>有的情况下，如果JVM判断本次young GC需要提升的大小年老代放不下就会放弃本次young GC，而是直接触发一次Full GC。这种情况被称为young GC的”悲观策略“。ParNew收集器里”悲观策略“相关判断逻辑在ParNewGeneration的collect里，collection_attempt_is_safe定义在基类DefNewGeneration里，将真正的判断逻辑_next_gen-&gt;promotion_attempt_is_safe交给了next_gen（也就是CMS回收器），promotion_attempt_is_safe代码在ConcurrentMarkSweepGeneration里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the next generation is too full to accommodate worst-case promotion</span></span><br><span class="line">  <span class="comment">// from this generation, pass on collection; let the next generation</span></span><br><span class="line">  <span class="comment">// do it.</span></span><br><span class="line">  <span class="keyword">if</span> (!collection_attempt_is_safe()) &#123;</span><br><span class="line">    gch-&gt;set_incremental_collection_failed();  <span class="comment">// slight lie, in that we did not even attempt one</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool DefNewGeneration::collection_attempt_is_safe() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!to()-&gt;is_empty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">" :: to is not empty :: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_next_gen == NULL) &#123;</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    _next_gen = gch-&gt;next_gen(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _next_gen-&gt;promotion_attempt_is_safe(used());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="cms预测本次young-gc需要promote的大小老年代是否可以放下的条件是">CMS预测本次young gc需要promote的大小老年代是否可以放下的条件是：</span></h4><ul><li>老年代可用空间大于gc_stats统计的新生代每次平均晋升的大小。</li><li>老年代可以容纳目前新生代的所有对象。</li></ul><p>两个条件满足一个即可正常触发young GC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool ConcurrentMarkSweepGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) <span class="keyword">const</span> &#123;</span><br><span class="line">  size_t available = max_available();</span><br><span class="line">  size_t av_promo  = (size_t)gc_stats()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">  bool   res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes);</span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print_cr(</span><br><span class="line">      <span class="string">"CMS: promo attempt is%s safe: available("</span> SIZE_FORMAT <span class="string">") %s av_promo("</span> SIZE_FORMAT <span class="string">"),"</span></span><br><span class="line">      <span class="string">"max_promo("</span> SIZE_FORMAT <span class="string">")"</span>,</span><br><span class="line">      res? <span class="string">""</span>:<span class="string">" not"</span>, available, res? <span class="string">"&gt;="</span>:<span class="string">"&lt;"</span>,</span><br><span class="line">      av_promo, max_promotion_in_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下这次GC情况就是触发了young GC的“悲观策略”，实际这次young GC没有执行，而是直接进行了一次Full GC。：</p><p><code class="hljs css">2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.761</span>+0800: 274170<span class="hljs-class">.361</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-09-24T20:18:01.762+0800: 274170.362: [ParNew: 6291456K-&gt;6291456K(7864320K), 0.0000411 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;18389797<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0011756</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.763</span>+0800: 274170<span class="hljs-class">.362</span>: <span class="hljs-attr_selector">[Full GC (Allocation Failure) 2018-09-24T20:18:01.763+0800: 274170.363: [CMS: 12098341K-&gt;12111250K(12582912K), 6.4734175 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;12111250<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 82207K-&gt;82207K(1124352K)]</span>, 6<span class="hljs-class">.4746029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.90 sys=1.03, real=6.48 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:08</span><span class="hljs-class">.238</span>+0800: 274176<span class="hljs-class">.838</span>: <span class="hljs-tag">Total</span> <span class="hljs-tag">time</span> <span class="hljs-tag">for</span> <span class="hljs-tag">which</span> <span class="hljs-tag">application</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">were</span> <span class="hljs-tag">stopped</span>: 6<span class="hljs-class">.5035487</span> <span class="hljs-tag">seconds</span>, <span class="hljs-tag">Stopping</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">took</span>: 0<span class="hljs-class">.0008020</span> <span class="hljs-tag">seconds</span><br></code></p><p>因此，当GC log出现promotion failed时肯定是不满足”悲观策略“的判断进行了并行的新生代的垃圾回收，在最后往年老代提升空间不够时才报出的。</p><h4><span id="promotion-failed时触发的full-gc的两种情况">promotion failed时触发的Full GC的两种情况</span></h4><p>采用CMS作为老年代垃圾回收器的时候，当发生promotion failed时会触发一次Full GC，但这次Full GC可能存在两种情况。JVM根据某些条件判断本次Full GC是否需要“整理”来决定这次Full GC是使用单线程的带标记整理（mark-sweep-compact）的Serial GC的算法（do_compaction_work）来进行整个堆的垃圾回收，还是使用CMS自己的mark-sweep（do_mark_sweep_work）来做一次 多线程的foregroud GC 来对老年代进行回收。<br>是否需要整理的判断条件如下:</p><ul><li><ol><li>UseCMSCompactAtFullCollection参数开启（默认开启）。</li></ol></li><li><ol start="2"><li>上次正常的backgroud GC后Full GC（全局Full GC或者老年代foreground GC）的次数_full_gcs_since_conc_gc（每次background GC执行完sweeping阶段就会设置为0）达到启动参数设置的阈值CMSFullGCsBeforeCompaction（默认是0，也就是默认就是每次都“compact”）。</li></ol></li><li><ol start="3"><li>如果是用户触发的System GC，那么直接进行compact。</li></ol></li><li><ol start="4"><li>如果上一次young gc晋升时失败了(incremental_collection_failed为true)或者“预测本次晋升可能失败”，那么也直接进行compact。</li></ol></li></ul><p>所以实际上发现，能走到并行的foregroud GC的条件比较苛刻，默认情况下都是执行单线程带compact的Serial Old GC算法（Lisp2算法实现，在genMarkSweep.cpp中）来对整个堆进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*should_compact =</span><br><span class="line">    UseCMSCompactAtFullCollection &amp;&amp;</span><br><span class="line">    ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||</span><br><span class="line">     GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||</span><br><span class="line">     gch-&gt;incremental_collection_will_fail(<span class="keyword">true</span> <span class="comment">/* consult_young */</span>));</span><br><span class="line">  ...</span><br><span class="line"> <span class="function">bool <span class="title">incremental_collection_will_fail</span><span class="params">(bool consult_young)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">assert</span>(heap()-&gt;collector_policy()-&gt;is_two_generation_policy(),</span><br><span class="line">           <span class="string">"the following definition may not be suitable for an n(&gt;2)-generation system"</span>);</span><br><span class="line">    <span class="keyword">return</span> incremental_collection_failed() ||</span><br><span class="line">           (consult_young &amp;&amp; !get_gen(<span class="number">0</span>)-&gt;collection_attempt_is_safe());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4><span id="msc实现的serial-old-gc">MSC实现的Serial Old GC</span></h4><p>如果需要压缩就使用“带压缩”算法的单线程的Serial Old GC来进行整堆的Full GC，否则使用CMS自己的多线程的foreground GC来对老年代进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (should_compact) &#123;</span><br><span class="line">    <span class="comment">// If the collection is being acquired from the background</span></span><br><span class="line">    <span class="comment">// collector, there may be references on the discovered</span></span><br><span class="line">    <span class="comment">// references lists that have NULL referents (being those</span></span><br><span class="line">    <span class="comment">// that were concurrently cleared by a mutator) or</span></span><br><span class="line">    <span class="comment">// that are no longer active (having been enqueued concurrently</span></span><br><span class="line">    <span class="comment">// by the mutator).</span></span><br><span class="line">    <span class="comment">// Scrub the list of those references because Mark-Sweep-Compact</span></span><br><span class="line">    <span class="comment">// code assumes referents are not NULL and that all discovered</span></span><br><span class="line">    <span class="comment">// Reference objects are active.</span></span><br><span class="line">    ref_processor()-&gt;clean_up_discovered_references();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">      save_heap_summary();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do_compaction_work(clear_all_soft_refs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the GC time limit been exceeded?</span></span><br><span class="line">    DefNewGeneration* young_gen = _young_gen-&gt;as_DefNewGeneration();</span><br><span class="line">    size_t max_eden_size = young_gen-&gt;max_capacity() -</span><br><span class="line">                           young_gen-&gt;to()-&gt;capacity() -</span><br><span class="line">                           young_gen-&gt;from()-&gt;capacity();</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    GCCause::Cause gc_cause = gch-&gt;gc_cause();</span><br><span class="line">    size_policy()-&gt;check_gc_overhead_limit(_young_gen-&gt;used(),</span><br><span class="line">                                           young_gen-&gt;eden()-&gt;used(),</span><br><span class="line">                                           _cmsGen-&gt;max_capacity(),</span><br><span class="line">                                           max_eden_size,</span><br><span class="line">                                           full,</span><br><span class="line">                                           gc_cause,</span><br><span class="line">                                           gch-&gt;collector_policy());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_mark_sweep_work(clear_all_soft_refs, first_state,</span><br><span class="line">      should_start_over);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>MSC的具体实现在GenMarkSweep类中（genMarkSweep.cpp)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concurrentMarkSweepGeneration.cpp</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::do_compaction_work(bool clear_all_soft_refs) &#123;</span><br><span class="line">...</span><br><span class="line">GenMarkSweep::invoke_at_safepoint(_cmsGen-&gt;level(),</span><br><span class="line">    ref_processor(), clear_all_soft_refs);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//genMarkSweep.cpp</span></span><br><span class="line"><span class="keyword">void</span> GenMarkSweep::invoke_at_safepoint(<span class="keyword">int</span> level, ReferenceProcessor* rp, bool clear_all_softrefs) &#123;</span><br><span class="line">  guarantee(level == <span class="number">1</span>, <span class="string">"We always collect both old and young."</span>);</span><br><span class="line">  <span class="keyword">assert</span>(SafepointSynchronize::is_at_safepoint(), <span class="string">"must be at a safepoint"</span>);</span><br><span class="line"></span><br><span class="line">  GenCollectedHeap* gch = GenCollectedHeap::heap(); <span class="comment">//处理整个堆</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h4><span id="并行的foreground-gc">并行的foreground GC</span></h4><p>如果使用并行的foreground GC，整个过程都是暂停应用的，而且是<em>同步</em>的（但仍然是多线程进行处理），为了提高效率，会跳过其中一些阶段。那么这些省下来的阶段主要是并行阶段：Precleaning、AbortablePreclean，Resizing。<br>另外，如果当前backgroud的GC正在进行中，如果走到了foreground GC，那么foreground GC会在下一个安全点接管未完成的backgroud GC的后续步骤，这样还能跳过一些之前backgroud GC已经完成的阶段。</p><p>concurrentMarkSweepGeneration.cpp中相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A work method used by the foreground collector to do</span></span><br><span class="line"><span class="comment">// a mark-sweep, after taking over from a possibly on-going</span></span><br><span class="line"><span class="comment">// concurrent mark-sweep collection.</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::do_mark_sweep_work(bool clear_all_soft_refs,</span><br><span class="line">  CollectorState first_state, bool should_start_over) &#123;</span><br><span class="line">  <span class="keyword">if</span> (PrintGC &amp;&amp; Verbose) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print_cr(<span class="string">"Pass concurrent collection to foreground "</span></span><br><span class="line">      <span class="string">"collector with count %d"</span>,</span><br><span class="line">      _full_gcs_since_conc_gc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">    <span class="keyword">case</span> Idling:</span><br><span class="line">      <span class="keyword">if</span> (first_state == Idling || should_start_over) &#123;</span><br><span class="line">        <span class="comment">// The background GC was not active, or should</span></span><br><span class="line">        <span class="comment">// restarted from scratch;  start the cycle.</span></span><br><span class="line">        _collectorState = InitialMarking;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If first_state was not Idling, then a background GC</span></span><br><span class="line">      <span class="comment">// was in progress and has now finished.  No need to do it</span></span><br><span class="line">      <span class="comment">// again.  Leave the state as Idling.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="comment">// In the foreground case don't do the precleaning since</span></span><br><span class="line">      <span class="comment">// it is not done concurrently and there is extra work</span></span><br><span class="line">      <span class="comment">// required.</span></span><br><span class="line">      _collectorState = FinalMarking;</span><br><span class="line">  &#125;</span><br><span class="line">  collect_in_foreground(clear_all_soft_refs, GenCollectedHeap::heap()-&gt;gc_cause());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For a mark-sweep, compute_new_size() will be called</span></span><br><span class="line">  <span class="comment">// in the heap's do_collection() method.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMSCollector::collect_in_foreground(bool clear_all_soft_refs, GCCause::Cause cause) &#123;</span><br><span class="line"><span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">      <span class="keyword">case</span> InitialMarking:</span><br><span class="line">        register_foreground_gc_start(cause);</span><br><span class="line">        init_mark_was_synchronous = <span class="keyword">true</span>;  <span class="comment">// fact to be exploited in re-mark</span></span><br><span class="line">        checkpointRootsInitial(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Marking, <span class="string">"Collector state should have changed"</span></span><br><span class="line">          <span class="string">" within checkpointRootsInitial()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Marking:</span><br><span class="line">        <span class="comment">// initial marking in checkpointRootsInitialWork has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before initial mark: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          bool res = markFromRoots(<span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">assert</span>(res &amp;&amp; _collectorState == FinalMarking, <span class="string">"Collector state should "</span></span><br><span class="line">            <span class="string">"have changed"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> FinalMarking:</span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before re-mark: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        checkpointRootsFinal(<span class="keyword">false</span>, clear_all_soft_refs,</span><br><span class="line">                             init_mark_was_synchronous);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Sweeping, <span class="string">"Collector state should not "</span></span><br><span class="line">          <span class="string">"have changed within checkpointRootsFinal()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Sweeping:</span><br><span class="line">        <span class="comment">// final marking in checkpointRootsFinal has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before sweep: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sweep(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Resizing, <span class="string">"Incorrect state"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Resizing: &#123;</span><br><span class="line">        <span class="comment">// Sweeping has been completed; the actual resize in this case</span></span><br><span class="line">        <span class="comment">// is done separately; nothing to be done in this state.</span></span><br><span class="line">        _collectorState = Resetting;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Resetting:</span><br><span class="line">        <span class="comment">// The heap has been resized.</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before reset: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        save_heap_summary();</span><br><span class="line">        reset(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Idling, <span class="string">"Collector state should "</span></span><br><span class="line">          <span class="string">"have changed"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="keyword">case</span> AbortablePreclean:</span><br><span class="line">        <span class="comment">// Elide the preclean phase</span></span><br><span class="line">        _collectorState = FinalMarking;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ShouldNotReachHere();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreground GC由于没有压缩导致本次GC完还是没有足够空间存放的补救<br>很多情况下，如果走到了foreground GC没有进行compact，碎片问题还是没法得到解决。因此如果这次foreground GC后还是空间不足的话，就会接着进行一次彻底的Full GC，并清理软引用来尽可能回收内存，标记回收软引用后，CMS就会将is_compact设置成true，这样这最后一次Full GC就会使用单线程（VM Thread）的带标记整理（mark-sweep-compact）的Serial Old GC的算法（do_compaction_work）来进行整个堆的垃圾回收。如果这次Full GC还是不行就抛出OOM了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try a full collection; see delta for bug id 6266275</span></span><br><span class="line">    <span class="comment">// for the original code and why this has been simplified</span></span><br><span class="line">    <span class="comment">// with from-space allocation criteria modified and</span></span><br><span class="line">    <span class="comment">// such allocation moved out of the safepoint path.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = gch-&gt;attempt_allocation(size, is_tlab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">  result = expand_heap_and_allocate(size, is_tlab);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we reach this point, we're really out of memory. Try every trick</span></span><br><span class="line">  <span class="comment">// we can to reclaim memory. Force collection of soft references. Force</span></span><br><span class="line">  <span class="comment">// a complete compaction of the heap. Any additional methods for finding</span></span><br><span class="line">  <span class="comment">// free memory should be here, especially if they are expensive. If this</span></span><br><span class="line">  <span class="comment">// attempt fails, an OOM exception will be thrown.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">UIntFlagSetting <span class="title">flag_change</span><span class="params">(MarkSweepAlwaysCompactCount, <span class="number">1</span>)</span></span>; <span class="comment">// Make sure the heap is fully compacted</span></span><br><span class="line"></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clear_all_soft_refs &amp;&amp; !*should_compact) &#123;</span><br><span class="line">    <span class="comment">// We are about to do a last ditch collection attempt</span></span><br><span class="line">    <span class="comment">// so it would normally make sense to do a compaction</span></span><br><span class="line">    <span class="comment">// to reclaim as much space as possible.</span></span><br><span class="line">    <span class="keyword">if</span> (CMSCompactWhenClearAllSoftRefs) &#123;</span><br><span class="line">      <span class="comment">// Default: The rationale is that in this case either</span></span><br><span class="line">      <span class="comment">// we are past the final marking phase, in which case</span></span><br><span class="line">      <span class="comment">// we'd have to start over, or so little has been done</span></span><br><span class="line">      <span class="comment">// that there's little point in saving that work. Compaction</span></span><br><span class="line">      <span class="comment">// appears to be the sensible choice in either case.</span></span><br><span class="line">      *should_compact = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="promote-failed后gc日志打印的占用大小释疑">promote failed后GC日志打印的占用大小释疑</span></h4><p>当出现promote failed时，有的情况下会发现，本次触发的young GC后，年轻代的内存占用比回收前还上涨了。如下面示例这次：<br>这次Minor GC后，居然年轻代的占用空间还从3088943K涨到了3476337K。这个需要了解下Minor GC的过程：Minor GC开始后，遍历GC Roots，碰到eden区和from区的对象就把它挪到to区，但是并不会马上释放老的对象，直到GC完成后才会释放。如果GC出现晋升失败，这种情况下是不会释放这些老对象的，尽管to区里已经有一些eden区和from区对象的副本了。但是GC不管是否成功都会在结束后对from区和to区进行切换，这个时候原来的to区变成from区了，由于GC日志统计的只是eden+from的使用大小，GC前统计的eden+from变成了eden（未释放老对象）+原来的to（包含eden存活的部分拷贝+原来from存活的备份拷贝），这样是有可能统计出来比之前要大的。</p><p><code class="hljs css">2017<span class="hljs-tag">-10-13T18</span><span class="hljs-pseudo">:11</span><span class="hljs-pseudo">:03</span><span class="hljs-class">.817</span>+0800: 341300<span class="hljs-class">.509</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-10-13T18:11:03.818+0800: 341300.509: [ParNew (promotion failed): 3088943K-&gt;3476337K(3495296K), 0.2446697 secs]</span>2017<span class="hljs-tag">-10-13T18</span><span class="hljs-pseudo">:11</span><span class="hljs-pseudo">:04</span><span class="hljs-class">.063</span>+0800: 341300<span class="hljs-class">.754</span>: <span class="hljs-attr_selector">[CMS: 3953608K-&gt;2518422K(6291456K), 1.4883145 secs]</span> 7042552<span class="hljs-tag">K-</span>&gt;2518422<span class="hljs-tag">K</span>(9786752<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 73035K-&gt;73035K(1116160K)]</span>, 1<span class="hljs-class">.7337265</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.32 sys=0.02, real=1.73 secs]</span><br></code></p><h3><span id="concurrent-mode-failure">concurrent mode failure</span></h3><p>有的时候GC日志中还会出现“concurrent mode failure”类似的异常，一般这种异常会伴随着较长的STW时间发生。出现这种情况的前提是使用了CMS作为年老代的垃圾回收器。CMS是一款并发收集器，GC回收线程和业务的用户线程是并发执行的（除了初始标记和重新标记外其他阶段都是可以和业务线程并行的），并发执行意味着在垃圾回收执行的同时还会不停有新的对象promote到年老代。在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过剩余的空间（担保失败），就会触发concurrent mode failure。</p><p><code class="hljs css">2018<span class="hljs-tag">-05-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.818</span>+0800: 101200<span class="hljs-class">.681</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-05-05T15:32:56.819+0800: 101200.682: [ParNew: 5242832K-&gt;5242832K(5242880K), 0.0000388 secs]</span>2018<span class="hljs-tag">-05</span><br><span class="hljs-tag">-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.819</span>+0800: 101200<span class="hljs-class">.682</span>: <span class="hljs-attr_selector">[CMS2018-05-05T15:32:56.873+0800: 101200.736: [CMS-concurrent-sweep: 0.212/0.240 secs]</span> <span class="hljs-attr_selector">[Times: user=0.26 sys=0.00, real=0.23 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 7033555<span class="hljs-tag">K-</span>&gt;7033541<span class="hljs-tag">K</span>(9437184<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0766034</span> <span class="hljs-tag">secs</span>] 12276388<span class="hljs-tag">K-</span>&gt;12276374<span class="hljs-tag">K</span>(14680064<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 75013K-&gt;75013K(1118208K)]</span>, 0<span class="hljs-class">.0777029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.08 secs]</span><br></code></p><p>如上面这次concurrent mode failure，对象分配失败请求一次年轻代GC，但是这次年轻代GC并没有真正执行，根据历史promote的大小和当前年老代的空间剩余大小估算，剩余年老代空间可能不够存放promote上来的对象。因此直接触发了一次Full GC，由于当时backgroup GC正在进行中，所以这时会中止backgroup gc，然后执行一次Full GC或者foreground GC。如这次Full GC总共花费了0.08s，最终年老代空间从7033555K调整成7033541K，整个过程是STW的。</p><h4><span id="导致concurrent-mode-failure的几种情况">导致concurrent mode failure的几种情况</span></h4><p>当JVM需要申请老年代空间但剩余可用空间不够时，会去判断当前年老代是否正在进行中，如果是在进行中，除了执行Full GC外还会报告concurrent mode failure，以下几种情况会导致concurrent mode failure：</p><ol><li>年轻代发生young GC需要promote对象到老年代但老年代可用空间不够，且老年代正在执行background GC。</li><li>年轻代由于“悲观策略”放弃young GC需要触发Full GC或者CMS的foreground GC，且老年代正在执行background GC。</li><li>新分配对象大小超过-XX:PretenureSizeThreshold阈值直接在老年代分配但老年代可用空间不够，且老年代正在执行background GC。</li></ol><p>所以promotion failed不一定会导致concurrent mode failure；当然，concurrent mode failure也不一定都是由于promotion failed后的Full GC导致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMSCollector::acquire_control_and_collect</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">    report_concurrent_mode_interruption();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如下日志：本次“concurrent mode failure”就是由于young GC时“promotion failed”之后的Full GC导致的，而对象直接在年老代分配但老年代可用空间不够时，：<br><code class="hljs css">2017<span class="hljs-tag">-07-13T21</span><span class="hljs-pseudo">:37</span><span class="hljs-pseudo">:21</span><span class="hljs-class">.616</span>+0800: 2317149<span class="hljs-class">.720</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-07-13T21:37:21.616+0800: 2317149.721: [ParNew (promotion failed): 3774912K-&gt;3702108K(3774912K), 0.3012695 secs]</span>2017<span class="hljs-tag">-07-13T21</span><span class="hljs-pseudo">:37</span><span class="hljs-pseudo">:21</span><span class="hljs-class">.918</span>+0800: 2317150<span class="hljs-class">.022</span>: <span class="hljs-attr_selector">[CMS2017-07-13T21:37:21.929+0800: 2317150.034: [CMS-concurrent-abortable-preclean: 3.608/4.392 secs]</span> <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=4.39 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 5408872<span class="hljs-tag">K-</span>&gt;5935072<span class="hljs-tag">K</span>(6291456<span class="hljs-tag">K</span>), 2<span class="hljs-class">.6779990</span> <span class="hljs-tag">secs</span>] 8578988<span class="hljs-tag">K-</span>&gt;5935072<span class="hljs-tag">K</span>(10066368<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 72542K-&gt;72542K(1116160K)]</span>, 2<span class="hljs-class">.9802519</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=2.98 secs]</span><br></code></p><p>如下日志：对象在年轻代分配但年轻代由于“悲观策略”并不真正执行而是直接触发一次Full GC。</p><p><code class="hljs css">2018<span class="hljs-tag">-05-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.818</span>+0800: 101200<span class="hljs-class">.681</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-05-05T15:32:56.819+0800: 101200.682: [ParNew: 5242832K-&gt;5242832K(5242880K), 0.0000388 secs]</span>2018<span class="hljs-tag">-05</span><br><span class="hljs-tag">-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.819</span>+0800: 101200<span class="hljs-class">.682</span>: <span class="hljs-attr_selector">[CMS2018-05-05T15:32:56.873+0800: 101200.736: [CMS-concurrent-sweep: 0.212/0.240 secs]</span> <span class="hljs-attr_selector">[Times: user=0.26 sys=0.00, real=0.23 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 7033555<span class="hljs-tag">K-</span>&gt;7033541<span class="hljs-tag">K</span>(9437184<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0766034</span> <span class="hljs-tag">secs</span>] 12276388<span class="hljs-tag">K-</span>&gt;12276374<span class="hljs-tag">K</span>(14680064<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 75013K-&gt;75013K(1118208K)]</span>, 0<span class="hljs-class">.0777029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.08 secs]</span><br></code></p><p>promotion failed也不一定会导致concurrent mode failure。如果当前CMS的background gc没有在执行的话就不会出现“concurrent mode failure”，而是显示Full GC。</p><p><code class="hljs css">2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.761</span>+0800: 274170<span class="hljs-class">.361</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-09-24T20:18:01.762+0800: 274170.362: [ParNew: 6291456K-&gt;6291456K(7864320K), 0.0000411 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;18389797<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0011756</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.763</span>+0800: 274170<span class="hljs-class">.362</span>: <span class="hljs-attr_selector">[Full GC (Allocation Failure) 2018-09-24T20:18:01.763+0800: 274170.363: [CMS: 12098341K-&gt;12111250K(12582912K), 6.4734175 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;12111250<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 82207K-&gt;82207K(1124352K)]</span>, 6<span class="hljs-class">.4746029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.90 sys=1.03, real=6.48 secs]</span><br></code></p><h2><span id="解决方案">解决方案</span></h2><h2><span id="原因1cms触发太晚">原因1：CMS触发太晚</span></h2><ul><li>说明</li></ul><p>CMS的backgroup GC触发时机太晚，会导致在backgroup GC完成前，年老代剩余可用空间放不下新提升上来的或者直接在年老代分配的对象，从而触发Full GC并中断并发过程。</p><ul><li>方案</li></ul><p>通过参数-XX:CMSInitiatingOccupancyFraction=N -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSWaitDuration=M 调小，更早、更快触发年老代backgroup GC。<br>CMSInitiatingOccupancyFraction默认值是92%，CMS backgroup GC扫描间隔默认是：2000（2s）。<br>但注意这里并不是调的越小越好，越小年老代GC频率会越高，整体业务暂停的时间有可能会更长。另外，某些情况下，该参数设置太小导致年老代空间触发backgroup GC前可用的空间根本放不下所有晋升上来的长生命周期的对象，从而导致JVM一直不停地做年老代GC，严重影响业务性能。</p><h2><span id="原因2cms-gc回收处理效率太低">原因2：CMS GC回收处理效率太低</span></h2><ul><li><p>说明<br>CMS是一个并发的垃圾回收器，用于CMS各个阶段的GC线程数默认值是： ConcGCThreads = （ParallelGCThreads+3）/4。</p><p>而这里ParallelGCThreads表示的是GC并行时使用的线程数。比如如果新生代使用ParNew，那么ParallelGCThreads也就是新生代GC线程数。默认情况下，当CPU数量小于8时，ParallelGCThreads的值就是CPU的数量，当CPU数量大于8时，ParallelGCThreads的值等于3+5*cpuCount/8。</p><p>例如，在32核机器上，新生代并行GC线程数为 3 + 5*32/8 = 23，所以对应的CMS的并发线程数为 （23 +3） / 4 = 6。</p></li><li><p>方案<br>通过参数 -XX:ParallelGCThreads和-XX：ConcGCThreads来分别增加年轻代GC并行处理和年老代GC并发处理的能力。但这里也并不是越大越好，因为CMS的很多阶段都是和业务线程并发进行的，如果用于GC的线程数太多也会更多抢占业务线程的处理时间片，从而影响业务性能，所以这里需要进行实际场景的验证测试。</p></li></ul><h2><span id="原因3年老代空间碎片太多">原因3:年老代空间碎片太多</span></h2><ul><li>说明<br>CMS收集器采用的标记-清除算法，并不对年老代进行回收后的内存整理（虽然GC后会进行一些连续空间的合并）。因此多次GC后会存在较多的空间碎片。所以可能导致年老代剩余空间足够，但在大对象提升时由于没有连续的可用空间导致提升失败。</li><li>方案<br>通过-XX:+UseCMSCompactAtFullCollection和-XX:CMSFullGCsBeforeCompaction=n来让JVM在多少次Full GC后进行年老代空间的碎片整理。但是这两个参数起到的是”病后用药“的作用，前提是已经发生了Full GC才触发（所以有一些比较曲线救国的办法就是在凌晨低峰期间：代码中定时调用System.gc来触发一次Full GC从而进行年老代的空间整理）。</li></ul><p>如果碎片问题确实比较严重，可以考虑改用G1垃圾回收器（G1每次GC都会对region进行整理）。</p><h2><span id="原因4年轻代提升速度过快">原因4：年轻代提升速度过快</span></h2><ul><li>说明<br>不管是promotion failed还是concurrent mode failure，都是由于提升时年老代可用空间不够导致的，因此提升速度过快是导致这些问题的直接原因。具体会导致提升过快的非业务原因有几点：<ol><li>年轻代对象晋升年龄阈值太小。</li><li>eden区太小，触发年轻代GC太容易。</li><li>survivor空间溢出（未满年龄的对象提前晋升，参考前面的Desired survivor size的计算）。</li><li>业务中大对象较多，超过阈值直接在年老代中分配。</li></ol></li><li>方案<ol><li>调整-XX:MaxTenuringThreshold（默认15），提高年轻代晋升年龄。</li><li>注意：这里并不代表真正达到这个年龄才晋升，但JVM计算一个desired survivor size大小，survivor区对象如果累计到某一个age值的对象大小大于desired survivor size，下次晋升时大于等于该年龄的对象就会被提前promote到年老代，这里这个age值就是动态计算出来的。</li><li>eden区和survior可用区默认比例是（8:1)，survior区分s0和s1两部分，同一时刻只有一个区可用。所以实际可用大小为xmn的1/10。一般可以通过扩大eden区来减少年轻代GC次数，让年轻代对象到达触发年龄的速度慢一点。调整eden去和survior比例使用： -XX:SurvivorRatio=N。</li><li>survivor空间溢出的直接原因是计算的Desired survivor size太小，导致很多未满年龄的对象提前晋升到年老代，可以通过降低-XX:TargetSurvivorRatio=N（默认50，就是一个s0或者s1的一半），尽量避免提前晋升的溢出问题。</li><li>针对大对象，可以通过-XX:PretenureSizeThreshold来设置直接在年老代分配的对象阈值，默认是0，即：由JVM动态决定（PS：这个参数尽量不要用，除非对自己的业务细节访问模型很清楚）。</li></ol></li></ul><p>最后：如果以上调整都没办法彻底解决GC问题，那么应该考虑在系统内存可用范围内扩大整个heap的大小了。</p><h3><span id="延伸阅读如何手动触发full-gc">延伸阅读：如何手动触发Full GC？</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有开启-XX:+DisableExplicitGC的前提下调用System.gc()就会发生FullGC</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>或者通过jmap命令触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live pid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(5)</title>
      <link href="/article/java-cms-gc-2/"/>
      <url>/article/java-cms-gc-2/</url>
      
        <content type="html"><![CDATA[<h3><span id="回顾">回顾</span></h3><p>继上一节，讨论了CMS的gc 流程，本篇讨论几个遗留的问题。</p><h4><span id="cms-的缺点">CMS 的缺点</span></h4><h4><span id="cms-gc-和full-gc-和-minor-gc-的区别">CMS GC 和Full GC 和 Minor GC 的区别</span></h4><ul><li><p>CMS GC</p><p>通过一个后台线程触发，触发机制是默认每隔2秒判断一下当前老年代的内存使用率是否达到阈值，当然具体的触发条件没有这么简单，如果是则触发一次cms gc，在该过程中只会标记出存活对象，然后清除死亡对象，期间会产生碎片空间。</p></li><li><p>Full GC</p><p>是通过 vm thread 执行的，整个过程是 stop-the-world，在该过程中会判断当前 gc 是否需要进行compact，即把存活对象移动到内存的一端，可以有效的消除cms gc产生的碎片空间。</p></li></ul><ul><li><p>Minor GC</p><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：</p><p>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。<br>对年轻代的 Eden 和 Survivor 区进行了标记和复制操作，无碎片。</p></li></ul><h4><span id="cms-gc-如何触发">CMS GC 如何触发</span></h4><p>对于 cms gc 来说，触发条件很简单，实现位于 ConcurrentMarkSweepThread 类中，相当于Java 中的Thread，该线程随着堆一起初始化，在该类的 run 方法中有这么一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_should_terminate) &#123;</span><br><span class="line">    sleepBeforeNextCycle();</span><br><span class="line">    <span class="keyword">if</span> (_should_terminate) <span class="keyword">break</span>;</span><br><span class="line">    GCCause::Cause cause = _collector-&gt;_full_gc_requested ?</span><br><span class="line">      _collector-&gt;_full_gc_cause : GCCause::_cms_concurrent_mark;</span><br><span class="line">    _collector-&gt;collect_in_background(<span class="keyword">false</span>, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleepBeforeNextCycle()</code>保证了最晚每 2 秒（-XX:CMSWaitDuration）进行一次判断，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConcurrentMarkSweepThread::sleepBeforeNextCycle() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!_should_terminate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CMSIncrementalMode) &#123;</span><br><span class="line">      icms_wait();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Wait until the next synchronous GC, a concurrent full gc</span></span><br><span class="line">      <span class="comment">// request or a timeout, whichever is earlier.</span></span><br><span class="line">      wait_on_cms_lock(CMSWaitDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check if we should start a CMS collection cycle</span></span><br><span class="line">    <span class="keyword">if</span> (_collector-&gt;shouldConcurrentCollect()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .. collection criterion not yet met, let's go back</span></span><br><span class="line">    <span class="comment">// and wait some more</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>shouldConcurrentCollect()</code>方法决定了是否可以触发本次 cms gc，分为以下几种情况：</p><ol><li><p>如果<code>_full_gc_requested</code>为真，说明有明确的需求要进行gc，比如调用<code>System.gc()</code>;</p></li><li><p>CMS 默认采用 jvm 运行时的统计数据判断是否需要触发 cms gc，如果需要根据 <code>CMSInitiatingOccupancyFraction</code> 的值进行判断，需要设置参数<code>-XX:+UseCMSInitiatingOccupancyOnly</code></p></li><li><p>如果开启了<code>UseCMSInitiatingOccupancyOnly</code>参数，判断当前老年代使用率是否大于阈值，则触发 cms gc，该阈值可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>进行设置，如果没有设置，默认为92%</p></li><li><p>如果之前的 ygc 失败过，或则下次新生代执行 ygc 可能失败，这两种情况下都需要触发 cms gc；</p></li><li><p>CMS 默认不会对永久代进行垃圾收集，如果希望对永久代进行垃圾收集，需要设置参数<code>-XX:+CMSClassUnloadingEnabled</code>如果开启了CMSClassUnloadingEnabled，根据永久带的内存使用率判断是否触发 cms gc；</p></li><li><p>…还有一些其它情况<br>如果有上述几种情况，说明需要执行一次 cms gc，通过调用<code>_collector-&gt;collect_in_background(false, cause)</code> 进行触发，注意这个方法名中的in_background</p></li></ol><p>FULL GC 如何触发<br>触发 full gc 的主要原因是在eden区为对象或TLAB分配内存失败，导致一次 ygc，在 GenCollectorPolicy 类的satisfy_failed_allocation()方法中有这么一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do an incremental collection.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try a full collection; see delta for bug id 6266275</span></span><br><span class="line">    <span class="comment">// for the original code and why this has been simplified</span></span><br><span class="line">    <span class="comment">// with from-space allocation criteria modified and</span></span><br><span class="line">    <span class="comment">// such allocation moved out of the safepoint path.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法是由 vm thread 执行的，整个过程都是 stop-the-world，如果当前<code>incremental_collection_will_fail</code>方法返回 false，则会放弃本次的 ygc，直接触发一次 full gc，<code>incremental_collection_will_fail</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">incremental_collection_will_fail</span><span class="params">(bool consult_young)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assumes a 2-generation system; the first disjunct remembers if an</span></span><br><span class="line">    <span class="comment">// incremental collection failed, even when we thought (second disjunct)</span></span><br><span class="line">    <span class="comment">// that it would not.</span></span><br><span class="line">    <span class="keyword">assert</span>(heap()-&gt;collector_policy()-&gt;is_two_generation_policy(),</span><br><span class="line">           <span class="string">"the following definition may not be suitable for an n(&gt;2)-generation system"</span>);</span><br><span class="line">    <span class="keyword">return</span> incremental_collection_failed() ||</span><br><span class="line">           (consult_young &amp;&amp; !get_gen(<span class="number">0</span>)-&gt;collection_attempt_is_safe());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中参数 <code>consult_young</code> 为 <code>false</code>，如果i<code>ncremental_collection_failed()</code>返回 <code>true</code>，会导致执行很慢很慢很慢的full gc，如果上一次 ygc 过程中发生 <code>promotion failure</code>时，会设置 <code>_incremental_collection_failed</code>为 <code>true</code>，即方法<code>incremental_collection_failed()</code>返回 true，相当于触发了 full gc。</p><p>还有一种情况是，当发生ygc之后，还是没有足够的内存进行分配，这时会继续触发 full gc，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we reach this point, we're really out of memory. Try every trick</span></span><br><span class="line">  <span class="comment">// we can to reclaim memory. Force collection of soft references. Force</span></span><br><span class="line">  <span class="comment">// a complete compaction of the heap. Any additional methods for finding</span></span><br><span class="line">  <span class="comment">// free memory should be here, especially if they are expensive. If this</span></span><br><span class="line">  <span class="comment">// attempt fails, an OOM exception will be thrown.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">IntFlagSetting <span class="title">flag_change</span><span class="params">(MarkSweepAlwaysCompactCount, <span class="number">1</span>)</span></span>; <span class="comment">// Make sure the heap is fully compacted</span></span><br><span class="line"></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="full-gc-中的compact">FULL GC 中的compact</span></h3><p>每次触发 full gc，会根据<code>should_compact</code> 标识进行判断是否需要执行 compact ，判断实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*should_compact =</span><br><span class="line">      UseCMSCompactAtFullCollection &amp;&amp;</span><br><span class="line">        ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||</span><br><span class="line">         GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||</span><br><span class="line">         gch-&gt;incremental_collection_will_fail(<span class="keyword">true</span> <span class="comment">/* consult_young */</span>));</span><br></pre></td></tr></table></figure><p><code>UseCMSCompactAtFullCollection</code>默认开启，但是否要进行 compact，还得看后面的条件：</p><ol><li>最近一次cms gc 以来发生 full gc 的次数<code>_full_gcs_since_conc_gc</code>（这个值每次执行完 cms gc 的sweeping 阶段就会设置为0）达到阈值<code>CMSFullGCsBeforeCompaction</code>。</li><li>用户强制执行了gc，如<code>System.gc()</code>。</li><li>上一次 ygc 已经失败（发生了promotion failure），或预测下一次 ygc 不会成功。</li></ol><p>如果上述条件都不满足，是否就一直不进行 compact，这样碎片问题就得不到缓解了，幸好还有补救的机会，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clear_all_soft_refs &amp;&amp; !*should_compact) &#123;</span><br><span class="line">        <span class="comment">// We are about to do a last ditch collection attempt</span></span><br><span class="line">        <span class="comment">// so it would normally make sense to do a compaction</span></span><br><span class="line">        <span class="comment">// to reclaim as much space as possible.</span></span><br><span class="line">      <span class="keyword">if</span> (CMSCompactWhenClearAllSoftRefs) &#123;</span><br><span class="line">          <span class="comment">// Default: The rationale is that in this case either</span></span><br><span class="line">          <span class="comment">// we are past the final marking phase, in which case</span></span><br><span class="line">          <span class="comment">// we'd have to start over, or so little has been done</span></span><br><span class="line">          <span class="comment">// that there's little point in saving that work. Compaction</span></span><br><span class="line">          <span class="comment">// appears to be the sensible choice in either case.</span></span><br><span class="line">        *should_compact = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We have been asked to clear all soft refs, but not to</span></span><br><span class="line">          <span class="comment">// compact. Make sure that we aren't past the final checkpoint</span></span><br><span class="line">          <span class="comment">// phase, for that is where we process soft refs. If we are already</span></span><br><span class="line">          <span class="comment">// past that phase, we'll need to redo the refs discovery phase and</span></span><br><span class="line">          <span class="comment">// if necessary clear soft refs that weren't previously</span></span><br><span class="line">          <span class="comment">// cleared. We do so by remembering the phase in which</span></span><br><span class="line">          <span class="comment">// we came in, and if we are past the refs processing</span></span><br><span class="line">          <span class="comment">// phase, we'll choose to just redo the mark-sweep</span></span><br><span class="line">          <span class="comment">// collection from scratch.</span></span><br><span class="line">        <span class="keyword">if</span> (_collectorState &gt; FinalMarking) &#123;</span><br><span class="line">            <span class="comment">// We are past the refs processing phase;</span></span><br><span class="line">            <span class="comment">// start over and do a fresh synchronous CMS cycle</span></span><br><span class="line">          _collectorState = Resetting; <span class="comment">// skip to reset to start new cycle</span></span><br><span class="line">          reset(<span class="keyword">false</span> <span class="comment">/* == !asynch */</span>);</span><br><span class="line">          *should_start_over = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="comment">// else we can continue a possibly ongoing current cycle</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的 full gc，参数<code>clear_all_soft_refs</code>为 false，不会清理软引用，如果在执行完 full gc，空间还是不足的话，会执行一次彻底的 full gc，尝试清理所有的软引用，想方设法的收集可用内存，这种情况<code>clear_all_soft_refs</code>为 true，而且<code>CMSCompactWhenClearAllSoftRefs</code>默认为 true，在垃圾收集完可以执行一次compact，如果真的走到了这一步，该好好的查查代码了，因为这次 gc 的暂停时间已经很长很长很长了。<br>根据对<code>should_compact</code>参数的判断，执行不同的算法进行 full gc，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (should_compact) &#123;</span><br><span class="line">    <span class="comment">// If the collection is being acquired from the background</span></span><br><span class="line">    <span class="comment">// collector, there may be references on the discovered</span></span><br><span class="line">    <span class="comment">// references lists that have NULL referents (being those</span></span><br><span class="line">    <span class="comment">// that were concurrently cleared by a mutator) or</span></span><br><span class="line">    <span class="comment">// that are no longer active (having been enqueued concurrently</span></span><br><span class="line">    <span class="comment">// by the mutator).</span></span><br><span class="line">    <span class="comment">// Scrub the list of those references because Mark-Sweep-Compact</span></span><br><span class="line">    <span class="comment">// code assumes referents are not NULL and that all discovered</span></span><br><span class="line">    <span class="comment">// Reference objects are active.</span></span><br><span class="line">    ref_processor()-&gt;clean_up_discovered_references();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">      save_heap_summary();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do_compaction_work(clear_all_soft_refs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the GC time limit been exceeded?</span></span><br><span class="line">    DefNewGeneration* young_gen = _young_gen-&gt;as_DefNewGeneration();</span><br><span class="line">    size_t max_eden_size = young_gen-&gt;max_capacity() -</span><br><span class="line">                           young_gen-&gt;to()-&gt;capacity() -</span><br><span class="line">                           young_gen-&gt;from()-&gt;capacity();</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    GCCause::Cause gc_cause = gch-&gt;gc_cause();</span><br><span class="line">    size_policy()-&gt;check_gc_overhead_limit(_young_gen-&gt;used(),</span><br><span class="line">                                           young_gen-&gt;eden()-&gt;used(),</span><br><span class="line">                                           _cmsGen-&gt;max_capacity(),</span><br><span class="line">                                           max_eden_size,</span><br><span class="line">                                           full,</span><br><span class="line">                                           gc_cause,</span><br><span class="line">                                           gch-&gt;collector_policy());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_mark_sweep_work(clear_all_soft_refs, first_state,  should_start_over);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于引用和和gc 处理 将会在下节讨论</p><p><em>参考：</em></p><p><a href="https://www.jianshu.com/p/55670407fdb9" target="_blank" rel="noopener">关于CMS垃圾收集算法的一些疑惑</a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Retry 源码分析</title>
      <link href="/article/retry-2-spring-retry/"/>
      <url>/article/retry-2-spring-retry/</url>
      
        <content type="html"><![CDATA[<p>前面我们用自己的代理模式完成一些重试的操作，接下来我们将分析一下 <code>SpringRetry</code> 的实现方式<code>spring-retry</code> 项目实现了重试和熔断功能，目前已用于SpringBatch、Spring Integration等项目</p><h2><span id="详解">详解</span></h2><h1><span id="quickstart">QuickStart</span></h1><p>我们首先来看一下使用。<br>首先我们引入使用,这里我们使用的是<code>1.3</code>版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.retry/spring-retry --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * spring-retry1.3.x版本开始提供建造者模式支持了，可</span></span><br><span class="line"><span class="comment">         * RetryTemplate template = RetryTemplate.builder()</span></span><br><span class="line"><span class="comment">                .maxAttempts(5)</span></span><br><span class="line"><span class="comment">                .customPolicy(new SimpleRetryPolicy()).build();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">// 设置重试策略</span></span><br><span class="line">        SimpleRetryPolicy simpleRetryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        simpleRetryPolicy.setMaxAttempts(<span class="number">5</span>);</span><br><span class="line">        template.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        Object result = template.execute(</span><br><span class="line">                <span class="keyword">new</span> RetryCallback&lt;Object, Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 第一次请求，不算重试， 所以第一次请求时，context.getRetryCount()值为0</span></span><br><span class="line">                        System.out.println(context.getRetryCount());</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span> + (context.getRetryCount() + <span class="number">1</span>) + <span class="string">"次调用失败!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"走recover逻辑了! \t异常类是"</span> + lastThrowable.getClass().getName()</span><br><span class="line">                                + <span class="string">"\t异常信息是"</span> + lastThrowable.getMessage();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下调用结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">走recover逻辑了! 异常类是java.lang.RuntimeException异常信息是第<span class="number">5</span>次调用失败!</span><br></pre></td></tr></table></figure><h1><span id="详解">详解</span></h1><h2><span id="类关系">类关系</span></h2><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596005961.png" alt></p><h2><span id="概念详解">概念详解</span></h2><ul><li><p><strong>RetryOperations</strong> 和 <strong>RetryTemplate</strong><br>RetryOperations定义了重试的API，RetryTemplate提供了模板实现，线程安全的，同于Spring 一贯的API风格，RetryTemplate将重试、熔断功能封装到模板中，提供健壮和不易出错的API供大家使用。</p></li><li><p><strong>RetryCallback</strong> 和 <strong>RecoverCallback</strong><br>通过RetryCallback定义需重试的业务服务，当重试超过最大重试时间或最大重试次数后可以调用RecoveryCallback进行恢复，比如返回假数据或托底数据。</p></li><li><p><strong>RetryPolicy</strong><br>当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p></li><li><p><strong>RetryListener</strong>和<strong>RetryStatistics</strong><br>RetryListener实现拦截器模式,这里主要用于统计等，当然也可以用户自定义拦截器。</p></li><li><p><strong>BackOff</strong> ：补偿值，一般指失败后多久进行重试的延迟值。</p></li><li><p><strong>Sleeper</strong> ：暂停应用的工具，通常用来应用补偿值。</p></li><li><p><strong>RetryContext</strong> ：重试上下文，代表了能被重试动作使用的资源。</p></li><li><p><strong>RetryState</strong> ：重试状态，通常包含一个重试的键值。</p></li></ul><h2><span id="分解详解">分解详解</span></h2><h3><span id="retryoperations"><strong>RetryOperations</strong></span></h3><ul><li>首先看一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryOperations</span> </span>&#123;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RetryState retryState)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E, ExhaustedRetryException</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            RetryState retryState)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，new 出一个 <code>RetryTemplate</code> 对象后，核心是在 <code>template.execute()</code>,传递一个 <code>RetryCallback</code>，内部执行我们需要重试的具体方法。</p><p>这里我们看到 <code>RetryOperations</code> 具体定义了 <code>execute</code> 方法，用于去执行我们的相关逻辑。这里我们看到了有个 <code>RetryState</code> 对象，这里的主要是重试的状态，这个我们暂且略过，我们先来看一下<strong>重试策略</strong></p><h3><span id="retrypolicy">RetryPolicy</span></h3><p>那什么时候需重试？<code>spring-retry</code>是当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p><ol><li><strong>接口</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//是否需要重试</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// retry 生命周期函数</span></span><br><span class="line"><span class="function">RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重试接口定义了四个接口，具体的重试策略就是通过具体的实现类来完成的。<br><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596007673.png" alt></p><ol start="2"><li><strong>重试策略</strong><br>重试策略有哪些呢？spring-retry提供了如下重试策略。</li></ol><ul><li><strong>NeverRetryPolicy</strong> ：只允许调用RetryCallback一次，不允许重试；</li><li><strong>AlwaysRetryPolicy</strong> ：允许无限重试，直到成功，此方式逻辑不当会导致死循环；</li><li><strong>SimpleRetryPolicy</strong> ：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</li><li><strong>TimeoutRetryPolicy</strong> ：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</li><li><strong>MaxAttemptsRetryPolicy</strong>： 简单重试策略，仅通过重试次数判断是否能够重试，不推荐使用。</li><li><strong>CircuitBreakerRetryPolicy</strong> ：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate，稍后详细介绍该策略；</li><li><strong>CompositeRetryPolicy</strong> ：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</li></ul><p>接下来我们分析一下<code>SimpleRetryPolicy</code> 类的基本实现。</p><ol start="3"><li><strong>构造函数</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量，重试次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_ATTEMPTS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 实际重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maxAttempts;</span><br><span class="line"><span class="comment">// 错误分类器 classify包作为retry的辅助类，主要应用于RetryPolicy的canRetry()方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件</span></span><br><span class="line"><span class="keyword">private</span> BinaryExceptionClassifier retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryPolicy</span><span class="params">(<span class="keyword">int</span> maxAttempts, Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; retryableExceptions,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> traverseCauses, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.maxAttempts = maxAttempts;</span><br><span class="line"><span class="keyword">this</span>.retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(retryableExceptions, defaultValue);</span><br><span class="line"><span class="keyword">this</span>.retryableClassifier.setTraverseCauses(traverseCauses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单介绍一下 <code>retryableClassifier</code> 这个成员<br><code>classify</code> 包作为retry的辅助类，主要应用于 <code>RetryPolicy</code> 的 <code>canRetry()</code> 方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件,现在只要知道他是 用于分类的就好了。</p><ol start="4"><li><strong>函数实现</strong></li></ol><ul><li>canRetry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable t = context.getLastThrowable();</span><br><span class="line"><span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; <span class="keyword">this</span>.maxAttempts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于识别 这个异常时时我们需要的异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">retryForException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.retryableClassifier.classify(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看看出，当异常使我们需要重试的异常且次数小于制定重试次数的时候，进行重试。<code>getLastThrowable</code> 是重试上下文中捕获的最后的异常类型</p><ul><li>open</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryContext(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open 这个方法用于协调资源，是重试一开始的时候会被主流程调用，这里主要是new了一个<br><code>SimpleRetryContext上</code>下文。 所以我们如果想继续了解 这个重试策略，就要简单了解一下 <code>RetryContext</code> 上下文了。</p><ol start="5"><li><strong>SimpleRetryContext</strong><br>我们首先来看一下 <code>SimpleRetryContext</code> 这个类的定义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>SimpleRetryContext</code> 紧紧就是一个 <code>RetryContextSupport</code> 实现。我们再来看这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryContextSupport</span> <span class="keyword">extends</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">RetryContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RetryContext parent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminate = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Throwable lastException;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryContextSupport</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 一些 getset 方法</span></span><br><span class="line">    <span class="comment">// 用于记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastException = throwable;</span><br><span class="line"><span class="keyword">if</span> (throwable != <span class="keyword">null</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AttributeAccessorSupport</code> 就是一个属性类，让继承他的类可以实现增加属性。</li><li><code>RetryContext</code> 定义一些状态和属性以及  <code>AttributeAccessorSupport</code> 实现的接口方法。具体的代码不贴了，想了解的可以去翻阅源码。</li></ul><ul><li><strong>异常记录</strong><br>SimpleRetryPolicy 的异常注册其实是注册到了context中。当我们捕获了异常，就会将异常封装到这个上下文中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleRetryPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line">SimpleRetryContext simpleContext = ((SimpleRetryContext) context);</span><br><span class="line">simpleContext.registerThrowable(throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="retrytemplate">RetryTemplate</span></h3><p>到此基本的概念就讲完了。接下来先看下RetryTemplate主要流程实现：</p><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596191348.png" alt></p><p>我来看一下几个关键的成员变量</p><ol><li><strong>成员变量</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GLOBAL_STATE = <span class="string">"state.global"</span>;</span><br><span class="line"><span class="comment">// 回退策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> BackOffPolicy backOffPolicy = <span class="keyword">new</span> NoBackOffPolicy();</span><br><span class="line"><span class="comment">// 重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 重试的监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryListener[] listeners = <span class="keyword">new</span> RetryListener[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 重试上下文</span></span><br><span class="line"><span class="keyword">private</span> RetryContextCache retryContextCache = <span class="keyword">new</span> MapRetryContextCache();</span><br><span class="line"><span class="comment">// ？</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> throwLastExceptionOnExhausted;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>核心方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">   <span class="comment">//重试策略</span></span><br><span class="line">   RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">   <span class="comment">//退避策略</span></span><br><span class="line">   BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">   <span class="comment">//重试上下文，当前重试次数等都记录在上下文中</span></span><br><span class="line">   RetryContext context = open(retryPolicy, state);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同步管理器注册context 用于将context链接成一个context链儿</span></span><br><span class="line">   RetrySynchronizationManager.register(context);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拦截器模式，执行RetryListener#open</span></span><br><span class="line">      <span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// .... running 必须问true 否则 抛出异常，代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get or Start the backoff context...</span></span><br><span class="line">BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">backOffContext = (BackOffContext) resource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">backOffContext = backOffPolicy.start(context);</span><br><span class="line"><span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否可以重试执行</span></span><br><span class="line">      <span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//执行RetryCallback回调</span></span><br><span class="line">            lastException = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常</span></span><br><span class="line">            lastException = e;</span><br><span class="line">            <span class="comment">//异常时，要进行下一次重试准备</span></span><br><span class="line">            <span class="comment">//遇到异常后，注册该异常的失败次数</span></span><br><span class="line">            registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">            <span class="comment">//执行RetryListener#onError</span></span><br><span class="line">            doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">            <span class="comment">//如果可以重试，执行退避算法，比如休眠一小段时间后再重试</span></span><br><span class="line">            <span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    backOffPolicy.backOff(backOffContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">                    lastException = e;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//state != null &amp;&amp; state.rollbackFor(context.getLastThrowable())</span></span><br><span class="line">            <span class="comment">//在有状态重试时，如果是需要执行回滚操作的异常，则立即抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果是有状态重试，且有GLOBAL_STATE属性，则立即跳出重试终止；当抛出的异常是非需要执行回滚操作的异常时，才会执行到此处，CircuitBreakerRetryPolicy会在此跳出循环；</span></span><br><span class="line">         <span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      exhausted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//重试失败后，如果有RecoveryCallback，则执行此回调，否则抛出异常</span></span><br><span class="line">      <span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//清理环境</span></span><br><span class="line">      close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">      <span class="comment">//执行RetryListener#close，比如统计重试信息</span></span><br><span class="line">      doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">      <span class="comment">//RetrySynchronizationManager 清空</span></span><br><span class="line">      RetrySynchronizationManager.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上述代码，感觉很头疼，我们来提几个问题。</p><ol><li><code>MapRetryContextCache</code> 是干啥用的？</li><li><code>RetryContext context = open(retryPolicy, state)</code>中open 方法和state是什么;</li><li><code>RetrySynchronizationManager.register(context)</code>; 为什么要注册这个？</li><li><code>BackOffContext</code> 是干什么用的</li><li><code>状态重试</code>和<code>回滚操作</code>是什么意思？</li></ol><p>接下来我们来逐一分解这些流程。</p><h3><span id="有状态or无状态">有状态or无状态</span></h3><ul><li><p><strong>无状态重试</strong>，是在一个循环中执行完重试策略，即重试上下文保持在一个线程上下文中，在一次调用中进行完整的重试策略判断。非常简单的情况，如远程调用某个查询方法时是最常见的无状态重试。</p></li><li><p><strong>有状态重试</strong>，有两种情况需要使用有状态重试，事务操作需要回滚或者熔断器模式。事务操作需要回滚场景时，当整个操作中抛出的是数据库异常 DataAccessException，则不能进行重试需要回滚，而抛出其他异常则可以进行重试，可以通过 <code>RetryState</code> 实现：</p></li></ul><p>我们来具体看一下 <code>RetryState</code> 的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryState</span> </span>&#123;</span><br><span class="line"><span class="comment">//状态缓存使用的key</span></span><br><span class="line"><span class="function">Object <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 强制刷新状态</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isForceRefresh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判定当前的异常是否需要回归，默认是true.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">rollbackFor</span><span class="params">(Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最简单的情况下，重试只是一个while循环，<code>RetryTemplate</code> 可以一直尝试，直到成功或失败。RetryContext包含一些状态来决定是重试还是中止，但是这个状态位于堆栈上，不需要将它存储在全局的任何位置，因此我们将此称为无状态重试。无状态重试和有状态重试之间的区别包含在RetryPolicy的实现中（<code>RetryTemplate</code>可以同时处理这两种情况），在无状态重试中，回调总是在重试失败时在同一个线程中执行。</p><p>当我出现数据库事务性的失败的时候，我们需要回滚，这样我们会在整个 <code>template</code> 中加上try catch 代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前状态的名称，当把状态放入缓存时，通过该key查询获取</span></span><br><span class="line">Object key = <span class="string">"mykey"</span>;</span><br><span class="line"><span class="comment">//是否每次都重新生成上下文还是从缓存中查询，即全局模式（如熔断器策略时从缓存中查询）</span></span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//对DataAccessException进行回滚</span></span><br><span class="line">BinaryExceptionClassifier rf =</span><br><span class="line">        <span class="keyword">new</span> BinaryExceptionClassifier(Collections.&lt;Class&lt;? extends Throwable&gt;&gt;singleton(DataAccessException<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh, rf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// state 提出来，可以保证status 在多个 template 的exectue中可以共享一些数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = template.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchDataAccessException(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, () -&gt; <span class="string">"default"</span>, state);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(DataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 执行回滚操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这些情况下，无状态重试是不够的，因为重新抛出和回滚必然会离开<code>RetryOperations.execute()</code>方法，并可能丢失堆栈上的上下文。</p><p>为了避免丢失它，我们必须引入一种存储策略，将它从堆栈中取出并（至少）放入堆存储中，为此，Spring Retry提供了一种存储策略 <code>RetryContextCache</code>，可以将其注入 <code>RetryTemplate</code> 。<code>RetryContextCache</code> 的默认实现在内存中，使用一个简单的Map，它有一个严格执行的最大容量，以避免内存泄漏，但它没有任何高级缓存功能，如生存时间。如果需要，应该考虑注入具有这些特性的Map，在集群环境中对多个进程的高级使用可能还会考虑使用某种集群缓存实现<code>RetryContextCache</code>（不过，即使在集群环境中，这也可能是多余的）。</p><p><code>RetryOperations</code> 的部分职责是在失败的操作在新执行中返回时识别它们（通常封装在新事务中），为了促进这一点，Spring Retry提供了 <code>RetryState</code> 抽象，这与 <code>RetryOperations</code> 中的特殊 <code>execute</code> 方法一起工作。识别失败操作的方法是跨重试的多个调用标识状态，要标识状态，用户可以提供 <code>RetryState</code> 对象，该对象负责返回标识该项的唯一键，标识符用作<code>RetryContextCache</code> 中的键。</p><p>了解这个之后，我们可以来分析解决了 <code>RetryState</code> 的问题，我们来分析一下open 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RetryContext <span class="title">open</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    Object key = state.getKey();</span><br><span class="line">    <span class="keyword">if</span> (state.isForceRefresh()) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is no cache hit we can avoid the possible expense of the</span></span><br><span class="line">    <span class="comment">// cache re-hydration.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// The cache is only used if there is a failure.</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RetryContext context = <span class="keyword">this</span>.retryContextCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RetryException(<span class="string">"Inconsistent state for failed item: no history found. "</span></span><br><span class="line">                    + <span class="string">"Consider whether equals() or hashCode() for the item might be inconsistent, "</span></span><br><span class="line">                    + <span class="string">"or if you need to supply a better ItemKeyGenerator"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The cache could have been expired in between calls to</span></span><br><span class="line">        <span class="comment">// containsKey(), so we have to live with this:</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a clean slate for state that others may be inspecting</span></span><br><span class="line">    context.removeAttribute(RetryContext.CLOSED);</span><br><span class="line">    context.removeAttribute(RetryContext.EXHAUSTED);</span><br><span class="line">    context.removeAttribute(RetryContext.RECOVERED);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码我们可以了解到， 当 state 为空的时候，证明是无状态重试，那么在exectue的时候，优先执行open方法，open 方法又去执行了 <code>doOpenInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RetryContext <span class="title">doOpenInternal</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    RetryContext context = retryPolicy.open(RetrySynchronizationManager.getContext());</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setAttribute(RetryContext.STATE_KEY, state.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">        registerContext(context, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doOpenInternal</code> 方法是调用的  policy 的 open 方法，也就是 <code>simplePolicy</code> 的open 方法，<br><code>simplepolicy</code> 的方法就是创建一个 context。 另外在创建的 时候传入了一个父类 <code>context</code><br>那么 <code>RetrySynchronizationManager</code> 是在什么时候注册的呢？</p><p>实在从上面的代码看到，是在 <code>open</code> 方法结束之后，注册的，也就是说，如果同一个线程可如果多次重试，那么 <code>context</code> 是会保留的下来的，是一个链式结构。</p><p>在多个Context 之间可以共享 <code>state</code> 而这个 state 可以放到外边，多个<code>template</code> 可以共享一个<code>state</code><br>当我们的 <code>state</code> 状态设置成 不强制刷新，则会从 <code>this.retryContextCache</code> 中去寻找相关<code>key</code>对应的<code>context</code>用来复用，这样一来就实现了 多个<code>context</code> 共享一个 <code>state</code>.</p><hr><h3><span id="回退策略">回退策略</span></h3><p>重试时的退避策略是什么？是立即重试还是等待一段时间后重试，比如是网络错误，立即重试将导致立即失败，最好等待一小段时间后重试，还要防止很多服务同时重试导致DDos。</p><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596171720.png" alt></p><ul><li><p><strong>NoBackOffPolicy</strong> ：无退避算法策略，即当重试时是立即重试；</p></li><li><p><strong>FixedBackOffPolicy</strong> ：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒；</p></li><li><p><strong>UniformRandomBackOffPolicy</strong> ：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒；</p></li><li><p><strong>ExponentialBackOffPolicy</strong> ：指数退避策略，需设置参数 <code>sleeper、initialInterval、maxInterval</code>和<code>multiplier，initialInterval</code>指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，<code>multiplier</code>指定乘数，即下一次休眠时间为当前休眠时间*multiplier；</p></li><li><p><strong>ExponentialRandomBackOffPolicy</strong> ：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.retry.backoff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line"><span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"><span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"><span class="comment">//退避策略：固定时间退避策略</span></span><br><span class="line">FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line"><span class="comment">// 每次重试间隔5000</span></span><br><span class="line">backOffPolicy.setBackOffPeriod(<span class="number">5000</span>); </span><br><span class="line">template.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">String result = template.execute(context -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们继承图可以看到，固定时间的退避策略继承了 <code>StatelessBackOffPolicy</code> 无状态的退避策略，无状态的退避策略的start 方法 返回null<br>从template 的流程中看到，退避策略一旦出了问题，会直接抛出异常，中断重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatelessBackOffPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BackOffContext <span class="title">start</span><span class="params">(RetryContext status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="熔断策略">熔断策略</span></h3><p>熔断策略解决的是 当我们随意组合了重试策略，比如说一直重试的时候，保护系统的一种机制，可以根据重试时间来中断重拾，这种中断方式会根据实际请求的来动态调整，我们来看使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">CircuitBreakerRetryPolicy retryPolicy =</span><br><span class="line">        <span class="comment">// 这里使用了 一直重试</span></span><br><span class="line">        <span class="keyword">new</span> CircuitBreakerRetryPolicy(<span class="keyword">new</span> AlwaysRetryPolicy());</span><br><span class="line"><span class="comment">// 超时时间5s</span></span><br><span class="line">retryPolicy.setOpenTimeout(<span class="number">5000</span>);</span><br><span class="line">retryPolicy.setResetTimeout(<span class="number">5000</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object key = <span class="string">"circuit"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh);</span><br><span class="line">        String result = template.execute(<span class="keyword">new</span> RetryCallback&lt;String, RuntimeException&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> RecoveryCallback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, state);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说是全局模式呢？我们配置了isForceRefresh为false，则在获取上下文时是根据key “circuit”从缓存中获取，从而拿到同一个上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object key = <span class="string">"circuit"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key,isForceRefresh);</span><br><span class="line"><span class="comment">//如下RetryTemplate代码说明在有状态模式下，不会在循环中进行重试。</span></span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熔断器策略配置代码，<code>CircuitBreakerRetryPolicy</code> 需要配置三个参数：</p><ul><li><code>delegate</code>：是真正判断是否重试的策略，当重试失败时，则执行熔断策略；</li><li><code>openTimeout</code>：openWindow，配置熔断器电路打开的超时时间，当超过openTimeout之后熔断器电路变成半打开状态（主要有一次重试成功，则闭合电路）；</li><li><code>resetTimeout</code>：timeout，配置重置熔断器重新闭合的超时时间。</li></ul><p>断熔断器电路是否打开的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line">   <span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">   <span class="keyword">if</span> (!retryable) &#123;<span class="comment">//重试失败</span></span><br><span class="line">      <span class="comment">//在重置熔断器超时后，熔断器器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="comment">//当在熔断器打开状态时，熔断器电路打开，立即熔断</span></span><br><span class="line">         <span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//重试成功</span></span><br><span class="line">      <span class="comment">//在熔断器电路半打开状态时，断路器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line">   <span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从如上代码可看出spring-retry的熔断策略相对简单：</p><ul><li>当重试失败，且在熔断器打开时间窗口[0,openWindow) 内，立即熔断；</li><li>当重试失败，且在指定超时时间后(&gt;timeout)，熔断器电路重新闭合；</li><li>在熔断器半打开状态[openWindow, timeout] 时，只要重试成功则重置上下文，断路器闭合。</li></ul><h2><span id="总结">总结</span></h2><p>从template 的流程我们可以看出spring 工程师的设计思想。<br>1、 核心是一个 while(retry) {} 的循环<br>2、 增加了 listener 等监听机制<br>3、 在 retry 的前后加入了 接口用来实现不同的重试策略<br>4、 在不同的重试策略中，加入了重试的退避策略<br>5、 在不同的策略中和重试主流程中加入了 status 状态用于共享数据。</p><p>我们根据这些机制的不断组合，可以实现更多的重试机制。 核心代码不是很多，也很好理解。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://developer.aliyun.com/article/92899" target="_blank" rel="noopener">spring-retry重试与熔断详解—《亿级流量》内容补充</a></li><li><a href="https://segmentfault.com/a/1190000019932970" target="_blank" rel="noopener">Spring 指南（spring-retry）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之Atomic和LongAddr类（2）</title>
      <link href="/article/java-concurrence-2-1/"/>
      <url>/article/java-concurrence-2-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一节，我们讨论了Atomic类的实现原理，以及代码分析。这一节我来看 <code>LongAddr</code> 类。<code>LongAdder</code> 是JDK8添加到JUC中的。它是一个线程安全的、比Atomic*系工具性能更好的&quot;计数器&quot;。</p><p>首先我们来看一下 Doug Lea 大神对这个类的概述 <code>LongAddr</code></p><blockquote><p><code>LongAdder</code> 中会维护一个或多个变量，这些变量共同组成一个long型的和(这个和就是 <code>LongAddr</code> 的值)。<br>当多个线程同时更新值时，为了减少竞争，可能会动态地增加这组变量的数量。“sum”方法（等效于longValue方法）返回这组变量的“和”值。</p></blockquote><blockquote><p>当我们的场景是为了统计技术，而不是为了更细粒度的同步控制时，并且是在多线程更新的场景时，<code>LongAdder</code> 类比<code>AtomicLong</code>更好用。</p></blockquote><p>在小并发的环境下，论更新的效率，两者都差不多。但是高并发的场景下，LongAdder有着明显更高的吞吐量，但是有着更高的空间复杂度。</p><h2><span id="atomic缺陷">Atomic缺陷</span></h2><p>AtomicLong 的 Add() 是依赖自旋不断的 CAS 去累加一个 Long 值。如果在竞争激烈的情况下，CAS 操作不断的失败，就会有大量的线程不断的自旋尝试 CAS 会造成 CPU 的极大的消耗。</p><h2><span id="longaddr详解">LongAddr详解</span></h2><h2><span id="longaddr-类图">LongAddr 类图</span></h2><p><img src="/article/java-concurrence-2-1/java-concurrence-2-1-105130.png" alt></p><p>这里主要涉及两个主要的类</p><ul><li>Striped64</li><li>LongAddr<br>如果我们要了解 <code>LongAddr</code>， 就要先了解 <code>LongAddr</code> 如何使用。</li></ul><h2><span id="longaddr的使用">LongAddr的使用</span></h2><p>LongAddr 在主要方法体现在一下几个地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">longAdder.add(<span class="number">20L</span>);     <span class="comment">// 增加20</span></span><br><span class="line">longAdder.increment();     <span class="comment">// +1</span></span><br><span class="line">longAdder.decrement();     <span class="comment">// -1 </span></span><br><span class="line"><span class="keyword">long</span> sum = longAdder.sum(); <span class="comment">// 获取 longaddr 值</span></span><br><span class="line"><span class="keyword">long</span> sumThenReset = longAdder.sumThenReset();   <span class="comment">// 将long addr 置零并且获取值</span></span><br><span class="line">longAdder.reset();  <span class="comment">//置零</span></span><br></pre></td></tr></table></figure><h2><span id="add-方法">Add 方法</span></h2><p>对于累加器 最核心的方法就是 add 方法了，我们来看一下add 方法的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 cells 数组不为空，对参数进行 casBase 操作，如果 casBase 操作失败。可能是竞争激烈，进入第二步。</li><li>如果 cells 为空，直接进入 <code>longAccumulate()</code>;</li><li>m = cells 数组长度减一，如果数组长度小于 1，则进入 <code>longAccumulate()</code></li></ol><p>如果都没有满足以上条件，则对当前线程进行某种 hash 生成一个数组下标，对下标保存的值进行 cas 操作。如果操作失败，则说明竞争依然激烈，则进入 <code>longAccumulate()</code>.</p><p>从类图上来看，<code>LongAdder</code> 没有任何的成员比变量，那么add 方法所用的基本上都是<code>Striped64</code> 类中的变量。<code>LongAddr</code> 继承了 <code>Striped64</code> 类，而 <code>Striped64</code> 是计数器的核心功能点.</p><p>这里我们提一个问题:</p><ol><li>Cell 是什么？</li><li>CasBase 方法是什么？</li><li>LongAccumulate 方法又在干什么？</li></ol><p>要解答以上三个问题，我们需要了解一下  Striped64 到底干了什么事情。</p><h2><span id="striped64">Striped64</span></h2><p><code>Striped64</code> 是在java8中添加用来支持累加器的并发组件，它可以在并发环境下使用来做某种计数。</p><h3><span id="设计思路">设计思路</span></h3><p><code>Striped64</code>: 设计思路是在竞争激烈的时候尽量分散竞争，在实现上 <code>Striped64</code> 维护了一个<code>base Count</code>和一个<code>Cell</code>数组。</p><p>计数线程会首先试图更新 <code>base</code> 变量，如果成功则退出计数，否则会认为当前竞争是很激烈的，那么就会通过 <code>Cell</code> 数组来分散计数</p><p><code>Striped64</code> 根据线程来计算哈希，然后将不同的线程分散到不同的Cell数组的 <code>index</code> 上，然后这个线程的计数内容就会保存在该 <code>Cell</code> 的位置上面，基于这种设计，最后的总计数需要结合 <code>base</code> 以及散落在Cell数组中的计数内容。</p><p><img src="/article/java-concurrence-2-1/java-concurrence-2-1-102933.png" alt></p><p>我们来看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cell组</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Unsafe方法，用于</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** CPU数量 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/**Cell数组 2的平方. */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line">    <span class="comment">/** Base value 基础值 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line">    <span class="comment">/** cells 正在扩容的标志位*/</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line">    Striped64() &#123;&#125;</span><br><span class="line">    <span class="comment">// Cas基础值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** casCellsBusy cas替换，表示正在扩容*/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casCellsBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取线程的 Probe 可以理解为随机数种子  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">advanceProbe</span><span class="params">(<span class="keyword">int</span> probe)</span> </span>&#123;</span><br><span class="line">        probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">        probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        probe ^= probe &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);</span><br><span class="line">        <span class="keyword">return</span> probe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; sk = Striped64<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            BASE = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"base"</span>));</span><br><span class="line">            CELLSBUSY = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">            Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ... ... ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，我们可以回答一下上面的几个问题了<br>我们在看一下 <code>add</code> 的代码,分析得到了一下结论</p><p>1、 <code>Cell</code> 是什么<br><code>Cell</code> 就是加了 避免为共享的类 <code>Cell</code> 里面只有一个value值， 更新Cell 的value 值值能通过 cas 方法</p><p>2、 <code>casBase</code> 是更新 <code>base value</code> 的方法， <code>Striped64</code> 有 <code>cell</code> 数组，如果竞争激烈，也就是 <code>casBase</code> 方法 失败，那么意味着多个线程竞争修改 <code>base</code> value值</p><p>3、发生竞争，就去 <code>cell</code> 数组中选择一个 <code>cell</code> 去更新，选择计算 <code>getProbe() &amp; m</code>的值，其中m为 <code>cell</code> 数组个数。</p><p>4、 如果找到了 cell 则执行cell 的cas操作，如果找不到，或者cas操作也失败了则执行 <code>longAccumulate</code> 方法</p><h3><span id="longaccumulate">longAccumulate</span></h3><p>来看一下 <code>longAccumulate</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// ThreadLocalRandom 初始化主要是为了得到 threadLocalRandomProbe 值</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;  <span class="comment">// cells 数组不为空</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// 判断是否有其他线程在扩容</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// 创建一个 Cell </span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// casCellsBusy</span></span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;        </span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// 在cas 下做二次校验 </span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;     <span class="comment">// 赋值成功</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;      <span class="comment">// cells 变成0 以防出异常退出</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;          <span class="comment">// 如果创建了这退出</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// 没有创建成功则继续循环，说明在复制的时候出错了</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))    <span class="comment">// 如果找到cell 直接用cas操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;                       <span class="comment">// 这里仅仅是扩容 没有负责</span></span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Cell数组扩容 </span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                h = advanceProbe(h);         </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一下代表cell 为空 cells == as 表示前面已经经历过 第一层的判断了 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// 初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从判断上来看，我们一共发现了三个主要逻辑判断<br>在 longAccumulate 中有几个标记位，我们也先理解一下</p><ol><li><code>cellsBusy</code> <code>cells</code> 的操作标记位，如果正在修改、新建、操作 <code>cells</code> 数组中的元素会,会将其 cas 为 1，否则为0。</li><li><code>wasUncontended</code> 表示 <code>cas</code> 是否失败，如果失败则考虑操作升级。</li><li><code>collide</code> 是否冲突，如果冲突，则考虑扩容 <code>cells</code> 的长度。</li></ol><p>整个 for(;;) 死循环，都是以 cas 操作成功而告终。否则则会修改上述描述的几个标记位，重新进入循环。</p><ul><li><p>1、如果Cell不为空 (<code>if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0)</code>)</p><ul><li>果 cell[i] 某个下标为空，则 new 一个 cell，并初始化值，然后退出</li><li>如果 上层传过来的结果是 cas 失败，继续循环。</li><li>如果 cell 不为空，且 cell cas 成功，退出</li><li>如果 cell 的数量，大于等于 cpu 数量或者已经扩容了，继续重试。（扩容没意义）</li><li>设置 collide 为 true。</li><li>获取 cellsBusy 成功就对 cell 进行扩容，获取 cellBusy 失败则重新 hash 再重试。</li></ul></li><li><p>2、 是否能 更新 <code>cellsBusy</code> 值 ，走到这里表示 如果Cell 为空, 这个步骤讲的是需要开始初始化 cell(<code>(cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy())</code>)</p></li><li><p>3、<code>cellsBusy</code> 获取失败,表示有可能别的进程在扩容，则自己去更新 base 值， <code>baseCas</code> ，操作成功退出，不成功则重试<br><code>if (casBase(v = base, ((fn == null) ? v + x :fn.applyAsLong(v, x))</code></p></li></ul><p>至此 longAccumulate 就分析完了。之所以这个方法那么复杂，我认为有两个原因</p><ol><li>是因为并发环境下要考虑各种操作的原子性，所以对于锁都进行了 double check。</li><li>操作都是逐步升级，以最小的代价实现功能。</li></ol><h3><span id="sum-方法">Sum 方法</span></h3><p>它需要累计base和Cell数组中的Cell中的计数，base中的计数为线程竞争不是很激烈的时候累计的数，而在线程竞争比较激烈的时候就会将计数的任务分散到Cell数组中，所以在sum方法里，需要合并两处的计数值。</p><p>除了获取总计数，我们有时候想reset一下，下面的代码展示了这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 大家注意到，这里并没有加锁，也就是标明，sum 调用的时候是允许，其他线程继续更新的。这种只是调用返回的一个快照值，在返回sum的过程中，有可能更新还在继续</strong>。</p><h2><span id="reset-方法">reset 方法</span></h2><p>reset 方法将 base 和每个cell 当中的 value 值重置成0<br>但是有几个需要注意的地方</p><ol><li>reset 方法不会重置 cell 数组的数量。</li><li>reset 调用的前提 是没有线程再去更新值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="striped64在concurrenthashmap">Striped64在ConcurrentHashMap</span></h2><p><code>Striped64</code> 的计数方法在java8的 <code>ConcurrentHashMap</code> 中也有使用，具体的实现细节可以参考 <code>addCount</code> 方法，下面来看一下 <code>ConcurrentHashMap</code> 的size方法的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/30d328e9353b" target="_blank" rel="noopener">Java 并发计数组件Striped64详解</a></li><li><a href="https://xilidou.com/2018/11/27/LongAdder/" target="_blank" rel="noopener">从 LongAdder 中窥见并发组件的设计思路</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之Atomic和LongAddr类（1）</title>
      <link href="/article/java-concurrence-2/"/>
      <url>/article/java-concurrence-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><h2><span id="atomic与longaddr解决什么问题">Atomic与LongAddr解决什么问题</span></h2><p>解决变量赋值的原子性问题。 底层采用的是CAS的自旋的方式来实现的。CAS会有ABA和性能的问题，Atomic 采用版本号的方式来解决ABA的问题。ABA问题是否会对业务产生影响，还需要业务方自己评估，大部分情况下比如一些非金融业务系统中，ABA不会对业务造成影响。<br>至于性能问题，CAS自旋的方式确实会造成一些CPU的空转，因为严格意义上来说CAS不能算是锁，所以说CAS的也有适用范围。</p><p>自旋操作适用于线程竞争力度大，线程执行时间比较短的情况。这种情况下，CAS自旋空转的等待时间表少，如线程运行时间比较长，最好的方式还是使用重量级的锁，比如说 synchronized AQS等重量级的锁。</p><h2><span id="atomic类与longaddr类简单对比">Atomic类与LongAddr类简单对比</span></h2><p>我们来看一个实例程序 分别来计算 <code>synchronized</code>,<code>Atomic</code>,<code>LongAdder</code> 运行N秒，累加数量的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例： 同时运行5秒，检查谁的次数最多</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Atomic方式</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong acount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// LongAdder 方式  （jdk1.8,新计数器）</span></span><br><span class="line">    <span class="keyword">private</span> LongAdder lacount = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    <span class="comment">// 运行时间，毫秒数</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> time=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 同步代码块的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"SyncThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + count);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    acount.incrementAndGet(); <span class="comment">// acount++;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"AtomicThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + acount.incrementAndGet());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLongAdder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    lacount.increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"LongAdderThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + lacount.sum());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdderDemo demo = <span class="keyword">new</span> LongAdderDemo();</span><br><span class="line">        demo.testSync();</span><br><span class="line">        demo.testAtomic();</span><br><span class="line">        demo.testLongAdder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看耗时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832099</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832100</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832101</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309048936</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309098061</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309356235</span></span><br></pre></td></tr></table></figure><blockquote><p>从耗时就可以看出来，在相同的时间内，LongAddr执行的效率最高，可以是sync关键字的2倍，是Atomic的1.5倍左右。<br>本次的数据仅在这个测试用例中生效。每个单元的执行效率还是要根据具体的业务来看。</p></blockquote><h2><span id="类图">类图</span></h2><p><img src="/article/java-concurrence-2/java-concurrence-2-211756.png" alt></p><h2><span id="atomic-详解">Atomic 详解</span></h2><h2><span id="atomic-家族概述">Atomic 家族概述</span></h2><ul><li><strong>AtomicBoolean</strong>  boolean 类型的atomic类</li><li><strong>AtomicInteger</strong>  Integer 类型 atomic 类</li><li><strong>AtomicIntegerArray</strong>  List元素为Integer ，且元素支持原子更新的类</li><li><strong>AtomicIntegerFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新</li><li><strong>AtomicLong</strong>    Long类型的atomic类</li><li><strong>AtomicLongArray</strong> List元素为Long ，且元素支持原子更新的类</li><li><strong>AtomicLongFieldUpdater</strong>   基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新</li><li><strong>AtomicMarkableReference</strong> 是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。</li><li><strong>AtomicReference</strong> 提供了一个可以原子读写的对象引用变量</li><li><strong>AtomicReferenceArray</strong>  List元素为引用类型 ，且元素支持原子更新的类</li><li><strong>AtomicReferenceFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile object 字段进行原子更新</li><li><strong>AtomicStampedReference</strong> 是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。</li></ul><h2><span id="atomic-详解">Atomic 详解</span></h2><p>下面我们来具体分析一下 <code>AtomicInteger</code> 这个类<br>AtomicInteger 的核心字段一共有三个</p><ol><li>unsafe 对象</li><li>value 值</li><li>valueOffset在对象中的偏移量</li></ol><p>方法如下图：</p><p><img src="/article/java-concurrence-2/java-concurrence-2-102243.png" alt></p><ul><li>Unsafe 更新值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// atomic 具体的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>几个核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unsafe 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 省略其他</span></span><br></pre></td></tr></table></figure><p>从这个方法就能看出，其实Atomic其实调用的是Unsafe类中的 <code>do while</code> 代码块来实现CAS交换的，而<code>Unsafe</code>中这个方法<code>compareAndSwapInt</code>是一个Native的方法。</p><p>unsafe对象在类初始化的时候，已经将<code>Atomic</code> 中用于存放直的value 的偏移量生成 <code>valueOffset</code>， 用于更新操作。<br>再在更新的时候，调用 <code>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</code> 方法，意思是，将本类的<code>valueOffset</code>的偏移量更新成<code>update</code>值，如果<code>this</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。</p><p>我们来看一下OpenJDK中的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a> 方法</p><ul><li>CAS底层原理</li></ul><p>CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//openjdk-jdk8u源码：/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>compareAndSwapInt</code> 和  compareAndSwapLong 实现是在 <code>Unsafe_CompareAndSwapInt</code> 和 <code>Unsafe_CompareAndSwapLong</code><br>下面我们深入到 <code>Unsafe_CompareAndSwapInt</code> 中去。</p><h3><span id="unsafe_compareandswapint-方法">Unsafe_CompareAndSwapInt 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  <span class="comment">// p是取出的对象</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// addr是p中offset处的地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();   <span class="comment">// &gt;1 = true</span></span><br><span class="line">  <span class="comment">// __asm__说明是ASM汇编，__volatile__禁止编译器优化</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">                    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">                    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">                    : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br><span class="line"><span class="string">  return exchange_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp</span></span><br><span class="line"><span class="string">static inline bool is_MP() &#123;</span></span><br><span class="line"><span class="string">    assert(_processor_count &gt; 0, "</span>invalid processor count<span class="string">");</span></span><br><span class="line"><span class="string">    // 我们可以利用 -XX:-AssumeMP 这个参数关闭多核运行状态 </span></span><br><span class="line"><span class="string">    return _processor_count &gt; 1 || AssumeMP;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">static int _processor_count;              // number of processors</span></span><br></pre></td></tr></table></figure><p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌汇编模板</span></span><br><span class="line"><span class="comment">// 第1行：汇编语句</span></span><br><span class="line">asm ( assembler template</span><br><span class="line">     <span class="comment">// 第2行：输出参数，以','分割</span></span><br><span class="line">      : <span class="function">output <span class="title">operands</span>               <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">     <span class="comment">// 第3行：输入参数，以','分割</span></span></span><br><span class="line"><span class="function">      : input <span class="title">operands</span>                <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">      : list of clobbered registers   </span></span><br><span class="line"><span class="function">        <span class="params">(optional)</span>   </span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>对照下面的源码，关键字<code>asm</code>和<code>__asm__</code>用于说明随后的字符串是内联汇编代码块。<code>volatile</code> 或 <code>__volatile__</code> 是可选的，可以将它们添加到 <code>asm</code> 后面，禁止某些编译器的优化。其实，<code>asm</code>和<code>__asm__</code>几乎是相同的，惟一的区别是，当预处理程序宏中使用内联汇编时，<code>asm</code>在编译过程中可能会引发警告，<code>volatile</code>也是同样的道理。因此Atomic::cmpxchg函数中汇编指令部分源码可以作如下解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义表达的意思，后面再说</span></span><br><span class="line"><span class="comment">// 第1行：表示汇编指令 cmpxchgl</span></span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">    <span class="comment">// 输出参数，"=a"表示把数据保存到eax寄存器中，"="表示这类操作数是只写的</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 这里的意思就是把 exchange_value的值保存到CPU的eax寄存器当中 (输出参数)</span></span></span><br><span class="line"><span class="function">    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">    // 输入参数："</span>r<span class="string">"表示任意寄存器，"</span>a<span class="string">"表示eax寄存器</span></span><br><span class="line"><span class="string">    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">    // 这里列出需要使用的寄存器：cc表示汇编代码将改变条件寄存器，memory表示有内存被修改</span></span><br><span class="line"><span class="string">    // 前面也提到过，这里仅列出指令改变的寄存器，输入输出使用的寄存器不放入其中，因此'a'不需要放到这儿</span></span><br><span class="line"><span class="string">    // 如果汇编指令修改了eax而输入输出没有用到eax，那么就需要在这儿加上'a'</span></span><br><span class="line"><span class="string">     : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br></pre></td></tr></table></figure><p>这里的 <code>cmpxchgl %1,(%3)</code> 中的 %1 和 %3 中的数字表示参数列表：[&quot;=a&quot; (exchange_value),“r” (exchange_value),“a” (compare_value),“r” (dest), “r” (mp)] 的下标，这里指的是<code>&quot;r&quot; (exchange_value)</code> 和 <code>&quot;r&quot; (dest)</code></p><ul><li>compare_value 表示 期望内存中的值，即旧值</li><li>exchange_value 表示 更新后的值，即新值</li><li>dest 表示 java对象对应属性的内存地址， (dest) 获取地址dest指向的值</li></ul><p><code>cmpxchg</code>指令即交换比较指令，让目标操作数先和AL，AX，EAX寄存器中的值进行比较：</p><ul><li>如果相等，将源操作数直接装载到目标操作数，并将寄存器标志位ZF(zero flag)置为1</li><li>如果不相等，将目标操作数转载到AL，AX，EAX寄存器，并将ZF清0</li></ul><p>那上面的代码中哪一个是源操作数，哪一个是目标操作数？这又涉及到汇编语言编程风格的问题，在DOS/Windows下的汇编语言采用Intel风格，而Unix和Linux系统中，更多采用的是AT&amp;T风格，这两者在语法格式上有很大不同，具体到操作数，有如下区别：</p><ul><li>AT&amp;T 汇编格式：指令 源操作数 目标操作数</li><li>Intel汇编格式：指令 目标操作数 源操作数</li></ul><p>还有一个需要注意的区别就是：操作数的字长。</p><ul><li>AT&amp;T 汇编格式：由操作符的最后一个字母决定，后缀b、w、l分别表示操作数为字节(byte,8bit)、字(word,16bit)、长字(long,32bit)</li><li>Intel汇编格式：用byte ptr、word ptr等前缀来表示，比如：mov al, byte ptr val</li></ul><p>那么表达式其实就是<code>cmpxchgl exchange_value ,dest</code>。<br>EAX寄存器中存的是&quot;a&quot; (compare_value)， 也就是<code>cmpxchgl</code>中l表示的寄存器的值也就是期望值，目标操作数是<code>dest</code>指向的值，即内存中存储的值，源操作数是<code>exchange_value</code>，即新值。将期望内存中的值与实际内存值比较，如果相等，则把<code>exchange_value</code>新值装载到dest内存中，并把新值写入<code>EAX</code>中；如果不相等，把<code>dest</code>地址的实际值放入EAX中。</p><blockquote><p>而C/C++内联汇编的特性架起了这样一座桥梁：一边是C语言，一边是汇编语言，在汇编中可以接收C传过来的参数，并且汇编指令也可以把值写入C语言变量中。</p></blockquote><p><code>LOCK_IF_MP</code> 是内联函数，定位如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p><code>os::is_MP</code>判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p><ul><li><strong>cmp $0, #mp</strong><ul><li>cmp是比较命令，两个操作数：$0表示立即操作数0，理解为常量。</li><li>mp为参数，从<code>%4</code>处引用而来，而<code>%4</code>表示 <code>&quot;r&quot;(mp)</code>，即把<code>mp</code>的值存储到任意寄存器。mp如何来？看函数代码的第一句：<code>int mp = os::is_MP()</code>，用于判断是否是多处理器机器, mp 如果为false（表示单核） 那就是0</li></ul></li><li>je lf;<ul><li>je为跳转指令，当ZF=1时，跳转到指定位置，这里表示跳转到标签1</li></ul></li><li>lock :表示Lock前缀</li><li>1<br>表示标签，类似于goto语句 <code>1: cmpxchgl %1,(%3)</code></li></ul><p>这里便于大家理解，写一个伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmp(var1, var2) &#123;</span><br><span class="line">    zf ;</span><br><span class="line">    <span class="keyword">if</span> (var1 == var2) &#123;</span><br><span class="line">        zf = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zf = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zf</span><br><span class="line">&#125;</span><br><span class="line">zf = cmp(<span class="number">0</span>, mp)  <span class="comment">// zf 标志位 </span></span><br><span class="line"><span class="keyword">if</span> (zf == <span class="number">1</span>) &#123;</span><br><span class="line">    goto:<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lock();</span><br><span class="line">    goto:<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译过来就是，如果是在多处理器上运行则先添加<code>LOCK#</code>前缀后，再执行cmpxchgl命令，如果是单处理器，则直接执行 <code>cmpxchgl</code> 命令。那为什么在多处理器机器上要先添加<code>LOCK#</code>前缀。</p><h3><span id="lock前缀">Lock前缀</span></h3><p>Lock前缀指令导致在执行指令期间，声言处理器的LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存（因为它会锁住总线，导致其他CPU不能访问总线，也就不能访问系统内存，在Intel486和Pentium处理器中都是这种策略）。</p><blockquote><p>在最近的处理器里，LOCK# 信号一般不锁总线，而是锁缓存，因为锁总线开销的比较大。在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK# 信号。相反，它会锁定这块区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上的处理器缓存的内存区域数据。</p></blockquote><p>由于我们操作的是count这个值，这个变量是用<code>volatile</code> 变量修饰的，所以保证了线程见的可见性。关于<code>volatile</code> 变量的细节，我会单独另一篇文章讨论。</p><p>下面我们来总结一下：<br><strong>当执行CAS操作的时候，我们先判断机器的核数，如果是多核CPU,则调用 lock cmpxchgl 这个汇编执行，lock执行会根据cpu的型号和架构，来选择总线锁还是缓存锁，来实行原子更新。更新之后，由于更新的值为<code>volatile</code> 变量修饰，（JVM层面规定是内存屏障），强制其他核心从主内存当中读值。这样以来就实现了原子更新</strong>。</p><h3><span id="unsafe_compareandswaplong-方法">Unsafe_CompareAndSwapLong 方法</span></h3><p>在 <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a>  的源码中，Int 和 Long 的swap 略有不同。我们来看一下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapLong"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">p</span> <span class="params">(THREAD, JNIHandles::resolve(obj))</span></span>;</span><br><span class="line">  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));</span><br><span class="line">  <span class="keyword">if</span> (VM_Version::supports_cx8())</span><br><span class="line">    <span class="keyword">return</span> (jlong)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    jboolean success = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 不支持，则直接锁住对象</span></span><br><span class="line">    <span class="function">ObjectLocker <span class="title">ol</span><span class="params">(p, THREAD)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (*addr == e) &#123; *addr = x; success = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>可以看到，如果不支持<code>cx8</code>，那么就需要用到<code>ObjectLocker</code>锁，那么什么 <code>VM_Version::supports_cx8()</code> 的底层实现又是什么呢？篇幅应县个，这里不做详细的分析，源代码在：在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/vm_version.hpp" target="_blank" rel="noopener">vm_version.hpp</a>里</p><p>底层则是判断CUP 是否支持 <code>CMPXCHG8B</code> 指令，简单来说就是CUP是否支持对寄存器的8字节的比较。在早期的CUP一般不支持，现代的CPU一般都在会支持。</p><h2><span id="atomicreference-类">AtomicReference 类</span></h2><p>这个类主要负责对于引用类型的赋值，他的核心代码很简单就是讲原来的<code>compareAndSwapInt</code> 换成了 <code>compareAndSwapObject</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// unsafe类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span> </span>&#123;</span><br><span class="line">    Object var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getObjectVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapObject(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照既定的惯例，我们来找到<code>compareAndSwapObject</code> 的native方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapObject"</span>);</span><br><span class="line">  oop x = JNIHandles::resolve(x_h); <span class="comment">// 新值</span></span><br><span class="line">  oop e = JNIHandles::resolve(e_h); <span class="comment">// 预期值</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// 在内存中的具体位置</span></span><br><span class="line">  HeapWord* addr = (HeapWord *)index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 调用了另一个方法</span></span><br><span class="line">  oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果返回的res等于e，则判定满足compare条件（说明res应该为内存中的当前值），但实际上会有ABA的问题</span></span><br><span class="line">  jboolean success  = (res == e); </span><br><span class="line">  <span class="keyword">if</span> (success) </span><br><span class="line">    <span class="comment">// success为true时，说明此时已经交换成功（调用的是最底层的cmpxchg指令）</span></span><br><span class="line">    <span class="comment">// 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作，配合垃圾收集器</span></span><br><span class="line">    update_barrier_set((<span class="keyword">void</span>*)addr, x); </span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p><code>compareAndSwapObject</code> 方法其实比较的就是两个 <code>Java Object</code> 的地址，如果相等则将新的地址（Java Object）赋给该字段。</p><p>我们看一下atomic_compare_exchange_oop 在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/oops/oop.inline.hpp" target="_blank" rel="noopener">oop.inline.hpp</a>的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> oop <span class="title">oopDesc::atomic_compare_exchange_oop</span><span class="params">(oop exchange_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">volatile</span> HeapWord *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                oop compare_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">bool</span> prebarrier)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseCompressedOops) &#123; </span><br><span class="line">      <span class="comment">// 如果使用了压缩普通对象指针(CompressedOops)，有一个重新编解码的过程</span></span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((narrowOop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// encode exchange and compare value from oop to T</span></span><br><span class="line">    narrowOop val = encode_heap_oop(exchange_value); <span class="comment">// 新值</span></span><br><span class="line">    narrowOop cmp = encode_heap_oop(compare_value); <span class="comment">// 预期值</span></span><br><span class="line">    <span class="comment">// 这里调用了  cmpxchg 方法</span></span><br><span class="line">    narrowOop old = (narrowOop) Atomic::cmpxchg(val, (narrowOop*)dest, cmp); </span><br><span class="line">    <span class="keyword">return</span> decode_heap_oop(old);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((oop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里表示 执行cmpxchg的汇编指令采用 支持 </span></span><br><span class="line">    <span class="keyword">return</span> (oop)Atomic::cmpxchg_ptr(exchange_value, (oop*)dest, compare_value); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  cmpxchg_ptr 的汇编指令集 和 cmpxchg 不同的是 采用了 cmpxchgq 指令</span></span><br><span class="line">__asm__ __volatile__ (LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgq %1,(%3)"</span></span><br><span class="line">                         : <span class="string">"=a"</span> (exchange_value)</span><br><span class="line">                         : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><br><span class="line">                         : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br><span class="line">    <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="atomicstampedreference-与-atomicmarkablereference">AtomicStampedReference 与  AtomicMarkableReference</span></h2><p>上面的普通的CAS操作都会有ABA的问题，其根本原因在于在CAS操作过程中，操作者不知道被操作的只中途是否发生过改变，那么解决方案就很自然，当改变一个只，就给这个值附上一个版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法, 传入引用和戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期值并且 当前版本戳等于预期版本戳, 将更新新的引用和新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期引用, 将更新新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptStamp</span><span class="params">(V expectedReference, <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置当前引用的新引用和版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure><p>我们来看用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(str1,<span class="number">1</span>);</span><br><span class="line">reference.compareAndSet(str1,str2,reference.getStamp(),reference.getStamp()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们比较时候，不仅要传递<code>expected</code> 和<code>new</code> 值，还要去传递版本戳，我们来看一下他的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AtomicStampedReference</code> 可以知道，引用变量中途被更改了几次。有时候，我们并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 <code>AtomicMarkableReference。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="atomicreferenceatomicstampedreference与-atomicmarkablereference-的区别">AtomicReference，AtomicStampedReference与 AtomicMarkableReference 的区别</span></h2><table><thead><tr><th>类</th><th>区别</th></tr></thead><tbody><tr><td><strong>AtomicReference</strong></td><td>通过volatile和Unsafe提供的CAS函数实现原子操作。 <br>自旋+CAS的无锁操作保证共享变量的线程安全.value是volatile类型，这保证了：当某线程修改value的值时，其他线程看到的value的值都是最新的值，即修改之后的volatile的值通过CAS设置value<br>这保证了：某线程池通过CAS函数（如compareAndSet函数）设置value时，它的操作时原子性的，即线程在操作vu略时不会被中断。<br> 但是CAS操作可能存在ABA问题</td></tr><tr><td><strong>AtomicStampedReference</strong></td><td>构造方法中initialStamp（时间戳）用来唯一标识引用变量，在构造器内部，实例化了一个Pair对象，Pair对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现ABA的问题。</td></tr><tr><td><strong>AtomicMarkableReference</strong></td><td>AtomicStampedReference 时间戳 只有true 和false</td></tr></tbody></table><h2><span id="fieldupdater">FieldUpdater</span></h2><p><code>FieldUpdater</code> 包含了<br><code>AtomicIntegerFieldUpdater</code>, <code>AtomicLongFieldUpdater</code> 和 <code>AtomicReferenceFieldUpdater</code> 这3个修改类的成员的原子类型的原理和用法相似</p><p>以 AtomicIntegerFieldUpdater 为例来分析一下特性及其源码</p><h2><span id="特性">特性</span></h2><p><code>AtomicIntegerFieldUpdater</code> 可以对指定&quot;类的 <code>volatile int</code> 类型的成员&quot;进行原子更新。它是基于反射原理实现的。<br><code>AtomicIntegerFieldUpdater</code> 以下几个限制</p><ul><li>（1）字段必须是 <strong>volatile</strong> 类型</li><li>（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li><li>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</li><li>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</li><li>（5）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</li></ul><h2><span id="实例代码">实例代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater aifu = AtomicIntegerFieldUpdater.newUpdater(Student.class, "number");</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> compareAndSet = aifu.compareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.weakCompareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.set(student, <span class="number">1</span>);</span><br><span class="line">        aifu.lazySet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.get(student);</span><br><span class="line">        aifu.getAndSet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndIncrement(student);</span><br><span class="line">        aifu.getAndDecrement(student);</span><br><span class="line">        aifu.getAndAdd(student, <span class="number">1</span>);</span><br><span class="line">        aifu.incrementAndGet(student);</span><br><span class="line">        aifu.decrementAndGet(student);</span><br><span class="line">        aifu.addAndGet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndUpdate(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.updateAndGet(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.getAndAccumulate(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.accumulateAndGet(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AtomicIntegerFieldUpdaterDemo 必须能够访问  number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Student</code> number 是private 修饰的，则会抛出 <code>$Student with modifiers &quot;private volatile&quot;</code> 异常</p><p>如果我们将<code>Student</code> 放到其他包下，则会抛出 <code>Atomic can not access a member of class {your bean} with modifiers &quot;volatile</code></p><h2><span id="源码分析">源码分析</span></h2><p>AtomicIntegerFieldUpdater 和  AtomicLongFieldUpdater 实现类有些不同<br>FieldUpdater 都继承与  AtomicXXFieldUpdater类，这些类提供了CAS的基本方法。</p><p>这是AtomicLongFieldUpdater<br><img src="/article/java-concurrence-2/java-concurrence-2-141202.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 AtomicIntegerFieldUpdater 底层用的是  AtomicIntegerFieldUpdaterImpl 实现<br>而  AtomicLongFieldUpdater 底层用的是 CASUpdater 或者 LockedUpdater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicLongFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                           String fieldName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (AtomicLong.VM_SUPPORTS_LONG_CAS)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CASUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CASUpdater</code> 和  <code>LockedUpdater</code> 区别就在于 是否支持  cmpxchg 源操作数为64个bit的CPU 原语言。我们从这个指令就可以看出 除了long和double类型, Java基本数据类型都是的简单读写都是原子的.</p><p><code>LockedUpdater</code> 与 <code>CASUpdater</code> 的区别在于核心的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CASUpdater </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">return</span> U.compareAndSwapLong(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LockedUpdater </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> v = U.getLong(obj, offset);</span><br><span class="line">                <span class="keyword">if</span> (v != expect)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                U.putLong(obj, offset, update);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到了 <code>CASUpdater</code> 是直接调用 <code>compareAndSwapLong</code> 方法 而 <code>LockedUpdater</code> 则是通过加锁的方式实现 CAS</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li><li><a href="https://www.hicsc.com/post/2020031059" target="_blank" rel="noopener">007 番外：JVM CAS机制的实现原理</a></li><li><a href="https://chriswhocodes.com/hotspot_options_jdk8.html" target="_blank" rel="noopener">VM Options Explorer - JDK8 HotSpot</a></li><li><a href="https://crowhawk.github.io/2018/02/10/volatile/" target="_blank" rel="noopener">Java volatile 关键字底层实现原理解析</a></li><li><a href="https://www.zhihu.com/question/65372648" target="_blank" rel="noopener">cas做了锁了总线或缓存行还是volatile做了锁总线或缓存行?</a></li><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp" target="_blank" rel="noopener">os.hpp</a></li><li><a href="https://blog.csdn.net/qqqqq1993qqqqq/article/details/75211993" target="_blank" rel="noopener">并发实战——原子类AtomicReference及底层源码CompareAndSwapObject分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TSL详解(3)</title>
      <link href="/article/tcpip-4-SSL-TLS-3/"/>
      <url>/article/tcpip-4-SSL-TLS-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>TLS 握手协议包含如下几步:</p><ul><li>交换 Hello 消息, 交换随机数和支持的密码套件列表, 以协商出密码套件和对应的算法。检查会话是否可恢复</li><li>交换必要的密码参数以允许 client 和 server 协商预备主密钥 premaster secret</li><li>交换证书和密码信息以允许 client 和 server 进行身份认证</li><li>从预备主密钥 premaster secret 和交换的随机数中生成主密钥 master secret</li><li>为 TLS 记录层提供安全参数(主要是密码块)</li><li>允许 client 和 server 验证它们的对端已经计算出了相同的安全参数, 而且握手过程不被攻击者篡改</li></ul><p>下面行文思路会按照 TLS 首次握手，会话恢复的顺序，依次对比 TLS 1.2 和 TLS 1.3 在握手上的不同，并且结合 Wireshark 抓取实际的网络包进行分析讲解。最后分析一下 TLS 1.3 新出的 0-RTT 是怎么回事。</p><h2><span id="tls12握手过程">TLS1.2握手过程</span></h2><h2><span id="tls12握手示意图">TLS1.2握手示意图</span></h2><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-100409.png" alt></p><h2><span id="握手流程分析">握手流程分析</span></h2><h3><span id="0hello_request">（0）hello_request</span></h3><p>HelloRequest 消息可以在任何时间由 Server 发送。</p><p>这个消息的含义: HelloRequest 是一个简单的通知，告诉 Client 应该开始重协商流程。在响应过程中，Client 应该在方便的时候发送一个 ClientHello 消息。这个消息并不是意图确定哪端是 Client 或 Server，而仅仅是发起一个新的协商。Server 不应该在 Client 发起连接后立即发送一个 HelloRequest。</p><p>如果 Client当前正在协商一个会话时，HelloRequest 这个消息会被 Client忽略。如果 Client 不想重新协商一个会话，或 Client 希望响应一个 no_renegotiation alert 消息，那么也可能忽略 HelloRequest 消息。因为握手消息意图先于应用数据被传送，它希望协商会在少量记录消息被 Client 接收之前开始。如果 Server 发送了一个 HelloRequest 但没有收到一个 ClientHello 响应，它应该用一个致命错误 alert 消息关闭连接。在发送一个 HelloRequest 之后，Server 不应该重复这个请求直到随后的握手协商完成。</p><h3><span id="1client-hello">（1）Client Hello</span></h3><p>当一个 <code>Client</code> 第一次连接一个 <code>Server</code> 时，发送的第一条消息必须是 <code>ClientHello</code>。<code>Client</code> 也能发送一个 <code>ClientHello</code> 作为对 <code>HelloRequest</code> 的响应，或用于自身的初始化以便在一个已有连接中重新协商安全参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uint32 gmt_unix_time;   <span class="comment">//时间戳</span></span><br><span class="line">   opaque random_bytes[<span class="number">28</span>]; <span class="comment">//随机数</span></span><br><span class="line">&#125; Random;</span><br><span class="line">   </span><br><span class="line">struct &#123;</span><br><span class="line">   ProtocolVersion client_version;  <span class="comment">// 版本</span></span><br><span class="line">   Random random;                   <span class="comment">// 随机数</span></span><br><span class="line">   SessionID session_id;            <span class="comment">// session id</span></span><br><span class="line">   CipherSuite cipher_suites&lt;<span class="number">2</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">2</span>&gt;;  <span class="comment">// 密码套件</span></span><br><span class="line">   <span class="comment">// 压缩算法，一般不启动</span></span><br><span class="line">   CompressionMethod compression_methods&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">8</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   <span class="comment">// Clients 可以通过在扩展域中发送数据来请求 Server 的扩展功能 后边详解</span></span><br><span class="line">   select (extensions_present) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">false</span>:</span><br><span class="line">            struct &#123;&#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">true</span>:</span><br><span class="line">            Extension extensions&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ClientHello;</span><br></pre></td></tr></table></figure><ul><li>Session id由服务器生成，服务器普遍采用OpenSSL，而OpenSSL基本只生成32字节的session id，如果碰到其他字节长度的Session id，切莫认为是异常client hello。</li></ul><p><code>随机数的作用：生成主密钥 + 避免重放攻击</code></p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161429.png" alt></p><h3><span id="2server-hello">（2）Server Hello</span></h3><p>当 Server 能够找到一个可接受的算法集时，Server 发送这个消息作为对 ClientHello 消息的响应。如果不能找到这样的算法集, 它会发送一个握手失败 alert 消息作为响应。</p><p>Server Hello 消息的结构是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   <span class="comment">// Client 在 Client hello 消息中建议的较低版本和 Server 所能支持的最高版本</span></span><br><span class="line">   ProtocolVersion server_version;</span><br><span class="line">   <span class="comment">// 服务端随机数，独立于client 随机数</span></span><br><span class="line">   Random random;</span><br><span class="line">   SessionID session_id;</span><br><span class="line">   <span class="comment">// Server 在 ClientHello.cipher_suites 中所选择的单个密码套件</span></span><br><span class="line">   CipherSuite cipher_suite;</span><br><span class="line">   CompressionMethod compression_method;</span><br><span class="line">   <span class="comment">// 扩展的列表. 需要注意的是只有由 Client 给出的扩展才能出现在 Server 的列表中</span></span><br><span class="line">   select (extensions_present) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">false</span>:</span><br><span class="line">            struct &#123;&#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">true</span>:</span><br><span class="line">            Extension extensions&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ServerHello;</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161539.png" alt></p><ul><li>SessionId<br>如果 ClientHello.session_id 非空，Server 将在它的会话缓存中进行匹配查询。如果匹配项被找到，且 Server 愿意使用指定的会话状态建立新的连接，Server 会将与 Client 所提供的相同的值返回回去。 我会在Session重用的章节分析</li></ul><h3><span id="3server-certificate-certificate-status">（3）Server Certificate (Certificate status)</span></h3><p><code>Server</code> 就必须发送一个 <code>Certificate</code>。<code>Server Certificate</code> 消息紧跟着 <code>ServerHello</code> 之后，<strong>通常他们俩者在同一个网络包中，即同一个 TLS 记录层消息中, 也有可能会紧跟着其他的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opaque ASN<span class="number">.1</span>Cert&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">struct &#123;</span><br><span class="line">   ASN<span class="number">.1</span>Cert certificate_list&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">&#125; Certificate;</span><br></pre></td></tr></table></figure><ul><li><strong>certificate_list</strong>:</li></ul><p>这是一个证书序列(链)。每张证书都必须是 ASN.1Cert 结构。发送者的证书必须在列表的第一个位置。每个随后的证书必须直接证明它前面的证书。假设远端必须已经拥有它以便在任何情况下验证它，在这个假设下，因为证书验证要求根密钥是独立分发的，所以可以从链中省略指定根证书颁发机构的自签名证书。根证书集成到了 Client 的根证书列表中，没有必要包含在 Server 证书消息中。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161900.png" alt></p><ul><li><strong>Certificate status</strong></li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162222.png" alt></p><p>如果 client hello 带了 扩展字段 ：<code>status_request</code> 则意味着请求要求服务器请求OCSP，服务器可以发送cettificate status到客户端，里面带上ocsp的信息</p><p>cettificate status  ：表示该证书的请求状态</p><p><strong>OCSP（Online Certificate Status Protocol ）是TLS协议的扩展协议</strong>，在TLS的使用中，客户端无法判断一个还没有过期的证书是否被吊销了。因为CA在颁发了证书之后大部分情况下都是等待这个证书过期了之后的自然失效，而如果CA出于某些原因要人为的吊销某个证书就没有了办法。</p><p>CA吊销这个证书肯定是有考虑的，所以客户端为了自身的安全也应该支持CA的这种需求。这个时候客户端在从服务端拿到了一个证书之后，去找服务端的接口去验证一下这个证书的是否过期这一信息。客户端由于网络有各种各样的情况，每个连接去验证国外的服务器的话就会带来完全不可控的用户体验和访问延时，并且对于CA来说也是一个不小的并发连接。所以OCSP一般会被应用到服务端，给客户端节省这部分的时间。</p><p>服务端周期性的去连接CA的OCSP服务器，验证一个证书的合法性，存储在本地。当客户端与服务端进行TLS握手的时候，服务端在传送了证书链之后（certificate消息），会继续再传输一个certificate status消息，这个status消息就是服务端从CA的OCSP服务器那里获得而来的证书吊销状态信息，双方仍然是通过密码学的方式保证了客户端可以确认这个确认消息来源于CA。</p><p>浏览器没有命中 OCSP 缓存。Ocsp 一般的更新周期是 7 天，firefox 的查询周期也是 7 天，也就说是 7 天中才会发生一次 ocsp 的查询。</p><h3><span id="3server-key-exchange-message">（3）Server Key Exchange Message</span></h3><p>这个消息会紧随在 Server 证书消息之后发送(如果是一个匿名协商的话，会紧随在 Server Hello消息之后发送)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   <span class="comment">// 选择秘钥算法类型</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   KeyExchangeAlgorithm 类型的不同，加入了不同的参数。</span></span><br><span class="line"><span class="comment">   对于匿名协商，不需要证书，所以也不需要身份验证，没有证书。</span></span><br><span class="line"><span class="comment">   DHE 开头的协商算法，Server 需要发给 Client 动态的 DH 参数 ServerDHParams 和 数字签名。这里的数字签名会包含 Client 端传过来的随机数，Server 端生成的随机数和 ServerDHParams。</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">      <span class="keyword">case</span> dh_anon:</span><br><span class="line">            ServerDHParams params;</span><br><span class="line">      <span class="keyword">case</span> dhe_dss:</span><br><span class="line">      <span class="keyword">case</span> dhe_rsa:</span><br><span class="line">            ServerDHParams params;</span><br><span class="line">            digitally-signed struct &#123;</span><br><span class="line">               opaque client_random[<span class="number">32</span>];</span><br><span class="line">               opaque server_random[<span class="number">32</span>];</span><br><span class="line">               ServerDHParams params;</span><br><span class="line">            &#125; signed_params;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于  rsa dh_dss dh_rsa 则不发送该消息</span></span><br><span class="line">      <span class="keyword">case</span> rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_dss:</span><br><span class="line">      <span class="keyword">case</span> dh_rsa:</span><br><span class="line">            struct &#123;&#125; ;</span><br><span class="line">      <span class="comment">/* 消息忽略 rsa, dh_dss, 和dh_rsa */</span></span><br><span class="line">      <span class="keyword">case</span> ec_diffie_hellman:</span><br><span class="line">            ServerECDHParams    params;</span><br><span class="line">            Signature           signed_params; </span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ServerKeyExchange;</span><br></pre></td></tr></table></figure><p><code>ServerKeyExchange</code> 消息由 Server 发送，但仅在 Server 证书消息(如果发送了)没有包含足够的数据以允许 Client 交换一个预密钥时。这个限制对于如下的密钥交换算法是成立的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要发送 ServerKeyExchange </span></span><br><span class="line">DHE_DSS</span><br><span class="line">DHE_RSA</span><br><span class="line">ECDHE_ECDSA       </span><br><span class="line">ECDHE_RSA</span><br></pre></td></tr></table></figure><p>对于上面前 4 个密码套件，证书中是不包含这些动态的 <code>DH</code> 信息<code>(DH 参数和 DH 公钥</code>)，所以需要使用 <code>Server Key Exchange</code> 消息传递这些信息。传递的信息需要使用 Server 私钥进行签名加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态DH 算法   Server 不应该发送该消息</span></span><br><span class="line">DH_anon</span><br><span class="line">ECDH_anon  <span class="comment">//匿名的 ECDH + 无签名证书</span></span><br></pre></td></tr></table></figure><p>对于上面后 2 个密码套件，是匿名协商，使用的静态的 DH/ECDH 密钥协商算法，而且它们也没有证书消息(Server Certificate 消息)，所以同样需要使用 <code>Server Key Exchange</code> 消息传递这些信息。传递的静态 DH 信息需要使用 Server 私钥进行签名加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需发送消息的 ServerKeyExchange</span></span><br><span class="line">RSA</span><br><span class="line">DH_DSS</span><br><span class="line">DH_RSA</span><br></pre></td></tr></table></figure><p>一般 HTTPS 都会部署这 4 种密码套件：<code>ECDHE_RSA、DHE_RSA、ECDHE_ECDSA、RSA</code>。</p><ul><li>静态DH和动态DH算法<br>DH密钥协商又可以分为<strong>静态DH和动态DH</strong>两种，</li></ul><p><strong>静态DH</strong>： 服务器端的DH参数和服务器公钥是固定的，每一次客户端请求连接得到的DH参数和公钥也都是一样的。</p><p>使用静态DH方式好处是不用每次建立连接时都去重新生成参数，节省了时间，提高了性能，不过致命的缺点就是安全性问题，一旦参数泄露就麻烦了。</p><p><strong>动态DH</strong>： 每次客户端和服务器端建立连接时，都会重新创建DH参数和服务器公钥，即使中间出现密钥泄露，也只是这次通信可能造成信息泄露影响，把损失大大地降低。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162431.png" alt></p><h3><span id="4certificate-request">（4）Certificate Request</span></h3><p>双向认证时，服务器会发送certificate request，表明自己想要收到客户端的证书</p><p>一个非匿名的 Server 可以选择性地请求一个 Client 发送的证书，如果相互选定的密码套件合适的话。如果 ServerKeyExchange 消息发送了的话，就紧跟在 ServerKeyExchange 消息的后面。如果 ServerKeyExchange 消息没有发送的话，就跟在 Server Certificate 消息后面。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162512.png" alt></p><h3><span id="5server-hello-done">（5）Server Hello Done</span></h3><p>ServerHelloDone 消息已经被 Server 发送以表明 ServerHello 及其相关消息的结束。发送这个消息之后, Server 将会等待 Client 发过来的响应。</p><p>这个消息意味着 Server 发送完了所有支持密钥交换的消息，Client 能继续它的密钥协商，证书校验等步骤。</p><p>在收到 ServerHelloDone 消息之后，Client 应当验证 Server 提供的是否是有效的证书，如果有要求的话, 还需要进一步检查 Server hello 参数是否可以接受。</p><h3><span id="6client-certificate">（6）Client Certificate</span></h3><p>这是 Client 在收到一个 ServerHelloDone 消息后发送的第一个消息。这个消息只能在 Server 请求一个证书时发送。</p><p>如果没有合适的证书，Client 必须发送一个不带证书的证书消息。即, certificate_list 结构体的长度是 0。如果 Client 不发送任何证书，Server 可以自行决定是否可以在不验证 Client 的情况下继续握手，或者回复一个致命 handshake_failure 警报 alert 信息。而且, 如果证书链某些方面不能接受(例如, 它没有被一个知名的可信 CA 签名)，Server 可以自行决定是否继续握手(考虑到 Client 无认证)或发送一个致命的警报 alert 信息。</p><p>Client 证书的数据结构和 Server Certificate 是相同的。</p><p>Client Certificate 消息的目的是传递 Client 的证书链给 Server；当验证 CertificateVerify 消息时(当 Client 的验证基于签名时)Server 会用它来验证或计算预备主密钥(对于静态的 Diffie-Hellman)。证书必须适用于已协商的密码套件的密钥交换算法, 和任何已协商的扩展.</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162548.png" alt></p><h3><span id="7-client-key-exchange-message">（7） Client Key Exchange Message</span></h3><p>这个消息始终由 Client 发送。如果有 Client Certificate 消息的话，Client Key Exchange 紧跟在 Client Certificate 消息之后发送。如果不存在Client Certificate 消息的话，它必须是在 Client 收到 ServerHelloDone 后发送的第一个消息。</p><p>这个消息的含义是，在这个消息中设置了预备主密钥，或者通过 RSA 加密后直接传输，或者通过传输 Diffie-Hellman 参数来允许双方协商出一致的预备主密钥。</p><p>当 Client 使用一个动态的 Diffie-Hellman 指数时，这个消息就会包含 Client 的 Diffie-Hellman 公钥。如果 Client 正在发送一个包含一个静态 DH 指数(例如，它正在进行 fixed_dh Client 认证)的证书时，这个消息必须被发送但必须为空。</p><p>这个消息的选项依赖于选择了哪种密钥交互方法。关于 KeyExchangeAlgorithm 的定义，见 Server Key Exchange Message 这一节。</p><p>ClientKeyExchange 消息的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; implicit, explicit &#125; PublicValueEncoding;</span><br><span class="line">struct &#123;</span><br><span class="line">      select (PublicValueEncoding) &#123;</span><br><span class="line">         <span class="keyword">case</span> implicit: struct &#123; &#125;;</span><br><span class="line">         <span class="keyword">case</span> explicit: ECPoint ecdh_Yc;</span><br><span class="line">      &#125; ecdh_public;</span><br><span class="line">&#125; ClientECDiffieHellmanPublic;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">   select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">      <span class="keyword">case</span> rsa:</span><br><span class="line">            EncryptedPreMasterSecret;</span><br><span class="line">      <span class="keyword">case</span> dhe_dss:</span><br><span class="line">      <span class="keyword">case</span> dhe_rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_dss:</span><br><span class="line">      <span class="keyword">case</span> dh_rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_anon:</span><br><span class="line">            ClientDiffieHellmanPublic;</span><br><span class="line">      <span class="keyword">case</span> ec_diffie_hellman: </span><br><span class="line">            ClientECDiffieHellmanPublic;</span><br><span class="line">   &#125; exchange_keys;</span><br><span class="line">&#125; ClientKeyExchange;</span><br></pre></td></tr></table></figure><p>从 exchange_keys 的 case 中可以看到主要分为 3 种处理方式：EncryptedPreMasterSecret(RSA、ClientDiffieHellmanPublic(DH)、ClientECDiffieHellmanPublic(ECD)。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162746.png" alt></p><h3><span id="8-certificate-verify">（8） Certificate verify</span></h3><p>发送这个类型的握手需要2个前提条件</p><ul><li>（1）：服务器端请求了客户端证书</li><li>（2）：客户端发送了非0长的证书</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   digitally-<span class="keyword">signed</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         opaque handshake_messages[handshake_messages_length];</span><br><span class="line">   &#125;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure><p>这里 <code>handshake_messages</code> 是指发送或接收到的所有握手消息，从 <code>client hello</code> 开始到但不包括本消息，包含握手消息的类型和长度域。</p><p>需要注意的是这要求两端要么缓存消息，要么计算用所有可用的 <code>hash</code> 算法计算运行时的 <code>hash</code> 值直到计算 <code>CertificateVerify</code> 的 hash 值为止。</p><p>在签名中使用的 <code>hash</code> 和签名算法必须是 <code>CertificateRequest</code> 消息中 <code>supported_signature_algorithms</code> 字段所列出的算法中的一种。</p><h3><span id="9-change-cipher">（9） Change cipher</span></h3><p>这是一个无关紧要的数据。在TLS1.3中就被废弃了(可以发送、也可以不发送)。<br>需要注意的是，该数据本身不被计算握手摘要，因为它的type不是Handshake。<br>发送改报文表示自己后续的发送数据会被新秘钥加密。</p><h3><span id="10-encrypted-handshake-message">（10） Encrypted handshake message</span></h3><p>这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据，发送了什么数据。来保证中间没人篡改报文。<br>其次，这个报文作用就是确认秘钥的正确性。因为Encrypted handshake message是使用对称秘钥进行加密的第一个报文，如果这个报文加解密校验成功，那么就说明对称秘钥是正确的。</p><p>具体 这个 Encrypted handshake message 怎么计算，就是把当前（准备发送Encrypted handshake message）前，自己收到的数据和发送的数据进行一次简单运算（hash+加密，详细见下文）。</p><blockquote><p>如果中间有人篡改了报文，比如，把客户端的client hello中的提供的加密套件改成了 一个弱秘钥算法，那么对于server而言，收到的client hello 和 客户端实际发送的是不同的，假设server收到的叫做client_hello_bad，这样，server 在计算Encrypted handshake message时，因为使用了client_hello_bad，计算完成之后，会发送给客户端，客户端为了确定握手数据是否被篡改，也需要模拟server端计算这个Encrypted handshake message，显然 客户端 计算 Encrypted handshake message 用的client hello 不是client_hello_bad，这样，客户端计算出来的，就和 服务端发过来的不同了，验证自然失败。</p></blockquote><blockquote><p>其次，某端要验证 Encrypted handshake message，必然需要先解密 Encrypted handshake message（因为他是用共享秘钥加密的），如果验证失败，也可能是 两端秘钥协商不成功。但是不管怎么样，无论是秘钥协商不成功还是数据被人篡改，都需要断开连接，即让握手失败。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">      opaque verify_data[verify_data_length];</span><br><span class="line">   &#125; Finished;</span><br><span class="line">   <span class="comment">// PRF 密码套件中的摘要算法</span></span><br><span class="line">   verify_data = </span><br><span class="line">      PRF(master_secret, finished_label, Hash(handshake_messages))</span><br><span class="line">         [<span class="number">0</span>..verify_data_length-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>加密过程</p><ul><li>finished_label: client finished / server finished</li><li>handshake_messages：handshake_messages 的值包括了从 ClientHello 开始一直到（但不包括）Finished 消息的所有握手消息</li><li>master_secret： 主密钥 对称秘钥</li></ul><p>计算完摘要后（md_result + Hash(handshake_messages)），按这种格式：“client finished”+ md_result，作为prf的输入。PRF的输出指定为12字节。12字节的数据前填充4字节message头部信息，就可以送入对称加密流程进行加密了。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-163533.png" alt></p><p>解密后的：<br><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-163555.png" alt></p><h2><span id="密码套件">密码套件</span></h2><p>Client 所支持的密码套件列表 格式如下:</p><p><code>TLS(协议)_ECDHE(秘钥交换协议)_RSA(签名算法)_WITH_AES_256_CBC(对称加密算法)_SHA（消息认证码）</code></p><p>密钥协商算法是 ECDHE，身份验证算法是 ECDSA，加密模式是 AES_256_GCM，由于 GCM 是属于 AEAD 加密模式，所以整个密码套件无须另外的 HMAC，SHA384 指的是 PRF 算法。</p><h2><span id="会话复用握手过程">会话复用握手过程</span></h2><p>Client 和 Server 只要一关闭连接，短时间内再次访问 HTTPS 网站的时候又需要重新连接。新的连接会造成网络延迟，并消耗双方的计算能力。有没有办法能复用之前的 TLS 连接呢？办法是有的，这就涉及到了 TLS 会话复用机制。</p><h3><span id="session信息">Session信息</span></h3><p>Session 是服务器为每一个client 保存的会话上下文，一般用于恢复会话使用。</p><p>Session 主要保存以下几个配置</p><ul><li>会话标识符(session identifier): 每个会话的唯一标识符</li><li>对端的证书(peer certificate):</li><li>压缩算法(compression method):</li><li>密码套件(cipher spec): Client 和 Server 协商共同协商出来的密码套件</li><li>主密钥(master secret):</li></ul><h3><span id="sessionid-方式">SessionId 方式</span></h3><ul><li>流程</li></ul><p>对于已经建立的SSL会话，使用session id为key（session id来自第一次请求的server hello中的session id字段），主密钥为value组成一对键值，保存在本地，服务器和客户端都保存一份。</p><p>当第二次握手时，客户端若想使用会话复用</p><ul><li><p>client 则发起的client hello中session id会置上对应的值。</p></li><li><p>服务器收到这个client hello，解析session id，查找本地是否有该session id，如果有，判断当前的加密套件和上个会话的加密套件是否一致，一致则允许使用会话复用，于是自己的server hello 中session id也置上和client hello中一样的值。</p></li><li><p>双方互发 ChangeCipherSpec + Finished 消息恢复通讯</p></li></ul><p>基于 Session ID 会话恢复的流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure><ul><li><p>优点</p><ul><li>减少网络延迟，握手耗时从 2-RTT -&gt; 1-RTT</li><li>减少了 Client 和 Server 端的负载，减少了加密运算的 CPU 资源消耗</li></ul></li><li><p>缺点</p><ul><li>Server 存储会话信息，限制了 Server 的扩展能力。</li><li>分布式系统中，如果只是简单的在 Server 的内存中存储 Session Cache，那么多台机器的数据同步也是一个问题。</li></ul></li></ul><h3><span id="session-ticket-的会话恢复">Session Ticket 的会话恢复</span></h3><p>用来替代 <code>Session ID</code> 会话恢复的方案是使用会话票证（<code>Session ticket</code>）。使用这种方式，除了所有的状态都保存在客户端（与 HTTP Cookie 的原理类似）之外，其消息流与服务器会话缓存是一样的。</p><p>其思想是服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在 <code>ClientHello</code> 的扩展字段 <code>session_ticket</code> 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。</p><ul><li><strong>(1). 获取 SessionTicket</strong><br>Client 在进行一次完整握手以后才能获取到 SessionTicket。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">(empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                           (empty SessionTicket extension)</span><br><span class="line">                                             Certificate*</span><br><span class="line">                                       ServerKeyExchange*</span><br><span class="line">                                       CertificateRequest*</span><br><span class="line">                           &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                          NewSessionTicket</span><br><span class="line">                                       [ChangeCipherSpec]</span><br><span class="line">                           &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure><ul><li>1：客户端发起client hello，拓展中带上空的session ticket TLS，表明自己支持session ticket。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-104846.png" alt></p><ul><li>2：服务器在握手过程中，如果支持session ticket，则发送New session ticket类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息，当然，最简单的就是只发送master key。为了让中间人不可见，这个session ticket部分会进行编码、加密等操作。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-104839.png" alt></p><ul><li><p>3：客户端收到这个session ticket，就把当前的master key和这个ticket组成一对键值保存起来。服务器无需保存任何会话信息，客户端也无需知道session ticket具体表示什么。</p></li><li><p>4：当客户端尝试会话复用时，会在client hello的拓展中加上session ticket，然后服务器收到session ticket，回去进行解密、解码能相关操作，来恢复会话信息。如果能够恢复会话信息，那么久提取会话信息的主密钥进行后续的操作。</p></li></ul><ul><li>(2). <strong>基于 SessionTicket 的会话恢复</strong><br>当 Client 本地获取了 SessionTicket 以后，下次想要进行简短握手，就可以使用这个 SessionTicket 了。</li></ul><pre><code class="language-C">Client                                                ServerClientHello(SessionTicket extension)     --------&gt;                                                ServerHello                              (empty SessionTicket extension)                                          NewSessionTicket                                          [ChangeCipherSpec]                              &lt;--------             Finished[ChangeCipherSpec]Finished                      --------&gt;Application Data              &lt;-------&gt;     Application Data</code></pre><ul><li>客户端第二次发起请求，根据目的ip port查找，查找master key和session ticket，然后把session ticket加在client hello中的拓展中。同时也需要session id。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-105050.png" alt></p><ul><li><p>如果 Server 支持 SessionTicket 会话恢复，则会在 ServerHello 中回复一个空的 SessionTicket 扩展。Server 将会话信息进行加密保护，生成一个新的 ticket，通过 NewSessionTicket 子消息发给 Client。发送完</p></li><li><p>NewSessionTicket 消息以后，紧跟着发送 ChangeCipherSpec 和 Finished 消息。Client 收到上述消息以后，回应 ChangeCipherSpec 和 Finished 消息，会话恢复成功。</p></li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-105102.png" alt></p><h2><span id="tls-常见的攻击举例">TLS 常见的攻击举例</span></h2><h3><span id="heartbleed心脏出血">Heartbleed（心脏出血）</span></h3><h3><span id="replay-attacks重放攻击">Replay Attacks（重放攻击）</span></h3><h3><span id="降级攻击freaklogjam-和-curveswap">降级攻击(FREAK，LogJam 和 CurveSwap)</span></h3><p>降级攻击一般包括两种：</p><ul><li>加密套件降级攻击 (cipher suite rollback)</li><li>协议降级攻击（version roll back）。</li></ul><p>降级攻击的原理就是攻击者伪造或者修改 client hello 消息，使得客户端和服务器之间使用比较弱的加密套件或者协议完成通信。<br>为了应对降级攻击，现在 server 端和浏览器之间都实现了 SCSV 功能，原理参考 <a href="https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00%E3%80%82" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00。</a><br>一句话解释就是如果客户端想要降级，必须发送 TLS_SCSV 的信号，服务器如果看到 TLS_SCSV，就不会接受比服务端最高协议版本低的协议。</p><h3><span id="重新协商攻击">重新协商攻击</span></h3><p>重新协商（tls renegotiation）分为两种：</p><ul><li>加密套件重协商 (cipher suite renegotiation)</li><li>协议重协商（protocol renegotiation）。</li></ul><p>重新协商会有两个隐患：</p><ul><li>重协商后使用弱的安全算法。这样的后果就是传输内容很容易泄露。</li><li>重协商过程中不断发起完全握手请求，触发服务端进行高强度计算并引发服务拒绝。 对于重协商，最直接的保护手段就是禁止客户端主动重协商，当然出于特殊场景的需求，应该允许服务端主动发起重协商。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/justinzengTM/article/details/104054056" target="_blank" rel="noopener">总结HTTPS握手层和加密层</a></li></ul><blockquote><p>本文大部分来自 以下内容的 节选</p></blockquote><ul><li><a href="https://halfrost.com/https_tls1-2_handshake/" target="_blank" rel="noopener">HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TSL详解(2)</title>
      <link href="/article/tcpip-4-SSL-TLS-2/"/>
      <url>/article/tcpip-4-SSL-TLS-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>前面章节，我们简单介绍了TLS的秘钥交换的算法。接下来我们来讲一下SSL层。</p><h2><span id="tls层ssl层">TLS层SSL层</span></h2><p><strong>TLS是介于网络层和传输层之间的半层。</strong></p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-123531.png" alt></p><h2><span id="协议层分类">协议层分类</span></h2><p>TLS/SSL 协议位于应用层和传输层 TCP 协议之间。TLS 粗略的划分又可以分为 2 层：</p><ul><li>靠近应用层的握手协议 <strong>TLS Handshaking Protocols</strong></li><li>靠近 TCP 的记录层协议 <strong>TLS Record Protocol</strong></li></ul><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-125556.png" alt></p><h2><span id="ssltcl层">SSL/TCL层</span></h2><h3><span id="握手协议">握手协议</span></h3><p>TLS 握手协议还能细分为 5 个子协议：</p><p>如上图</p><ul><li>change_cipher_spec (在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)： 密码切换协议</li><li>alert： 告警协议</li><li>handshake： 握手协议</li><li>application_data： 应用数据协议</li><li>heartbeat (这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议) 心跳协议</li></ul><p>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。<br>基本过程</p><ul><li><p>1、 client 端想server 端获取公钥</p></li><li><p>2、 双方协商生成&quot;对话密钥&quot;</p></li><li><p>3、 双方用对话秘钥进行通讯</p></li><li><p><strong>一个TCL1.2 秘钥交换的大致过程</strong></p></li></ul><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-112851.png" alt></p><hr><br><br><br><h2><span id="协议详解">协议详解</span></h2><h2><span id="记录层协议">记录层协议</span></h2><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-133951.png" alt></p><p>记录层将上层的信息块分段为 <code>TLSPlaintext</code> 记录<br><code>TLSPlaintext</code> 记录规范如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         ContentType type;</span><br><span class="line">         ProtocolVersion legacy_record_version;</span><br><span class="line">         uint16 length;</span><br><span class="line">         opaque fragment[TLSPlaintext.length];</span><br><span class="line">   &#125; TLSPlaintext;</span><br></pre></td></tr></table></figure><p>记录层将上层的信息块分段为 <code>TLSPlaintext</code> 记录，<code>TLSPlaintext</code> 中包含 2^14 字节或更少字节块的数据。根据底层 <code>ContentType</code> 的不同，消息边界的处理方式也不同。TLS 1.3 中的规则比 TLS 1.2 中强制执行的规则更加严格。</p><p>握手消息可以合并为单个 <code>TLSPlaintext</code> 记录，或者在几个记录中分段，前提是：</p><ul><li><p>握手消息不得与其他记录类型交错。也就是说，如果握手消息被分成两个或多个记录，则它们之间不能有任何其他记录。</p></li><li><p>握手消息绝不能跨越密钥更改。实现方必须验证密钥更改之前的所有消息是否与记录边界对齐; 如果没有，那么他们必须用 “unexpected_message” alert 消息终止连接。因为 ClientHello，EndOfEarlyData，ServerHello，Finished 和 KeyUpdate 消息可以在密钥更改之前立即发生，所以实现方必须将这些消息与记录边界对齐。</p></li><li><p>实现方绝不能发送握手类型的零长度片段，即使这些片段包含填充。</p></li><li><p>另外 Alert 消息禁止在记录之间进行分段，并且多条 <code>alert</code> 消息不得合并为单个 <code>TLSPlaintext</code> 记录。换句话说，具有 alert 类型的记录必须只包含一条消息。</p></li></ul><p>应用数据消息包含对 TLS 不透明的数据。应用数据消息始终应该受到保护。可以发送应用数据的零长度片段，因为它们可能作为流量分析对策使用。应用数据片段可以拆分为多个记录，也可以合并为一个记录。</p><h3><span id="字段详解">字段详解</span></h3><h4><span id="contenttype">ContentType</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    invalid(<span class="number">0</span>),</span><br><span class="line">    change_cipher_spec(<span class="number">20</span>),</span><br><span class="line">    alert(<span class="number">21</span>),</span><br><span class="line">    handshake(<span class="number">22</span>),</span><br><span class="line">    application_data(<span class="number">23</span>),</span><br><span class="line">    heartbeat(<span class="number">24</span>),  <span class="comment">/* RFC 6520 */</span></span><br><span class="line">&#125; ContentType;</span><br></pre></td></tr></table></figure><table><thead><tr><th>消息头类型</th><th>ContentType</th><th>协议内容</th></tr></thead><tbody><tr><td>change_cipher_spec</td><td>0x014</td><td>在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)： 密码切换协议</td></tr><tr><td>alert</td><td>0x015</td><td>告警协议</td></tr><tr><td>handshake</td><td>0x016</td><td>握手协议</td></tr><tr><td>application_data</td><td>0x017</td><td>数据传输协议</td></tr><tr><td>heartbeat (TLS 1.3 新增)</td><td>0x018</td><td>心跳协议</td></tr></tbody></table><h4><span id="protocolversion-协议版本">ProtocolVersion 协议版本</span></h4><table><thead><tr><th>协议版本</th><th>version</th></tr></thead><tbody><tr><td>TLS 1.3</td><td>0x0304</td></tr><tr><td>TLS 1.2</td><td>0x0303</td></tr><tr><td>TLS 1.1</td><td>0x0302</td></tr><tr><td>TLS 1.0</td><td>0x0301</td></tr><tr><td>SSL 3.0</td><td>0x0300</td></tr></tbody></table><h4><span id="fragment">fragment</span></h4><ul><li>length:</li></ul><p><code>TLSPlaintext.fragment</code> 的长度(以字节为单位)。长度不得超过 2 ^ 14 字节。接收超过此长度的记录的端点必须使用 <code>&quot;record_overflow&quot; alert</code> 消息终止连接。</p><ul><li>fragment:</li></ul><p>正在传输的数据。此字段的值是透明的，它并被视为一个独立的块，由类型字段指定的更高级别协议处理。</p><p>TLS 记录层协议在整个 TLS 协议中的定位如下：</p><blockquote><p>封装处理 TLS 上层(握手层)中的平行子协议(TLS 1.3 中是 5 个子协议，TLS 1.2 及更老的版本是 4 个子协议)，加上消息头，打包往下传递给 TCP 处理。</p></blockquote><p>对上层应用数据协议进行密码保护，对其他的子协议只是简单封装(即不加密)</p><h2><span id="tls-密码切换协议change_cipher_spec">TLS 密码切换协议（change_cipher_spec）</span></h2><blockquote><p>change_cipher_spec 在TSL1.3 可能被删除</p></blockquote><p><code>change_cipher_spec</code> (以下简称 CCS 协议) 协议，是 TLS 记录层对应用数据是否进行加密的分界线。客户端或者服务端一旦收到对端发来的 CCS 协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。</p><p>TLS 记录层在处理上层 5 个协议(密码切换协议，警告协议，握手协议，心跳协议，应用数据协议)的时候，TLS 不同版本对不同协议加密的情况不同，具体情况如下：</p><table><thead><tr><th>议版本</th><th>密码切换协议</th><th>警告协议</th><th>握手协议</th><th>心跳协议</th><th>应用数据协议</th></tr></thead><tbody><tr><td>TLS 1.3</td><td>无</td><td>✅(根据连接状态不同进行加密，即一部分会加密)</td><td>✅(一部分加密)</td><td>❌</td><td>✅</td></tr><tr><td>TLS 1.2</td><td>❌</td><td>❌</td><td>❌</td><td>无</td><td>✅</td></tr></tbody></table><p>协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; change_cipher_spec(<span class="number">1</span>), (<span class="number">255</span>) &#125; type;</span><br><span class="line">&#125; ChangeCipherSpec;</span><br></pre></td></tr></table></figure><p>经过 TLS 记录层包装以后，结构如下:</p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141552.png" alt></p><h2><span id="tls-警告协议alert">TLS 警告协议（alert）</span></h2><p><code>TLS</code> 提供 <code>alert</code> 内容类型用来表示关闭信息和错误。<br>与其他消息一样，alert 消息也会根据当前连接状态的进行加密。</p><p>在 <code>TLS</code> 1.3 中，错误的严重性隐含在正在发送的警报类型中，并且可以安全地忽略 “<code>level</code>” 字段。<br>&quot;<code>close_notify</code>&quot; <code>alert</code> <code>用于表示连接从一个方向开始有序的关闭。收到这样的警报后，TLS</code> 实现方应该表明应用程序的数据结束。</p><p>收到错误警报后，<code>TLS</code> 实现方应该向应用程序表示出现了错误，并且不允许在连接上发送或接收任何其他数据。</p><p>协议数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; warning(<span class="number">1</span>), fatal(<span class="number">2</span>), (<span class="number">255</span>) &#125; AlertLevel;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AlertLevel level;</span><br><span class="line">    AlertDescription description;</span><br><span class="line">&#125; Alert;</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141226.png" alt></p><ul><li>TLS 1.2 的所有警告描述信息：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation(<span class="number">100</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),           <span class="comment">/* new */</span></span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><ul><li><strong>TLS 1.3 的所有警告描述信息：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure_RESERVED(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    inappropriate_fallback(<span class="number">86</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation_RESERVED(<span class="number">100</span>),</span><br><span class="line">    missing_extension(<span class="number">109</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),</span><br><span class="line">    certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">    unrecognized_name(<span class="number">112</span>),</span><br><span class="line">    bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">    bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">    unknown_psk_identity(<span class="number">115</span>),</span><br><span class="line">    certificate_required(<span class="number">116</span>),</span><br><span class="line">    no_application_protocol(<span class="number">120</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><p>TLS 1.3 比 TLS 1.2 新增了 9 个警告描述信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inappropriate_fallback(<span class="number">86</span>),</span><br><span class="line">missing_extension(<span class="number">109</span>),</span><br><span class="line">certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">unrecognized_name(<span class="number">112</span>),</span><br><span class="line">bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">unknown_psk_identity(<span class="number">115</span>),</span><br><span class="line">certificate_required(<span class="number">116</span>),</span><br><span class="line">no_application_protocol(<span class="number">120</span>),</span><br></pre></td></tr></table></figure><h2><span id="数据传输协议application_data">数据传输协议（application_data）</span></h2><p>应用数据协议就是 TLS 上层的各种协议，TLS 主要保护的数据就是应用数据协议的数据。<br><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141131.png" alt><br>TLS 记录层会根据加密模式的不同在应用数据的末尾加上 MAC 校验数据。</p><h2><span id="心跳协议">心跳协议</span></h2><p>这个协议是 TLS 1.3 新增的。更加细节可以看这篇文章<a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_Heartbeat.md" target="_blank" rel="noopener">《TLS &amp; DTLS Heartbeat Extension》</a>， [RFC 6520] 翻译的。感兴趣的可以去看看这篇文章。这篇文章还涉及到了 DTLS 和 PMTU 发现。</p><p>协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    heartbeat_request(<span class="number">1</span>),</span><br><span class="line">    heartbeat_response(<span class="number">2</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HeartbeatMessageType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HeartbeatMessageType type;</span><br><span class="line">    uint16 payload_length;</span><br><span class="line">    opaque payload[HeartbeatMessage.payload_length];</span><br><span class="line">    opaque padding[padding_length];</span><br><span class="line">&#125; HeartbeatMessage;</span><br></pre></td></tr></table></figure><p>经过 TLS 记录层包装以后，结构如下:</p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-145352.png" alt></p><p>根据 [RFC6066] 中的定义，在协商的时候，HeartbeatMessage 的总长度不得超过 2 ^ 14 或 max_fragment_length。<br><code>HeartbeatMessage</code> 的长度为 TLS 的 <code>TLSPlaintext.length</code> 和 <code>DTLS</code> 的 <code>DTLSPlaintext.length</code>。此外，类型 <code>type</code> 字段的长度是 1 个字节，并且 <code>payload_length</code> 的长度是 2 个字节。因此，padding_length 是TLSPlaintext.length - <code>payload_length</code> - 3 用于 <code>TLS，DTLSPlaintext.length - payload_length - 3</code> 用于 <code>DTLS</code>。<code>padding_length</code> 必须至少为 16。</p><p><code>HeartbeatMessage</code> 的发送方必须使用至少 16 个字节的随机填充。必须忽略收到的 <code>HeartbeatMessage</code> 消息的填充。</p><h2><span id="握手协议">握手协议</span></h2><p>握手协议是整个 <code>TLS</code> <code>协议簇中最最核心的协议，HTTPS</code> 能保证安全也是因为它的功劳。</p><p>握手协议由多个子消息构成，服务端和客户端第一次完成一次握手需要 <code>2-RTT</code>。</p><p>握手协议的目的是为了双方协商出密码块，这个密码块会交给 TLS 记录层进行密钥加密。也就是说握手协议达成的“共识”(密码块)是整个 TLS 和 <code>HTTPS</code> 安全的基础。</p><p>握手协议在 <code>TLS 1.2</code>和 <code>TLS 1.3</code> 中发生了很大的变化。<code>TLS 1.3</code> 的 <strong>0-RTT</strong>是一个全新的概念。两个版本在密钥协商上，密码套件选择上都有很大不同。</p><ul><li>TLS 1.2 协议数据结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request(<span class="number">0</span>), </span><br><span class="line">    client_hello(<span class="number">1</span>), </span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    certificate(<span class="number">11</span>), </span><br><span class="line">    server_key_exchange (<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>), </span><br><span class="line">    server_hello_done(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>), </span><br><span class="line">    client_key_exchange(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>)</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;</span><br><span class="line">    uint24 length;</span><br><span class="line">    select (HandshakeType) &#123;</span><br><span class="line">        <span class="keyword">case</span> hello_request:       HelloRequest;</span><br><span class="line">        <span class="keyword">case</span> client_hello:        ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:        ServerHello;</span><br><span class="line">        <span class="keyword">case</span> certificate:         Certificate;</span><br><span class="line">        <span class="keyword">case</span> server_key_exchange: ServerKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> certificate_request: CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> server_hello_done:   ServerHelloDone;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:  CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> client_key_exchange: ClientKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> finished:            Finished;</span><br><span class="line">    &#125; body;</span><br><span class="line">&#125; Handshake;</span><br></pre></td></tr></table></figure><ul><li>TLS 1.3 协议数据结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议类型</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request_RESERVED(<span class="number">0</span>),</span><br><span class="line">    client_hello(<span class="number">1</span>),</span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    hello_verify_request_RESERVED(<span class="number">3</span>),</span><br><span class="line">    new_session_ticket(<span class="number">4</span>),</span><br><span class="line">    end_of_early_data(<span class="number">5</span>),</span><br><span class="line">    hello_retry_request_RESERVED(<span class="number">6</span>),</span><br><span class="line">    encrypted_extensions(<span class="number">8</span>),</span><br><span class="line">    certificate(<span class="number">11</span>),</span><br><span class="line">    server_key_exchange_RESERVED(<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>),</span><br><span class="line">    server_hello_done_RESERVED(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>),</span><br><span class="line">    client_key_exchange_RESERVED(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>),</span><br><span class="line">    certificate_url_RESERVED(<span class="number">21</span>),</span><br><span class="line">    certificate_status_RESERVED(<span class="number">22</span>),</span><br><span class="line">    supplemental_data_RESERVED(<span class="number">23</span>),</span><br><span class="line">    key_update(<span class="number">24</span>),</span><br><span class="line">    message_hash(<span class="number">254</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;    <span class="comment">/* handshake type */</span></span><br><span class="line">    uint24 length;             <span class="comment">/* bytes in message */</span></span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> client_hello:          ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:          ServerHello;</span><br><span class="line">        <span class="keyword">case</span> end_of_early_data:     EndOfEarlyData;</span><br><span class="line">        <span class="keyword">case</span> encrypted_extensions:  EncryptedExtensions;</span><br><span class="line">        <span class="keyword">case</span> certificate_request:   CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> certificate:           Certificate;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:    CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> finished:              Finished;</span><br><span class="line">        <span class="keyword">case</span> new_session_ticket:    NewSessionTicket;</span><br><span class="line">        <span class="keyword">case</span> key_update:            KeyUpdate;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; Handshake</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-144932.png" alt></p><p><strong>握手消息类型虽然有很多种，但是最终传到 TLS 记录层，有些会被合并到一条消息。</strong></p><h2><span id="参考">参考</span></h2><ul><li><a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC8446</a></li><li><a href="https://halfrost.com/https-begin/" target="_blank" rel="noopener">HTTPS 温故知新（一） —— 开篇</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TLS详解(1)</title>
      <link href="/article/tcpip-4-SSL-TLS/"/>
      <url>/article/tcpip-4-SSL-TLS/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><h2><span id="ssltsl-协议">SSL/TSL 协议</span></h2><p>**SSL（安全套接字层）**是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接。</p><p><strong>TLS:(Transport Layer Security)</strong>: 是SSL协议（Secure Sockets Layer）的升级版，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。现在习惯将这个两个组合在一起称为<strong>SSL/TLS</strong>，它是一种用于加密的安全协议就好了。</p><h2><span id="发展史">发展史</span></h2><ul><li>1995: SSL 2.0. 由 Netscape 提出，这个版本由于设计缺陷，并不安全，很快被发现有严重漏洞，已经废弃。</li><li>1996: SSL 3.0. 写成 RFC，开始流行。目前（2015年）已经不安全，必须禁用。</li><li>1999: TLS 1.0. 互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。</li><li>2006: TLS 1.1. 作为 RFC 4346 发布。主要 fix 了 CBC 模式相关的如 BEAST 攻击等漏洞。</li><li>2008: TLS 1.2. 作为 RFC 5246 发布。增进安全性。目前（2015 年）应该主要部署的版本，请确保你使用的是这个版本。</li><li>2018：8月10日 RFC8446 TLS 1.3 协议正式发布，它剔除了 TLS 1.2 协议中不安全的因素，极大地增强了协议的安全性和性能。</li></ul><h2><span id="作用">作用</span></h2><p>TCP/IP 协议栈</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-123531.png" alt></p><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ul><li>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>（2） 篡改风险（tampering）：第三方可以修改通信内容。</li><li>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ul><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><ul><li>（1） 所有信息都是加密传播，第三方无法窃听。</li><li>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</li><li>（3） 配备身份证书，防止身份被冒充。</li></ul><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><h2><span id="加密算法">加密算法</span></h2><h2><span id="单项加密">单项加密</span></h2><p>单项加密，又称不可逆的加密<br>特性：</p><ul><li>定长输出: 无论原始数据是多大，结果大小都相同的</li><li>雪崩效应: 输入的微小改变，将会引起结果的巨大改变</li><li>单向加密算法：MD5（128位）、SHA1、SHA256、SHA384、SHA512</li></ul><p>缺点： 雪崩，不可逆</p><p>主要用途： 特征码</p><h2><span id="对称加密">对称加密</span></h2><p>在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。</p><p>收信方收到密文后，若想解读原文，则需要使用<strong>加密用过的密钥及相同算法的逆算法</strong>对密文进行解密，在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥和加密算法。</p><p>缺点： 不安全，局限性，需要知道对称加密秘钥</p><p>优点：加密解密速度快</p><h2><span id="公钥加密非对称加密">公钥加密（非对称加密）</span></h2><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-214134.png" alt></p><p>现代互联网普遍用的加密手段。</p><ul><li><p>特点：</p><ul><li>公钥公开，私钥保密</li><li>公钥加密，私钥解密</li><li>私钥加密，公钥解密</li></ul></li><li><p>用途:  接收方用发送方的公钥解密，若能解密就以为这这个数据一定是拥有该公钥对应的私钥的人发送的，实现了身份认证机制。</p><ul><li>数字签名</li><li>HTTPS/OPENSSL/SSL</li><li>区块链</li></ul></li><li><p>公钥加密算法<br>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。<br>使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。</p></li><li><p>缺点： 加密解密速度较慢，无法对大规模的数据进行加密<br>一般情况下非对称加密用来数字签名的。</p></li><li><p>RSA 算法原理<br>做个连接 不做过多解读 <a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA 算法原理</a></p></li><li><p>ECC 算法<br><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">Elliptic Curve Cryptography: a gentle introduction</a></p></li></ul><h2><span id="数字签名">数字签名</span></h2><p>私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密,在这个意义上来说，加密就毫无意义。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，也就是说对原始消息的哈希特征值进行加密，保证这个消息不会被其他第三方串改。</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110824.png" alt></p><ul><li>数字签名的作用<ul><li>防止伪造；</li><li>防止抵赖；</li><li>检测篡改。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">    KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">    kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">    KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">    PrivateKey sk = kp.getPrivate();</span><br><span class="line">    PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待签名的消息:</span></span><br><span class="line">    <span class="keyword">byte</span>[] message = <span class="string">"Hello, I am Bob!"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥签名:</span></span><br><span class="line">    Signature s = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">    s.initSign(sk);</span><br><span class="line">    s.update(message);</span><br><span class="line">    <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">    System.out.println(String.format(<span class="string">"signature: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥验证:</span></span><br><span class="line">    Signature v = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">    v.initVerify(pk);</span><br><span class="line">    v.update(message);</span><br><span class="line">    <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">    System.out.println(<span class="string">"valid? "</span> + valid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="现代加密过程">现代加密过程</span></h2><p>非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势</p><p>如下图：</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110512.png" alt></p><p><strong>加密解密过程和原理详细说明：</strong><br><strong>1、发送端B :</strong></p><ul><li><p>（1）为保证安全，要对报文加密。加密方法有三类：对称加密、公钥加密和单向加密。对称加密不安全，单向加密是不可逆的，因而使用公钥加密。<br>公钥加密安全（一般为2048位），但是加密过程太慢了，不适用当前网络需求</p></li><li><p>（2）为了解决上述问题，B可以用单向加密提取出报文的特征码（<strong>特征码能保证报文的数据完整性</strong>），再使用自身的私钥对特征码进行公钥加密（特征码数据小，对其进行公钥加密速度快），并把加密后的特征码附加到报文后。（使用私钥加密是为了验证身份）但是，这种方式能实现数据完整性和身份验证的检验，但是却缺失了报文的数据保密性</p></li><li><p>（3）为了解决上述问题，B在把加密的特征码附加到报文后，把特征码和报文当做一个数据（假设为data），使用对称加密算法对该数据(data)加密得出一个密码，再把密码附加到该数据(data)后。为了使得在传输过程中密码不被其他人获取或篡改，使用A的公钥对密码进行加密（只有A的私钥能对其解密），把加密的密码附加到数据data后，再这些数据一并发送给A。</p></li></ul><blockquote><p><strong>对称加密算法有很多种，那么如何选择加密算法呢？ 这是因为前面会有个加密算法协商的过程，客户端和服务器各自支持的加密算法不一样，所有在数据加密传输过程中工会有加密算法协商的过程</strong>。</p></blockquote><p><strong>2、接收端A：</strong></p><ul><li>（1）A接收到B传来的报文，利用自身的私钥对其解密，获得密码。因为只有A的私钥能对B传来的报文（使用A的公钥加密密码）解密，所以能防止其他人对该传输的报文进行解密而获得其中的信息，保证了数据的保密性。</li><li>（2）A利用获得的密码解密其中对称加密的数据，获得经过加密的特征码和原报文。</li><li>（3）A使用B的公钥对该特征码解密，能解密则说明该报文是B发送过来的，实现了身份验证。（假设解密后的特征码是fcode）</li><li>（4）A使用同等单向加密算法对接收到的原报文提取其特征码。使用该特征码和解密后获得的特征码(fcode)做比较，如果一样，则说明原报文的数据完整。</li></ul><p>以上这种方式能保证数据完整性、身份验证和数据的保密性，在加密和解密的过程中都要用到对方的公钥，<strong>如何在传输过程中安全可靠地获得对方的公钥就成了关键的一环</strong>，</p><p>遗留问题</p><ul><li><strong>1. 公钥如何安全的获取服务器公钥？</strong></li><li><strong>2. 对称加密的秘钥如何生成，加密算法如何协商？</strong></li></ul><p>要解决三个问题必须要客户端和服务器进行协商，协商出双方一致的秘钥算法。所以，客户端和服务器必须有一个完整的秘钥交换机制。</p><h2><span id="秘钥交换">秘钥交换</span></h2><h2><span id="直接秘钥交换">直接秘钥交换</span></h2><p>由于公钥公开，所以当客户端连接服务器的时候，服务器会给客户端发自己公钥，然后客户端用公钥加密密码（也就是对称秘钥），发送给服务器，服务器有私钥，可以解密数据。这样就实现了数据加密的传输。 这种秘钥交换在https 里映射为对<strong>称秘钥的交换</strong></p><blockquote><p>虽然公钥是公开的，但是也并不意味着和所有人都可以拥有公钥,公钥的公开是指公钥可以在网络上传输。<br>如果你能保证公钥和私钥一样，能安全的进行交换，那么双方的传输安全是没有问题。一般情况下为<strong>人肉传输/线下传输</strong>。比如：公钥放到专用的安全U盘上，然后在去服务器传输。</p></blockquote><p><strong>漏洞</strong>： 公钥会暴露给中间人。</p><p>原因：秘钥在网络上传输导致的。但是很多时候，无法进行线下传输，秘钥交换必不可少。</p><p>实现：RSA秘钥交换算法</p><h2><span id="dh算法解决秘钥交换漏洞">DH算法解决秘钥交换漏洞</span></h2><p>如果要解决中间人替换漏洞：<strong>Diffie-Hellman</strong>算法应运而生。<br>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p><p><strong>DH算法的过程</strong>：</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-214429.png" alt></p><p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p><ul><li><p>1、通信方A和通信方B约定一个初始数 <code>g</code>，如<code>g=5</code>，一个质数<code>p</code>，如p=23，g和p是公开的,且<code>1&lt; g &lt; p</code></p></li><li><p>2、Alice生成一个随机数<code>a</code>，<code>a</code>是保密的，如<code>a=6</code></p></li><li><p>3、Alice 计算 <code>A=g^a%p</code> 发送给B  即：<code>g^a%p=5^6%23=8</code></p></li><li><p>4、B生成一个随机数b，b是保密的，如 <code>b=15</code></p></li><li><p>5、Bob计算<code>B=g^b%p</code>发送给A，B=g^b%p=5^15%23=19</p></li><li><p>6、A接收到<code>g^b%p</code>后，再使用保密的a，计算<code>(g^b%p)^a%p=19^6%23=2</code></p></li><li><p>7、B接收到<code>g^a%p</code>后，再使用保密的b，计算(<code>g^a%p)^b%p=8^15%23=2</code></p></li><li><p>算法实现如下</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; createDiffieHellman &#125; = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = createDiffieHellman(<span class="number">512</span>)   <span class="comment">// 内部已经有随机值a</span></span><br><span class="line"><span class="keyword">let</span> clientKey = client.generateKeys();  <span class="comment">// 生成A</span></span><br><span class="line"><span class="keyword">let</span> prime = client.getPrime();          <span class="comment">// 生成 p</span></span><br><span class="line"><span class="keyword">let</span> generator = client.getGenerator()   <span class="comment">// 生成g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次传输   传输prime（p） 和 generator（g）  和 clientKey (A  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = createDiffieHellman(prime, generator)  <span class="comment">// 内部生成随机值b 保存 p 和 g </span></span><br><span class="line"><span class="keyword">let</span> serverKey = server.generateKeys()               <span class="comment">//  生成B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次传输 服务传输  serverKey (B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算  B^a%p</span></span><br><span class="line"><span class="keyword">let</span> secretClient = client.computeSecret(serverKey)</span><br><span class="line"><span class="comment">// 计算  A^b%p</span></span><br><span class="line"><span class="keyword">let</span> secretServer = server.computeSecret(clientKey)</span><br><span class="line"><span class="comment">//  secretServer == secretClient</span></span><br><span class="line"><span class="built_in">console</span>.log(secretClient.toString(<span class="string">"hex"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(secretServer.toString(<span class="string">"hex"</span>))</span><br></pre></td></tr></table></figure><p>解决：秘钥不用再公开传输<br>详见：<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman_key_exchange</a></p><blockquote><p>ECC 算法就是DH算法的一个实现</p></blockquote><h2><span id="秘钥交换协议的常用实现">秘钥交换协议的常用实现</span></h2><h3><span id="rsa密钥交换算法直接交换">RSA密钥交换算法（直接交换）</span></h3><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-122153.png" alt></p><ul><li><p>（1）：任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。</p></li><li><p>（2）：客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行 加密，生成C，把C发送到服务器。</p></li><li><p>（3）：服务器收到C，使用公钥对应的私钥进行解密，得到S。</p></li><li><p>（4）：上述交换步骤后，客户端和服务器都得到了S，S为密钥（<strong>预主密钥</strong>）。</p></li></ul><blockquote><p>一般预备主密钥还要经过一个随机数及其序列号生成主密钥，用于防止重放攻击使用</p></blockquote><h3><span id="dhe算法流程文字描述如下">DHE算法流程文字描述如下：</span></h3><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-122821.png" alt></p><p>DHE算法流程文字描述如下：</p><ul><li><p>（1）：客户端计算一个随机值Xa，使用Xa作为指数，即计算Pa = q^Xa mod p，其中q和p是全世界公认的一对值。客户端把Pa发送至服务器，Xa作为自己私钥，仅且自己知道。</p></li><li><p>（2）：服务器和客户端计算流程一样，生成一个随机值Xb，使用Xb作为指数，计算   Pb = q^Xb mod p，将结果Pb发送至客户端，Xb仅自己保存。</p></li><li><p>（3）：客户端收到Pb后计算Sa = Pb ^Xa mod p；服务器收到Pa后计算Sb = Pa^Xb mod p</p></li><li><p>（4）：算法保证了Sa = Sb = S，故密钥交换成功，S为密钥（预主密钥）。</p></li></ul><p>上述密钥交换流程中，和RSA密钥交换有较大不同，DHE密钥交换时，服务器私钥没有参与进来。也就是说，私钥即使泄漏，也不会导致会话加密密钥S被第三方解密。</p><p>实际使用过程中，私钥的功能被削弱到用来身份认证（上图中没有画出）。</p><p>上图中DHE参数和Pb都是通过server key exchange发送给客户端，Pa通过client key exchange发送给服务器。server key exchange的结尾处需要使用服务器私钥对该报文本身进行签名，以表明自己拥有私钥（图中为了表明私钥没有参与密钥计算，没有画出，但不影响理解DHE算法）。</p><h3><span id="ecdhe-or-ecdh-密钥交换算法">ECDHE or ECDH 密钥交换算法</span></h3><p>只要理解DHE密钥交换原理，那么理解ECDHE密钥交换原理其实并不难（如果不想深究的话）。<br>ECDHE的运算是把DHE中模幂运算替换成了点乘运算，速度更快，可逆更难。</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-123219.png" alt></p><p>ECDHE算法流程文字描述如下：</p><ul><li><p>（1）：客户端随机生成随机值Ra，计算Pa(x, y) = Ra * Q(x, y)，Q(x, y)为全世界公认的某个椭圆曲线算法的基点。将Pa(x, y)发送至服务器。</p></li><li><p>（2）：服务器随机生成随机值Rb，计算Pb(x,y) - Rb * Q(x, y)。将Pb(x, y)发送至客户端。</p></li><li><p>（3）：客户端计算Sa(x, y) = Ra * Pb(x, y)；服务器计算Sb(x, y) = Rb *Pa(x, y)</p></li><li><p>（4）：算法保证了Sa = Sb = S，提取其中的S的x向量作为密钥（预主密钥）。</p></li></ul><p><strong>ECDHE与ECDH算法的区别</strong><br>字面少了一个E，E代表了“临时”，即在握手流程中，作为服务器端，ECDH少了一步计算Pb的过程，Pb用证书中的公钥代替，而证书对应的私钥就是Xb。由此可见，使用ECDH密钥交换算法，服务器必须采用ECC证书；服务器不发送server key exchange报文，因为发送certificate报文时，证书本身就包含了Pb信息。</p><p><strong>ECDHE与RSA的区别</strong><br>    ECDHE（DHE）算法属于DH类密钥交换算法， 私钥不参与密钥的协商，故即使私钥泄漏，客户端和服务器之间加密的报文都无法被解密，这叫 前向安全（forward secrity）。由于ECDHE每条会话都重新计算一个密钥（Ra、Rb），故一条会话被解密后，其他会话仍旧安全。（随机数 + 会话序列帧）</p><p>然而，ECDH算法服务器端的私钥是固定的，即证书的私钥作为Rb，故ECDH不被认为前向安全，因为私钥泄漏相当于Rb泄漏，Rb泄漏，导致会话密钥可被第三方计算。ECDH交换算法已经被OpenSSL废</p><h2><span id="中间人劫持-man-in-the-middle-attack-mitm">中间人劫持-Man-In-The-Middle attack MITM。</span></h2><p>中间人攻击</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-103447.png" alt></p><h2><span id="mitmproxy模拟中间人挟持">mitmproxy模拟中间人挟持</span></h2><p>解决：当发送方要发送公钥的时候，不发送公钥，而是发送一个<strong>数字证书</strong>，证书中会包含一些具体信息。接收方收到证书后验证证书真伪，然后获取证书内的公钥。<br>所以安全可靠地获取对方的公钥靠CA(Certificate Authority )证书授权中心来实现。</p><h2><span id="ca证书体系">CA证书体系</span></h2><h2><span id="ca是什么">CA是什么？</span></h2><p>上面提到的数字证书就是CA发行的。CA是<strong>Certificate Authority</strong>的缩写，也叫“证书授权中心”。它是负责管理和签发证书的第三方机构，作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。</p><p>所以，CA实际上是一个机构，负责“证件”印制核发。就像负责颁发身份证的公安局、负责发放行驶证、驾驶证的车管所。</p><h2><span id="ca证书的信任链">CA证书的信任链</span></h2><p>实际上，证书之间的信任关系，是可以嵌套的。比如，C 信任 A1，A1 信任 A2，A2 信任 A3…这个叫做证书的信任链。只要你信任链上的头一个证书，那后续的证书，都是可以信任滴。<br>　<br><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110350.png" alt></p><p>处于最顶上的树根位置的那个证书，就是“根证书”。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明“根证书”可靠捏？实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴）。<br>　　聪明的同学此刻应该意识到了：根证书是整个证书体系安全的根本。所以，如果某个证书体系中，根证书出了问题（不再可信了），那么所有被根证书所信任的其它证书，也就不再可信了。</p><h2><span id="ca证书的结构">CA证书的结构</span></h2><ul><li><strong>1、CA证书标准：x.509</strong><br>x.509: 定义了证书结构和认证协议标准；（基于公钥和数字签名）<br>用于：IP安全、TLS/SSL（传输层安全）和S/MIME（安全电子邮件通信）<br><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-112110.png" alt></li></ul><p><strong>x.509证书标准详细说明：</strong></p><ul><li>（1）版本号（默认为1，如果有多个扩展，可能为3）</li><li>（2）证书序列号（是一个整数，在CA中唯一标识，表明发行了多少个证书）</li><li>（3）算法参数 （标志用了那种算法）</li><li>（4）发行者的名称（CA自己的名字）</li><li>（5）有效期限</li><li>（6）主体名称（证书拥有者名称）(很关键！！！)（个人用户使用的是个人用户名，主机使用的必须是主机名而不是ip地址）</li><li>（7）<strong>公钥（最重要）（公钥由证书拥有者提供）</strong></li><li>（8）发行者的ID（CA的唯一编号）</li><li>（9）主体的ID（CA生成的证书拥有者唯一编号）</li><li>（10）扩展</li><li><strong>（11）CA的签名（用于验证CA的来源合法性） CA是相对于发送方B和接收方A的第三方，是具有公信力的机构。</strong></li></ul><h2><span id="证书的验证过程">证书的验证过程</span></h2><p>假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你</p><ul><li><p>颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；而这个上级机构他的证书又是同样的方法由CA颁发的。</p></li><li><p>首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的</p></li><li><p>颁发者证书的公钥，解密你的证书的特征码，然后再用收到的证书中的加密算法，再使用同样的单向加密算法提取收到证书的特征码，比较这两个特征码是否一样，如果一样，则表示获得你的的数字证书是完整的。</p></li><li><p>从证书中获取你的公钥</p></li></ul><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-120425.png" alt></p><h2><span id="遗留问题">遗留问题</span></h2><p>通过我们前面的认识，我们来回答下了几个问题</p><ul><li><strong>1. 公钥如何安全的获取</strong>：        通过CA证书的方式来获取 解决中间人攻击</li><li><strong>2. 对称加密的秘钥如何生成/获取</strong>  通过DH算法来获取（秘钥协商）</li></ul><p>那么我们接下来就要讨论一下，在应用层面上来说，服务器客户端双方怎么能快速的达成秘钥的交换和生成。<br>如果要交换秘钥，TLS在连接之前会进行握手操作，该操作用于交换秘钥，协商加密算法等等，用于建立安全的连接。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626" target="_blank" rel="noopener">签名算法</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://blog.csdn.net/mrpre/article/details/78025940" target="_blank" rel="noopener">TLS/SSL 协议详解 (30) SSL中的RSA、DHE、ECDHE、ECDH流程与区别</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（四）</title>
      <link href="/article/java-thrift-4-2/"/>
      <url>/article/java-thrift-4-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一届主要讨论了<code>Thrift</code>编解码中的二进制协议格式。这是一种比较大众的协议。本节来讨论二进制协议的另一种加强版本。<code>TCompactProtocol</code></p><h2><span id="编解码">编解码</span></h2><p>对于二进制编码，经常需要对数据进行压缩以节省空间，varint可以压缩较小的正数，但是对于负数varint反而更浪费空间，zigzag编码可以处理负数，使负数也可以使用varint编码压缩，protobuf和thrift都使用二者结合的方式来压缩数字类型。</p><p>原码、反码、补码<br>首先，计算机为了方便位运算，使用补码来存储数字。</p><p>然后回顾下：</p><ul><li><strong>原码：最高位为符号位，剩余位表示绝对值；</strong></li><li><strong>反码：除符号位外，对原码剩余位依次取反；</strong></li><li><em>补码：对于正数，补码为其自身；对于负数，除符号位外对原码剩余位依次取反然后+1。</em></li></ul><h2><span id="varint">varint</span></h2><p>本文以int类型为例，详细介绍如果通过varint+zigzag编码技术压缩数字。<br>首先，我们常用的数字其实多数都不是很大，比如：商品的价值、动态计数等，对于这些不是很大的数字，二进制的高位多数是0。<br>varint编码每个字节前1位表示下一个字节是否也是该数字的一部分，后7位表示实际的值，最后，先低位后高位，对于int类型来说，varint编码最少占用1个字节，最多占用5个字节。</p><p>varint编码java代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(idx = <span class="number">0</span>; (n &amp; -<span class="number">128</span>) != <span class="number">0</span>; n &gt;&gt;&gt;= <span class="number">7</span>) &#123;</span><br><span class="line">  bytes[idx++] = (<span class="keyword">byte</span>)(n &amp; <span class="number">127</span> | <span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line">bytes[idx++] = (<span class="keyword">byte</span>)n;</span><br></pre></td></tr></table></figure><p>例如，对于int类型1来说，二进制表示为 <code>00000000 00000000 00000000 00000001</code>，总共占用4个字节，然而，前3个字节都是0，varint就是通过压缩高位的0来达到节省空间的目的，使用varint压缩后，二进制表示为 <code>00000001</code>，只占用1个字节。</p><p>对于int类型2^30来说二进制表示为<br><code>01000000 00000000 00000000 00000000</code>，使用varint压缩后，二进制表示为<code>10000000 10000000 10000000 10000000 00000100</code>，占用5个字节。</p><p><img src="/article/java-thrift-4-2/java-thrift-4-2-210005.png" alt></p><h2><span id="zigzag">zigzag</span></h2><p>对于负数来说，因为最高位符号位始终为1，使用 <code>varint</code> 编码就很浪费空间，<code>zigzag</code> 编码就是解决负数的问题的，同时其对正数也没有很大的影响。</p><p>int类型zigzag变换的代码表示为<code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></p><ul><li><strong>左移1位可以消去符号位，低位补0</strong></li><li><strong>有符号右移31位将符号位移动到最低位，负数高位补1，正数高位补0</strong></li></ul><p>例如：对于正数来说，最低位符号位为0，其他位不变<br>对于负数，最低位符号位为1，其他位按位取反<br>-1的二进制表示为 <code>11111111 11111111 11111111 11111111</code>，zigzag变换后 <code>00000000 00000000 00000000 00000001</code>，再用varint编码，是不是很小了。</p><p>1的二进制表示为 <code>00000000 00000000 00000000 00000001</code>，zigzag变换后<code>00000001</code>，再用varint编码，依然很小。</p><h2><span id="解码">解码</span></h2><p>zigzag操作为<code>(n &gt;&gt;&gt; 1) ^ -(n &amp; 1)</code></p><p>正数：当前的数乘以2， zigzagY = x * 2<br>负数：当前的数乘以-2后减1, zigzagY = x * -2 - 1</p><ul><li>无符号右移1位</li><li>按位与1，然后取负值，这一步非常巧妙，对于正数就是0，负数就是-1</li><li>按位异或得到结果<ul><li>正数是与0按位异或</li><li>负数是与-1按位异或</li></ul></li></ul><p>-1 的解码过程为</p><ul><li><p><code>00000000 00000000 00000000 00000010</code>  = 无符号右移1位（(n &gt;&gt;&gt; 1)） = <code>00000000 00000000 00000000 00000001</code></p></li><li><p><code>00000000 00000000 00000000 00000010</code>  = 按位与1（都为1则为1，否则为0）（(n &amp; 1)）= <code>00000000 00000000 00000000 00000000</code> 为负数</p></li><li><p>上面两个记过异或 <code>00000000 00000000 00000000 00000001</code> (异或 -1 相同为0，不同为1) = <code>11111111 11111111 11111111 11111111</code> =  <code>00000000 00000000 00000000 00000001</code></p></li></ul><h2><span id="tcompactprotocol-代码详解">TCompactProtocol 代码详解</span></h2><p><code>TCompactProtocol</code>对于二进制编码，经常需要对数据进行压缩以节省空间，varint可以压缩较小的正数，但是对于负数varint反而更浪费空间，zigzag编码可以处理负数，使负数也可以使用varint编码压缩，protobuf和thrift都使用二者结合的方式来压缩数字类型。</p><p>来看一下二级制的图示<br><img src="/article/java-thrift-4-2/java-thrift-4-2-095010.png" alt></p><h2><span id="代码">代码</span></h2><p>下面代码省略了一些部分信息，保留了关键注释和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCompactProtocol</span> <span class="keyword">extends</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> TStruct ANONYMOUS_STRUCT = <span class="keyword">new</span> TStruct(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> TField TSTOP = <span class="keyword">new</span> TField(<span class="string">""</span>, TType.STOP, (<span class="keyword">short</span>)<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] ttypeToCompactType = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    ttypeToCompactType[TType.STOP] = TType.STOP;</span><br><span class="line">    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;</span><br><span class="line">    ttypeToCompactType[TType.BYTE] = Types.BYTE;</span><br><span class="line">    ttypeToCompactType[TType.I16] = Types.I16;</span><br><span class="line">    ttypeToCompactType[TType.I32] = Types.I32;</span><br><span class="line">    ttypeToCompactType[TType.I64] = Types.I64;</span><br><span class="line">    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;</span><br><span class="line">    ttypeToCompactType[TType.STRING] = Types.BINARY;</span><br><span class="line">    ttypeToCompactType[TType.LIST] = Types.LIST;</span><br><span class="line">    ttypeToCompactType[TType.SET] = Types.SET;</span><br><span class="line">    ttypeToCompactType[TType.MAP] = Types.MAP;</span><br><span class="line">    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PROTOCOL_ID = (<span class="keyword">byte</span>)<span class="number">0x82</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VERSION = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VERSION_MASK = <span class="number">0x1f</span>; <span class="comment">// 0001 1111</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> TYPE_MASK = (<span class="keyword">byte</span>)<span class="number">0xE0</span>; <span class="comment">// 1110 0000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TYPE_SHIFT_AMOUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Types</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOLEAN_TRUE   = <span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOLEAN_FALSE  = <span class="number">0x02</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE           = <span class="number">0x03</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16            = <span class="number">0x04</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32            = <span class="number">0x05</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64            = <span class="number">0x06</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE         = <span class="number">0x07</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BINARY         = <span class="number">0x08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST           = <span class="number">0x09</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET            = <span class="number">0x0A</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP            = <span class="number">0x0B</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT         = <span class="number">0x0C</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Thrift 自己实现的short类型栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ShortStack lastField_ = <span class="keyword">new</span> ShortStack(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">short</span> lastFieldId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If we encounter a boolean field begin, save the TField here so it can </span></span><br><span class="line"><span class="comment">   * have the value incorporated.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> TField booleanField_ = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If we read a field header, and it's a boolean field, save the boolean </span></span><br><span class="line"><span class="comment">   * value here so that readBool can use it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Boolean boolValue_ = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastField_.clear();</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a message header to the wire. Compact Protocol messages contain the</span></span><br><span class="line"><span class="comment">   * protocol version so we can migrate forwards in the future if need be.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(PROTOCOL_ID);</span><br><span class="line">    writeByteDirect((VERSION &amp; VERSION_MASK) | ((message.type &lt;&lt; TYPE_SHIFT_AMOUNT) &amp; TYPE_MASK));</span><br><span class="line">    writeVarint32(message.seqid);</span><br><span class="line">    writeString(message.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a struct begin. This doesn't actually put anything on the wire. We </span></span><br><span class="line"><span class="comment">   * use it as an opportunity to put special placeholder markers on the field</span></span><br><span class="line"><span class="comment">   * stack so we can get the field id deltas correct.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastField_.push(lastFieldId_);</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a struct end. This doesn't actually put anything on the wire. We use</span></span><br><span class="line"><span class="comment">   * this as an opportunity to pop the last field from the current struct off</span></span><br><span class="line"><span class="comment">   * of the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastFieldId_ = lastField_.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a field header containing the field id and field type. If the</span></span><br><span class="line"><span class="comment">   * difference between the current field id and the last one is small (&lt; 15),</span></span><br><span class="line"><span class="comment">   * then the field id will be encoded in the 4 MSB as a delta. Otherwise, the</span></span><br><span class="line"><span class="comment">   * field id will follow the type header as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field.type == TType.BOOL) &#123;</span><br><span class="line">      <span class="comment">// we want to possibly include the value, so we'll wait.</span></span><br><span class="line">      booleanField_ = field;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeFieldBeginInternal(field, (<span class="keyword">byte</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The workhorse of writeFieldBegin. It has the option of doing a </span></span><br><span class="line"><span class="comment">   * 'type override' of the type header. This is used specifically in the </span></span><br><span class="line"><span class="comment">   * boolean field case.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldBeginInternal</span><span class="params">(TField field, <span class="keyword">byte</span> typeOverride)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="comment">// short lastField = lastField_.pop();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there's a type override, use that.</span></span><br><span class="line">    <span class="keyword">byte</span> typeToWrite = typeOverride == -<span class="number">1</span> ? getCompactType(field.type) : typeOverride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we can use delta encoding for the field id</span></span><br><span class="line">    <span class="keyword">if</span> (field.id &gt; lastFieldId_ &amp;&amp; field.id - lastFieldId_ &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">      <span class="comment">// write them together</span></span><br><span class="line">      writeByteDirect((field.id - lastFieldId_) &lt;&lt; <span class="number">4</span> | typeToWrite);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// write them separate</span></span><br><span class="line">      writeByteDirect(typeToWrite);</span><br><span class="line">      writeI16(field.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="comment">// lastField_.push(field.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write the STOP symbol so we know there are no more fields in this struct.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(TType.STOP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a map header. If the map is empty, omit the key and value type </span></span><br><span class="line"><span class="comment">   * headers, as we don't need any additional information to skip it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.size == <span class="number">0</span>) &#123;</span><br><span class="line">      writeByteDirect(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeVarint32(map.size);</span><br><span class="line">      writeByteDirect(getCompactType(map.keyType) &lt;&lt; <span class="number">4</span> | getCompactType(map.valueType));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Write a list header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeCollectionBegin(list.elemType, list.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a set header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeCollectionBegin(set.elemType, set.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a boolean value. Potentially, this could be a boolean field, in </span></span><br><span class="line"><span class="comment">   * which case the field header info isn't written yet. If so, decide what the</span></span><br><span class="line"><span class="comment">   * right type header is for the value and then write the field header. </span></span><br><span class="line"><span class="comment">   * Otherwise, write a single byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (booleanField_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we haven't written the field header yet</span></span><br><span class="line">      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">      booleanField_ = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// we're not part of a field, so just write the value.</span></span><br><span class="line">      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//ZigZag编码：16位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(intToZigZag(i16));</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//ZigZag编码：32位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(intToZigZag(i32));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//ZigZag编码：64位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint64(longToZigzag(i64));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    fixedLongToBytes(Double.doubleToLongBits(dub), data, <span class="number">0</span>);</span><br><span class="line">    trans_.write(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">      writeBinary(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"UTF-8 not supported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a byte array, using a varint for the size. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">    writeBinary(bin.array(), bin.position() + bin.arrayOffset(), length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(length);</span><br><span class="line">    trans_.write(buf, offset, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 其他层复写的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Abstract method for writing the start of lists and sets. List and sets on </span></span><br><span class="line"><span class="comment">   * the wire differ only by the type indicator.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeCollectionBegin</span><span class="params">(<span class="keyword">byte</span> elemType, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">14</span>) &#123;</span><br><span class="line">      writeByteDirect(size &lt;&lt; <span class="number">4</span> | getCompactType(elemType));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeByteDirect(<span class="number">0xf0</span> | getCompactType(elemType));</span><br><span class="line">      writeVarint32(size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write an i32 as a varint. Results in 1-5 bytes on the wire.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">TODO:</span> make a permanent buffer like writeVarint64?</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">byte</span>[] i32buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeVarint32</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &amp; ~<span class="number">0x7F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        i32buf[idx++] = (<span class="keyword">byte</span>)n;</span><br><span class="line">        <span class="comment">// writeByteDirect((byte)n);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i32buf[idx++] = (<span class="keyword">byte</span>)((n &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>);</span><br><span class="line">        <span class="comment">// writeByteDirect((byte)((n &amp; 0x7F) | 0x80));</span></span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans_.write(i32buf, <span class="number">0</span>, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write an i64 as a varint. Results in 1-10 bytes on the wire.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">byte</span>[] varint64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeVarint64</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &amp; ~<span class="number">0x7FL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        varint64out[idx++] = (<span class="keyword">byte</span>)n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        varint64out[idx++] = ((<span class="keyword">byte</span>)((n &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>));</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans_.write(varint64out, <span class="number">0</span>, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert l into a zigzag long. This allows negative numbers to be </span></span><br><span class="line"><span class="comment">   * represented compactly as a varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">longToZigzag</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l &lt;&lt; <span class="number">1</span>) ^ (l &gt;&gt; <span class="number">63</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert n into a zigzag int. This allows negative numbers to be </span></span><br><span class="line"><span class="comment">   * represented compactly as a varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">intToZigZag</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;&lt; <span class="number">1</span>) ^ (n &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert a long into little-endian bytes in buf starting at off and going </span></span><br><span class="line"><span class="comment">   * until off+7.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixedLongToBytes</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">    buf[off+<span class="number">0</span>] = (<span class="keyword">byte</span>)( n        &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">1</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">2</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">3</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">4</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">5</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">6</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">7</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">56</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Writes a byte without any possibility of all that field header nonsense. </span></span><br><span class="line"><span class="comment">   * Used internally by other writing methods that know they need to write a byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] byteDirectBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeByteDirect</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    byteDirectBuffer[<span class="number">0</span>] = b;</span><br><span class="line">    trans_.write(byteDirectBuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Writes a byte without any possibility of all that field header nonsense.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeByteDirect</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect((<span class="keyword">byte</span>)n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// Reading methods.</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a message header. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> protocolId = readByte();</span><br><span class="line">    <span class="keyword">if</span> (protocolId != PROTOCOL_ID) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"Expected protocol id "</span> + Integer.toHexString(PROTOCOL_ID) + <span class="string">" but got "</span> + Integer.toHexString(protocolId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> versionAndType = readByte();</span><br><span class="line">    <span class="keyword">byte</span> version = (<span class="keyword">byte</span>)(versionAndType &amp; VERSION_MASK);</span><br><span class="line">    <span class="keyword">if</span> (version != VERSION) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"Expected version "</span> + VERSION + <span class="string">" but got "</span> + version);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> type = (<span class="keyword">byte</span>)((versionAndType &gt;&gt; TYPE_SHIFT_AMOUNT) &amp; <span class="number">0x03</span>);</span><br><span class="line">    <span class="keyword">int</span> seqid = readVarint32();</span><br><span class="line">    String messageName = readString();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMessage(messageName, type, seqid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a struct begin. There's nothing on the wire for this, but it is our</span></span><br><span class="line"><span class="comment">   * opportunity to push a new struct begin marker onto the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastField_.push(lastFieldId_);</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ANONYMOUS_STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Doesn't actually consume any wire data, just removes the last field for </span></span><br><span class="line"><span class="comment">   * this struct from the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="comment">// consume the last field we read off the wire.</span></span><br><span class="line">    lastFieldId_ = lastField_.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a field header off the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if it's a stop, then we can return immediately, as the struct is over.</span></span><br><span class="line">    <span class="keyword">if</span> (type == TType.STOP) &#123;</span><br><span class="line">      <span class="keyword">return</span> TSTOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> fieldId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mask off the 4 MSB of the type header. it could contain a field id delta.</span></span><br><span class="line">    <span class="keyword">short</span> modifier = (<span class="keyword">short</span>)((type &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (modifier == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// not a delta. look ahead for the zigzag varint field id.</span></span><br><span class="line">      fieldId = readI16();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// has a delta. add the delta to the last read field id.</span></span><br><span class="line">      fieldId = (<span class="keyword">short</span>)(lastFieldId_ + modifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TField field = <span class="keyword">new</span> TField(<span class="string">""</span>, getTType((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)), fieldId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this happens to be a boolean field, the value is encoded in the type</span></span><br><span class="line">    <span class="keyword">if</span> (isBoolType(type)) &#123;</span><br><span class="line">      <span class="comment">// save the boolean value in a special instance variable.</span></span><br><span class="line">      boolValue_ = (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the new field onto the field stack so we can keep the deltas going.</span></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Read a map header off the wire. If the size is zero, skip reading the key</span></span><br><span class="line"><span class="comment">   * and value type. This means that 0-length maps will yield TMaps without the</span></span><br><span class="line"><span class="comment">   * "correct" types.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readVarint32();</span><br><span class="line">    <span class="keyword">byte</span> keyAndValueType = size == <span class="number">0</span> ? <span class="number">0</span> : readByte();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMap(getTType((<span class="keyword">byte</span>)(keyAndValueType &gt;&gt; <span class="number">4</span>)), getTType((<span class="keyword">byte</span>)(keyAndValueType &amp; <span class="number">0xf</span>)), size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a list header off the wire. If the list size is 0-14, the size will </span></span><br><span class="line"><span class="comment">   * be packed into the element type header. If it's a longer list, the 4 MSB</span></span><br><span class="line"><span class="comment">   * of the element type header will be 0xF, and a varint will follow with the</span></span><br><span class="line"><span class="comment">   * true size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> size_and_type = readByte();</span><br><span class="line">    <span class="keyword">int</span> size = (size_and_type &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">15</span>) &#123;</span><br><span class="line">      size = readVarint32();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> type = getTType(size_and_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TList(type, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a set header off the wire. If the set size is 0-14, the size will </span></span><br><span class="line"><span class="comment">   * be packed into the element type header. If it's a longer set, the 4 MSB</span></span><br><span class="line"><span class="comment">   * of the element type header will be 0xF, and a varint will follow with the</span></span><br><span class="line"><span class="comment">   * true size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TSet(readListBegin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a boolean off the wire. If this is a boolean field, the value should</span></span><br><span class="line"><span class="comment">   * already have been read during readFieldBegin, so we'll just consume the</span></span><br><span class="line"><span class="comment">   * pre-stored value. Otherwise, read a byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (boolValue_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> result = boolValue_.booleanValue();</span><br><span class="line">      boolValue_ = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readByte() == Types.BOOLEAN_TRUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] byteRawBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a single byte off the wire. Nothing interesting here.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">      trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      trans_.readAll(byteRawBuf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      b = byteRawBuf[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i16 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">short</span>)zigzagToInt(readVarint32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i32 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zigzagToInt(readVarint32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i64 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zigzagToLong(readVarint64());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * No magic here - just read a double off the wire.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] longBits = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    trans_.readAll(longBits, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(bytesToLong(longBits));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reads a byte[] (via readBinary), and then UTF-8 decodes it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = readVarint32();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= length) &#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(trans_.getBuffer(), trans_.getBufferPosition(), length, <span class="string">"UTF-8"</span>);</span><br><span class="line">        trans_.consumeBuffer(length);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(readBinary(length), <span class="string">"UTF-8"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"UTF-8 not supported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a byte[] from the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = readVarint32();</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a byte[] of a known length from the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] readBinary(<span class="keyword">int</span> length) <span class="keyword">throws</span> TException &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// These methods are here for the struct to call, but don't have any wire </span></span><br><span class="line">  <span class="comment">// encoding.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Internal reading methods</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i32 from the wire as a varint. The MSB of each byte is set</span></span><br><span class="line"><span class="comment">   * if there is another byte to follow. This can read up to 5 bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readVarint32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i64 from the wire as a proper varint. The MSB of each byte is set </span></span><br><span class="line"><span class="comment">   * if there is another byte to follow. This can read up to 10 bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">readVarint64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">long</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">long</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift +=<span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// encoding helpers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert from zigzag int to int.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">zigzagToInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt;&gt; <span class="number">1</span>) ^ -(n &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Convert from zigzag long to long.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">zigzagToLong</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt;&gt; <span class="number">1</span>) ^ -(n &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note that it's important that the mask bytes are long literals, </span></span><br><span class="line"><span class="comment">   * otherwise they'll default to ints, and when you shift an int left 56 bits,</span></span><br><span class="line"><span class="comment">   * you just get a messed up int.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">bytesToLong</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((bytes[<span class="number">7</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">      ((bytes[<span class="number">6</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">      ((bytes[<span class="number">5</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">      ((bytes[<span class="number">4</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">      ((bytes[<span class="number">3</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((bytes[<span class="number">2</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((bytes[<span class="number">1</span>] &amp; <span class="number">0xffL</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((bytes[<span class="number">0</span>] &amp; <span class="number">0xffL</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// type testing and converting</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBoolType</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowerNibble = b &amp; <span class="number">0x0f</span>;</span><br><span class="line">    <span class="keyword">return</span> lowerNibble == Types.BOOLEAN_TRUE || lowerNibble == Types.BOOLEAN_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Given a TCompactProtocol.Types constant, convert it to its corresponding </span></span><br><span class="line"><span class="comment">   * TType value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getTType</span><span class="params">(<span class="keyword">byte</span> type)</span> <span class="keyword">throws</span> TProtocolException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> TType.STOP:</span><br><span class="line">        <span class="keyword">return</span> TType.STOP;</span><br><span class="line">      <span class="keyword">case</span> Types.BOOLEAN_FALSE:</span><br><span class="line">      <span class="keyword">case</span> Types.BOOLEAN_TRUE:</span><br><span class="line">        <span class="keyword">return</span> TType.BOOL;</span><br><span class="line">      <span class="keyword">case</span> Types.BYTE:</span><br><span class="line">        <span class="keyword">return</span> TType.BYTE;</span><br><span class="line">      <span class="keyword">case</span> Types.I16:</span><br><span class="line">        <span class="keyword">return</span> TType.I16;</span><br><span class="line">      <span class="keyword">case</span> Types.I32:</span><br><span class="line">        <span class="keyword">return</span> TType.I32;</span><br><span class="line">      <span class="keyword">case</span> Types.I64:</span><br><span class="line">        <span class="keyword">return</span> TType.I64;</span><br><span class="line">      <span class="keyword">case</span> Types.DOUBLE:</span><br><span class="line">        <span class="keyword">return</span> TType.DOUBLE;</span><br><span class="line">      <span class="keyword">case</span> Types.BINARY:</span><br><span class="line">        <span class="keyword">return</span> TType.STRING;</span><br><span class="line">      <span class="keyword">case</span> Types.LIST:</span><br><span class="line">        <span class="keyword">return</span> TType.LIST;</span><br><span class="line">      <span class="keyword">case</span> Types.SET:</span><br><span class="line">        <span class="keyword">return</span> TType.SET;</span><br><span class="line">      <span class="keyword">case</span> Types.MAP:</span><br><span class="line">        <span class="keyword">return</span> TType.MAP;</span><br><span class="line">      <span class="keyword">case</span> Types.STRUCT:</span><br><span class="line">        <span class="keyword">return</span> TType.STRUCT;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"don't know what type: "</span> + (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Given a TType value, find the appropriate TCompactProtocol.Types constant.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getCompactType</span><span class="params">(<span class="keyword">byte</span> ttype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ttypeToCompactType[ttype];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="写入方式">写入方式</span></h2><p>这里我们需要讲几个具体的例子</p><h3><span id="写bool类型">写bool类型。</span></h3><p>由于bool类型只有是否两种状态，且在我们的生成的代码当中是以TField的形式存在的，所有对于boolean的写入特殊处理。<br>写入bool类型的在struct 生成代码当中的的样例</p><p>TCompactProtocol写入Boolean分两种情况，</p><ul><li>1：该boolean值为TStruct中的内部成员时TField时，得写入header数据（即内容和数据类型压缩在一起写）；</li><li>2 ：如果不为TField内部类型的话，直接按byte写入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oprot.writeFieldBegin(BOOLTYPE_FIELD_DESC);  <span class="comment">//  BOOLTYPE_FIELD_DESC type = </span></span><br><span class="line">oprot.writeBool(struct.boolType);</span><br></pre></td></tr></table></figure><p>所以在下面用booleanField_ 先保存了TField 然后在后续执行  writeBool 判断一下booleanField_ 是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field.type == TType.BOOL) &#123;</span><br><span class="line">      booleanField_ = field;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeFieldBeginInternal(field, (<span class="keyword">byte</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (booleanField_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we haven't written the field header yet</span></span><br><span class="line">      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">      booleanField_ = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// we're not part of a field, so just write the value.</span></span><br><span class="line">      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="writefieldbegininternal-压缩写法"><code>writeFieldBeginInternal</code> 压缩写法</span></h3><p>writeFieldBeginInternal 每次写入一个Field 就说做一个记录，如果连续写的Field 不超过16个，那么他会将type 压缩写入。<br>具体的压缩过程。<br>第一，算出 Field的标号<br>第二， 把编号的低4为空余出来<br>第三，将type类型和Field的第四位拼起来。</p><p>比如：</p><ul><li><a href="http://field.id" target="_blank" rel="noopener">field.id</a> &gt; this.lastFieldId_  = 3  即 为 <code>0000 0011</code></li><li>&lt;&lt; 4   =       <code>0011 0000</code></li><li>找到field type   <code>this.getCompactType(field.type)</code></li><li>| 上 type   比如说Type 为 1</li><li>最终结果  <code>0011 0001</code> 写入</li></ul><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ttypeToCompactType[TType.STOP] = TType.STOP;</span><br><span class="line">    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;</span><br><span class="line">    ttypeToCompactType[TType.BYTE] = Types.BYTE;</span><br><span class="line">    ttypeToCompactType[TType.I16] = Types.I16;</span><br><span class="line">    ttypeToCompactType[TType.I32] = Types.I32;</span><br><span class="line">    ttypeToCompactType[TType.I64] = Types.I64;</span><br><span class="line">    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;</span><br><span class="line">    ttypeToCompactType[TType.STRING] = Types.BINARY;</span><br><span class="line">    ttypeToCompactType[TType.LIST] = Types.LIST;</span><br><span class="line">    ttypeToCompactType[TType.SET] = Types.SET;</span><br><span class="line">    ttypeToCompactType[TType.MAP] = Types.MAP;</span><br><span class="line">    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldBeginInternal</span><span class="params">(TField field, <span class="keyword">byte</span> typeOverride)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">                                            <span class="comment">// ttypeToCompactType[ttype]</span></span><br><span class="line">    <span class="keyword">byte</span> typeToWrite = typeOverride == -<span class="number">1</span> ? <span class="keyword">this</span>.getCompactType(field.type) : typeOverride;</span><br><span class="line">    <span class="comment">// 得到 差值 这个差值在 0 - 15 一个byte 就可。  </span></span><br><span class="line">    <span class="keyword">if</span> (field.id &gt; <span class="keyword">this</span>.lastFieldId_ &amp;&amp; field.id - <span class="keyword">this</span>.lastFieldId_ &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="comment">// 然后 &lt;&lt; 4 表示 把地四位 空余出来，</span></span><br><span class="line">        <span class="keyword">this</span>.writeByteDirect(field.id - <span class="keyword">this</span>.lastFieldId_ &lt;&lt; <span class="number">4</span> | typeToWrite);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeByteDirect(typeToWrite);</span><br><span class="line">        <span class="keyword">this</span>.writeI16(field.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lastFieldId_ = field.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="其他格式">其他格式</span></h3><ul><li>bool类型：<br>一个字节。</li></ul><blockquote><p>如果bool型的字段是结构体或消息的成员字段并且有编号，一个字节的高4位表示字段编号，低4位表示bool的值（0001:true， 0010：false），即：一个字节的低4位的值（true：1，false：2）.</p></blockquote><blockquote><p>如果bool型的字段单独存在，一个字节表示值，即：一个字节的值（true：1，false：2）.</p></blockquote><ul><li>Byte类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的值.</p></blockquote><ul><li>I16类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至三个字节的值.</p></blockquote><ul><li>I32类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的值.</p></blockquote><ul><li>I64类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至十个字节的值.</p></blockquote><ul><li>double类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），八个字节的值.注：把double类型的数据转成八字节保存，并用小端方式发送。</p></blockquote><ul><li>String类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的负载数据的长度，负载数据.</p></blockquote><ul><li>Struct类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），结构体负载数据，一个字节的结束标记.</p></blockquote><ul><li>MAP类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的map元素的个数，一个字节的键值类型组合（高4位键类型，低4位值类型），Map负载数据.</p></blockquote><ul><li>Set类型：</li></ul><blockquote><p>表示方式一：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的元素个数和值类型组合（高4位键元素个数，低4位值类型），Set负载数据.适用于<strong>Set中元素个数小于等于14个的情况</strong>。</p></blockquote><blockquote><p>表示方式二：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的键值类型（高4位全为1，低4位值类型），一至五个字节的map元素的个数，Set负载数据.<strong>适用于Set中元素个数大于14个的情况</strong>。</p></blockquote><ul><li>List类型：</li></ul><blockquote><p>表示方式一：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的元素个数和值类型组合（高4位键元素个数，低4位值类型），List负载数据.<br><strong>适用于Set中元素个数小于等于14个的情况。</strong></p></blockquote><blockquote><p>表示方式二：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的键值类型（高4位全为1，低4位值类型），一至五个字节的map元素的个数，List负载数据.<strong>适用于Set中元素个数大于14个的情况。</strong></p></blockquote><ul><li>消息（函数）类型：</li></ul><blockquote><p>一个字节的版本，一个字节的消息调用（请求：0x21，响应：0x41，异常：0x61，oneway：0x81），一至五个字节的消息名称长度，消息名称，消息参数负载数据，一个字节的结束标记。</p></blockquote><p>以上说明是基于相邻字段的编号小于等于15的情况。</p><p>如果字段相邻编号大于15，需要把类型和编号分开表示：用一个字节表示类型，一至五个字节表示编号偏移值。</p><h2><span id="读取方式">读取方式</span></h2><p>经过代码分析，我们了解了写入的过程，下面来了解读取过程。<br>我们还是来看 读取Field的例子，Field 会封装在TMessage 当中，所以，首先read会读取TMessage,读取TMessage的没有什么特殊的，就是将TMessage 按照writeMessage 的顺序读取出来，之前会有一个判断版本号的一个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line">    <span class="keyword">if</span> (type == TType.STOP) &#123;</span><br><span class="line">      <span class="keyword">return</span> TSTOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> fieldId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是计算field的id</span></span><br><span class="line">    <span class="comment">// 写入是以高4为未field id的偏移 所以需要将field 的偏移算出来</span></span><br><span class="line">    <span class="keyword">short</span> modifier = (<span class="keyword">short</span>)((type &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (modifier == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果否没有偏移 直接 读取16位的field id</span></span><br><span class="line">      fieldId = readI16();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则 偏移 + 组内编号得到 field整整的id</span></span><br><span class="line">      fieldId = (<span class="keyword">short</span>)(lastFieldId_ + modifier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为 type</span></span><br><span class="line">    TField field = <span class="keyword">new</span> TField(<span class="string">""</span>, getTType((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)), fieldId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this happens to be a boolean field, the value is encoded in the type</span></span><br><span class="line">    <span class="keyword">if</span> (isBoolType(type)) &#123;</span><br><span class="line">      <span class="comment">// save the boolean value in a special instance variable.</span></span><br><span class="line">      boolValue_ = (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录field</span></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="read-方法举例">read 方法举例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">short</span>)zigzagToInt(readVarint32());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readVarint32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i32buf 是5个字节 也就是说 varint 最大字节为5 </span></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// varin32的读法，建议读一下上面的 varint32的写法 这里不再详解</span></span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2><span id="压缩测试">压缩测试</span></h2><p>本节我们来讨论压缩比，上面说了这么多，那么TCompactProtocol 的压缩比如何呢？<br>首先我们需要 <a href="https://github.com/zhang-xzhi/memoryutil" target="_blank" rel="noopener">MemeoryUtil</a> 这个工具</p><ul><li>1、 编写测试bean 并生成对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="number">1</span>: required string name,</span><br><span class="line">    <span class="number">2</span>: required i16 age = <span class="number">0</span>;</span><br><span class="line">    <span class="number">3</span>: required bool gender,</span><br><span class="line">    <span class="number">4</span>: required i32 No,</span><br><span class="line">    <span class="number">5</span>: required i64 createTime,</span><br><span class="line">    <span class="number">6</span>: required <span class="keyword">double</span> grade,</span><br><span class="line">    <span class="number">7</span>: required list&lt;Friends&gt; friends,</span><br><span class="line">    <span class="number">8</span>: optional map&lt;i32, Friends&gt; mapUser,</span><br><span class="line">    <span class="number">9</span>: optional set&lt;Friends&gt; setUser,</span><br><span class="line">    <span class="number">10</span>: required UserType userType = UserType.STUDENT,</span><br><span class="line">    <span class="number">11</span>: optional i32 number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、 编写测试方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">protected</span> TMemoryInputTransport memory ;</span><br><span class="line">    <span class="keyword">protected</span> TByteArrayOutputStream tByteArrayOutputStream ;</span><br><span class="line">    <span class="keyword">protected</span> TFramedTransport tFramedTransport;</span><br><span class="line">    <span class="keyword">protected</span> TCompactProtocol tcprotocol;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;? extends TFramedTransport&gt; aClass ;</span><br><span class="line">    Field writeBuffer_;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        memory = <span class="keyword">new</span> TMemoryInputTransport(buf);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          利用反射 将写如的对象转换成 TByteArrayOutputStream</span></span><br><span class="line"><span class="comment">          这样通过 TCompactProtocol 写入的就是   TByteArrayOutputStream 这个对象当中，方面我们统计</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        tByteArrayOutputStream = <span class="keyword">new</span> TByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        tFramedTransport = <span class="keyword">new</span> TFramedTransport(memory);</span><br><span class="line">        tcprotocol = <span class="keyword">new</span> TCompactProtocol(tFramedTransport);</span><br><span class="line">        aClass = tFramedTransport.getClass();</span><br><span class="line"></span><br><span class="line">        writeBuffer_ = aClass.getDeclaredField(<span class="string">"writeBuffer_"</span>);</span><br><span class="line">        writeBuffer_.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        writeBuffer_.set(tFramedTransport, tByteArrayOutputStream);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MemoryUtil 是classmexer 当中的方法</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTMessageCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] total = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                .mapToObj(CompressionTest::mockUser)</span><br><span class="line">                .forEach(user -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        user.write(tcprotocol);</span><br><span class="line">                        <span class="keyword">long</span> l = MemoryUtil.deepMemoryUsageOf(user, MemoryUtil.VisibilityFilter.ALL);</span><br><span class="line">                        total[<span class="number">0</span>] +=l;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = tByteArrayOutputStream.len();</span><br><span class="line">        <span class="comment">// 转换</span></span><br><span class="line">        <span class="keyword">double</span> userTotalDouble = (<span class="keyword">double</span>) total[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>) len / userTotalDouble;</span><br><span class="line">        String format = String.format(<span class="string">"%.4f"</span>, rate);</span><br><span class="line">        System.out.println(<span class="string">"total:"</span> + total[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"len:"</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"rate:"</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inet 类型的测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tcprotocol.writeI32(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = tByteArrayOutputStream.len();</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>) len / (<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"rate:"</span> + rate);</span><br><span class="line">        System.out.println(<span class="string">"len:"</span> + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成一个 测试对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">mockUser</span> <span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(Short.MAX_VALUE);</span><br><span class="line">        user.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        user.setGender(<span class="keyword">true</span>);</span><br><span class="line">        user.setName(<span class="string">"name"</span> + no);</span><br><span class="line">        user.setNo(no);</span><br><span class="line">        Friends friends = <span class="keyword">new</span> Friends();</span><br><span class="line">        friends.setNo(Short.MAX_VALUE);</span><br><span class="line">        user.setFriends(Collections.singletonList(friends));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>3、 将  <a href="https://github.com/zhang-xzhi/memoryutil" target="_blank" rel="noopener">classmexer.jar</a>  添加到lib 当中去</li><li>4、 jvm 参数加上代理 参数： VM options:如下图所示</li></ul><p><img src="/article/java-thrift-4-2/java-thrift-4-2-184948.png" alt></p><p>最后得出结果<br>User 1000个的压缩结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total:<span class="number">815184</span></span><br><span class="line">len:<span class="number">42786</span></span><br><span class="line">rate:<span class="number">0.0525</span></span><br></pre></td></tr></table></figure><p>Int 类型压缩结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate:<span class="number">0.48425</span></span><br><span class="line">len:<span class="number">1937</span></span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://wikimore.github.io/2016/09/22/zig-zag-intro/" target="_blank" rel="noopener">varint和zigzag编码</a></li><li><a href="https://www.cnblogs.com/voipman/p/5163267.html" target="_blank" rel="noopener">Thrift的TCompactProtocol紧凑型二进制协议分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（四）</title>
      <link href="/article/java-thrift-4/"/>
      <url>/article/java-thrift-4/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>本节来讨论thrift 的编解码器。</p><h2><span id="核心组件">核心组件</span></h2><h2><span id="整体架构">整体架构</span></h2><p><img src="/article/java-thrift-4/java-thrift-1-112101.png" alt></p><p><strong>Thrift的核心组件, 主要包含以下几个方面</strong></p><ul><li>IDL服务描述组件,负责完成跨平台和跨语言(针对不同语言完成了Server层和Client代码的生成)</li><li>TServer和Client，服务端和客户端组件的实现</li><li>TProtocal 协议和解编码组件</li><li>TTransport 传输组件</li><li>TProcessor 服务调用组件，完成对服务实现的调用</li></ul><p>协议和编解码是一个网络应用程序的核心问题之一，客户端和服务器通过约定的协议来传输消息(数据)，通过特定的格式来编解码字节流，并转化成业务消息，提供给上层框架调用。</p><p>本节主要主要针对<code>TProtocal</code> 协议组件来讨论。</p><h2><span id="编解码">编解码</span></h2><h2><span id="协议">协议</span></h2><p>thrift 做到很好的让用户在服务器端与客户端选择对应的传输协议，总体上一般为2种传输协议：<br><strong>二进制或者文本</strong>.</p><p>如果想要节省带宽可以采用二进制的协议，如果希望方便抓包、调试则可以选择文本协议，用户可用根据自己的项目需求选择对应的协议。</p><h3><span id="类图">类图</span></h3><p><img src="https://icefrozen.github.io/article/java-thrift-3/java-thrift-3-161213.png" alt></p><ul><li><strong>TCompactProtocol</strong> ： 紧凑的、高效的二进制传输协议；</li><li><strong>TBinaryProtocol</strong> ： 基于二进制传输的协议，使用方法与TCompactProtocol 相同</li><li><strong>TJSONProtocol</strong> ： 使用json格式编码传输协议</li><li>TSimpleJSONProtocol 使用简单json格式编码传输协议</li></ul><p>我们可以看到所有的</p><h3><span id="tprotocol-方法">TProtocol 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">protected</span> TTransport trans_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 写方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer buf)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="comment">// 读取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里面定义了一些抽象方法，用于<code>Thrift</code> 中各个消息的系列化入口，子类根基自身的提醒来实现这些方法，用于达到不同的类型，用不同的序列化协议。</p><p>我们以最基本的二级制协议格式来具体看一下，那么是究竟如何序列化的。</p><h3><span id="tbinaryprotocol-二进制">TBinaryProtocol （二进制）</span></h3><p>二级制序列化是每个序列化框架都应该具备基本序列化方法，虽然在网络上最终是以二进制的方法，但是这种而序列化方法能让我们决定具体的二级序列，避免了浪费带宽。<br>先看源码</p><h3><span id="源码">源码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TBinaryProtocol</span> <span class="keyword">extends</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TStruct ANONYMOUS_STRUCT = <span class="keyword">new</span> TStruct();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_MASK = <span class="number">0xffff0000</span>;     <span class="comment">// -65536</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_1 = <span class="number">0x80010000</span>;       <span class="comment">//2147418112</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> strictRead_ = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> strictWrite_ = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> readLength_;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> checkReadLength_ = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 协议工厂</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">TProtocolFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> strictRead_ = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> strictWrite_ = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> readLength_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(strictRead, strictWrite, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite, <span class="keyword">int</span> readLength)</span> </span>&#123;</span><br><span class="line">      strictRead_ = strictRead;</span><br><span class="line">      strictWrite_ = strictWrite;</span><br><span class="line">      readLength_ = readLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TProtocol <span class="title">getProtocol</span><span class="params">(TTransport trans)</span> </span>&#123;</span><br><span class="line">      TBinaryProtocol proto = <span class="keyword">new</span> TBinaryProtocol(trans, strictRead_, strictWrite_);</span><br><span class="line">      <span class="keyword">if</span> (readLength_ != <span class="number">0</span>) &#123;</span><br><span class="line">        proto.setReadLength(readLength_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> proto;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// factory  ... ... ... ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TBinaryProtocol</span><span class="params">(TTransport trans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(trans, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TBinaryProtocol</span><span class="params">(TTransport trans, <span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(trans);</span><br><span class="line">    strictRead_ = strictRead;</span><br><span class="line">    strictWrite_ = strictWrite;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入 message 相关信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strictWrite_) &#123;</span><br><span class="line">      <span class="keyword">int</span> version = VERSION_1 | message.type;</span><br><span class="line">      writeI32(version);</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeByte(message.type);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 写入 field </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(field.type);</span><br><span class="line">    writeI16(field.id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// field stop 表示</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(TType.STOP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Map 写入开始</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(map.keyType);</span><br><span class="line">    writeByte(map.valueType);</span><br><span class="line">    writeI32(map.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(list.elemType);</span><br><span class="line">    writeI32(list.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(set.elemType);</span><br><span class="line">    writeI32(set.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(b ? (<span class="keyword">byte</span>)<span class="number">1</span> : (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span> [] bout = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 写入一个 byte 数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    bout[<span class="number">0</span>] = b;</span><br><span class="line">    trans_.write(bout, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i16out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i16out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i16out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16));</span><br><span class="line">    trans_.write(i16out, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i32out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i32out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    i32out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    i32out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i32out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32));</span><br><span class="line">    trans_.write(i32out, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i64out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">    i64out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">    i64out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">    i64out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    i64out[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    i64out[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    i64out[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i64out[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">    trans_.write(i64out, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeI64(Double.doubleToLongBits(dub));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">      writeI32(dat.length);</span><br><span class="line">      trans_.write(dat, <span class="number">0</span>, dat.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">    writeI32(length);</span><br><span class="line">    trans_.write(bin.array(), bin.position() + bin.arrayOffset(), length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reading methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> version = size &amp; VERSION_MASK;</span><br><span class="line">      <span class="keyword">if</span> (version != VERSION_1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class="string">"Bad version in readMessageBegin"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TMessage(readString(), (<span class="keyword">byte</span>)(size &amp; <span class="number">0x000000ff</span>), readI32());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (strictRead_) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class="string">"Missing version in readMessageBegin, old client?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TMessage(readStringBody(size), readByte(), readI32());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ANONYMOUS_STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line">    <span class="keyword">short</span> id = type == TType.STOP ? <span class="number">0</span> : readI16();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TField(<span class="string">""</span>, type, id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMap(readByte(), readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TList(readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TSet(readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readByte() == <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] bin = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span> b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">      trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    readAll(bin, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bin[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i16rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i16rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i16rd, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      (<span class="keyword">short</span>)</span><br><span class="line">      (((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">       ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i32rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i32rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i32rd, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i64rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i64rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i64rd, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off]   &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">7</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(readI64());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(trans_.getBuffer(), trans_.getBufferPosition(), size, <span class="string">"UTF-8"</span>);</span><br><span class="line">        trans_.consumeBuffer(size);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readStringBody(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readStringBody</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      checkReadLength(size);</span><br><span class="line">      <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">      trans_.readAll(buf, <span class="number">0</span>, size);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line">    checkReadLength(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">      ByteBuffer bb = ByteBuffer.wrap(trans_.getBuffer(), trans_.getBufferPosition(), size);</span><br><span class="line">      trans_.consumeBuffer(size);</span><br><span class="line">      <span class="keyword">return</span> bb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readAll</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    checkReadLength(len);</span><br><span class="line">    <span class="keyword">return</span> trans_.readAll(buf, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadLength</span><span class="params">(<span class="keyword">int</span> readLength)</span> </span>&#123;</span><br><span class="line">    readLength_ = readLength;</span><br><span class="line">    checkReadLength_ = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkReadLength</span><span class="params">(<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"Negative length: "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkReadLength_) &#123;</span><br><span class="line">      readLength_ -= length;</span><br><span class="line">      <span class="keyword">if</span> (readLength_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"Message length exceeded: "</span> + length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="write数据">write数据</span></h3><p>二级制协议主要的核心代码 主要集中在序列化上， Thrift 对 封装好的</p><ul><li>TStruct</li><li>TMessage类型</li><li>TField 类型</li><li>TCollection 方法 TMap, TStruct, TSet</li><li>基础类型 i16， i32, i64 … binary, string 等</li></ul><p>类型都有特定的 写入begin和写入end 两种方法。Begin 都会将自己的id 和 type 写入到 byte 当中。所有的byte写入会调用，下面几种基础写入方法</p><ul><li>writeBool</li><li>writeByte</li><li>writeI16</li><li>writeI32</li><li>writeI64</li><li>writeDouble</li><li>writeString</li></ul><p>我们先来看一个方法 核心的序列化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 64位 需要8个字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] i64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">   i64out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">   i64out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">   i64out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">   i64out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">   i64out[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">   i64out[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">   i64out[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">   i64out[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">   trans_.write(i64out, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>0xff 值为：<br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code></li><li>i64 是我们要序列化的数字 每个8bit是一个属于<br><code>10000000 01000000 00100000 00010000 00001000 00000100 00000010 00000001</code></li><li>“&gt;&gt;56” 相当于我们 让上面的数字想右边移动 56 位 ，取到 10000000</li></ul><p>然后和 0xff &amp; 一下 得到<br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code><br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 10000000</code><br>&amp;的计算方法 不在赘述最后得到了  10000000 这段 byte 数据。</p><p>其实以上的意思是 将 i64 最高的 一个byte 取出来 放到  i64out 的第一位<br>最后将 i64 的数字 变成<br><code>10000000 01000000 00100000 00010000 00001000 00000100 00000010 00000001</code><br>即：</p><ul><li><code>i64out[0] = 10000000</code></li><li><code>i64out[1] = 01000000</code></li><li><code>i64out[2] = 00100000</code></li><li><code>i64out[3] = 00010000</code></li><li><code>i64out[4] = 00001000</code></li><li><code>i64out[5] = 00000100</code></li><li><code>i64out[6] = 00000010</code></li><li><code>i64out[7] = 00000001</code></li></ul><h3><span id="read-数据">read 数据</span></h3><p>读数据其实本质上是要按照写的方法去读取数据，也就是说是写数据反向操作。 具体的方法可以参考以上源码，这里不再过多赘述。<br>这里要介绍一个概念。Transport<br>RPC作为一种特殊的网络编程，会封装一层传输层来支持底层的网络通信。Thrift使用了Transport来封装传输层，但Transport不仅仅是底层网络传输，它还是上层流的封装。<br>我们看到，无论TProtocal 如何处理数据，最终都会交给  Transport 去传输<br>Transport 如何传输，本章节不在讨论。请看下一个章节。</p><h3><span id="factory">Factory</span></h3><p>这是一个协议封装好的工厂，这个工厂是要向外提供出去，供Server 和 Client 使用的，所以这里没有引用。<br>具体看一下<a href="https://icefrozen.github.io/article/java-thrift-1/#-9" target="_blank" rel="noopener">Thrift框架详解（一)</a></p><h2><span id="参考">参考</span></h2><ul><li><a href="http://www.cpper.cn/2016/03/17/develop/Thrift-Reserch/" target="_blank" rel="noopener">Thrift框架调研</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构（一）</title>
      <link href="/article/architecture/"/>
      <url>/article/architecture/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>阿姆达尔定律</p><h2><span id="什么是阿姆达尔定律">什么是阿姆达尔定律</span></h2><p>阿姆达尔定律（英语：Amdahl’s law，Amdahl’s argument），一个计算机科学界的经验法则，因吉恩·阿姆达尔(Gene Amdahl)而得名。它代表了处理器平行运算之后效率提升的能力。<br>1967年计算机体系结构专家吉恩.阿姆达尔提出过一个定律阿姆达尔定律，说：<strong>在并行计算中用多处理器的应用加速受限于程序所需的串行时间百分比</strong>。<br>举两个例子说明这个问题：</p><ol><li><p><strong>譬如说，你的程序50%是串行的，其他一半可以并行，那么，最大的加速比就是2。不管你用多少处理器并行，这个加速比不可能提高。在这种情况下，改进串行算法可能比多核处理器并行更有效。</strong></p></li><li><p><strong>假设某一功能的处理时间为整体系统运行时间的60%，若使该功能的处理速度提高至原来的5倍，则根据阿姆达尔定律，整个系统的处理速度可提高至原来的多少倍</strong>？</p></li></ol><h2><span id="阿姆达尔定律规则">阿姆达尔定律规则</span></h2><h3><span id="加速比">加速比</span></h3><p>优化前系统总耗时To(old)，优化后系统总耗时Tn(new)，为加速比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S =To/Tn</span><br></pre></td></tr></table></figure><h3><span id="原系统中能够改进的部分占总部分的比例c">原系统中能够改进的部分占总部分的比例:C</span></h3><p>原系统中能够改进的部分占总部分的比例，也可以说能够改进部分运行时间占总系统运行时间的比例，比如上文所说的，加入的你程序100%是并行的，如果将50% 改成并行（或者其他能提高速度的方式），那么 <code>C = 50%</code></p><h3><span id="系统的提升比例st">系统的提升比例St</span></h3><p>比如 系统比原系统提升了5倍 这是个比例(St=5)</p><h3><span id="公式如下">公式如下</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = To/Tn = <span class="number">1</span> / ((<span class="number">1</span>-C) + C/St)</span><br></pre></td></tr></table></figure><h3><span id="计算">计算</span></h3><p>那么我们来回答第一个问题</p><blockquote><p>你的程序50%是串行的，其他一半可以并行，那么，最大的加速比就是2。不管你用多少处理器并行，这个加速比不可能提高。<br>根据公式得到</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当St 变的很大的时候 0.5/St 将会趋于 0，得到 </span><br><span class="line"></span><br><span class="line">```S = 1/(1 - 0.5 + 0) = 1 / 0.5 = 2</span><br></pre></td></tr></table></figure><p>也就是说你把另一半程序优化的比原来提升多少倍,那么加速比，也就是说 你能提升的性能最大可能是原来的 2倍。</p><blockquote><p><strong>假设某一功能的处理时间为整体系统运行时间的60%，若使该功能的处理速度提高至原来的5倍，则根据阿姆达尔定律，整个系统的处理速度可提高至原来的多少倍</strong>？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S   = <span class="number">1</span>/((<span class="number">1</span> - <span class="number">0.6</span> ）+ <span class="number">0.6</span> / <span class="number">5</span>) </span><br><span class="line">    = <span class="number">1</span> / (<span class="number">0.4</span> + <span class="number">0.12</span>)</span><br><span class="line">    = <span class="number">1</span> / <span class="number">0.52</span></span><br><span class="line">    ≈ <span class="number">1.923</span></span><br></pre></td></tr></table></figure><h2><span id="阿姆达尔定律原理">阿姆达尔定律原理</span></h2><p>为了更好地理解阿姆达尔定律，我会尝试演示这个定定律是如何诞生的。</p><p><strong>首先，一个程序可以被分割为两部分，一部分为不可并行部分B，一部分为可并行部分1 – B。如下图：</strong></p><p><img src="/article/architecture/architecture-110031.png" alt></p><p><strong>在顶部被带有分割线的那条直线代表总时间 T(1)。</strong></p><p><strong>下面你可以看到在并行因子为2的情况下的执行时间：</strong></p><p><img src="/article/architecture/architecture-110049.png" alt></p><p><strong>并行因子为3的情况：</strong></p><p><img src="/article/architecture/architecture-110106.png" alt></p><p>我们假设不考虑其他因素，并行因子越大， 那么1 - B 所占用的时间越短，也就是图中略色的部分也就越短。<br>当我们 并行因子（也就是我们 将 1 - B 运行的速度提升 n 倍 n → ∞）提升无穷大。那么绿色的面积会越来越小，最后约等于0<br>那么我们程序的总时间将约等于 B 的时间。<br>因此我们得出结论：<strong>在并行计算中用多处理器的应用加速受限于程序所需的串行时间百分比</strong>。</p><h2><span id="总结">总结</span></h2><p>虽然阿姆达尔定律允许你并行化一个算法的理论加速比，但是不要过度依赖这样的计算。在实际场景中，当你优化或并行化一个算法时，可以有很多的因子可以被考虑进来。</p><p>内存的速度，CPU缓存，磁盘，网卡等可能都是一个限制因子。如果一个算法的最新版本是并行化的，但是导致了大量的CPU缓存浪费，你可能不会再使用x N个CPU来获得x N的期望加速。如果你的内存总线（memory bus），磁盘，网卡或者网络连接都处于高负载状态，也是一样的情况。</p><p>我们的建议是，使用阿姆达尔定律定律来指导我们优化程序，而不是用来测量优化带来的实际加速比。记住，有时候一个高度串行化的算法胜过一个并行化的算法，因为串行化版本不需要进行协调管理（上下文切换），而且一个单个的CPU在底层硬件工作（CPU管道、CPU缓存等）上的一致性可能更好。</p><h2><span id="参考">参考</span></h2><ul><li><a href="http://ifeve.com/amdahls-law/" target="_blank" rel="noopener">阿姆达尔定律</a></li><li><a href="https://www.geek-share.com/detail/2783250020.html" target="_blank" rel="noopener">阿姆达尔Law对系统性能提升的定义</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（三）</title>
      <link href="/article/java-thrift-3/"/>
      <url>/article/java-thrift-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一节，我们已经详解了IDL详细的语法，Thrift 就是根据这个语法，替我们生成目标代码的。下面我们来具体分析一下，生成的代码究竟是什么作用。</p><h2><span id="准备">准备</span></h2><h2><span id="目录结构">目录结构</span></h2><p>我们来看一下代码结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── java</span><br><span class="line">│   └── learn</span><br><span class="line">│       └── thrift</span><br><span class="line">│           ├── bean</span><br><span class="line">│           ├── client</span><br><span class="line">│           │   └── Client.java</span><br><span class="line">│           ├── constant</span><br><span class="line">│           │   └── ServerConfig.java</span><br><span class="line">│           ├── gen_code.sh</span><br><span class="line">│           ├── idl</span><br><span class="line">│           │   ├── bean.thrift</span><br><span class="line">│           │   └── hello.thrift</span><br><span class="line">│           ├── idlcode</span><br><span class="line">│           │   ├── HelloWorldService.java</span><br><span class="line">│           │   └── UserService.java</span><br><span class="line">│           └── server</span><br><span class="line">│               ├── Server.java</span><br><span class="line">│               └── handler</span><br><span class="line">│                   ├── HelloWorldServiceImpl.java</span><br><span class="line">│                   └── UserServiceImpl.java</span><br></pre></td></tr></table></figure><h2><span id="代码生成">代码生成</span></h2><p>我们来看一下 gen_code.sh 的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">thrift_name=hello.thrift</span><br><span class="line">thrift_bean=bean.thrift</span><br><span class="line">pathroot=../..</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"gen code "</span></span><br><span class="line">thrift --gen java -out <span class="variable">$pathroot</span> ./idl/<span class="variable">$thrift_name</span></span><br><span class="line">thrift --gen java -out <span class="variable">$pathroot</span> ./idl/<span class="variable">$thrift_bean</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finsh"</span></span><br></pre></td></tr></table></figure><p>当我们执行这个脚本的时候 会将 idl 的两个文件生成对应的代码。<br>来看一下  bean.thrift 文件，这里主要是定义的 thrift struct 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namesapce 的用法   java 标识生成java 代码。 后边的标识报名，代码将会生成到那个包下。</span></span><br><span class="line"><span class="comment">// 就是上文提到的 bean 目录下。</span></span><br><span class="line">namespace java learn.thrift.bean</span><br><span class="line"></span><br><span class="line">struct Friends &#123;</span><br><span class="line">    <span class="number">1</span>: required i16 No</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行后发现在bean 下多了一个文件叫<code>Friends</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── java</span><br><span class="line">│   └── learn</span><br><span class="line">│       └── thrift</span><br><span class="line">│           ├── bean</span><br><span class="line">                |-- Friends.java</span><br></pre></td></tr></table></figure><h2><span id="生成代码样例">生成代码样例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.thrift.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friends</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">Friends</span>, <span class="title">Friends</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TStruct STRUCT_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TStruct(<span class="string">"Friends"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TField NO_FIELD_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TField(<span class="string">"No"</span>, org.apache.thrift.protocol.TType.I16, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    schemes.put(StandardScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsStandardSchemeFactory</span>())</span>;</span><br><span class="line">    schemes.put(TupleScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsTupleSchemeFactory</span>())</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">short</span> No; <span class="comment">// required</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> _Fields implements org.apache.thrift.TFieldIdEnum &#123;</span><br><span class="line">    NO((<span class="keyword">short</span>)<span class="number">1</span>, <span class="string">"No"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, _Fields&gt; byName = <span class="keyword">new</span> HashMap&lt;String, _Fields&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (_Fields field : EnumSet.allOf(_Fields<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        byName.put(field.getFieldName(), field);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches fieldId, or null if its not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByThriftId</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span>(fieldId) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">          <span class="keyword">return</span> NO;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches fieldId, throwing an exception</span></span><br><span class="line"><span class="comment">     * if it is not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByThriftIdOrThrow</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">      _Fields fields = findByThriftId(fieldId);</span><br><span class="line">      <span class="keyword">if</span> (fields == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Field "</span> + fieldId + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">      <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches name, or null if its not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> byName.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> _thriftId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String _fieldName;</span><br><span class="line"></span><br><span class="line">    _Fields(<span class="keyword">short</span> thriftId, String fieldName) &#123;</span><br><span class="line">      _thriftId = thriftId;</span><br><span class="line">      _fieldName = fieldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getThriftFieldId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _thriftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFieldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _fieldName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isset id assignments</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> __NO_ISSET_ID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> BitSet __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; metaDataMap;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; tmpMap = <span class="keyword">new</span> EnumMap&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt;(_Fields<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    tmpMap.put(_Fields.NO, <span class="keyword">new</span> org.apache.thrift.meta_data.FieldMetaData(<span class="string">"No"</span>, org.apache.thrift.TFieldRequirementType.REQUIRED, </span><br><span class="line">        <span class="keyword">new</span> org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I16)));</span><br><span class="line">    metaDataMap = Collections.unmodifiableMap(tmpMap);</span><br><span class="line">    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Friends<span class="class">.<span class="keyword">class</span>, <span class="title">metaDataMap</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">short</span> No)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="keyword">this</span>.No = No;</span><br><span class="line">    setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Performs a deep copy on &lt;i&gt;other&lt;/i&gt;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(Friends other)</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.clear();</span><br><span class="line">    __isset_bit_vector.or(other.__isset_bit_vector);</span><br><span class="line">    <span class="keyword">this</span>.No = other.No;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Friends <span class="title">deepCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Friends(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setNoIsSet(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.No = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.No;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Friends <span class="title">setNo</span><span class="params">(<span class="keyword">short</span> No)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.No = No;</span><br><span class="line">    setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.clear(__NO_ISSET_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if field No is set (has been assigned a value) and false otherwise */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __isset_bit_vector.get(__NO_ISSET_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoIsSet</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.set(__NO_ISSET_ID, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(_Fields field, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unsetNo();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setNo((Short)value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getFieldValue</span><span class="params">(_Fields field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">return</span> Short.valueOf(getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(_Fields field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">return</span> isSetNo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (that <span class="keyword">instanceof</span> Friends)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.equals((Friends)that);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Friends that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> this_present_No = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> that_present_No = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (this_present_No || that_present_No) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(this_present_No &amp;&amp; that_present_No))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.No != that.No)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Friends other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getClass().equals(other.getClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> getClass().getName().compareTo(other.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastComparison = <span class="number">0</span>;</span><br><span class="line">    Friends typedOther = (Friends)other;</span><br><span class="line"></span><br><span class="line">    lastComparison = Boolean.valueOf(isSetNo()).compareTo(typedOther.isSetNo());</span><br><span class="line">    <span class="keyword">if</span> (lastComparison != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lastComparison;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSetNo()) &#123;</span><br><span class="line">      lastComparison = org.apache.thrift.TBaseHelper.compareTo(<span class="keyword">this</span>.No, typedOther.No);</span><br><span class="line">      <span class="keyword">if</span> (lastComparison != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lastComparison;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> _Fields <span class="title">fieldForId</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Fields.findByThriftId(fieldId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(iprot.getScheme()).getScheme().read(iprot, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(oprot.getScheme()).getScheme().write(oprot, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Friends("</span>);</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">"No:"</span>);</span><br><span class="line">    sb.append(<span class="keyword">this</span>.No);</span><br><span class="line">    first = <span class="keyword">false</span>;</span><br><span class="line">    sb.append(<span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    <span class="comment">// check for required fields</span></span><br><span class="line">    <span class="comment">// alas, we cannot check 'No' because it's a primitive and you chose the non-beans generator.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      write(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(out)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.</span></span><br><span class="line">      __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line">      read(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(in)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsStandardScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsStandardScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">      iprot.readStructBegin();</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        schemeField = iprot.readFieldBegin();</span><br><span class="line">        <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">            <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.I16) &#123;</span><br><span class="line">              struct.No = iprot.readI16();</span><br><span class="line">              struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">        &#125;</span><br><span class="line">        iprot.readFieldEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">      <span class="keyword">if</span> (!struct.isSetNo()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'No' was not found in serialized data! Struct: "</span> + toString());</span><br><span class="line">      &#125;</span><br><span class="line">      struct.validate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      struct.validate();</span><br><span class="line"></span><br><span class="line">      oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">      oprot.writeFieldBegin(NO_FIELD_DESC);</span><br><span class="line">      oprot.writeI16(struct.No);</span><br><span class="line">      oprot.writeFieldEnd();</span><br><span class="line">      oprot.writeFieldStop();</span><br><span class="line">      oprot.writeStructEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsTupleScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsTupleScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleScheme</span> <span class="keyword">extends</span> <span class="title">TupleScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      TTupleProtocol oprot = (TTupleProtocol) prot;</span><br><span class="line">      oprot.writeI16(struct.No);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      TTupleProtocol iprot = (TTupleProtocol) prot;</span><br><span class="line">      struct.No = iprot.readI16();</span><br><span class="line">      struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="代码详解">代码详解</span></h2><h2><span id="类图">类图</span></h2><p>下面我们会对上文的代码做详细分析。首先我们来看一下类图。<br><img src="/article/java-thrift-3/java-thrift-3-155727.png" alt></p><p>我们可以看到 <code>Friends</code> 是继承 <code>TBase</code> , <code>TBase</code> 又实现 <code>TFieldIdEnum</code>。<br>我们来看TBase 代码</p><h1><span id="基础数据结构">基础数据结构</span></h1><h2><span id="tbase">TBase</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TBase</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">TBase</span>&lt;?, ?&gt;, <span class="title">F</span> <span class="keyword">extends</span> <span class="title">TFieldIdEnum</span>&gt; <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">F <span class="title">fieldForId</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(F var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getFieldValue</span><span class="params">(F var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(F var1, Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TBase&lt;T, F&gt; <span class="title">deepCopy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  TFieldIdEnum</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFieldIdEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">getThriftFieldId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFieldName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TBase</code> 是 <code>Thrift</code> 的所有Type 类型的基类接口，其中定了几个比较重要的方法，比如说读写，克隆和清空。 而<code>TFieldIdEnum</code> 只是一个id 和名字的枚举。 从这里可以看到，实现 <code>TBase</code>的类具有可序列化的功能。</p><h2><span id="tstruct">TStruct</span></h2><p>接下来是 本 <code>Struct</code> 的一个描述， <code>TStruct</code> 只是对 <code>struct</code> 名字的一个描述的封装类，并没有什么特别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TStruct STRUCT_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TStruct(<span class="string">"Friends"</span>);</span><br><span class="line"><span class="comment">// TStruct.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TStruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TStruct</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TStruct 类似的文件是 Thrift 协议层的一个定义，另外协议层还有一下方法<br><img src="/article/java-thrift-3/java-thrift-3-161213.png" alt></p><h2><span id="协议层">协议层</span></h2><p>这一层主要是用来定义如何序列化数据，属于协议层的一部分，将会在其他章节详细讨论，本节不在详细讲述。</p><ul><li><strong>TProtocol</strong></li><li><strong>TBinaryProtocol</strong></li><li><strong>TCompactProtocol</strong></li><li><strong>TJSONProtocol</strong></li><li><strong>TProtocolFactory</strong></li><li><strong>TProtocolUtil</strong></li><li><strong>TSimpleJSONProtocol</strong></li><li><strong>TTupleProtocol</strong></li><li><strong>TProtocolException</strong></li></ul><h2><span id="元数据">元数据</span></h2><p>这里定义的各种其他元数据的类声明</p><ul><li><strong>TBase64Utils</strong> :  Base64 数据的编解码工具</li><li><strong>TField</strong>: Field 字段的声明</li><li><strong>TList</strong>  : List 结构的声明</li><li><strong>TMap</strong>    : Map 结构的声明</li><li><strong>TMessage</strong> : Message 结构的声明</li><li><strong>TMessageType</strong>:  Message类型</li><li><strong>TSet</strong>    :  set类型的声明</li><li><strong>TStruct</strong>:   struct 类型的声明</li><li><strong>TType</strong> :   thrift 所有支持类型的枚举</li></ul><h2><span id="ttype">TType</span></h2><p>Thrift 所有支持的类型 都在 <code>TType</code> 里定义的，我们看一下TType的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STOP   = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VOID   = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOL   = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE   = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16    = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32    = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64    = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRING = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP    = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET    = <span class="number">14</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST   = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ENUM   = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tmessage">TMessage</span></h2><p>这个是 封装结构元数据的上层类, 当我们调用RPC 的时候， Thrift 会将我们要求我们按照他的格式封装元数据，然后在通过TMessage 封装元数据，然后通过网络发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMessageType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CALL  = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> REPLY = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> EXCEPTION = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ONEWAY = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TMessage 结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> seqid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">""</span>, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMessage</span><span class="params">(String n, <span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.type = t;</span><br><span class="line">        <span class="keyword">this</span>.seqid = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;TMessage name:'"</span> + <span class="keyword">this</span>.name + <span class="string">"' type: "</span> + <span class="keyword">this</span>.type + <span class="string">" seqid:"</span> + <span class="keyword">this</span>.seqid + <span class="string">"&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TMessage ? <span class="keyword">this</span>.equals((TMessage)other) : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TMessage other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(other.name) &amp;&amp; <span class="keyword">this</span>.type == other.type &amp;&amp; <span class="keyword">this</span>.seqid == other.seqid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tmap-结构">TMap 结构</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> keyType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> valueType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">byte</span>)<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMap</span><span class="params">(<span class="keyword">byte</span> k, <span class="keyword">byte</span> v, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyType = k;</span><br><span class="line">        <span class="keyword">this</span>.valueType = v;</span><br><span class="line">        <span class="keyword">this</span>.size = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tset">TSet</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> elemType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">(<span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elemType = t;</span><br><span class="line">        <span class="keyword">this</span>.size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">(TList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(list.elemType, list.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tlist">TList</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(TType.STOP, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TList</span><span class="params">(<span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    elemType = t;</span><br><span class="line">    size = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> elemType;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>  size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tfield">TField</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TField</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>   type;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>  id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">""</span>, TType.STOP, (<span class="keyword">short</span>)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TField</span><span class="params">(String n, <span class="keyword">byte</span> t, <span class="keyword">short</span> i)</span> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    type = t;</span><br><span class="line">    id = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;TField name:'"</span> + name + <span class="string">"' type:"</span> + type + <span class="string">" field-id:"</span> + id + <span class="string">"&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TField otherField)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type == otherField.type &amp;&amp; id == otherField.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Friends</code> 中每个变量都会用 TField 来封装，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TField NO_FIELD_DESC = </span><br><span class="line"><span class="keyword">new</span> TField(<span class="string">"No"</span>, TType.I16, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>里面记录了 Field 的名字，类型，和FieldId , thrift 会给每一个Struct的成员变量增加一个Field封装类。</p><h1><span id="ischeme">IScheme</span></h1><h2><span id="ischeme-的作用">IScheme 的作用</span></h2><p>除了变量的定义之外 Friends 类当中还有一个概念 叫 Scheme</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    schemes.put(StandardScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsStandardSchemeFactory</span>())</span>;</span><br><span class="line">    schemes.put(TupleScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsTupleSchemeFactory</span>())</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看一下继承关系</p><p><img src="/article/java-thrift-3/java-thrift-3-203051.png" alt></p><p><code>FriendsStandardSchemeFactory</code> 就是 <code>Scheme</code> 的工厂，意思就是新建一个 <code>FriendsStandardScheme</code>。  而 <code>FriendsStandardScheme</code> 又去实现了 <code>IScheme</code> 这个接口。 从而实现了 <code>read</code> 和 <code>write</code> 方法。</p><p>这个 <code>Scheme</code> 是干什么呢, 和 <code>FriendsStandardScheme</code>,  <code>Friends</code> 又是什么关系呢？</p><p><code>我们知道，Friends</code> 是继承 <code>TBase</code> 的 <code>TBase</code> 中有两个重要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br></pre></td></tr></table></figure><p>而 <code>Friends</code> 就是要实现这两个方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(iprot.getScheme()).getScheme().read(iprot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(oprot.getScheme()).getScheme().write(oprot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Scheme</code> 其实就是一种序列化方式，标识该类的具体读写策略、</p></li><li><p><code>Friends</code> 序列化的时候，需要传递协议，也就是 <code>TProtocol</code> 的实现类，<code>TProtocol</code> 会根据自身支持的 序列化方式选择来选择 <code>Friends</code>  所支持的序列化方式，也就是的对应的具体 <code>Scheme</code>工厂。从而创建出具体的 <code>Scheme</code> 实现类。</p></li><li><p>上述代码中 <code>schemes.get(oprot.getScheme()).getScheme()</code>，第一个<code>oprot.getScheme()</code> 是选择对应的<code>Scheme</code> 方式，也就是 <code>StandardScheme</code> 还是 <code>TupleScheme</code>。 从 <code>Friends</code> 静态对象 schemes 中找到<code>Scheme</code> 工厂然后实例化具体的 <code>Scheme</code> 的实现类。</p></li></ul><p>本例中，<code>Friends</code> 一共实现类两种实现类 一种是 <code>FriendsStandardScheme</code>, 一种是·<code>FriendsTupleScheme</code></p><p>来看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsTupleScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsTupleScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsStandardScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsStandardScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2><span id="ischeme-具体实现方式">IScheme 具体实现方式。</span></h2><p>下面我们具体来分析一下 <code>FriendsStandardScheme</code> 和  <code>FriendsTupleSchemeFactory</code> 具体的读写策略。</p><h3><span id="friendsstandardscheme">FriendsStandardScheme</span></h3><p>我们来具体分析一下 <code>FriendsStandardScheme</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">     iprot.readStructBegin();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       schemeField = iprot.readFieldBegin();</span><br><span class="line">       <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">           <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.I16) &#123;</span><br><span class="line">             struct.No = iprot.readI16();</span><br><span class="line">             struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">       &#125;</span><br><span class="line">       iprot.readFieldEnd();</span><br><span class="line">     &#125;</span><br><span class="line">     iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">     <span class="keyword">if</span> (!struct.isSetNo()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'No' was not found in serialized data! Struct: "</span> + toString());</span><br><span class="line">     &#125;</span><br><span class="line">     struct.validate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     struct.validate();</span><br><span class="line"></span><br><span class="line">     oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">     oprot.writeFieldBegin(NO_FIELD_DESC);</span><br><span class="line">     oprot.writeI16(struct.No);</span><br><span class="line">     oprot.writeFieldEnd();</span><br><span class="line">     oprot.writeFieldStop();</span><br><span class="line">     oprot.writeStructEnd();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Write 操作<br>从代码来分析  write 方法是写入规则，首先写入了 <code>STRUCT_DESC</code> 描述， 然后写入了 <code>NO_FIELD_DESC</code> 就是 No 这个字段，然后根据No 的大小吸入了No的具体的值，因为 No 是i16的类型，所以调用了 <code>writeI16</code> 的方法，然后 <code>writeFieldEnd</code> 标识该字段结束。<br><img src="/article/java-thrift-3/java-thrift-3-205443.png" alt></p></li><li><p>读操作<br>读取操作其实很写入操作相反， 需要注意一点是 读操作有个标记为 为 <code>schemeField.type == org.apache.thrift.protocol.TType.STOP</code><br>遇到这个标记为，则读取直接停止。那么这个 <code>STOP</code> 是什么作用呢？</p></li></ul><p>STOP 是 <code>writeFieldStop</code> 结束的标记为，标记该 <code>Struct</code> 的所有 <code>Field</code> 都已经读取完毕</p><p><img src="/article/java-thrift-3/java-thrift-3-114519.png" alt><br>从图中我们可以看到， 当Field 写入完毕后 <code>wirte</code> 会写入 <code>TType.STOP</code> <code>标记，代表所有的Field</code> 都已经图区完毕，这个时候 <code>read</code> 就可以退出了。</p><p>而在每个<code>Field</code>,<code>Struct</code> 协议的最后，又会写入结束的标记。<br>这个标记是由协议来实现的，目前不同的协议有不同的写入方法<br>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TBinaryProtocol.java  为空实现，什么也不写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TJSONProtocol.java 协议实现方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.writeJSONObjectEnd();<span class="comment">// 这里输入的是 “&#125;”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问，为什么 <code>TBinaryProtocol</code> 什么也不写呢？<br>问知道 <code>TField</code> 中有个 <code>type</code> 的字段， <code>type</code> 字段标明了 <code>value</code> 类型所占的长度，<br>所有我们用 往后读 <code>type</code> 所占的长度就可以获取 <code>value</code> 的值，所以 <code>Field</code> 的结束标记位可以什么都不用写。<br>那么又有读者会问，那么 <code>String</code> 类型呢，他没有固定长度。</p><p>二级制协议 <code>TBinaryProtocol</code> 中关于 写 <code>String</code> 写入的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">this</span>.writeI32(dat.length);</span><br><span class="line">        <span class="keyword">this</span>.trans_.write(dat, <span class="number">0</span>, dat.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看出， 写 <code>String</code> string 转成UTF8的编码，然后在value的地方前两个字节写入字符串的长度，然后在写入字符创的 byte 数据。<br>所以说，对于变长类型，写入的规则为 <strong>长度 + 数据</strong>的方式。</p><h3><span id="friendstuplescheme">FriendsTupleScheme</span></h3><p><code>FriendsTupleScheme</code> 重新定义了一种名为 <code>TTupleProtocol</code> 的协议，这个协议是一个<br><code>TCompactProtocol</code> 的子类， <code>TCompactProtocol</code> 我会在协议层分析。</p><p>简单说 <code>FriendsTupleScheme</code> 一种压缩的编码方式，将所有的指以固定长度压缩在一起。结构如下<br><img src="/article/java-thrift-3/java-thrift-3-120859.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleScheme</span> <span class="keyword">extends</span> <span class="title">TupleScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    TTupleProtocol oprot = (TTupleProtocol) prot;</span><br><span class="line">    oprot.writeI16(struct.No);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    TTupleProtocol iprot = (TTupleProtocol) prot;</span><br><span class="line">    struct.No = iprot.readI16();</span><br><span class="line">    struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="get-set-方法">GET SET 方法</span></h1><h2><span id="set-方法">SET 方法</span></h2><p><code>Friends</code> 为每一个Field 都生成了一个 set 方法 和一个 isSetXXX 的方法，标识该值是否被set。之所以有这个方式是因为 当我们在给 一个 i31的数 定义为 optional 的时候，i32 对应的是Java 语言的int 型 那么 这个值被初始化为 0，那么当rpc 过来的 这个值 就是0的时候，程序无法区分 这个0 是没有set 还是值就是0</p><blockquote><p>注意，在设计RPC 协议或者其他协议的时候，避免 0 这个值。</p></blockquote><p>Thrift 会给String 每个字段顶一个id, 名字为：<code>__{filed name}_ISSET_ID</code>,又会定义个bitSet 结构   bitSet 的大小为字段的个数。</p><p>当我们执行 setXX 这个方法的时候会调用 setXXIsSet(true) 方法。 来标明这个方法已经赋过值了。<br><code>setXXIsSet(true)</code> 本意就是讲 这个字段对应的BitSet 的位置控制成1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> __NO_ISSET_ID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> BitSet __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(<span class="keyword">short</span> No)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  <span class="keyword">this</span>.No = No;</span><br><span class="line">  setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们还可以判断这个指是否</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __isset_bit_vector.get(__NO_ISSET_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fieldmetadata-结构">FieldMetaData 结构</span></h2><p><code>Thrift</code> 对于每个生成的类会有一个 <code>FieldMetaData</code> 的结构<br>这个类会和 Field 一个名称的枚举类型来对应成一个map结构。<br><code>FieldMetaData</code> 主要是封装了 Field 值的一些元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; metaDataMap;</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">   Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; tmpMap = <span class="keyword">new</span> EnumMap&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt;(_Fields<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   tmpMap.put(_Fields.NO, <span class="keyword">new</span> org.apache.thrift.meta_data.FieldMetaData(<span class="string">"No"</span>, org.apache.thrift.TFieldRequirementType.REQUIRED, </span><br><span class="line">       <span class="keyword">new</span> org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I16)));</span><br><span class="line">   metaDataMap = Collections.unmodifiableMap(tmpMap);</span><br><span class="line">   org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Friends<span class="class">.<span class="keyword">class</span>, <span class="title">metaDataMap</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先我们来看一下meta包下都有哪些字段</p><ul><li>EnumMetaData</li><li>FieldMetaData</li><li>FieldValueMetaData</li><li>ListMetaData</li><li>MapMetaData</li><li>SetMetaData</li><li>StructMetaData</li></ul><h3><span id="继承关系类图">继承关系类图</span></h3><p><img src="/article/java-thrift-3/java-thrift-3-100507.png" alt></p><h3><span id="fieldmetadata">FieldMetaData</span></h3><p>这个数据结构是<code>Friends</code> 用来说明其中涉及<code>Field</code>信息的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMetaData</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String fieldName;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> requirementType;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> FieldValueMetaData valueMetaData;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends TBase&gt;, Map&lt;? extends TFieldIdEnum, FieldMetaData&gt;&gt; structMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所有Meta的映射关系</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    structMap = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends TBase&gt;, Map&lt;? extends TFieldIdEnum, FieldMetaData&gt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FieldMetaData</span><span class="params">(String name, <span class="keyword">byte</span> req, FieldValueMetaData vMetaData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fieldName = name;    <span class="comment">// Field 名字</span></span><br><span class="line">    <span class="keyword">this</span>.requirementType = req; <span class="comment">// 是否是必须的</span></span><br><span class="line">    <span class="keyword">this</span>.valueMetaData = vMetaData;  <span class="comment">// value 字段的元数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// .... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Friends</code> 或 <code>new</code> 一个这个出来，并传入了相应的信息，我们<code>struct</code>的中的<code>required</code> <code>optional</code> 的关键字 就是通过 这个常量类来定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TFieldRequirementType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> REQUIRED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> OPTIONAL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DEFAULT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TFieldRequirementType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="fieldvaluemetadata">FieldValueMetaData</span></h3><p>既然大部分是继承 <code>FieldValueMetaData</code> 那么我们首先来看这个数据结构,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueMetaData</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> type;    <span class="comment">// Field 类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isTypedefType; <span class="comment">// 是否是 Thrift 预定义的类型（TType 预定义的类型）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String typedefName; <span class="comment">// Filed 名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBinary;   <span class="comment">// 是否二进制协议</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="获取filedmetadata">获取FiledMetaData</span></h3><ul><li>全局获取<br>当我们新建好了 FiledMetaData之后可以通过 FiledMetaData 静态类来获取，</li></ul><p><code>FiledMetaData.getStructMetaDataMap(Friends.class)</code></p><ul><li>Friend API获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Friends friends = <span class="keyword">new</span> Friends();</span><br><span class="line">friends.getFieldValue(Friends._Fields.NO);</span><br></pre></td></tr></table></figure><h1><span id="复杂符合类型">复杂符合类型</span></h1><p>我们的 Friends 这是简单定义了 Friends 一个i16的字段No<br>如果我们在Friends 里增加一些复杂类型，Java 文件又是什么情况呢？</p><p>这里还要还有一个问题，我们只是分析了Struct 的生成类，那么Service的生成类是怎样的呢？</p><p>由于篇幅问题，我们这个话题留在下期去讨论。</p><h2><span id="总结">总结</span></h2><p>本节主要是总结了通过struct 文件生成的代码，主要谈论了框架生成的一些特性。更有一些协议层的相关的方法，thrift 的Java 代码非常轻量级，分层也非常明确，那么这些东西将会如何组织，整个的分层又是什么呢？我们下一节在详细论述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（二）</title>
      <link href="/article/java-thrift-2/"/>
      <url>/article/java-thrift-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><a href="https://icefrozen.github.io/article/java-thrift-1/" target="_blank" rel="noopener">前一章节</a>，我们基本入门，了解了 <code>Thrift</code> 的基本用法，这一节继续来分析 <code>Thrift</code> IDL的内容。<br><code>Thrift</code> 采用IDL（<code>Interface Definition Language</code>）来定义通用的服务接口，然后通过 <code>Thrift</code> 提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p><h2><span id="idl定义的规范">IDL定义的规范</span></h2><h2><span id="idl-结构规范">IDL 结构规范</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document   ::= Header* Definition*</span><br><span class="line">Header     ::= Include | CppInclude | Namespace</span><br><span class="line">Definition ::= Const | Typedef | Enum | Senum | Struct | Union | Exception | Service</span><br></pre></td></tr></table></figure><p>IDL的结构分为Header，Definition两个部分。<br>Head 只是的是协议头，主要包含三个关键字</p><ul><li>Include</li><li>CppInclude</li><li>Namespace<br>Thrift IDL 的 Definition为定义部分。</li></ul><h2><span id="idl-语法规范">IDL 语法规范</span></h2><h3><span id="identifier">Identifier</span></h3><p>官方文档中的定义如下：<br><code>Identifier ::= ( Letter | '_' ) ( Letter | Digit | '.' | '_' )*</code></p><p>复制代码即合法的标识符满足以下条件：</p><p>1、标识符只能由字母，数字，<em>（under score）, .（dot）组成<br>2、只能以字母，</em> 开头</p><h2><span id="idl-definition-部分">IDL Definition 部分</span></h2><p>语法组成</p><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## IDL （Field）基本类型</span><br><span class="line">+ 基本类型的语法格式</span><br><span class="line">```java</span><br><span class="line">FieldID? FieldReq? FieldType Identifier (&apos;=&apos; ConstValue)? XsdFieldOptions ListSeparator?</span><br></pre></td></tr></table></figure><h3><span id="fieldid-为类型的展位符号-通常用int">FieldID 为类型的展位符号 通常用int</span></h3><h3><span id="fieldtype">FieldType</span></h3><table><thead><tr><th>关键字</th><th>类型</th><th>对应Java中的类型</th></tr></thead><tbody><tr><td>bool</td><td>布尔值</td><td>对应Java中的boolean</td></tr><tr><td>byte</td><td>有符号字节</td><td>对应Java中的byte</td></tr><tr><td>i16</td><td>16位有符号整型</td><td>对应Java中的short</td></tr><tr><td>i32</td><td>32位有符号整型</td><td>对应Java中的int</td></tr><tr><td>i64</td><td>64位有符号整型</td><td>对应Java中的long</td></tr><tr><td>double</td><td>64位浮点型</td><td>对应Java中的double</td></tr><tr><td>string</td><td>字符串</td><td>对应Java中的String</td></tr><tr><td>binary</td><td>Blob 类型</td><td>对应Java中的byte[]</td></tr><tr><td>slist</td><td></td><td></td></tr></tbody></table><blockquote><p>可以是基础类型，容器类型或者合法标识符，这里的合法标识符就是下文中通过 typedef, enum, struct 等关键中声明的类型。</p></blockquote><h3><span id="filedreq">FiledReq</span></h3><ul><li><p><strong>required</strong>:</p><ol><li>写：必须字段始终写入，并且应该设置这些字段。</li><li>读：必须字段始终读取，并且它们将包含在输入流中</li><li>默认值：始终写入</li></ol><blockquote><p>注意：如果一个必须字段在读的时候丢失，则会抛出异常或返回错误，所以在版本控制的时候，要严格控制字段的必选和可选，必须字段如果被删或者改为可选，那将会造成版本不兼容。</p></blockquote></li><li><p><strong>optional</strong>:<br>1、写：可选字段仅在设置时写入<br>2、读：可选字段可能是也可能不是输入流的一部分<br>3、默认值：在设置了isset标志时写入</p><blockquote><p>Thrift使用所谓的“isset”标志来指示是否设置了特定的可选字段， 仅设置了此标志的字段会写入，相反，仅在从输入流中读取字段值时才设置该标志。</p></blockquote></li><li><p><strong>default</strong>:<br>1、写：理论上总是写入，但是有一些特例<br>2、读：跟optional一样<br>3、默认值：可能不会写入</p><blockquote><p>默认类型是required和optional的结合，可选输入（读），必须输出（写）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 例子</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    1: required string name,         </span><br><span class="line">    2: required i16 age = 0;</span><br></pre></td></tr></table></figure></p></blockquote></li></ul><h2><span id="container-容器">Container (容器)</span></h2><h3><span id="有3种可用容器类型">有3种可用容器类型：</span></h3><ul><li><p><strong>list<t></t></strong>: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或者其他语言的数组</p></li><li><p><strong>set<t></t></strong>: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了</p></li><li><p><strong>map&lt;t, t&gt;</strong>: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary</p></li></ul><h3><span id="例子">例子：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>: required list&lt;User&gt; friends,</span><br><span class="line"><span class="number">8</span>: optional map&lt;i32, User&gt; mapUser;</span><br><span class="line"><span class="number">9</span>: optional set&lt;User&gt; setUser;</span><br></pre></td></tr></table></figure><h2><span id="struct结构体">struct结构体</span></h2><h3><span id="struct语法">struct语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct     ::= <span class="string">'struct'</span> Identifier <span class="string">'xsd_all'</span>? <span class="string">'&#123;'</span> Field* <span class="string">'&#125;'</span></span><br><span class="line">Field      ::=  FieldID? FieldReq? <span class="function">FieldType <span class="title">Identifier</span> <span class="params">(<span class="string">'='</span> ConstValue)</span>? XsdFieldOptions ListSeparator?</span></span><br><span class="line"><span class="function">FieldID    ::</span>=  IntConstant <span class="string">':'</span></span><br><span class="line">FieldReq   ::=  <span class="string">'required'</span> | <span class="string">'optional'</span></span><br></pre></td></tr></table></figure><blockquote><p>xsd_all 是 Facebook 内部的字段，直接忽略，就算你写了，也不会有啥影响 Field 中的 XsdFeildOptions 也是 Facebook 内部字段，直接忽略</p></blockquote><p>从语法定义看，一个 Struct 定义的核心是 <code>Field</code> 字段，而且每个字段的名字在一个 <code>Struct</code> <code>内要确保是唯一的，Struct</code> 不能继承，但是可以嵌套使用，即可以作为 <code>struct</code> 字段的类型。<br>接下来就仔细看下 <code>Field</code> 的定义，一个合法的 <code>Field</code> 只需要哟 <code>FieldType</code> 和对应的 <code>Identifier</code> 就可以了，但是通常我们都会加上 <code>FieldId</code> 和 <code>ListSeparator</code>, 而 FieldReq 则视情况而定。<br><code>FieldId</code> 必须是整型常量加 : 组成。</p><h3><span id="struct约束">struct约束：</span></h3><ol><li>struct不能继承，但是可以嵌套，不能嵌套自己。</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li><li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li><li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li><li>每个字段可以设置默认值</li><li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li></ol><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Friends &#123;</span><br><span class="line">    <span class="number">1</span>: required i32 No,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    <span class="number">1</span>: required string name,         </span><br><span class="line">    <span class="number">2</span>: required i16 age = <span class="number">0</span>;            </span><br><span class="line">    <span class="number">3</span>: required bool gender,</span><br><span class="line">    <span class="number">4</span>: required i32 No,</span><br><span class="line">    <span class="number">5</span>: required i64 createTime,</span><br><span class="line">    <span class="number">6</span>: required <span class="keyword">double</span> grade,</span><br><span class="line">    <span class="number">7</span>: required list&lt;Friends&gt; friends,</span><br><span class="line">    <span class="number">8</span>: optional map&lt;i32, Friends&gt; mapUser;</span><br><span class="line">    <span class="number">9</span>: optional set&lt;Friends&gt; setUser;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="union">Union</span></h2><h3><span id="语法格式">语法格式</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Union` 语法定义除了关键字不一样外，基本与 `Struct` 相同，只不过语义上是有很大差别的，`Union` 可以定义这样一个结构体，结构体中的字段只要有要给被赋予合法值，就可以被 thrift 传输，而且 `Union` 结构中的字段默认就是 `optional` 的，不能使用 `required` 声明，写了也没意义，其语法定义如下：</span><br><span class="line"></span><br><span class="line">可以想象这么一个场景，我们收集用户的信息，只要用户填写了手机号或者邮箱中的一个就可以了，这时候我们就可以使用 `Union` 结构来标识这个类型</span><br><span class="line">```java</span><br><span class="line">union UserInfo &#123;</span><br><span class="line">  1: string phone,</span><br><span class="line">  2: string email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="常量类型">常量类型</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Const          ::= <span class="string">'const'</span> FieldType Identifier <span class="string">'='</span> ConstValue ListSeparator?</span><br><span class="line">ConstValue     ::= IntConstant | DoubleConstant | Literal | Identifier | ConstList | ConstMap</span><br><span class="line">IntConstant    ::= (<span class="string">'+'</span> | <span class="string">'-'</span>)? Digit+</span><br><span class="line">DoubleConstant ::= (<span class="string">'+'</span> | <span class="string">'-'</span>)? Digit* (<span class="string">'.'</span> Digit+)? ( (<span class="string">'E'</span> | <span class="string">'e'</span>) IntConstant )?</span><br><span class="line">ConstList      ::= <span class="string">'['</span> (ConstValue ListSeparator?)* <span class="string">']'</span></span><br><span class="line">ConstMap       ::= <span class="string">'&#123;'</span> (ConstValue <span class="string">':'</span> ConstValue ListSeparator?)* <span class="string">'&#125;'</span></span><br><span class="line">ListSeparator  ::= <span class="string">','</span> | <span class="string">';'</span></span><br></pre></td></tr></table></figure><h3><span id="例子">例子</span></h3><p>先说明下 <code>ListSeparator</code>, 这个分隔符就好比 Java 中一句话结束后的 ;，在 IDL 中分隔符可以是 , 或者 ; 而且大部分情况下可以忽略不写</p><p>IDL 中通过 const 关键字进行声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string testConst = <span class="string">'hello,thrift'</span>; <span class="comment">// `;` 可以替换为 `,` 也可以不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制代码常量声明语句中 = 后面的内容就是常量值，IDL 中的合法常量值如下：</span></span><br><span class="line"><span class="comment">// int 类型常量，和 js 中的 number 字面量是一个意思</span></span><br><span class="line"><span class="keyword">const</span> i8 count = <span class="number">100</span>  <span class="comment">// 可以是正数，负数（如：-2）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doubule 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> money = <span class="string">'13.14'</span>   <span class="comment">// 同样可正可负</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> rate = <span class="number">1.2e-5</span>     <span class="comment">// 可以使用科学计数法，表示 0.000012</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> salary = <span class="number">3.5e8</span>    <span class="comment">// 表示 350000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 list, 类似 js 中的数组字面量</span></span><br><span class="line"><span class="keyword">const</span> list&lt;string&gt; names = [ <span class="string">'tom'</span>, <span class="string">'joney'</span>, <span class="string">'catiy'</span> ]  <span class="comment">// 当然 `,` 可以替换成 ';', 也可以不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 map, 类似 js 中的对象字面量</span></span><br><span class="line"><span class="keyword">const</span> map&lt;string, string&gt; = &#123; <span class="string">'name'</span>: <span class="string">'johnson'</span>, <span class="string">'age'</span>: <span class="string">'20'</span> &#125;</span><br></pre></td></tr></table></figure><h2><span id="异常类型">异常类型</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">Exception 语法定义与 Struct 相似，但是这个类型通常适合目标语言的异常处理机制配合使用的</span><br><span class="line">```java</span><br><span class="line">exception Error &#123;</span><br><span class="line">  1: required i8 Code,</span><br><span class="line">  2: string Msg,</span><br><span class="line">&#125;</span><br><span class="line">service ExampleService &#123;</span><br><span class="line">  string GetName() throws (1: Error err),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="枚举类型">枚举类型</span></h2><h3><span id="语法">语法：</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">```java</span><br><span class="line">enum fb_status &#123;</span><br><span class="line">  DEAD = 0,</span><br><span class="line">  STARTING = 1,</span><br><span class="line">  ALIVE = 2,</span><br><span class="line">  STOPPING = 3,</span><br><span class="line">  STOPPED = 4,</span><br><span class="line">  WARNING = 5,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码从语法定义来看，(’=’ IntConstant)? 是一个可选项，也就是说我们可以不用指定值，默认就是从 0 开始递增，如果要指定，那就必须是一个整型常量，如果后续没有再指定，则从第一个指定的整型值开始进行递增. 所以上述示例中的枚举值，也可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> fb_status &#123;</span><br><span class="line">  DEAD,</span><br><span class="line">  STARTING,</span><br><span class="line">  ALIVE,</span><br><span class="line">  STOPPING,</span><br><span class="line">  STOPPED,</span><br><span class="line">  WARNING,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="typedef">Typedef</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">```java</span><br><span class="line">typedef i8 int8  // 这里把 i8 去个别名 int8, 在后面的定义中就可以使用了</span><br><span class="line">const int8 count = 100 // 等价于 const i8 count = 100</span><br></pre></td></tr></table></figure><h2><span id="services类型">Services类型</span></h2><h3><span id="语法">语法</span></h3><p>上面的小节中介绍的所有内容都是用来服务 <code>Service</code> <code>的，Service</code> 提供了我们要暴露的接口，而且，<code>Service</code> 是可以被继承的，<code>Service A</code>继承了 <code>Service B</code>, A 除了提供自己定义的接口外，他还提供了从 B 继承来的接口。语法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service      ::= <span class="string">'service'</span> Identifier ( <span class="string">'extends'</span> Identifier )? <span class="string">'&#123;'</span> Function* <span class="string">'&#125;'</span></span><br><span class="line">Function     ::= <span class="string">'oneway'</span>? FunctionType Identifier <span class="string">'('</span> Field* <span class="string">')'</span> Throws? ListSeparator?</span><br><span class="line">FunctionType ::= FieldType | <span class="string">'void'</span></span><br><span class="line">Throws       ::= <span class="string">'throws'</span> <span class="string">'('</span> Field* <span class="string">')'</span></span><br></pre></td></tr></table></figure><p>复制代码从语法定义，我们可以看到 Service 的核心就是 <code>Function</code> 的定义</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service ExampleService &#123;</span><br><span class="line">  <span class="function">oneway <span class="keyword">void</span> <span class="title">GetName</span><span class="params">(<span class="number">1</span>: string UserId)</span>,</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">GetAge</span><span class="params">(<span class="number">1</span>: string UserId)</span> <span class="title">throws</span> <span class="params">(<span class="number">1</span>: Error err)</span>,</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><code>oneway</code> 是一个关键字，从字面上，我们就可以了解到，他是单向的，怎么理解呢？非 <code>oneway</code> 修饰的 function 是应答式，即 <code>req-resp</code>, 客户端发请求，服务端返回响应，被 <code>oneway</code> 修饰后的函数，则意味着，客户端只是会发起，无须关注返回，服务端也不会响应，与 <code>void</code> 的区别是 <code>void</code> 类型的方法还可以返回异常。<br><code>FunctionType</code> 是任何合法的 <code>FieldType</code> 或者 <code>void</code> 关键字，表示无返回类型<br><code>Throws</code> 顾名思义，参考上述示例即可。</p><h2><span id="idl-head-部分">IDL Head 部分</span></h2><p>从语法定义看，Header 可以是 <code>Include</code>, <code>CppInclude</code>, <code>Namespace</code>, 接下来，我们依次进行介绍。</p><h2><span id="include-语法定义">Include 语法定义</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">复制代码从语法规则上看，Include 由 include 关键字 + thrift 文件路径组成。</span><br><span class="line">在真正的业务开发中，我们不可能把所有的服务都定义到一个文件中，通常会根据业务模块进行拆分，然后将这些服务 include 到一个入口文件中，然后在最终服务发布上线的时候，thrift 编译器只需要编译入口文件，就能将所有引入的文件都生成对应的代码，而且 include 进来的文件中定义的内容都是可见的</span><br><span class="line"></span><br><span class="line">### 例子</span><br><span class="line">+ base.thrift</span><br><span class="line">```java</span><br><span class="line">namespace go base</span><br><span class="line"></span><br><span class="line">struct Base &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>example.thrift</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">'base.thrift'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时，我们就可以引用从 base.thrift 导入的内容了</span></span><br><span class="line">struct Example &#123;</span><br><span class="line">  <span class="number">1</span>: base.Base ExampleBase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="cppinclude">CppInclude</span></h2><h3><span id="语法">语法</span></h3><p>复制代码CppInclude 语法定义<br>CppInclude ::= ‘cpp_include’ Literal<br>复制代码CppInclude 主要是用来为当前的 thrift 文件生成的代码中添加一个自定义的 C++ 引入声明 目前没有使用场景，不做过多陈述</p><h3><span id="namespace">Namespace</span></h3><h3><span id="语法">语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Namespace ::= ( <span class="string">'namespace'</span> ( NamespaceScope Identifier ) )</span><br><span class="line">NamespaceScope  ::=  <span class="string">'*'</span> | <span class="string">'c_glib'</span> | <span class="string">'cpp'</span> | <span class="string">'csharp'</span> | <span class="string">'delphi'</span> | <span class="string">'go'</span> | <span class="string">'java'</span> | <span class="string">'js'</span> | <span class="string">'lua'</span> | <span class="string">'netcore'</span> | <span class="string">'perl'</span> | <span class="string">'php'</span> | <span class="string">'py'</span> | <span class="string">'py.twisted'</span> | <span class="string">'rb'</span> | <span class="string">'st'</span> | <span class="string">'xsd'</span></span><br></pre></td></tr></table></figure><p>复制代码 <code>Namespace</code> 用来声明使用哪种语言来处理当前 <code>thrift</code> <code>文件中定义的各种类型，NamespaceScope</code> 就是各种语言的标识，也可以指定为通配符 * 标识，标识 thrift 文件中的定义适用于所有的语言。除此之外 Namespace 还有一个作用就是避免不同 <code>Identifier</code> 定义的命名冲突。</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace java com.facebook.fb303</span><br></pre></td></tr></table></figure><p>上述示例中 <code>Namespace</code> 声明语句，标识当前的 thrift 文件适用于 java<br>NamespaceScope 后面紧跟着的 Identifier 在不同语言中会有不一样的表现.</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/u011642663/article/details/56015576" target="_blank" rel="noopener">Thrift IDL基本语法</a></li><li><a href="https://juejin.im/post/5de8e38ef265da33d7441913" target="_blank" rel="noopener">Thrift &amp; IDL 介绍</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（一）</title>
      <link href="/article/java-thrift-1/"/>
      <url>/article/java-thrift-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="thrift-简介">Thrift 简介</span></h2><p>Thrift是一个轻量级、跨语言的远程服务调用框架，最初由Facebook开发，后面进入Apache开源项目。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端/客户端模板代码。<br>Thrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等，本系列主要讲述基于Java语言的Thrift的配置方式和具体使用。</p><p>Thrift的主要特点有：</p><ol><li>基于二进制的高性能的编解码框架</li><li>基于NIO的底层通信</li><li>相对简单的服务调用模型</li><li>使用IDL支持跨平台调用</li></ol><h2><span id="thrift-安装">Thrift 安装</span></h2><p>具体的安装不做介绍，可以去官网查询，本系列主要使用的是0.8.0， 截止到目前，最新版本是0.13.0， 由于目前就职的公司普遍使用的是0.8.0，则就以这个为准，后边会单独开一片0.8.0和0.13.0的区别。</p><h2><span id="thrift-设计">Thrift 设计</span></h2><h2><span id="设计架构">设计架构</span></h2><div align="center"><p><img src="/article/java-thrift-1/java-thrift-1-112101.png" alt></p></div><p>Thrift软件栈分层从下向上分别为：</p><ul><li><p><strong>传输层(Transport Layer)</strong>：传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议；比如说TCP/IP传输等。</p></li><li><p><strong>协议层(Protocol Layer)</strong>：协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化；比如说JSON、XML、二进制数据等。</p></li><li><p><strong>处理层(Processor Layer)</strong>：处理层是由具体的IDL（接口描述语言）生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的Handler进行处理。</p></li><li><p><strong>服务层(Server Layer)</strong>：整合上述组件，提供具体的网络线程/IO服务模型，形成最终的服务。</p></li></ul><h2><span id="特性">特性</span></h2><h3><span id="一-开发速度快">(一) 开发速度快</span></h3><p>通过编写RPC接口<strong>Thrift IDL</strong>文件，利用编译生成器自动生成服务端骨架(<code>Skeletons</code>)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p><p>服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(<code>Handler</code>)即实现类即可。<br>客户端：只需要拷贝IDL定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。</p><h3><span id="二-接口维护简单">(二) 接口维护简单</span></h3><p>通过维护<code>Thrift格</code>式的IDL（接口描述语言）文件（注意写好注释），即可作为给Client使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且Thrift协议可灵活支持接口的可扩展性。</p><h3><span id="三-学习成本低">(三) 学习成本低</span></h3><p>因为其来自Google Protobuf开发团队，所以其IDL文件风格类似Google Protobuf，且更加易读易懂；特别是RPC服务接口的风格就像写一个面向对象的Class一样简单。<br>初学者只需参照：<a href="thrift.apache.org"></a>，一个多小时就可以理解Thrift IDL文件的语法使用。</p><h3><span id="四-多语言跨语言支持">(四) 多语言/跨语言支持</span></h3><p>Thrift支持<code>C++、 Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk</code>等多种语言，即可生成上述语言的服务器端和客户端程序。<br>对于我们经常使用的<code>Java、PHP、Python、C++</code>支持良好。</p><h3><span id="五-稳定广泛使用">(五) 稳定/广泛使用</span></h3><p>Thrift在很多开源项目中已经被验证是稳定和高效的，例如<code>Cassandra、Hadoop、HBase</code>等；国外在Facebook中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><h2><span id="thrift-快速入门">Thrift 快速入门</span></h2><h3><span id="项目包路径">项目包路径</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com.thrift</span><br><span class="line">    |- client</span><br><span class="line">        |- client.java          <span class="comment">//主要存放 client的代码</span></span><br><span class="line">    |- constant</span><br><span class="line">        | - ServerConfig.java  <span class="comment">// 主要存放服务器配置等关键信息</span></span><br><span class="line">    |- idl</span><br><span class="line">        |- hello.thrift         <span class="comment">// IDL描述文件</span></span><br><span class="line">    |- idlcode</span><br><span class="line">        | - HelloWorldService.java <span class="comment">// 主要存放根据IDL自动生成的文件</span></span><br><span class="line">    | -server   </span><br><span class="line">        |- handler              <span class="comment">// rpc 接口的具体实现</span></span><br><span class="line">            |- HelloWorldServiceImpl.java</span><br><span class="line">        server.java             <span class="comment">// 服务器测试代码</span></span><br><span class="line">    gen_code.sh                 <span class="comment">// IDL生成命令</span></span><br></pre></td></tr></table></figure><h3><span id="具体实现">具体实现</span></h3><ul><li>（1） 编写IDL 文件,命名为 <code>hello.thrift</code>放到<code>com.thrift.idl</code> 这个包名下。如果需要提示，在Idea上安装 <code>Thrift</code> 编辑插件，具体可以搜索 <code>ThirftSupport</code> 这个插件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  string say(<span class="number">1</span>: string username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 运行gen_code.sh 用于生成 <code>thrift</code> 的各种代码块。<br>我们来看一下 gen_code.sh 的代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">path_root=`<span class="built_in">pwd</span>`</span><br><span class="line">idlDir=<span class="variable">$path_root</span>/idl</span><br><span class="line">idlCode=<span class="variable">$path_root</span>/idlCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> `ls <span class="variable">$idlDir</span>/*.thrift`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   thrift --gen java -out <span class="variable">$idlCode</span> <span class="variable">$f</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行完成或，我们会在 <code>idlcode</code> 生成一个<code>HelloWorldService.java</code> 文件，这个就是上文中服务器和客户端交互的核心代码。</p><p>我们来简单看一下这个java文件的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 同步接口定义</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步接口定义</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncIface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.say_call&gt; resultHandler)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 客户端</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TServiceClient</span> <span class="keyword">implements</span> <span class="title">Iface</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">  <span class="comment">// 异步客户端</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncClient</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">async</span>.<span class="title">TAsyncClient</span> <span class="keyword">implements</span> <span class="title">AsyncIface</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">  <span class="comment">// Processor 组件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span>&lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">Iface</span>&gt; <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBaseProcessor</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TProcessor</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">say_args</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">say_args</span>, <span class="title">say_args</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">say_result</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">say_result</span>, <span class="title">say_result</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span>  </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于开发人员而言，使用原生的Thrift框架，仅需要关注以下四个核心内部接口/类：<code>Iface, AsyncIface, Client和AsyncClient</code>。</p><ul><li>Iface：服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的同步业务逻辑。</li><li>AsyncIface：服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的异步业务逻辑。</li><li>Client：客户端通过HelloWorldService.Client的实例对象，以同步的方式访问服务端提供的服务方法。</li><li>AsyncClient：客户端通过HelloWorldService.AsyncClient的实例对象，以异步的方式访问服务端提供的服务方法。</li></ul><p>这里的结构不做详细分析，等到下一章节在做分析。</p><ul><li>（3） 安装thrift插件，我这里用的是0.8.0版本，所以在pom.xml 文件添加如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(4) 编写RPC的实现类<br>首先 我们要对 <code>HelloWorldService</code> 服务做实现，也就是我们要提供更多具体的RPC 方法<br>在 <code>server.handler</code> 包下创建 <code>HelloWorldServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello ==&gt; "</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（5） 编写服务器代码</li><li>Thrift的服务端类型<ol><li><strong>TSimpleServer</strong> ：单线程服务器端，使用标准的阻塞式I/O</li><li><strong>TThreadPoolServer</strong> ：多线程服务器端，使用标准的阻塞式I/O</li><li><strong>TNonblockingServer</strong> ：单线程服务器端，使用非阻塞式I/O</li><li><strong>THsHaServer</strong> ：半同步半异步服务器端，基于非阻塞式IO读写和多线程工作任务处理</li><li><strong>TThreadedSelectorServer</strong> ：多线程选择器服务器端，对THsHaServer在异步IO模型上进行增强</li></ol></li></ul><p>这里我们使用<code>TSimpleServer</code>，在 server包下新建 <code>server.java</code>以及定义 <code>ServerConfig</code> 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SimpleServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleServer</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">        <span class="comment">// 转换层</span></span><br><span class="line">        TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(serverSocket);</span><br><span class="line">        <span class="comment">// processor 层</span></span><br><span class="line">        HelloWorldService.Processor processor =</span><br><span class="line">                <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line">        <span class="comment">// 协议工厂</span></span><br><span class="line">        TBinaryProtocol.Factory protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">        TSimpleServer.Args tArgs = <span class="keyword">new</span> TSimpleServer.Args(serverTransport);</span><br><span class="line">        tArgs.processor(processor);</span><br><span class="line">        tArgs.protocolFactory(protocolFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的单线程服务模型 一般用于测试</span></span><br><span class="line">        TServer tServer = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">        System.out.println(<span class="string">"Running Simple Server"</span>);</span><br><span class="line">        tServer.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerConfig.java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">9988</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（6） client 代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport = <span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);</span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line">            String result = client.say(<span class="string">"Leo"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(7) 运行server<br>server控制台输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Running Simple Server</span><br></pre></td></tr></table></figure><p>client 输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result =: hello ==&gt; Leo</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>Thrift是一个RPC框架，内部实现的机制和概念还有很多，更重要的留下几个问题。、<br>1、Thrift如何做服务发现？ 这个留着下次再分析。<br>2、生成的java文件起着什么样的作用。<br>3、Rpc的流程是什么。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5b290dbf6fb9a00e5c5f7aaa" target="_blank" rel="noopener">Apache Thrift系列详解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(3)</title>
      <link href="/article/java-AQS3-read-write-lock/"/>
      <url>/article/java-AQS3-read-write-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="基础">基础</span></h2><p>所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为 如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。</p><h2><span id="样例">样例</span></h2><p>我们来看一段例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock rwl=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">double</span> data=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">readClass</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">readClass</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        System.out.println(i + <span class="string">" --&gt;读数据："</span>+data);</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">writeClass</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">writeClass</span><span class="params">(<span class="keyword">double</span> i)</span> </span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      data=i;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"写数据： "</span>+data);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sleep: ..."</span>);</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.printf(<span class="string">"wake up ... "</span>);</span><br><span class="line">      rwl.writeLock().unlock();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        readClass readClass = <span class="keyword">new</span> readClass(i);</span><br><span class="line">        callList.add(readClass);</span><br><span class="line">    &#125;</span><br><span class="line">    callList.add(<span class="keyword">new</span> writeClass(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      readClass readClass = <span class="keyword">new</span> readClass(i);</span><br><span class="line">      callList.add(readClass);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futures = executor.invokeAll(callList);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 --&gt;读数据：0.0</span><br><span class="line">2 --&gt;读数据：0.0</span><br><span class="line">0 --&gt;读数据：0.0</span><br><span class="line">4 --&gt;读数据：0.0</span><br><span class="line">3 --&gt;读数据：0.0</span><br><span class="line">6 --&gt;读数据：0.0</span><br><span class="line">5 --&gt;读数据：0.0</span><br><span class="line">7 --&gt;读数据：0.0</span><br><span class="line">8 --&gt;读数据：0.0</span><br><span class="line">9 --&gt;读数据：0.0</span><br><span class="line">写数据： 10.0</span><br><span class="line">sleep: ...wake up ... 10 --&gt;读数据：10.0</span><br><span class="line">11 --&gt;读数据：10.0</span><br><span class="line">12 --&gt;读数据：10.0</span><br><span class="line">13 --&gt;读数据：10.0</span><br><span class="line">14 --&gt;读数据：10.0</span><br><span class="line">15 --&gt;读数据：10.0</span><br><span class="line">17 --&gt;读数据：10.0</span><br><span class="line">19 --&gt;读数据：10.0</span><br><span class="line">16 --&gt;读数据：10.0</span><br><span class="line">18 --&gt;读数据：10.0</span><br></pre></td></tr></table></figure><p>结论，我们可以看到，<br>读写锁互斥的，当有写锁锁住资源的时候，无法进行读取，同理，当有数据加了读锁，无法进行写入。</p><h2><span id="源码分析">源码分析</span></h2><h2><span id="类图">类图</span></h2><ul><li><p>看一下<code>ReentrantReadWriteLock</code>的继承类图， 我们可以发现</p><p><img src="/article/java-AQS3-read-write-lock/1569557796298java-read-write-lock_.png" alt></p></li></ul><p><code>ReentrantReadWriteLock</code>类继承了读写锁 <code>ReadWriteLock</code> 的接口,来看一下这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们来看整体的类图</li></ul><p><img src="/article/java-AQS3-read-write-lock/1569586591335java-read-write-lock_.png" alt></p><p><code>ReentrantReadWriteLock</code>  中有个 <code>Sync</code> 对象<br>其中有两把锁分别是 <code>ReadLock</code> 和  <code>WriterLock</code> 两个内部类<br>这两个内部类当中有个 <code>Sync</code> 的对象这个对象<br>而这个 <code>Sync</code> 的对象和 <code>ReentrantReadWriteLock</code> Sync对象是同一个对象<br>而这个 <code>Sync</code> 这个对象正式 <code>FairSync</code> 公平 <code>NonfairSync</code> 的抽象类<br>其中 <code>FairSync</code> 和  <code>NonfairSync</code> 都有各自的实现，下文会分析。</p><ul><li>锁之间的关系</li></ul><ol><li><p><code>writeLock</code> 是排他的 <code>exclusive</code>, <code>readLock</code> 是共享的 <code>sahred</code></p></li><li><p>同一个线程可以拥有 <code>writeLock</code> 与 <code>readLock</code> (但必须先获取 <code>writeLock</code> 再获取 <code>readLock</code>, 反过来进行获取会导致死锁)<code>writeLock</code> 与 <code>readLock</code> 是互斥的(就像 <code>Mysql</code> 的 <code>X S</code> 锁)。（死锁的问题后面会具体分析）</p></li><li><p>在获取 <code>writeLock</code> 时监测到现在有线程获取 <code>readLock</code> , 锁一会一直在 aqs 的 <code>sync queue</code> 里面进行等待), 而此时其他的线程想获取 <code>writeLock</code> 也会一直 <code>block</code>, 而若获取 <code>readLock</code> 若这个线程以前获取过 <code>readLock</code>, 则还能继续 重入 (reentrant), 而没有获取 <code>readLock</code> 的线程因为 <code>aqs syn queue</code> 里面有获取 <code>writeLock</code> 的 <code>Node</code> 节点存在会存放在 <code>aqs syn queue</code> 队列里面 一直 <code>block</code></p></li><li><p>结论如下：<br>如果线程想要获取<code>readLock</code>,并且成功获取，那么前提是aqs队列中没有<code>writeLock</code>, 如果线程想要获取<code>writeLock</code>,并且成功获取，那么前提是aqs队列中没有<code>readLock</code>,</p></li></ol><h2><span id="reentrantreadwritelock">ReentrantReadWriteLock</span></h2><h2><span id="reentrantreadwritelock-构造方法">ReentrantReadWriteLock 构造方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里创建了两把锁，一把交读锁，一把写锁，并且将AQS队列传了减去<br>不了解AQS队列的可以参考<a href="https://icefrozen.github.io/article/java-AQS/" target="_blank" rel="noopener">JAVA多线程之AQS分析(1)</a>,<a href="https://icefrozen.github.io/article/Java-AQS2/" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)</a></p><h2><span id="sync-类">Sync 类</span></h2><p><code>ReentrantReadWriterLock</code> 同样使用自己的内部类 <code>Sync</code>（继承 <code>AbstractQueuedSynchronizer</code> ）实现CLH算法。<br>为了方便对读写锁获取机制的了解，先介绍一下Sync内部类中几个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);      <span class="comment">// 000000000 00000001 00000000 00000000</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  <span class="comment">// 000000000 00000000 11111111 11111111</span></span><br><span class="line">  <span class="comment">//表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 计算 readLock 的获取次数(包含 reentrant 的次数) */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>       </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">// 将字节向右移动 16位, 只剩下 原来的 高 16 位</span></span><br><span class="line"><span class="comment">/** 计算 writeLock 的获取的次数(包括 reentrant的次数) */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">// 与 EXCLUSIVE_MASK 与一下</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>ReentrantReadWriterLock</code>使用一个32位的int类型来表示锁被占用的线程数（<code>status</code> 这个字段在<code>ReentrantLock</code>中代表同一个线程的加锁次数，采取的办法是，高16位用来表示<strong>读锁占有的线程数量</strong>，用低16位表示<strong>写锁被同一个线程申请的次数</strong>。这里留一个疑问，<strong>就是为什么要保存同一个线程的申请次数</strong></li></ul><h3><span id="sync-状态静态变量的含义">Sync 状态(静态变量的含义)</span></h3><ul><li><p><code>Status</code><br>这个是是在AQS的类中定义的，并没有在<code>ReentrantReadWriteLock</code> 类的Sync单独实现，这个状态表示了当前锁的状态，而如何表示当前锁的状态就是 Sync中的其他字段类共同组成的。</p></li><li><p><code>SHARED_SHIFT</code>:</p><p>对32位的 int 进行分割 (对半 16)<code>SHARED_SHIFT</code>，表示读锁占用的位数，常量16 也就是对上文的status字段表示分割</p></li><li><p><code>SHARED_UNIT</code></p><p>如果增加一个读锁，按照上述设计，就相当于增加 <code>SHARED_UNIT</code>  其中的值为 <code>000000000 00000001 00000000 00000000</code><br>我们可以看到他的含义就是 将int的高16位作为一个单元，然后在这个单元上加上这个单元的1</p></li><li><p><code>MAX_COUNT</code></p><p>MAX_COUNT，表示申请读锁最大的线程数量，为65535 。 <code>000000000 00000000 11111111 11111111</code></p></li><li><p><code>EXCLUSIVE_MASK</code></p><p>表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</p></li><li><p>举例说明</p><blockquote><p>现在当前，申请读锁的线程数为13个，写锁一个，那<code>state</code>怎么表示？<br>用一个32位的int类型的高16位表示读锁线程数，13的二进制为 <code>1101</code>,那<code>state</code>的二进制表示为<code>00000000 00001101 00000000 00000001</code>十进制数为 <code>851969，</code>  接下来要得到读锁和写锁的数量的时候，需要根据这个851968这个值得出上文中的 13 与 1。要算成13，只需要将state 无符号向左移位16位置，得出00000000 00001101，就出13，根据851969要算成低16位置，只需要用该00000000 00001101 00000000 00000001 &amp; 111111111111111（15位），就可以得出00000001,就是利用了1&amp;1得1,1&amp;0得0这个技巧。</p></blockquote></li></ul><h2><span id="readlock">ReadLock</span></h2><p>我们来看一下读锁的源码</p><h4><span id="核心代码">核心代码</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">      sync = lock.sync;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.acquireShared(<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;sync.releaseShared(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="加锁的方法为获取">加锁的方法为获取</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync 的获取共享锁的方法   ReadSy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireShared(arg);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 这里表示 是否有写锁在，如果有且不是当前线程， 则加锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 获得当前线程</span></span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获得读锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 这里表示 读锁是否应该阻塞 这里的方法是根据 公平和非公平的锁来实现的</span></span><br><span class="line">    <span class="comment">// 公平锁 是直接调用 hasQueuedPredecessors() </span></span><br><span class="line">    <span class="comment">// 非公平锁 直接调用的是  apparentlyFirstQueuedIsExclusive(); 方法</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        <span class="comment">// 读锁的数量 + 1</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 加锁之前 没有读锁 本线程是第一个</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录第一个读锁的线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁 再次重入，那么读锁可重入的数量 ++</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的条件路径都失败，那么会继续调用fullTryAcquireShared方法。  </span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这段代码有几个问题：</p><ul><li>第一，为什么要记录第一把读锁 <code>firstReader</code> ？</li><li>第二 <code>cachedHoldCounter</code> 是干什么用的？</li><li>第三，排队的阻塞策略是什么？</li><li>第四， <code>fullTryAcquireShared</code> 这个方法是干什么用的，为什么保底要执行这个方法？</li><li>第五，加锁之前为什么要 <code>tryAcquireShared</code> 为什么不能直接加锁么，之后 <code>doAcquireShared</code> 方法是做什么，为什么要有这一步？</li></ul><p>带着这几个问题，我们往下看</p><h3><span id="readholds-类cachedholdcounter-作用">readHolds 类（cachedHoldCounter 作用）</span></h3><ul><li>首先来解决第二个问题 <code>cachedHoldCounter</code> 是干什么用的？<br>在Sync类当中有这么几个参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br></pre></td></tr></table></figure><p>读写锁是要给多个线程调用的，也就是说，多个线程会同事操作同一个对象，每个线程如果读锁重入，就要记住没个线程对应重入了多少读锁。<br><code>HoldCounter</code> 相当于一个计数器。一次共享锁的操作就相当于在该计数器的操作。获取共享锁，则该计数器 + 1，释放共享锁，该计数器 - 1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。<br>所以 <code>HoldCounter</code> 的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p><p><code>HoldCounter</code> 定义非常简单，就是一个计数器 <code>count</code> 和线程 <code>tid</code>两个变量。按照这个意思我们看到 <code>HoldCounter</code> 是需要和某给线程进行绑定了，我们知道如果要将一个对象和线程绑定仅仅有 <code>tid</code> 是不够的，而且从上面的代码我们可以看到 <code>HoldCounter</code> 仅仅只是记录了tid，根本起不到绑定线程的作用。那么怎么实现呢？答案是 <code>ThreadLocal</code>， 定义如下：</p><p><code>ThradLocalHoldCounter</code> 继承了<code>ThreadLocal</code>, 将 <code>HoldCounter</code> 绑定到当前线程上，同时 <code>HoldCounter</code> 也持有线程Id，这样在释放锁的时候才能知道 <code>ReadWriteLock</code> 里面缓存的上一个读取线程（<code>cachedHoldCounter</code>） 是否是当前线程。这样做的好处是可以减少 <code>ThreadLocal.get()</code>的次数，因为这也是一个耗时操作。需要说明的是这样 <code>HoldCounter</code> 绑定线程id而不绑定线程对象的原因是避免<code>HoldCounter</code> 和 <code>ThreadLocal</code>互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p><ul><li>第一，为什么要记录第一把读锁 <code>firstReader</code> ？<br>其实这个很好理解，有了上面 <code>cachedHoldCounter</code> 的解释，这里的 <code>firstReader</code> 第一个获取锁的线程也就好理解，一个是最后一个获取锁的线程，一个是第一个获取读锁的线程，这样做的目的就是为了性能考虑，实际上就是缓存。因为第一个和最后一个读锁在整个互斥链上有着比较重要的作用，在后边的代码中，我们可以看到他们的实际作用。</li></ul><h3><span id="fulltryacquireshared-自旋效应">fullTryAcquireShared 自旋效应</span></h3><ul><li>齐次，<code>fullTryAcquireShared</code> 这个方法是干什么用的，为什么保底要执行这个方法？？<br>我们来看一下代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">  HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          <span class="comment">/*如果当前持有写锁的是本线程，那么应该让继续去获取读锁，否则一旦返回，改线程睡眠，则会导致死锁*/</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">          <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">          <span class="comment">// 这里的 firstReader 的作用就出来了，这里firstReader的缓存可以有效的帮助</span></span><br><span class="line">          <span class="comment">// 快速的判断 读线程是否需要阻塞</span></span><br><span class="line">          <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">              <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">              这里的代码是本线程应该排队的情况，如果最后一个获取读锁的线程不是本线程</span></span><br><span class="line"><span class="comment">              意味着，这个读线程应该排队。</span></span><br><span class="line"><span class="comment">              如果该线程的数量读锁的数量为0 证明没有以前并没有获取过，那么本线程应该睡眠</span></span><br><span class="line"><span class="comment">              否则一旦发现 本线程确实有获取过读锁，那么不能睡眠（不能返回-1），重入锁要走的自选逻辑。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 上一个读锁的线程</span></span><br><span class="line">                  rh = cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 如果没有人获取过读锁，或者上一个获取读锁的不是本线程</span></span><br><span class="line">                  <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                      <span class="comment">// 拿到当前线程的计数器</span></span><br><span class="line">                      rh = readHolds.get();</span><br><span class="line">                      <span class="comment">// 如果计数器 ==0 证明 该读锁已经没有获取过任何锁了，直接可以进入阻塞逻辑</span></span><br><span class="line">                      <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                          readHolds.remove();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">// 如果计数器 ==0 证明 该读锁已经没有获取过任何锁了，直接可以进入阻塞逻辑</span></span><br><span class="line">              <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一下是正常的加锁逻辑，共享锁首锁缓存，数量+1 计数器+1 等等</span></span><br><span class="line">      <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">              firstReader = current;</span><br><span class="line">              firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">              firstReaderHoldCount++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                  rh = cachedHoldCounter;</span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                  rh = readHolds.get();</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                  readHolds.set(rh);</span><br><span class="line">              rh.count++;</span><br><span class="line">              cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码发现，这段代码和 <code>tryAcquireShared</code> 特别相似，相对于其，多加了一些额外的判断和一个for循环。从<code>tryAcquireShared</code> 中可以看到，调用到该方法的前提是 一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>1、<code>readerShouldBlock</code>失败，证明当前有写锁，失败<br>2、<code>compareAndSetState</code> 失败，证明当前可能有读锁被抢占。<br>有读写锁的特性可以得到，读锁之间是可以重入的。那么如果这两个有任意一个调用失败，我们都可以进行再次的尝试.<br>如果再次尝试，写锁释放，我们既可以得到锁。<code>compareAndSetState</code>  失败，我们也可以再次尝试。<br>所有，当有上面两个条件任意一个失败的时候，我们让这个方法进入自旋状态，确保读锁可以有效的获取锁。</p><p>针对于上述的情况，我们可以知道。当第一种情况失败的时候，我们再次尝试第二次，如果第二次失败或者第一次尝试后，再有有一次类似的失败，我们就可以断定，这个锁确实被读写占用了，这时候，我们可以让读线程睡眠了，所有返回了 -1 具体体现在代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再次尝试是否需要排队</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3><span id="锁降级">锁降级</span></h3><p>在这段代码之前 我们还可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码的含义是，如果当前线程拥有写锁，但是又要去申请写锁，是允许的当写锁被持有时，</span></span><br><span class="line"><span class="comment">// 如果持有该锁的线程不是当前线程，就返回 “获取锁失败”，反之就会继续获取读锁。称之为锁降级。</span></span><br><span class="line"><span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p>锁降级定义：<br>重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p></li><li><p>锁降级的必要性</p><p>我们来看一下这样的情景， 如果读锁不在写锁之后 进行降级 那么情况1 中的 线程获取和修改的值就会出现类脏读的问题</p><p>线程1 命名修改了 data = 1 但是由于 写锁后没有降级成读锁，导致data 被线程2 改成了 2</p></li></ul><table><thead><tr><th>时间序列</th><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td></td><td>获取写锁</td><td></td></tr><tr><td></td><td>更改数据 data = 1</td><td></td></tr><tr><td></td><td>释放写锁</td><td>获取写锁</td></tr><tr><td></td><td></td><td>data =2</td></tr><tr><td></td><td>处理数据</td><td></td></tr><tr><td></td><td></td><td>释放写锁</td></tr><tr><td></td><td>处理完毕</td><td></td></tr><tr><td></td><td>打印data = 2</td><td></td></tr><tr><td></td><td></td><td>打印data = 2</td></tr></tbody></table><p>读锁降级为写锁</p><table><thead><tr><th>时间序列</th><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td></td><td>获取写锁</td><td></td></tr><tr><td></td><td>获得读锁</td><td></td></tr><tr><td></td><td>更改数据 data = 1</td><td></td></tr><tr><td></td><td>释放写锁</td><td></td></tr><tr><td></td><td></td><td>获取写锁失败 阻塞</td></tr><tr><td></td><td>处理数据</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>处理完毕</td><td></td></tr><tr><td></td><td>打印data = 2</td><td></td></tr><tr><td></td><td>释放读锁</td><td>获取写锁 成功</td></tr></tbody></table><h3><span id="doacquireshared-正式加锁">doAcquireShared 正式加锁</span></h3><p>若发现当前的线程应该排队的时候，那么会正式进入以下代码，用于加锁<br>代码 和 <code>acquireQueued</code> 比较相似 可以参考 <a href="https://icefrozen.github.io/article/Java-AQS2/#sync-doacquiresharedinterruptibly-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)-Sync doAcquireSharedInterruptibly </a><br>这里只贴一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">              <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  setHeadAndPropagate(node, r);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  <span class="keyword">if</span> (interrupted)</span><br><span class="line">                      selfInterrupt();</span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 阻塞</span></span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">              parkAndCheckInterrupt())</span><br><span class="line">              interrupted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">          cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="readlockunlock-解锁流程">ReadLockUnlock 解锁流程</span></h3><h4><span id="核心代码">核心代码</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 首个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">// 读锁数量 -1 如果没有清空</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码我们知道，其实就只是做了状态的更改，更改statue 和每个线程的holder的数量<br>具体的解锁流程代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      Node h = head;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 如果头结点 是等待信号状态，那么意味着head 节点是阻塞的</span></span><br><span class="line">              <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              unparkSuccessor(h);     <span class="comment">// 唤醒线程</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">              <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReleaseShared</code> 的方法 在<a href="https://icefrozen.github.io/article/Java-AQS2/#sync-doreleaseshared-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)-sync-doReleaseshared</a> 有详细的介绍<br>这里再次强调一下</p><ul><li>这里为什么要 拿到head？<br>因为共享锁是可以传播的，意思是如果某一个共享锁阻塞的线程被唤醒了，那么意味着排队链上的所有被共享节点阻塞的线程都应该被唤醒。</li><li>如果当前线程是排队链的第n个，那么当被唤醒的时候，我们要找到头部节点，如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功，将head链唤醒，当head被唤醒的时候，会执行 <code>setHeadAndPropagate</code> 这个方法，然后唤醒下一个被共享锁阻塞的线程。</li><li>如果头结点是当前线程，那就意味着头结点已经被唤醒了或者已经持有锁了，那么意味着已经做过唤醒其他的(<code>setHeadAndPropagate</code>)操作了。如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功</li></ul><p>致辞，我们已经完整了解了读写锁的加锁流程。 那么我们剩下一个问题，就是 排队的策略是什么样子的。这就涉及到我们的写锁流程</p><h2><span id="writelock">WriteLock</span></h2><p>按照我们的传统，来看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看到，加锁的流程会降级为普通排它锁，之所以可以这么做，完全可以无视上面的读写锁的互斥规则的原因就是<br>1、 读锁的重入基本上是不会对阻塞链造成什么改变的，原因如下 在读锁<code>tryAcquireShared</code> 的方法有个<br><code>readerShouldBlock</code> 方法，这个方法是由公平锁和非公平锁的类实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">      * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">      * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">      * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">      * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">      * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="排队的策略">排队的策略</span></h3><ul><li>公平锁的 <code>readerShouldBlock</code> / <code>writerShouldBlock</code><br>首先来看公平锁的 block 判定都是 <code>hasQueuedPredecessors</code> 这个方法。 这个方法的判断标准我们以前讨论过，就是看排队链有没有节点，也就是说，只有写锁tryAcquire 失败了（注意，tryAcquire ！= 0 证明 有读锁占据高位置） 才会加入到队列当中，<br>那么意味着，一旦加入排队，往后的读锁就要执行 <code>hasQueuedPredecessors</code> 方法的时候，就要排队了。<br>writerShouldBlock 也是一样，写锁要排到队列后边，两个写锁有先后关系。如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(read)  -&gt; wl1(写锁1)  -&gt; rl1（读锁1） ... -&gt; wl2(写锁2)  ---&gt; other</span><br></pre></td></tr></table></figure><ul><li><p>非公平锁的 <code>readerShouldBlock</code>/ <code>writerShouldBlock</code><br>非公平锁的排队策略 在注释生已经说的很清楚了，我们来看一下这两段注释</p></li><li><p>apparentlyFirstQueuedIsExclusive方法上的 注释</p><blockquote><p>As a heuristic to avoid indefinite writer starvation,<br>block if the thread that momentarily appears to be head<br>of queue, if one exists, is a waiting writer.  This is<br>only a probabilistic effect since a new reader will not<br>block if there is a waiting writer behind other enabled<br>readers that have not yet drained from the queue.</p></blockquote></li></ul><blockquote><p>Returns {@code true} if the apparent first queued thread, if one<br>exists, is waiting in exclusive mode.  If this method returns<br>{@code true}, and the current thread is attempting to acquire in<br>shared mode (that is, this method is invoked from {@link<br>tryAcquireShared}) then it is guaranteed that the current thread<br>is not the first queued thread.  Used only as a heuristic in<br>ReentrantReadWriteLock.</p></blockquote><p>简单的来说就是，当代队里中的第一个节点（head 后的第一个节点 ）不是共享锁的时候，需要排序。换句话说，当队列中（head 后第一个元素）是写锁的时候，且写锁被阻塞了，那么这个时候，读锁就要排队，因为读锁必须要排在写锁侯彪，看代码已经很清晰了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node h, s;</span><br><span class="line">  <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      !s.isShared()         &amp;&amp;</span><br><span class="line">      s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>致辞，AQS的核心已经全部分享完毕了。总结如下</p><ol><li>AQS的排最节点氛围 共享和排他两种模式，共享锁的唤醒是由前一个节点来唤醒。</li><li>排它锁的阻塞由阻塞线程完成，但是前一个排他锁的阻塞状态是由阻塞线程完成的。</li><li>statue 不仅保存了读锁的数量，还保存了写锁的数量。</li><li>读锁可重入，一旦有写锁加入等待队列，意味着后面想要获取锁的操作（未获取过锁的）操作都需要排队。一旦写锁释放，后边的写锁就都会被唤醒。</li></ol><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/6923c126e762" target="_blank" rel="noopener">ReentrantReadWriteLock 源码分析(基于Java 8)</a></li><li><a href="https://www.jianshu.com/p/d47fe1ec1bb3" target="_blank" rel="noopener">【死磕Java并发】-----J.U.C之读写锁：ReentrantReadWriteLock</a></li><li><a href="https://www.cnblogs.com/stateis0/p/9062062.html" target="_blank" rel="noopener">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇（3）</title>
      <link href="/article/databases-lock/"/>
      <url>/article/databases-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="innodb-介绍">InnoDB 介绍</span></h2><h2><span id="innodb-中的锁">InnoDB 中的锁</span></h2><p>你可能听过各种各样的 InnoDB 的数据库锁，Gap 锁，共享锁，排它锁，读锁，写锁等等。但是 InnoDB 的标准实现的锁只有 2 类，<strong>一种是行级锁，一种是意向锁</strong>。</p><h3><span id="innodb的行级锁">InnoDB的行级锁：</span></h3><ul><li><strong>共享锁(读锁 S Lock)</strong>，允许事务读一行数据。</li><li><strong>排它锁(写锁 X Lock)</strong>，允许事务删除一行数据或者更新一行数据。<br>行级锁中，除了 S 和 S 兼容，其他都不兼容。</li></ul><h3><span id="innodb-支持两种意向锁即为表级别的锁">InnoDB 支持两种意向锁(即为表级别的锁)：</span></h3><ul><li><strong>意向共享锁(读锁 IS Lock)</strong>，事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁(写锁 IX Lock)</strong>，事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。</li></ul><p>首先解释一下意向锁，意向锁为了表明某个事务正在锁定一行或者将要锁定一行数据。<br>首先申请意向锁的动作是 InnoDB 完成的，怎么理解意向锁呢?</p><blockquote><p>例如：事务 A 要对一行记录 R 进行上 X 锁，那么 InnoDB 会先申请表的 IX 锁，再锁定记录 R 的 X 锁。在事务 A 完成之前，事务 B 想要来个全表操作，此时直接在表级别的 IX 就告诉事务 B 需要等待而不需要在表上判断每一行是否有锁。<br>意向排它锁存在的价值在于节约 InnoDB 对于锁的定位和处理性能。另外注意了，除了全表扫描以外意向锁都不会阻塞。</p></blockquote><h3><span id="意向锁的存在意义">意向锁的存在意义</span></h3><p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p><p>假设 我们有一张users表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td></tr><tr><td>2</td><td>lisi</td></tr></tbody></table><p>当事务A 想要更新id=2的user 的时候，会做以下操作</p><ol><li>DB引擎给表增加一个意向排它锁</li><li>事务A给id=2的行增加一个排它锁</li></ol><blockquote><p>这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！！</p></blockquote><p>此时若有事务B想获取 User表的共享锁（注意，这里是表级别的锁） 这个时候，因为是要锁表，所以意味着表中的所有数据都不能修改，但是此时A 已经对2 加了锁，所有如果没有意向锁，事务B 必须在获取表级别的共享锁的时候，检测每一行是否有排他锁。</p><p>但是一旦有了意向共享锁，所以事务B 因此不用每一行都扫描。</p><p>因此此时事务 B 检测事务 A 持有 users 表的意向排他锁，就可以得知事务 A 必然持有该表中某些数据行的排他锁，那么事务 B 对 users 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p><p>我们可以根据下表来看一下各个锁的兼容性</p><h3><span id="锁的兼容互斥性">锁的兼容互斥性</span></h3><p>看一下意向锁的排斥性</p><table><thead><tr><th></th><th><strong>意向共享锁（IS）</strong></th><th><strong>意向排他锁（IX</strong>）</th></tr></thead><tbody><tr><td><strong>意向共享锁（IS）</strong></td><td>兼容</td><td>兼容</td></tr><tr><td><strong>意向排他锁（IX）</strong></td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意义： 意向锁不会跟对意向锁产生排斥，这设计到表的并发。<br>举个例子：还是刚才的User 表<br>事务A 要对id = 2 的表进行更新，那么事务A 会产生两个效果</p><ol><li>表级别的意向排它锁</li><li>行级别的排他锁。<br>此时B 事务想更新 id = 1 的行,</li><li>首要获取User 的意向排它锁，</li><li>发现User 表已经有意向排它锁</li><li>但是意向排他锁是互相兼容的，因此，事务B 加锁成功</li><li>id = 1的数据行上不存在任何排他锁，最终事务 B 成功获取到了该数据行上的排他锁。</li></ol><p>意向锁对共享和排他锁的互斥性</p><table><thead><tr><th></th><th><strong>意向共享锁（IS）</strong></th><th><strong>意向排他锁（IX）</strong></th></tr></thead><tbody><tr><td><strong>共享锁（IS）</strong></td><td>兼容</td><td>互斥</td></tr><tr><td><strong>排他锁（IX）</strong></td><td>互斥</td><td>互斥</td></tr></tbody></table><h3><span id="锁的算法">锁的算法</span></h3><p>InnoDB 有 3 种行锁的算法：</p><ul><li><strong>Record Lock</strong>： 单个行记录上的锁。</li><li><strong>Gap Lock</strong>：    间隙锁，锁定一个范围，而非记录本身。</li><li><strong>Next-Key Lock</strong>：结合 Gap Lock 和 Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是 RR 隔离级别下的幻读。</li></ul><p><code>Next-Key Lock</code> 和 <code>Gap Lock</code> 的区别就是：会首先对索引（如果我们的查询语句命中索引记录的话）记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。<br>如果没有命中索引记录，则直接退化成 <code>Gap Lock</code></p><h4><span id="gap-lock-和-next-key-lock">Gap Lock 和 Next-Key Lock</span></h4><ul><li>产生间隙锁的条件（RR事务隔离级别下；）：<ul><li>使用普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引锁定多行记录。</li><li>不使用索引则加全局锁</li></ul></li><li>举例说明，假若我们有如下表</li></ul><table><thead><tr><th>id（主键）</th><th>v1（索引）</th><th>v2（无索引）</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>3</td><td>1</td></tr><tr><td>3</td><td>4</td><td>2</td></tr><tr><td>5</td><td>5</td><td>9</td></tr><tr><td>7</td><td>7</td><td>4</td></tr><tr><td>10</td><td>9</td><td>5</td></tr></tbody></table><p>间隙锁（Gap Lock）一般是针对非唯一索引而言的，test表中的v1（非唯一索引）字段值可以划分的区间为：<br><code>-∞,1）（1,3）（3,4）（4,5）（5,7）（7,9）（9, +∞）</code></p><p>假如要更新<code>v1=7</code>的数据行，锁定的区间是（5,7）和（7,9）。同时找到,v1=7的数据行的主键索引和非唯一索引，对key加上锁。</p><ul><li><p>插入锁</p><table><thead><tr><th>事物1</th><th>事物2</th></tr></thead><tbody><tr><td>UPDATE test set v2=10 where v1=7（加锁范围（5，9））</td><td></td></tr><tr><td></td><td>insert into test values(15,6,3)（阻塞））</td></tr><tr><td></td><td>insert into test values(9,9,3)（阻塞））</td></tr><tr><td></td><td>insert into test values(11,9,3)（成功））</td></tr><tr><td></td><td>insert into test values(4,5,3)（成功））</td></tr></tbody></table><p>看一下 插入图<br><img src="/article/databases-lock/1577760232986distributed-transaction_.png" alt></p></li><li><p>更新锁</p><table><thead><tr><th>事物1</th><th>事物2</th></tr></thead><tbody><tr><td>UPDATE test set v2=10 where v1=7（加锁范围（5，9））</td><td></td></tr><tr><td></td><td>update test set v1=6 where v1=5（阻塞））</td></tr><tr><td></td><td>update test set v1=9 where v1=7（阻塞））</td></tr><tr><td></td><td>update test set v1=10 where v1=9（成功））</td></tr></tbody></table><p>v1 = 6 相当于在 5 7 范围内加入</p></li></ul><h4><span id="锁选择">锁选择</span></h4><ul><li>1）、如果更新条件没有走索引，此时会进行全表扫描，扫表的时候，要阻止其<br>他任何的更新操作，所以上升为表锁。</li><li>2）如果更新条件为索引字段，但是并非唯一索引（包括主键索引）那么此时<br>更新会使用Next-Key Lock。使用Next-Key Lock的原因：<br>a）、首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；<br>b）、还要保证锁定的区间不能插入新的数据。</li><li>3）、如果更新条件为唯一索引，则使用Record Lock（记录锁）。</li></ul><h4><span id="锁应用">锁应用</span></h4><ul><li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li><li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li><li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li><li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li><li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li><li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5c0fc472e51d451ac27c47eb" target="_blank" rel="noopener">MySQL探秘(七):InnoDB行锁算法</a></li><li><a href="https://www.gaoyaxuan.net/blog/296.html" target="_blank" rel="noopener">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://cloud.tencent.com/developer/article/1100494" target="_blank" rel="noopener">扫盲贴-分布式数据一致性：两阶段提交，三阶段提交</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li><li><a href="https://my.oschina.net/tridays/blog/791124" target="_blank" rel="noopener">事务并发的可能问题与其解决方案 </a></li><li><a href="https://juejin.im/post/5c9040e95188252d92095a9e" target="_blank" rel="noopener">MySQL的可重复读级别能解决幻读吗</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">MySQL的InnoDB的幻读问题</a></li><li><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></li><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;mid=2247483782&amp;idx=1&amp;sn=b5548efc354a04cf986709af4b7efdd8&amp;source=41#wechat_redirect" target="_blank" rel="noopener">MySQL探秘(六):InnoDB一致性非锁定读</a></li><li><a href="https://database.51cto.com/art/201904/594446.htm" target="_blank" rel="noopener">一文快速搞懂MySQL InnoDB事务ACID实现原理</a></li><li><a href="https://www.jianshu.com/p/1573c4dcecd6" target="_blank" rel="noopener">InnoDB逻辑存储结构</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483678&amp;idx=1&amp;sn=913780d42e7a81fd3f9b747da4fba8ec&amp;chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB数据页结构</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务详解（1）</title>
      <link href="/article/distributed-transaction-1/"/>
      <url>/article/distributed-transaction-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="分布式事务概述">分布式事务概述</span></h2><h2><span id="什么是事务">什么是事务</span></h2><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p><h2><span id="事务的四大特性acid">事务的四大特性ACID</span></h2><ul><li><p><strong>原子性（Atomicity）</strong>: 事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</p></li><li><p><strong>一致性（Consistency）</strong> : 一致性是指事务必须使数据库从一个一致性状态变成另一个一致性状态，也就是事务执行前后必须处于一致性状态。<br>以转账为例，假设用户A和B两者的钱加起来是5000，那么不管A和B之间如何转账，转多少次，事务结束后两个用户的钱加起来应该还得是5000，这就是事务的一致性。</p></li><li><p><strong>隔离性（Isolation）</strong>: 一个事务所做的修改在最终提交以前，对其他事务是不可见，当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其它的事务操作所干扰，多个并发事务之间要相互隔离。</p></li><li><p><strong>持久性（Durability)</strong>：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></li></ul><h2><span id="事务的隔离级别">事务的隔离级别</span></h2><h3><span id="事务并发的问题">事务并发的问题</span></h3><h3><span id="1脏读读取未提交数据">【1】脏读（读取未提交数据）</span></h3><p>当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:left">3</td><td></td><td>查询余额1000</td></tr><tr><td style="text-align:left">4</td><td></td><td>取出 500 余额为 500</td></tr><tr><td style="text-align:left">5</td><td>查询账户余额 500</td><td></td></tr><tr><td style="text-align:left">6</td><td></td><td>出错，撤销事务 余额为1000</td></tr><tr><td style="text-align:left">7</td><td>汇入100 余额 600</td><td></td></tr><tr><td style="text-align:left">8</td><td>提交事务</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照逻辑，转账事务读取了B 撤销后的事务出现脏读</td><td></td></tr></tbody></table><h3><span id="2不可重复读前后多次读取数据内容不一致">【2】不可重复读（前后多次读取，数据内容不一致）</span></h3><p>在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>begin</td><td></td></tr><tr><td style="text-align:left">2</td><td>第一次查询余额 100</td><td></td></tr><tr><td style="text-align:left">3</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">4</td><td>其他操作</td><td></td></tr><tr><td style="text-align:left">5</td><td></td><td>消费30 余额 变为 70</td></tr><tr><td style="text-align:left">6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:left">7</td><td>第二次查询 余额为70</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照正确的逻辑，事务A前后两次读取的数据应该一致</td><td></td></tr></tbody></table><h3><span id="3幻读前后多次读取数据总量不一致">【3】幻读（前后多次读取，数据总量不一致）</span></h3><p>在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>统计金额事务</th><th>转账事务 B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:left">3</td><td>统计金额为（100个账户）10000</td><td></td></tr><tr><td style="text-align:left">4</td><td></td><td></td></tr><tr><td style="text-align:left">5</td><td></td><td>新增一个存款账户，余额为100</td></tr><tr><td style="text-align:left">6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:left">7</td><td>再次统计存款 为 10100 元</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照正确的逻辑，统计事务后出现了幻读（数据行发生了变化）</td><td></td></tr></tbody></table><h3><span id="4丢失更新">【4】丢失更新</span></h3><ul><li>第一类更新丢失【回滚覆盖】</li></ul><p>撤消一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了</p><table><thead><tr><th>时间顺序</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td></td><td>开始事务</td></tr><tr><td>3</td><td>读余额为1000</td><td></td></tr><tr><td>4</td><td>取出100，余额改为900</td><td></td></tr><tr><td>5</td><td></td><td>读余额为1000</td></tr><tr><td>6</td><td></td><td>汇入100，余额改为1100</td></tr><tr><td>7</td><td></td><td>提交事务，余额定为1100</td></tr><tr><td>8</td><td>撤销事务，余额改回1000</td><td></td></tr><tr><td>9</td><td>最终余额1000，更新丢失</td><td></td></tr></tbody></table><ul><li>第二类更新丢失 【提交覆盖】</li></ul><p>提交覆盖：提交一个事务时，写操作依赖于事务内读到的数据，读发生在其他事务提交前，写发生在其他事务提交后，把其他已提交的事务写入的数据覆盖了。这是不可重复读的特例。</p><table><thead><tr><th>时间顺序</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td><td></td></tr><tr><td>2</td><td></td><td>开始事务</td></tr><tr><td>3</td><td>读余额为1000</td><td></td></tr><tr><td>4</td><td></td><td>读余额为1000</td></tr><tr><td>5</td><td></td><td>取出100，余额改为900</td></tr><tr><td>6</td><td></td><td>提交事务，余额定为900</td></tr><tr><td>7</td><td>取出100，余额改为1100</td><td></td></tr><tr><td>8</td><td>提交事务，余额定为1100</td><td></td></tr><tr><td>9</td><td>最终余额1100，更新丢失</td><td></td></tr></tbody></table><h3><span id="数据库的隔离级别">数据库的隔离级别</span></h3><ul><li><p><strong>数据库4中隔离级别</strong></p><p>为了解决多个事务并发会引发的问题，进行并发控制。数据库系统提供了四种事务隔离级别供用户选择。</p><ul><li><p><strong>Read Uncommitted 读未提交</strong>：</p><p>即允许当前会话事务读取到其他会话中未提交事务修改的数据，可能导致脏读。具体课件脏读的原因。</p></li><li><p><strong>Read Committed 读已提交</strong>：</p><p>只能读取到已成功提交事务的数据，因此可以避免发生脏读，但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。即事务前后两次读取的数据不一致。见不可重复读的例子。</p></li><li><p><strong>Repeatable Read 重复读</strong></p><p>重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务<br>但可能出现幻读。（这里为什么会出现幻读，参见后面的文章）</p><hr></li><li><p><strong>Serializable 串行化</strong>：所有的增删改查串行执行。</p></li></ul></li></ul><h2><span id="mvcc">MVCC</span></h2><pre><code>请参见下一篇</code></pre><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.gaoyaxuan.net/blog/296.html" target="_blank" rel="noopener">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://cloud.tencent.com/developer/article/1100494" target="_blank" rel="noopener">扫盲贴-分布式数据一致性：两阶段提交，三阶段提交</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li><li><a href="https://my.oschina.net/tridays/blog/791124" target="_blank" rel="noopener">事务并发的可能问题与其解决方案 </a></li><li><a href="https://juejin.im/post/5c9040e95188252d92095a9e" target="_blank" rel="noopener">MySQL的可重复读级别能解决幻读吗</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">MySQL的InnoDB的幻读问题</a></li><li><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></li><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事物 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇(2)</title>
      <link href="/article/distributed-transaction-innodb/"/>
      <url>/article/distributed-transaction-innodb/</url>
      
        <content type="html"><![CDATA[<h2><span id="innobd-的数据结构">InnoBD 的数据结构</span></h2><h2><span id="innobd-中的数据结构概览">InnoBD 中的数据结构概览</span></h2><p>先来看一下 InnoDB 中的整体存贮逻辑<br><img src="/article/distributed-transaction-innodb/1575793726712distributed-transaction_.png" alt></p><p>MySQL 使用 InnoDB 存储表时，会将<strong>表的定义</strong>和<strong>数据索引</strong>等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。</p><h3><span id="frm-文件">.frm 文件</span></h3><p>无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。</p><h3><span id="ibd-文件">.ibd 文件</span></h3><p>InnoDB 中用于存储数据的文件总共有两个部分，一是<strong>系统表空间文件</strong>，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。<br>当打开 <code>innodb_file_per_table</code> 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p><h3><span id="数据结构分类">数据结构分类</span></h3><ul><li><p><strong>表空间Tablespace（ibd文件）</strong></p><p>新建一个数据库时，innodb存储引擎会初始化一个名为<code>ibdata1</code>的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表 sys_tables、sys_columns、sys_indexes 、sys_fields等。此外，还会存储<strong>用来保证数据完整性的回滚段数据</strong>，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p></li><li><p><strong>段Segment（一个索引2个段）</strong></p><p>段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。<br>常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），<strong>因此数据即索引，索引即数据</strong>。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p><p>创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据，叶子段用来管理（存储）B+树叶子节点的数据；也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。</p></li><li><p><strong>簇(区)Extent（1MB）：64个Page</strong></p><p>簇是由64个连续的页组成的，<strong>每个页大小为16KB</strong>，<strong>即每个簇的大小为1MB</strong>。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</p><p>一个B+树节点就是一个页16KB,页的编号可以映射到物理文件偏移,B+树叶子节点前后形成双向链表,如下图</p><p><img src="/article/distributed-transaction-innodb/1575794673983distributed-transaction_.png" alt></p></li><li><p><strong>页Page（16KB）</strong>：</p><p>磁盘管理的最小单位,可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p><p>页的本质就是一块16KB大小的存储空间，InnoDB为了不同的目的而把页分为不同的类型，其中用于存放记录的页也称为数据页</p><p>常见的页类型有：</p><ul><li>数据页（B-tree Node）。</li><li>Undo页（Undo Log Page）。</li><li>系统页（System Page）。</li><li>事务数据页（Transaction system Page）。</li><li>插入缓冲位图页（Insert Buffer Bitmap）。</li><li>插入缓冲空闲列表页（Insert Buffer Free List）。</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）。</li><li>压缩的二进制大对象页（Compressed BLOB Page）。<br>在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</li></ul></li></ul><h2><span id="innobd-page详解">InnoBD Page详解</span></h2><h3><span id="page和行结构结构">Page和行结构结构</span></h3><p><img src="/article/distributed-transaction-innodb/1575794929155distributed-transaction_.png" alt><br>为了更好的理解Page页的具体作用，我们先来看行记录格式<br>行记录格式 存放在 <code>UserRecords</code> 中，是从 <code>Free Space</code> 分配而来的</p><h4><span id="行记录格式">行记录格式</span></h4><ul><li><strong>行记录格式（Compact 格式）</strong></li></ul><p>想要了解 Page的结构，还需要从 行格式来说起。行记录记录在5.1版本的情况下，有 <code>Compact</code> 和 <code>Redundant</code> 格式两种情况,<code>Compact</code> 则是在5.0 的时候引入的。</p><p>另外还有其他两种结构 具体的请移步<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483670&amp;idx=1&amp;sn=751d84d0ce50d64934d636014abe2023&amp;chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&amp;mpshare=1&amp;scene=23&amp;srcid=1210jEAAUuWPRLJ9u61XjZLl&amp;sharer_sharetime=1575964590022&amp;sharer_shareid=224e201559d0f0f2cae21cbf8a695c55%23rd" target="_blank" rel="noopener">InnoDB记录存储结构</a></p><p>下面我们主要是讲解 <code>Compact</code> 格式的行记录，结构如下：</p><p><img src="/article/distributed-transaction-innodb/1575875953139distributed-transaction_.png" alt></p><p>我们可以用 <code>show table status like 'sth'\G;</code> 来查看行结构</p><ul><li><p><strong>变长字段长度列表：</strong>  如果列的长度小于255字节，用1字节表示；如果大于255个字节，用2字节表示，也就是说，innodb 中的 <code>varchar</code> 不能超过 <code>65535</code> 个字节，因为有其他的字段，所以实际创建的 <code>varchar</code> 的具体只要比 <code>65535</code> 个字节少</p></li><li><p><strong>NULL标志位</strong>：表明该行数据是否有NULL值。占一个字节。该行明确定义了哪些列可以为空，一个字节</p></li><li><p><strong>记录头信息</strong>：固定占用5字节,每位的含义见下表：</p></li></ul><table><thead><tr><th>字段名</th><th>大小</th><th>字段含义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>标记该记录是否为B+树的非叶子节点中的最小记录</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前槽管理的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><strong>事务id</strong>  占6个字节</li><li><strong>回滚指针</strong> 占7 个字节</li><li><strong>row_id</strong> 如果没有置顶主键， 则会默认生成一个这个列 占6个字节</li></ul><p>我们下面里创建一张表：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>这个新创建的 <code>page_demo</code> 表有3个列，其中 c1 和 c2 列是用来存储整数的，c3 列是用来存储字符串的。</p><p>需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中MySQL就没必要为我们去创建那个所谓的 <code>row_id</code> 隐藏列了。而且我们为这个表指定了ascii字符集以及 <code>Compact</code> 的行格式。所以这个表中记录的行格式示意图就是这样的：</p><p><img src="/article/distributed-transaction-innodb/1575876493352distributed-transaction_.png" alt></p><p>我们插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>插入之后的结果如下：</p><p><img src="/article/distributed-transaction-innodb/1575887545816distributed-transaction-innodb_.png" alt></p><p>下面我们具体来分析一下 记录头信息 信息相关内容</p><ul><li><p><code>delete_mask</code> 表示是否删除，行记录可能被其他覆盖</p></li><li><p><code>min_rec_mask</code> 标记该记录是否为B+树的非叶子节点中的最小记录</p></li><li><p><code>n_owned</code>:   该记录管理的槽数量，见页目录章节</p></li><li><p><code>heap_no</code> ：<br>这个属性表示当前记录在本页中的位置，从图中可以看出来，我们插入的4条记录在本页中的位置分别是 2、3、4、5<br>而0和1 表示两条虚拟记录，最大的和最小的，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录</p><p>这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p><p><img src="/article/distributed-transaction-innodb/1575878951094distributed-transaction_.png" alt></p><p>由于这两条记录不是我们自己定义的记录，所以它们并不存放在页的<code>User Records</code>部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分，如图所示：</p><p><img src="/article/distributed-transaction-innodb/1575880203017distributed-transaction_.png" alt></p></li><li><p><code>record_type</code></p><p>这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 <code>record_type</code> 值都是0，而最小记录和最大记录的 <code>record_type</code> 值分别为2和3。</p><p>至于 <code>record_type</code> 为1的情况，我们之后在说索引的时候会重点强调的。</p></li><li><p><code>next_record</code><br>它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的<code>next_record</code>值为36，意味着从第一条记录的真实数据的地址处向后找36个字节便是下一条记录的真实数据。</p><p>如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 最小记录 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 最大记录 ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：</p></li></ul><p><img src="/article/distributed-transaction-innodb/1575880301031distributed-transaction_.png" alt></p><p>图中可以看出来，我们的记录按照从小到大的顺序形成了一个单链表。最大记录的next_record的值为0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM page_demo WHERE c1 = 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>删掉第2条记录后的示意图就是：</p><p><img src="/article/distributed-transaction-innodb/1575882481097distributed-transaction_.png" alt></p><p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：<br>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li><li>第2条记录的 <code>next_record</code> 值变为了0，意味着该记录没有下一条记录了。</li><li>第1条记录的 <code>next_record</code> 指向了第3条记录。还有一点你可能忽略了，就是最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。</li></ul><p>再来看一个有意思的事情，因为主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中, 那么2这个数据 就会复用原来的空间。</p><ul><li><p><strong>行溢出</strong></p><p>即使我们能存放65 532个字节了，但是有没有想过，InnoDB存储引擎的页为16KB，即16 384个字节，怎么能存放65 532个字节呢？一般情况下，数据都是存放在B-tree Node的页类型中，但是当发生行溢处时，则这个存放行溢处的页类型为Uncompress BLOB Page。</p></li></ul><p>我们来看个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (a <span class="built_in">varchar</span> (<span class="number">65532</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="keyword">repeat</span> (<span class="string">'a'</span>,<span class="number">65532</span>);</span><br></pre></td></tr></table></figure><p>下面的表空间文件:<br><img src="/article/distributed-transaction-innodb/1575895093171distributed-transaction-innodb_.png" alt></p><p>可以看到一个B-tree Node页类型，另外有4个为Uncompressed BLOB Page，这些页中才是真正存放了65 532个字节的数据。既然实际存放的数据都放到BLOB页中，那数据页中又存放了些什么东西呢？同样，通过之前的hexdump来读取表空间文件,可以看到，从0x0000c093到0x0000c392数据页面其实只保存了varchar（65 532）的前768个字节的前缀（prefix）数据（这里都是a），之后跟的是偏移量，指向行溢出页，也就是前面我们看到的Uncompressed BLOB Page。因此，对于行溢出数据，其存放方式下图4所示：<br><img src="/article/distributed-transaction-innodb/1575895129375distributed-transaction-innodb_.png" alt></p><p>CHAR很明确地被视为了变长类型，对于未能占满长度的字符还是填充0x20。</p><ul><li><strong>页目录</strong></li></ul><p>上边我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p><p><code>SELECT * FROM page_demo WHERE c1 = 3;</code></p><p><strong>顺序查找：</strong></p><p>从最小记录开始，沿着链表一直往后找，在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。<br>但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的。</p><p><strong>基于slot的查找</strong><br>因此基于目录的思想，innodBD 设计了如下的数据结构：</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的<strong>最后一条记录</strong>的头信息中的n_owned属性表示该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（英文名：Slot）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为<code>Page Directory</code>。</li></ul><p>比方说现在的 <code>page_demo</code> 表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：<br><img src="/article/distributed-transaction-innodb/1575884533564distributed-transaction_.png" alt></p><p>从这个图中我们需要注意这么几点：<br>现在Page Directory部分中有两个槽，也就意味着我们的记录被分成了两个组，槽0中的值是112，代表最大记录的地址偏移量；槽1中的值是99，代表最小记录的地址偏移量。</p><ul><li>注意最小和最大记录的头信息中的n_owned属性</li><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul><p>99和112这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：</p><p><img src="/article/distributed-transaction-innodb/1575884564248distributed-transaction_.png" alt></p><p>单纯从逻辑上看一下这些记录和页目录的关系，如下图<br><img src="/article/distributed-transaction-innodb/1575884591930distributed-transaction_.png" alt></p><p>设计InnoDB的设计师个分组中的记录条数是有规定的，对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。所以分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个。</li><li>在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到该组中了。</li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(5, 500, 'eeee'), </span><br><span class="line">(6, 600, 'ffff'), (7, 700, 'gggg'), </span><br><span class="line">(8, 800, 'hhhh'), (9, 900, 'iiii'), </span><br><span class="line">(10, 1000, 'jjjj'), (11, 1100, 'kkkk'), </span><br><span class="line">(12, 1200, 'llll'), (13, 1300, 'mmmm'), </span><br><span class="line">(14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');</span><br><span class="line">Query OK, 12 rows affected (0.00 sec)</span><br><span class="line">Records: 12  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>往表中添加了12条记录，现在就一共有16条正常的记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：<br><img src="/article/distributed-transaction-innodb/1575884726338distributed-transaction_.png" alt></p><p><strong>查找过程</strong></p><p>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。4个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为5的记录，过程是这样的：</p><ul><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 5，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4。所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为5的记录在槽1和槽2之间，接下来就是遍历链表的查找了。</li><li>所以在一个数据页中查找指定主键值的记录的过程分为两步：<br>通过二分法确定该记录所在的槽。<br>通过记录的 <code>next_record</code> 属性组成的链表遍历查找该槽中的各个记录。</li></ul><h3><span id="page结构的详细说明">Page结构的详细说明</span></h3><p>本章开始 我们已经介绍过了Page的信息，下面我们在来看一下每一页的具体细节。</p><p><img src="/article/distributed-transaction-innodb/1575794929155distributed-transaction_.png" alt></p><h4><span id="page-header">Page Header</span></h4><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>PAGE_N_DIR_SLOTS</code></td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td><code>PAGE_HEAP_TOP</code></td><td>2字节</td><td>第一个记录的地址</td></tr><tr><td><code>PAGE_N_HEAP</code></td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td><code>PAGE_FREE</code></td><td>2字节</td><td>指向可重用空间的地址（就是标记为删除的记录地址）</td></tr><tr><td><code>PAGE_GARBAGE</code></td><td>2字节</td><td>已删除的字节数，行记录结构中delete_flag为1的记录大小总数</td></tr><tr><td><code>PAGE_LAST_INSERT</code></td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td><code>PAGE_DIRECTION</code></td><td>2字节</td><td>最后插入的方向</td></tr><tr><td><code>PAGE_N_DIRECTION</code></td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td><code>PAGE_N_RECS</code></td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td><code>PAGE_MAX_TRX_ID</code></td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td><code>PAGE_LEVEL</code></td><td>2字节</td><td>当前页在索引树中的位置，高度</td></tr><tr><td><code>PAGE_INDEX_ID</code></td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td><code>PAGE_BTR</code></td><td>10字节</td><td>非叶节点所在段的segment header，仅在B+树的Root页定义</td></tr><tr><td><code>PAGE_LEVEL</code></td><td>10字节</td><td>B+树所在段的segment header，仅在B+树的Root页定义</td></tr></tbody></table><h4><span id="file-header">File Header</span></h4><p><img src="/article/distributed-transaction-innodb/1575966669980distributed-transaction-innodb_.png" alt></p><ul><li>FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p><ul><li>FIL_PAGE_OFFSET</li></ul><p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</p><ul><li>FIL_PAGE_TYPE</li></ul><p>这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，本集中介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><p><img src="/article/distributed-transaction-innodb/1575966710639distributed-transaction-innodb_.png" alt></p><ul><li>FIL_PAGE_PREV和FIL_PAGE_NEXT</li></ul><p>一张表中可以有成千上万条记录，一个页只有16KB，所以可能需要好多页来存放数据，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的数据页是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：<br><img src="/article/distributed-transaction-innodb/1575966768836distributed-transaction-innodb_.png" alt></p><h4><span id="freespace">FreeSpace</span></h4><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下</p><p><img src="/article/distributed-transaction-innodb/1575875117094distributed-transaction_.png" alt></p><h3><span id="file-header">File Header</span></h3><p>对于这个部分，我的理解比较简单，我们知道InnoDB 会把数据从内存刷新到磁盘，中间交互的单位是页 ，但是我们想想，假如再刷新到磁盘的时候出现了问题，这样的话怎么办呢？<br>​这就是File Trailer 作用，这个部分由8个字节组成，可以分成2个小部分：</p><ul><li>前四个字节代表页的检验和：</li></ul><p>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错；</p><ul><li>后四个字节代表日志序列位置（LSN）这个部分也是为了校验页的完整性的，可以先不用管这个属性。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.gaoyaxuan.net/blog/296.html" target="_blank" rel="noopener">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://cloud.tencent.com/developer/article/1100494" target="_blank" rel="noopener">扫盲贴-分布式数据一致性：两阶段提交，三阶段提交</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li><li><a href="https://my.oschina.net/tridays/blog/791124" target="_blank" rel="noopener">事务并发的可能问题与其解决方案 </a></li><li><a href="https://juejin.im/post/5c9040e95188252d92095a9e" target="_blank" rel="noopener">MySQL的可重复读级别能解决幻读吗</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">MySQL的InnoDB的幻读问题</a></li><li><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></li><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://database.51cto.com/art/201904/594446.htm" target="_blank" rel="noopener">一文快速搞懂MySQL InnoDB事务ACID实现原理</a></li><li><a href="https://www.jianshu.com/p/1573c4dcecd6" target="_blank" rel="noopener">InnoDB逻辑存储结构</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483678&amp;idx=1&amp;sn=913780d42e7a81fd3f9b747da4fba8ec&amp;chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB数据页结构</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事物 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka系列</title>
      <link href="/article/kafka/"/>
      <url>/article/kafka/</url>
      
        <content type="html"><![CDATA[<h2><span id="kafka概述">Kafka概述</span></h2><h2><span id="kafka-定义">Kafka 定义</span></h2><p>Kafka 是一个分布式的基于发布/订阅模式的消息队列(Message Queue)，主要应用于 大数据实时处理领域。</p><h2><span id="消息队列好处">消息队列好处</span></h2><p>可以参考我的另一篇博文<a href="https://icefrozen.github.io/article/why-mq/" target="_blank" rel="noopener">MQ可以解决哪些实际问题</a></p><h2><span id="优缺点">优缺点</span></h2><ul><li><p>优点：</p><ul><li>可扩展。Kafka集群可以透明的扩展，增加新的服务器进集群。</li><li>高性能。Kafka性能远超过传统的ActiveMQ、RabbitMQ等，Kafka支持Batch操作。</li><li>容错性。Kafka每个Partition数据会复制到几台服务器，当某个Broker失效时，Zookeeper将通知生产者和消费者从而使用其他的Broker。</li></ul></li><li><p>缺点：</p><ul><li>重复消息。Kafka保证每条消息至少送达一次，虽然几率很小，但一条消息可能被送达多次。</li><li>消息乱序。Kafka某一个固定的Partition内部的消息是保证有序的，如果一个Topic有多个Partition，partition之间的消息送达不保证有序。</li><li>复杂性。Kafka需要Zookeeper的支持，Topic一般需要人工创建，部署和维护比一般MQ成本更高。</li></ul></li></ul><h2><span id="kafka应用场景">Kafka应用场景</span></h2><p>Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。在大数据领域的数据采集。离线数据采集等日志收集方面，Kafka几乎是规范。<br>两个作用：</p><ul><li><p>降低系统组网复杂度。<br>降低编程复杂度，各个子系统不在是相互协商接口，各个子系统类似插口插在插座上，Kafka承担高速数据总线的作用。</p></li><li><p>Kafka主要特点：</p><ol><li>同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。</li><li>可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。</li><li>分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。</li><li>消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。</li><li>支持online和offline的场景。</li></ol></li><li><p>Kafka的设计要点：</p><ol><li>直接使用linux 文件系统的cache，来高效缓存数据。</li><li>采用linux Zero-Copy提高发送性能。传统的数据发送需要发送4次上下文切换，采用sendfile系统调用之后，数据直接在内核态交换，系统上下文切换减少 为2次。根据测试结果，可以提高60%的数据发送性能。</li><li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="noopener">Zero-Copy详细的技术</a></li></ol></li></ul><h2><span id="kafka架构">Kafka架构</span></h2><h2><span id="kafka架构图">Kafka架构图</span></h2><p><img src="/article/kafka/1568778317608kafka_.png" alt></p><ol><li><strong>Producer</strong> :消息生产者，就是向 kafka broker 发消息的客户端;</li><li><strong>Consumer</strong> :消息消费者，向 kafka broker 取消息的客户端;</li><li><strong>Consumer Group (CG)</strong>:消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费;消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker</strong> :一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li><li><strong>Topic</strong> :可以理解为一个队列，生产者和消费者面向的都是一个 topic;</li><li><strong>Partition</strong>:为了实现扩展性，一个非常大的 topic 可以分布到多个 broker(即服务器)上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列;</li><li><strong>Replica</strong>:副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。</li><li><strong>leader</strong>:每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。</li><li><strong>follower</strong>:每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。</li></ol><h2><span id="kafka深入理解">Kafka深入理解</span></h2><h2><span id="kafka-生产者">Kafka 生产者</span></h2><h3><span id="kafka-工作流程及文件存储机制">Kafka 工作流程及文件存储机制</span></h3><p><img src="/article/kafka/1568778701466kafka_.png" alt><br>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。</p><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><h3><span id="kafka的日志存贮">Kafka的日志存贮</span></h3><p>在kafka的配置文件当中有个名叫<code>log.dirs=/opt/module/kafka/logs</code> 的配置文件，主要是存放的是 partition 用于存放日志文件<br>来看一下日志文件的分布图<br><img src="/article/kafka/1568963295967kafka_.png" alt></p><h4><span id="partiton的分布">partiton的分布</span></h4><p>下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：</p><p><img src="/article/kafka/1568948547101kafka_.png" alt></p><ul><li>(1)指明 <code>partition</code> 的情况下，直接将指明的值直接作为 <code>partiton</code> 值;</li><li>(2)没有指明 <code>partition</code> 值但有 key 的情况下，将 key 的 hash 值与 topic 的 <code>partition</code> 数进行取余得到 <code>partition</code> 值;</li><li>(3)既没有 <code>partition</code> 值又没有 key 值的情况下，第一次调用时随机生成一个整数(后 面每次调用在这个整数上自增)，将这个值与 topic 可用的 <code>partition</code> 总数取余得到 <code>partition</code> 值，也就是常说的<code>round-robin</code> 算法。</li></ul><h4><span id="ptopic中partition存储分布">ptopic中partition存储分布</span></h4><p>下面示意图形象说明了partition中文件存储方式:<br><img src="/article/kafka/1568953593516kafka_.png" alt></p><p>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</p><p>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</p><ul><li><p><strong>partiton中segment文件存储结构</strong></p><ul><li><p>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.</p></li><li><p>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</p></li></ul><p>建一个topicXXX包含1 partition，设置每个segment大小为500MB,并启动producer向Kafka broker写入大量数据,如下图2所示segment文件列表形象说明了上述2个规则：</p><p><img src="/article/kafka/1568953760884kafka_.png" alt></p><p>接下来我们看一下 kafka segment 文件的详解：<br><img src="/article/kafka/1568953908892kafka_.png" alt></p><p>上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。 其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。</p><p>从上述图3了解到segment data file由许多message组成，下面详细说明message物理结构如下：<br><img src="/article/kafka/1568954000231kafka_.png" alt></p><table><thead><tr><th>关键字</th><th>解释说明</th></tr></thead><tbody><tr><td>8 byte offset</td><td>在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td></tr><tr><td>4 byte message size</td><td>message大小</td></tr><tr><td>4 byte CRC32</td><td>用crc32校验message</td></tr><tr><td>1 byte “magic”</td><td>表示本次发布Kafka服务程序协议版本号</td></tr><tr><td>1 byte “attributes”</td><td>表示为独立版本、或标识压缩类型、或编码类型。</td></tr><tr><td>4 byte key length</td><td>表示key的长度,当key为-1时，K byte key字段不填</td></tr><tr><td>K byte key</td><td>可选</td></tr><tr><td>value bytes payload</td><td>表示实际消息数据。</td></tr></tbody></table></li></ul><h4><span id="在partition中如何通过offset查找message"><strong>在partition中如何通过offset查找message</strong></span></h4><p>例如读取offset=368776的message，需要通过下面2个步骤查找。</p><ul><li><p>第一步查找segment file 上述图2为例，其中00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1.同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset <strong>二分查找</strong>文件列表，就可以快速定位到具体文件。 当offset=368776时定位到00000000000000368769.index|log</p></li><li><p>第二步通过segment file查找message 通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</p></li></ul><p>这样做的优点，segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p><h3><span id="数据可靠性保证">数据可靠性保证</span></h3><ul><li><strong>副本数据同步策略以及</strong></li></ul><p>为了提高消息的可靠性，Kafka每个topic的partition有N个副本（replicas），其中N(大于等于1)是topic的复制因子（replica fator）的个数。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个broker失效情况下仍然保证服务可用。</p><p>在Kafka中发生复制时确保partition的日志能有序地写到其他节点上，N个replicas中，其中一个replica为leader，其他都为follower, leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。</p><p>假设我们有3个border, id 分别为 0,1,2,分别将信息放在 border0, border1, border2 目录下。此时我们创建一个 my-replicated-topic主题 我们将topic 分为3个分区和3个副本执行</p><blockquote><p>bin/kafka-topics.sh --create --bootstrap-server localhost:9000 --replication-factor 3 --partitions 3 --topic my-replicated-topic<br>然后我们查看一下 topic 的分布情况</p></blockquote><blockquote><p>bin/kafka-topics.sh --describe --bootstrap-server localhost:9000 --topic my-replicated-topic</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Topic:my-replicated-topicPartitionCount:3ReplicationFactor:3Configs:segment.bytes=536870912</span><br><span class="line">Topic: my-replicated-topicPartition: 0Leader: 2Replicas: 2,1,0Isr: 0,1,2</span><br><span class="line">Topic: my-replicated-topicPartition: 1Leader: 1Replicas: 1,0,2Isr: 0,1,2</span><br><span class="line">Topic: my-replicated-topicPartition: 2Leader: 0Replicas: 0,2,1Isr: 0,1,2</span><br></pre></td></tr></table></figure><blockquote><p>我来解释一下 Partition 0 ,代表0号分区，由于我们有3个分区和3个副本，所以Replicas中为 0号分区所在的border 分别为 2，1，0 而leader :2 代表2 好分区负责读写 至于这里头个ISR 后面在继续分析</p></blockquote><ul><li><strong>ACK应答机制</strong></li></ul><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack(acknowledgement 确认收到)，如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="/article/kafka/1568964462017kafka_.png" alt></p><p>kafka 提供了三种ACK机制</p><ul><li><p>0:producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据;</p></li><li><p>1:producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据;</p></li><li><p>-1(all):producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p></li><li><p><strong>ISR机制</strong><br>上述过程有个问题，即当ack设置为all的时候，leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢?</p><p>在zk中会保存AR（Assigned Replicas）列表，其中包含了分区所有的副本，其中 AR = ISR+OSR</p><p><strong>ISR（in sync replica）</strong>：</p><p>是kafka动态维护的一组同步副本，在ISR中有成员存活时，只有这个组的成员才可以成为leader，内部保存的为每次提交信息时必须同步的副本（acks = all时），每当leader挂掉时，在ISR集合中选举出一个follower作为leader提供服务，当ISR中的副本被认为坏掉的时候，会被踢出ISR，当重新跟上leader的消息数据时，重新进入ISR。</p><p>当然 ISR 在这里可以认为是活跃度border节点，当ack=all 的时候，只要保证所有isr中的节点同步完毕之后，就可以回复ACK消息。</p><p>kafka 会自己维护ISR里面border节点。kafka会根据中zk中的数据对border的活跃性做一个判断</p><ul><li>第一点：一个节点必须维持和zk的会话，通过zk的心跳检测实现</li><li>第二点：如果节点是一个slave也就是复制节点，那么他必须复制leader节点不能太落后。这里的落后可以指两种情况<ul><li>1：数据复制落后，slave节点和leader节点的数据相差较大，这种情况有一个缺点，在生产者突然发送大量消息导致网络堵塞后，大量的slav复制受阻，导致数据复制落后被大量的踢出ISR。</li><li>2：时间相差过大，指的是slave向leader请求复制的时间距离上次请求相隔时间过大。通过配置replica.lag.time.max就可以配置这个时间参数。这种方式解决了上述第一种方式导致的问题。</li></ul></li></ul></li></ul><blockquote><p>注意：最新的版本的kafka 已经干掉了 第一个中情况，采用了第二种时间的延迟的方式来维护ISR列表，原因是当kafka分批次发送消息，恰好这批消息是的 leader offset 大于ISR的临界值，那么kafka就会将所有的ISR 节点提出ISR列表，当同步完成之后，所有的follow 又和leader的值相等，这样就会将所有的节点加入ISR 这样一来，kafka 就会频繁的删减ISR列表</p></blockquote><p><strong>OSR（out sync replica）</strong>: 保存的副本不必保证必须同步完成才进行确认，OSR内的副本是否同步了leader的数据，不影响数据的提交，OSR内的follower尽力的去同步leader，可能数据版本会落后。</p><ul><li><strong>如果ISR内的全部副本挂掉怎么办？</strong><ul><li><p>服务直接不可用一段时间等待ISR中副本恢复</p><p>服务不可用方式这种适用在不允许消息丢失的情况下使用，适用于一致性大于可用性，可以有两种做法：</p><ul><li>设置ISR最小同步副本数量，如果ISR的当前数量大于设置的最小同步值，那么该分区才会接受写入，避免了ISR同步副本过少。如果小于最小值那么该分区将不接收写入。这个最小值设置只有在acks = all的时候才会生效。</li></ul></li><li><p>禁用unclean-leader选举，当isr中的所有副本全部不可用时，不可以使用OSR 中的副本作为leader，直接使服务不可用，直到等到ISR 中副本恢复再进行选举leader。</p></li></ul></li></ul><p>直接选择第一个副本作为leader的方式，适用于可用性大于一致性的场景，这也是kafka在isr中所有副本都死亡了的情况采用的默认处理方式，我们可以通过配置参数<code>unclean.leader.election.enable</code>来禁止这种行为，采用第一种方法。</p><ul><li><strong>ISR同步机制</strong></li></ul><p><img src="/article/kafka/1568966813187kafka_.png" alt></p><ul><li><p><strong>base offset</strong>：起始位移，replica中第一天消息的offset</p></li><li><p><strong>HW</strong>：replica高水印值，副本中最新一条已提交消息的位移。leader 的HW值也就是实际已提交消息的范围，每个replica都有HW值，但仅仅leader中的HW才能作为标示信息。什么意思呢，就是说当按照参数标准成功完成消息备份（成功同步给follower replica后）才会更新HW的值，代表消息理论上已经不会丢失，可以认为“已提交”。(也可以理解为指的是消费者能见到的最大的 offset)</p></li><li><p><strong>LEO</strong>：日志末端位移，也就是replica中下一条待写入消息的offset，注意哈，是下一条并且是待写入的，并不是最后一条。</p></li></ul><p>所以HW代表已经完成同步的数据的位置，LEO代表已经写入的最新位置，只有HW位置之前的才是可以被外界访问的数据。<br>现在就来看一下之前，broker从收到消息到返回响应这个黑盒子里发生了什么。<br><img src="/article/kafka/1568967144894kafka_.png" alt></p><ul><li><p>(1)follower 故障<br>follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。</p></li><li><p>(2)leader 故障<br>leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的 更多数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。<br><strong>注意:这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p></li></ul><h3><span id="exactly-once-语义">Exactly Once 语义</span></h3><ul><li><p><strong>At Least Once and At Most Once</strong></p><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。</p></li><li><p><strong>At Least Once</strong></p><p>可以保证数据不丢失，但是不能保证数据不重复;相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p></li></ul><p>0.11 版本的 Kafka，引入了一项重大特性:幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即:<br><strong>At Least Once + 幂等性 = Exactly Once</strong></p><p>要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka<br>的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。</p><p>开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。</p><p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。</p><ul><li><strong>Exactly Once</strong></li></ul><h2><span id="kafka-生产者">Kafka 生产者</span></h2><h3><span id="消费方式">消费方式</span></h3><p>consumer 采用 pull(拉)模式从 broker 中读取数据。</p><p>pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><h3><span id="消费者组">消费者组</span></h3><p>Kafka 存在 <code>Consumer Group</code>的概念，也就是 <code>group.id</code> 一样的 Consumer，这些 Consumer 属于同一个<code>Consumer Group</code>，组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。<br>当然，每个分区只能由同一个消费组内的一个consumer来消费。那么问题来了，同一个 Consumer Group 里面的 Consumer 是如何知道该消费哪些分区里面的数据呢？<br><img src="/article/kafka/1569295480813kafka_.png" alt></p><h3><span id="分区分配策略">分区分配策略</span></h3><p>在 Kafka 内部存在两种默认的分区分配策略：Range 和 RoundRobin。当以下事件发生时，Kafka 将会进行一次分区分配：</p><ul><li>同一个 Consumer Group 内新增消费者</li><li>消费者离开当前所属的Consumer Group，包括shuts down 或 crashes</li><li>订阅的主题新增分区</li><li>将分区的所有权从一个消费者移到另一个消费者称为重新平衡（rebalance），如何rebalance就涉及到本文提到的分区分配策略。</li></ul><p>下面我们将详细介绍 Kafka 内置的两种分区分配策略。本文假设我们有个名为 T1 的主题，其包含了10个分区，然后我们有两个消费者（C1，C2）来消费这10个分区里面的数据，而且 C1 的 num.streams = 1，C2 的 num.streams = 2。</p><p>Kafka 有两种分配策略，一是 <code>RoundRobin</code>，一是 <code>Range</code></p><ul><li>RoundRobin</li></ul><p><strong>使用RoundRobin策略有两个前提条件必须满足：</strong></p><ul><li>同一个Consumer Group里面的所有消费者的num.streams必须相等；</li><li>每个消费者订阅的主题必须相同。</li></ul><p>RoundRobin策略的工作原理：将<strong>所有主题</strong>的分区组成 TopicAndPartition 列表，然后对 TopicAndPartition 列表按照 hashCode 进行排序，然后按照轮询的方式进行分配</p><p><img src="/article/kafka/1569384344801kafka_.png" alt></p><ul><li>Range</li></ul><p><strong>Range策略是对每个主题而言的</strong></p><ul><li>首先对同一个主题里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。</li><li>在我们的例子里面，排完序的分区将会是0, 1, 2, 3, 4, 5, 6, 7, 8, 9；消费者线程排完序将会是C1-0, C2-0, C2-1。</li><li>然后将partitions的个数除于消费者线程的总数来决定每个消费者线程消费几个分区。</li><li>如果除不尽，那么前面几个消费者线程将会多消费一个分区。</li></ul><p>在我们的例子里面，我们有10个分区，3个消费者线程， 10 / 3 = 3，而且除不尽，那么消费者线程 C1-0 将会多消费一个分区，所以最后分区分配的结果看起来是这样的：</p><blockquote><p>C1-0 将消费 0, 1, 2, 3 分区</p></blockquote><blockquote><p>C2-0 将消费 4, 5, 6 分区</p></blockquote><blockquote><p>C2-1 将消费 7, 8, 9 分区</p></blockquote><p>假如我们有2个主题(T1和T2)，分别有10个分区，那么最后分区分配的结果看起来是这样的：</p><blockquote><p>C1-0 将消费 T1主题的 0, 1, 2, 3 分区以及 T2主题的 0, 1, 2, 3分区</p></blockquote><blockquote><p>C2-0 将消费 T1主题的 4, 5, 6 分区以及 T2主题的 4, 5, 6分区</p></blockquote><blockquote><p>C2-1 将消费 T1主题的 7, 8, 9 分区以及 T2主题的 7, 8, 9分区</p></blockquote><p>可以看出，C1-0 消费者线程比其他消费者线程多消费了2个分区，这就是Range strategy的一个很明显的弊端。</p><p><img src="/article/kafka/1569384264366kafka_.png" alt></p><h3><span id="offset">Offset</span></h3><h4><span id="offset-存贮">Offset 存贮</span></h4><p>在kafka 0.9版本之后，kafka为了降低zookeeper的io读写，减少network data transfer，也自己实现了在kafka server上存储consumer，topic，partitions，offset信息将消费的 offset 迁入到了 Kafka 一个名为 __consumer_offsets 的Topic中。<br>offset提交消息会根据消费组的key(消费组名称)进行分区. 对于一个给定的消费组,它的所有消息都会发送到唯一的broker,<br>这对offset的抓取请求会更加容易,因为不需要以分散-收集的方式对多个brokers发送请求并收集结果(只针对一个broker).</p><h4><span id="offset-提交方式">Offset 提交方式</span></h4><ul><li><p>自动提交</p><p>Kafka中偏移量的自动提交是由参数<code>enable_auto_commit</code>和<code>auto_commit_interval_ms</code>控制的，当<code>enable_auto_commit=True</code>时，Kafka在消费的过程中会以频率为<code>auto_commit_interval_ms</code>向Kafka自带的topic(__consumer_offsets)进行偏移量提交，具体提交到哪个Partation是以算法：<code>partation=hash(group_id)%50</code>来计算的。</p><blockquote><p>如：group_id=test_group_1，则partation=hash(“test_group_1”)%50=28</p></blockquote></li><li><p>手动提交</p><p>对于自动提交偏移量，如果auto_commit_interval_ms的值设置的过大，当消费者在自动提交偏移量之前异常退出，将导致kafka未提交偏移量，进而出现重复消费的问题，所以建议auto_commit_interval_ms的值越小越好。</p><p>鉴于Kafka自动提交offset的不灵活性和不精确性(只能是按指定频率的提交)，Kafka提供了手动提交offset策略。手动提交能对偏移量更加灵活精准地控制，以保证消息不被重复消费以及消息不被丢失。</p><p>对于手动提交offset主要有3种方式：</p><ol><li><p>同步提交 (consumer.commitSync())</p><p>虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞<br>吐量会收到很大的影响。因此更多的情况下，会选用异步提交 offset 的方式。</p></li><li><p>异步提交   consumer.commitAsync()</p></li></ol></li></ul><p>无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先<br>提交 offset 后消费，有可能造成数据的漏消费;而先消费后提交 offset，有可能会造成数据 的重复消费。</p><ul><li><p>自动管理</p><p>Kafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。<br>offset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace。</p><ul><li><p>当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发 生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance。</p></li><li><p>消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费</p></li></ul><p>kafka 提供了ConsumerRebalanceListener 类来监控 rebanlace</p><ul><li>当我们发生rebanlace 的时候需要将将offset 从落地库中取出来，最典型的应用就是将消息的落地和offset的提交做成一个事物。</li></ul></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/lizhitao/article/details/41778193" target="_blank" rel="noopener">Kafka集群partitions/replicas默认分配解析</a></li><li><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html" target="_blank" rel="noopener">Kafka文件存储机制那些事</a></li><li><a href="https://juejin.im/post/5c46e729e51d452c8e6d5679" target="_blank" rel="noopener">kafka-如何保证消息的可靠性与一致性</a></li><li><a href="https://juejin.im/post/5ccffe886fb9a03239689e5c" target="_blank" rel="noopener">kafka副本同步机制</a></li><li><a href="https://blog.csdn.net/lizhitao/article/details/23744675" target="_blank" rel="noopener">apache kafka系列之在zookeeper中存储结构</a></li><li><a href="https://zqhxuyuan.github.io/2016/02/18/Kafka-Consumer-Offset-Manager/" target="_blank" rel="noopener">译：Kafka消费者的Offset管理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇(1)</title>
      <link href="/article/database-clustered-index/"/>
      <url>/article/database-clustered-index/</url>
      
        <content type="html"><![CDATA[<h2><span id="索引概诉">索引概诉</span></h2><p><img src="/article/database-clustered-index/1575439752430database-clustered-index_.png" alt></p><h2><span id="索引详解">索引详解</span></h2><h2><span id="常见的索引算法">常见的索引算法</span></h2><p><img src="/article/database-clustered-index/1575459371999database-clustered-index_.png" alt></p><h3><span id="平衡二叉树索引">平衡二叉树索引</span></h3><p>二叉树的查找的时间复杂度是O(log2N)，其查找效率与深度有关，而普通的二叉树可能由于内部节点排列问题退化成链表，这样查找效率就会很低。因此平衡二叉树是更好的选择，因为它保持平衡，即通过旋转调整结构保持最小的深度。其查找的时间复杂度也是O(log2N)。</p><p>但实际上，数据库中索引的结构也并非AVL树或更优秀的红黑树，尽管它的查询的时间复杂度很低。</p><h3><span id="那为什么平衡二叉树不适合作为索引呢">那为什么平衡二叉树不适合作为索引呢？</span></h3><p>索引是存在于索引文件中，是存在于磁盘中的。因为索引通常是很大的，因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页的数据到内存中。而这个磁盘的读取的速度较内存中的读取速度而言是差了好几个级别。</p><p>注意，我们说的平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组。然后<strong>由于在逻辑结构上相近的节点在物理结构上可能会差很远</strong>。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。</p><p>而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。</p><h3><span id="为什么-二叉树物理结构上可能相差很远">为什么 二叉树物理结构上可能相差很远？</span></h3><p>举个例子：</p><p><img src="/article/database-clustered-index/1575457059710database-clustered-index_.png" alt></p><p>二叉树就物理结构来分可以分成：<strong>顺序存储</strong>结构和<strong>链式存储</strong>结构。</p><ul><li><p><strong>1. 顺序存储结构</strong>：</p><p>顺序存储结构，顾名思义就是二叉树的数据元素存放在一组连续的存储单元中。其主要有一下几个特点：</p><ul><li><p>① 逻辑上相邻的两个元素在物理位置上也是相邻的；</p></li><li><p>② 操作删除和插入的时候，需要整体移动元素；</p></li><li><p>③ 需要预先分配空间，不能动态增长；</p><p>例如：</p></li></ul></li></ul><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>下标</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td></tr></tbody></table><ul><li><p><strong>1. 链式存储结构：</strong></p><p>链式存储结构中二叉树的每个结点至少包含三个域：数据域、左指针域和右指针域。其二叉树是通过指针实现，链式存储结构有以下几个特点：</p><ul><li><p>① 逻辑上相邻的两个元素在物理位置上不一定是相邻的；</p></li><li><p>② 操作删除和插入的时候，不需要整体移动元素；只需要修改相应的指针即可；</p></li><li><p>③ 不需要预先分配空间；</p></li><li><p>④ 存储指针本身会消耗一定的存储的空间；</p><p>基本数据如下：</p></li></ul></li></ul><table><thead><tr><th>下标</th><th>左孩子</th><th>数据</th><th>右孩子</th></tr></thead><tbody><tr><td></td><td>left_child</td><td>data</td><td>right_child</td></tr></tbody></table><p>树的保存如下：</p><p><img src="/article/database-clustered-index/1575457965850database-clustered-index_.png" alt></p><p>由于索引是有序的， 所有我们可以假定 左子树小于右子树<br>即 <code>B &lt; A &lt; C ， D &lt; B &lt; E</code></p><p>如果也强制用数组表示的话：如下（0 表示为空）</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td>(2,A,3)</td><td>(4,B,5)</td><td>(6,C,7)</td><td>(8,D,9)</td><td>(10,E,0)</td><td>(0,F,0)</td><td>(0,G,0)</td><td>(0,H,0)</td><td>(0,I,0)</td><td>(0,J,0)</td></tr></tbody></table><p>所有,如果我要查找H 这个字符，当我们判断到到 <code>H &lt; D</code> 的时候，因为H D相差不是很大， 但是在数组存贮相差甚远。</p><p>所以当我们加载 1 - 6 的数据块的时候，H所在的 7 - 10 数据库就无法加载到内存当中。 所以，当找到D 的时候，我们需要再次进行一次io 将7 - 10 的数据块加载到内存当中。额外消耗了一次io。</p><h3><span id="b树索引">B树索引</span></h3><p>B树是平衡多叉树，解决了查找深度的问题。红黑树（平衡二叉树）没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。</p><p>局部性原理与磁盘预读：</p><blockquote><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<br>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><blockquote><p>程序运行期间所需要的数据通常比较集中。<br>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p></blockquote><p>B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p><p>B 树的索引结构：</p><p><img src="/article/database-clustered-index/1575516048252database-clustered-index_.png" alt></p><h3><span id="b树的索引">B+树的索引</span></h3><p>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据</p><p>B+树索引结构</p><p><img src="/article/database-clustered-index/1575516240587database-clustered-index_.png" alt></p><h3><span id="b树索引-vs-b树索引">B+树索引 VS B树索引</span></h3><ul><li>B树必须用中序遍历的方法按序扫库。</li><li>而B+树直接从叶子结点挨个扫一遍就完了，</li><li>B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</li><li>B+树非叶子节点不存数据，这样可以使得每一页能存贮更多的索引，是的树高减少。</li></ul><p>数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p><h2><span id="索引的种类">索引的种类</span></h2><p>按照索数据的组织方式，我们可以分<strong>聚簇索引，非聚簇索引（辅助索引）</strong><br>按照索引的作用 可以分为 <strong>主键索引，唯一索引，单建索引，复合索引，全文索</strong>引等。</p><h3><span id="主键索引">主键索引</span></h3><ul><li>概念：主键索引是唯一的，通常以表的ID设置为主键索引,一个表只能有一个主键索引，这是他跟唯一索引的区别。</li></ul><p>在 InnoDB 内部，表数据是优化主键快速查询而排列分布的，其查找速度是最快的，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。即使表中没有适合做主键的列，也推荐采用一个自动增长的整数主键(代理键)，那么这个表在增加数据的时候是顺序存放的，而且后续在别的表参考该外键查询的时候也会得到优化。</p><ul><li><p>主键的选择：</p><ul><li>显示的定义主键</li><li>如果没有，则非空的唯一索引（Unique NOT NULL</li><li>InnoDB 存储引擎自动创建一个 6 个字节大小的指针，用户不能查看或访问。</li></ul></li><li><p>主键的插入：<br>主键的推荐是使用自增的ID, 自增 ID 在插入的时候可以保证相邻的两条记录可能在同一个数据块,在插入的时候，由于要维持id的有序性，当自增的ID在物理上也连续，那么可以有效的减少磁盘块的加载次数。</p></li></ul><p><img src="/article/database-clustered-index/1575601089292database-clustered-index_.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="唯一索引">唯一索引</span></h3><ul><li>概念：唯一索引主要用于业务上的唯一约束</li><li>和主键的区别：他跟主键索引的区别是，一个表可以有多个唯一索引</li><li>创建语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="单键索">单键索</span></h3><ul><li>概念：以某一个字段为索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="联合索引">联合索引</span></h3><ul><li>概念：两个或两个以上字段联合组成一个索引</li><li>比如我们有表 如下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/article/database-clustered-index/1575611856923database-clustered-index_.png" alt></p><p>我们可以看到， 联合索引的结构依然是一个B+ 数的结构，只不过每一个节点存放的值并不是单个值，而是多个值。 节点的排序是先按照第一个索引的顺存放，然后再按照第二个索引大小的值存放，因此在叶子节点的排列应该是</p><pre><code>&gt; (1,1) (1, 2) (2, 1) (2, 4) (3,1) (3,2)</code></pre><ul><li><p>最左前缀</p><p>因此 对于查询</p><p><code>SELECT * FROM USER where a=xxx and b=xxx</code></p><p>我们当然可以通过索引查找对应的数值，因为 a最左边的索引，如果我们想要查<br><code>SELECT * FROM USER where b=xxx</code> 的时候，我们发现 b 在两个叶子节点数据分别为  1 2 1  和 4 1 3  完全无序， 那么因此，就不可以索引查询。因此这句话的查询索引就失效了。</p><p>这就是最左匹配原则。</p></li><li><p>上述的联合索引还有什么好处。因为我们的a b 是联合有序，那么在a 已经确定的情况下，我们可以直接利用索引，返回b的有序结合，不需要额外的二次排序。<br>比如如下语句</p><p><code>SELECT * FROM USER where a=xxx order by b desc limit 3</code></p><p>在a确定的情况下 b 已经是有序的了，所以不需要回表查询。</p></li></ul><h3><span id="全文索引">全文索引</span></h3><p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。<br>开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况<br>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；<br>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;<br>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。<br>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p><h3><span id="索引的使用场景">索引的使用场景</span></h3><ol><li>当数据多且字段值有相同的值得时候用普通索引。</li><li>当字段多且字段值没有重复的时候用唯一索引。</li><li>当有多个字段名都经常被查询的话用复合索引。</li><li>普通索引不支持空值，唯一索引支持空值。</li><li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li><li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li><li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li><li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li><li>所以，会对增删改的执行减缓速度，</li><li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li><li>更新太频繁地字段不适合创建索引。</li><li>不会出现在where条件中的字段不该建立索引。</li></ol><h3><span id="索引组织方式">索引组织方式：</span></h3><ul><li>聚簇索引</li></ul><p>InnoDB 可以看做是聚集索引，因为它的 B+ 树的叶结点包含了完整的数据记录。InnoDB 的数据文件本身就是索引文件，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，<strong>InnoDB 的所有辅助索引都引用主键作为 data 域</strong>。</p><ul><li>非聚簇索引（辅助索引）</li></ul><p>而 MyISAM 方式 B+ 树的叶结点只是存储了数据的地址，故称为非聚集索引。MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址；在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。</p><h3><span id="区别和用法">区别和用法</span></h3><p><img src="/article/database-clustered-index/1575614217485database-clustered-index_.png" alt></p><p>聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，根据主键查询可以直接利用聚簇索引定位到所在记录。</p><p>而普通索引根据申明这个索引时候的列来构建，<strong>叶子节点存放的是这一行记录对应的主键的值，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。</strong> 如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/weixin_30531261/article/details/79312676" target="_blank" rel="noopener">一步步分析为什么B+树适合作为索引的结构</a></li><li><a href="https://juejin.im/post/5cf3d550f265da1b76388a34" target="_blank" rel="noopener">MySQL 索引的原理与应用：索引类型，存储结构与锁</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事物 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(3)</title>
      <link href="/article/tcpip-tcpstatus/"/>
      <url>/article/tcpip-tcpstatus/</url>
      
        <content type="html"><![CDATA[<h2><span id="tcp-状态">TCP 状态</span></h2><p>一个TCP连接在它的生命周期内会有不同的状态。<br><img src="/article/tcpip-tcpstatus/1567651608053tcpip-tcpstatus_.png" alt></p><h3><span id="tcp状态图">TCP状态图</span></h3><p><img src="/article/tcpip-tcpstatus/1567653467803tcpip-tcpstatus_.png" alt></p><table>    <thead>        <tr>            <th>状态</th>            <th>描述</th>        </tr>    </thead>    <tbody>        <tr>            <td>LISTEN</td>            <td>等待来自远程TCP应用程序的请求</td>        </tr>        <tr>            <td>SYN_SENT</td>            <td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td>        </tr>        <tr>            <td>SYN-RECEIVED</td>            <td>该端点已经接收到连接请求并发送确认。                <br>该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td>        </tr>        <tr>            <td>ESTABLISHED</td>            <td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td>        </tr>        <tr>            <td>FIN_WAIT_1</td>            <td>等待来自远程TCP的终止连接请求或终止请求的确认</td>        </tr>        <tr>            <td>FIN_WAIT_2</td>            <td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td>        </tr>        <tr>            <td>CLOSE_WAIT</td>            <td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td>        </tr>        <tr>            <td>CLOSING</td>            <td>等待来自远程TCP的连接终止请求确认</td>        </tr>        <tr>            <td>LAST_ACK</td>            <td>等待先前发送到远程TCP的连接终止请求的确认</td>        </tr>        <tr>            <td>TIME_WAIT</td>            <td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td>        </tr>    </tbody></table><h3><span id="三次握手状态">三次握手状态</span></h3><h4><span id="closed">CLOSED：</span></h4><ul><li>起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。</li></ul><h4><span id="listen">LISTEN：</span></h4><ul><li>服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。</li></ul><h4><span id="syn_sent">SYN_SENT：</span></h4><ul><li>第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。</li></ul><h4><span id="syn_rcvd">SYN_RCVD：</span></h4><ul><li>第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即 SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。</li></ul><h4><span id="established">ESTABLISHED：</span></h4><ul><li>第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP 需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是 ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。</li></ul><h3><span id="四次回收状态">四次回收状态</span></h3><h4><span id="fin_wait_1">FIN_WAIT_1：</span></h4><ul><li>第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回 ACK 。调用 close() 第一次挥手就进入此状态。</li></ul><h4><span id="close_wait">CLOSE_WAIT：</span></h4><ul><li>接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送 ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。前面已经说过，TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入 LAST_ACK 状态。</li></ul><h4><span id="fin_wait_2">FIN_WAIT_2：</span></h4><ul><li>主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK 后进入此状态。</li></ul><h4><span id="last_ack">LAST_ACK：</span></h4><ul><li>被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。</li></ul><h4><span id="closing">CLOSING：</span></h4><ul><li>两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。</li></ul><h4><span id="time_wait">TIME_WAIT：</span></h4><ul><li>从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。主动关闭方在接收到被动关闭方的FIN请求后，发送成功给对方一个ACK后,将自己的状态由FIN_WAIT2修改为TIME_WAIT，而必须再等2倍 的MSL(Maximum Segment Lifetime,MSL是一个数据报在internetwork中能存在的时间)时间之后双方才能把状态 都改为CLOSED以关闭连接。目前RHEL里保持TIME_WAIT状态的时间为60秒。当然上述很多TCP状态在系统里都有对应的解释或设置,可见man tcp</li></ul><h3><span id="为什么建立连接协议是三次握手而关闭连接却是四次握手呢">为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</span></h3><ul><li>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><h3><span id="为什么time_wait状态还需要等2msl后才能返回到closed状态">为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</span></h3><ul><li>虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</li></ul><h2><span id="常用tcpip抓包命令">常用TCP/IP抓包命令</span></h2><table><thead><tr><th>命令</th><th>命令说明</th><th>命令返回结果</th></tr></thead><tbody><tr><td><code>netstat -an</code></td><td>查看哪些IP连接本机</td><td></td></tr><tr><td><code>netstat -nat|grep -i &quot;xx&quot;|wc -l</code></td><td>统计xx端口连接数</td><td></td></tr><tr><td><code>ps -ef|grep httpd|wc -l</code></td><td>统计httpd协议连接数</td><td></td></tr><tr><td><code>netstat -na|grep ESTABLISHED|wc -l</code></td><td>统计已连接上的，状态为established</td><td></td></tr><tr><td><code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</code></td><td>查看TCP网络连接情况</td><td></td></tr></tbody></table><h2><span id="tcp常见问题排查和解决">TCP常见问题排查和解决</span></h2><h3><span id="tcp的time_wait问题">TCP的TIME_WAIT问题</span></h3><ul><li><p>问题产生原因<br>由于主动关闭的一方在发送最后一个ACK后就会进入TIME_WAIT状态，并停留2MSL（Max Segment LifeTime）时间。所以，频繁的重复链接相同的IP地址，可能会导致大量的TIME_WAIT 状态。</p></li><li><p>五元组</p><p>网络中每个通信实体的 <code>socket</code> 是用一个三元组标识的。<strong>三元组指的是：协议族（地址族），网络地址、和传输层端口 （本文目前只介绍 Ipv4 ）。</strong></p><p>通信双方的一个连接是用网络五元组来标识的，它是由双方相同协议族的两个本地三元组合成的。**网络五元组指的是：协议族（地址族）、本地网络地址、本地端口、远程网络地址和远程端口。**上述五元组往往称为全相关。而三元组往往称为半相关</p><p>在监听的时候，协议 / 本地 IP/ 本地端口（监听端口）都是确定的，当收到客户端的报文时，远方 IP 就是报文的源 IP 地址，远方端口就是报文的源端口，这样一来五元组就确定了。</p><p>然后服务器进入处理阶段，需要开启一个新的线程与客户端交互，当然就需要确定一个新的五元组，这时候协议 / 本地 IP/ 远方 IP/ 远方端口都来自监听阶段确定的五元组，而本地端口会在 1024 以上随机选取 （不再使用监听端口，以便监听其他客户端的请求）。</p><p>客户端的话正好相反，在发送请求时采用随机的本地端口 ，而接受响应时采用服务器的源端口作为远方端口。</p><p><strong>如果占用本地端口过多，大量的新链接失败。</strong></p></li><li><p>查看TIME_WAIT的数量<br><code>netstat -n | awk '/^tcp/ {++S[$NF]} END { for(a in S) print(a,S[a])}'</code></p></li><li><p>短连接最大的缺点是将占用大量的系统资源，例如：本地端口、socket句柄。导致这个问题的原因其实很简单：<strong>tcp协议层并没有长短连接的概念，因此不管长连接还是短连接，连接建立-&gt;数据传输-&gt;连接关闭的流程和处理都是一样的</strong>。</p></li><li><p>TIME_WAIT的状态，持续的时间一般在1~4分钟，对于连接数不高的场景，1~4分钟其实并不长，对系统也不会有什么影响，但如果短时间内（例如1s内）进行大量的短连接</p></li><li><p>问题的调优</p></li></ul><ul><li>1）修改<strong>ipv4.ip_local_port_range</strong>，增大可用端口范围，但只能缓解问题，不能根本解决问题；</li><li>2）客户端程序中设置socket的SO_LINGER选项；</li><li>3）客户端机器打开tcp_tw_recycle和tcp_timestamps选项；<ul><li><strong>tcp_tw_reuse</strong>:让TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒- <strong>tcp_tw_recycle</strong>: 让TIME_WAIT尽快回收</li></ul></li><li>4）客户端机器设置tcp_max_tw_buckets为一个很小的值；</li><li><ol start="5"><li>客户端利用  shutdown() 替换 close()</li></ol></li></ul><h3><span id="tcp的close_wait问题">TCP的CLOSE_WAIT问题</span></h3><h3><span id="tcp-rst-复位报文">TCP RST 复位报文</span></h3><h4><span id="rst-复位">RST 复位</span></h4><p>RST表示复位，用来异常的关闭连接。发送RST包关闭连接时，不必等缓冲区的包都发出去（FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。TCP处理程序会在自己认为的异常时刻发送RST包。<br>举2种情况：</p><ul><li>a）C向S发起连接，但S之上并未监听相应的端口，这时S操作系统上的TCP处理程序会发RST包。（UDP没有连接，没有RST）</li><li>b）C和S已经正常建立连接，正在通讯时，C向S发送了FIN包要求关连接，S发送ACK后，C网断了，C通过若干原因放弃了这个连接（例如进程重启）。网络恢复之后，S又开始或重发数据包，C不知道这连接哪来的，就发RST包强制把连接关闭，S收到后会出现connect reset by peer错误。</li></ul><p>RST 出现的三种情况 TCP在下列三种情况下产生RST复位报文段。</p><ul><li><p>1.到不存在的端口的连接请求<br>　　产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在监听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息；而TCP则使用复位。</p></li><li><p>2.异常终止一个连接<br>　　终止一个连接的正常方式是一方发送FIN，这也称为有序释放，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是FIN来中途释放一个连接，这也称为异常释放。异常终止一个连接对应用程序来说有两个优点：（1）丢弃任何待发数据并立即发送复位报文段；（2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。</p></li><li><p>3.检测半关闭连接<br>　　如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。</p></li></ul><h4><span id="rst-复位攻击">RST 复位攻击</span></h4><p>A和服务器B之间建立了TCP连接，如果此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击。<br>伪造这样的TCP包能造成什么后果？</p><ul><li>1、假定C伪装成A发过去的包，这个包如果是RST包，冲区上所有数据B将会丢弃与A的缓，强制关掉连接。</li><li>2、如果发过去的包是SYN包，那么，B会表示A已经是正常连接却又来建新连接，B主动向A发个RST包，并在自己这端强制关掉连接。<br><strong>如何伪造成A发给B的包？</strong></li></ul><p>这里有两个关键因素，源端口和序列号。</p><p><strong>一个TCP连接都是四元组，由源IP、源端口、目标IP、目标端口唯一确定一个连接</strong>。所以，如果C要伪造A发给B的包，要在上面提到的IP头和TCP头，把源IP、源端口、目标IP、目标端口都填对。</p><ul><li><p>1）这里B作为服务器，IP和端口是公开的；</p></li><li><p>2）A是我们要下手的目标，IP当然知道，但A的源端口就不清楚了，因为这可能是A随机生成的。当然，如果能够对常见的OS如windows和linux找出生成source port规律的话，还是可以进行碰撞。</p></li><li><p>3）序列号问题是与滑动窗口对应的，伪造的TCP包里需要填序列号，如果序列号的值不在A之前向B发送时B的滑动窗口内，B是会主动丢弃的。所以我们要找到能落到当时的AB间滑动窗口的序列号。这个可以暴力解决，因为一个sequence长度是32位，取值范围0-4294967296，如果窗口大小像上图中我抓到的windows下的65535的话，只需要相除，就知道最多只需要发65537（4294967296/65535=65537）个包就能有一个序列号落到滑动窗口内。RST包是很小，IP头＋TCP头才40字节，算算我们的带宽就知道这实在只需要几秒钟就能搞定。</p></li><li><p>那么，序列号不是问题，源端口会麻烦点，如果各个操作系统不能完全随机的生成源端口，或者黑客们能通过其他方式获取到source port，RST攻击存在可能。</p></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/hguisu/article/details/38700899" target="_blank" rel="noopener">TCP连接的状态详解以及故障排查</a></li><li><a href="https://www.cnblogs.com/cslunatic/p/3783281.html" target="_blank" rel="noopener">TCP/IP详解–TCP/IP连接各个状态转换分析</a></li><li><a href="https://blog.csdn.net/wenqian1991/article/details/40110703" target="_blank" rel="noopener">【Unix 网络编程】TCP状态转换图详解</a></li><li><a href="https://blog.csdn.net/yunhua_lee/article/details/8146830_" target="_blank" rel="noopener">tcp短连接TIME_WAIT问题解决方法大全（1）</a></li><li><a href="https://www.superltx.com/archives/56" target="_blank" rel="noopener">TCP安全——RST复位攻击简析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之深入分析synchronized原理和锁膨胀过程</title>
      <link href="/article/java-synchronized/"/>
      <url>/article/java-synchronized/</url>
      
        <content type="html"><![CDATA[<h2><span id="synchronized概述">synchronized概述</span></h2><p>synchronized 是锁同步的一个关键字，这里主要讲解这个关键的概念性的东西，不做扫盲。</p><h2><span id="特性">特性</span></h2><ul><li>可见性</li><li>有序性</li><li>可见性</li><li>原子性</li></ul><h2><span id="synchronized-优化历史">synchronized 优化历史</span></h2><h2><span id="锁膨胀详解">锁膨胀详解</span></h2><h2><span id="前言">前言</span></h2><p>上一篇文章介绍了多线程的概念及<code>synchronized</code>的使用方法<a href="https://link.juejin.im?target=https%3A%2F%2Fddnd.cn%2F2019%2F03%2F21%2Fjava-synchronized%2F" target="_blank" rel="noopener">《synchronized的使用（一）》</a>，但是仅仅会用还是不够的，只有了解其底层实现才能在开发过程中运筹帷幄，所以本篇探讨<code>synchronized</code>的实现原理及锁升级(膨胀)的过程。</p><h2><span id="synchronized实现原理">synchronized实现原理</span></h2><p><code>synchronized</code>是依赖于<code>JVM</code>来实现同步的，在同步方法和代码块的原理有点区别。</p><h3><span id="同步代码块">同步代码块</span></h3><p>我们在代码块加上<code>synchronized</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: getfield      #2                  // Field object:Ljava/lang/String;</span><br><span class="line">        <span class="number">4</span>: dup</span><br><span class="line">        <span class="number">5</span>: astore_1</span><br><span class="line">        <span class="number">6</span>: monitorenter</span><br><span class="line">        7: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       10: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">13</span>: dup</span><br><span class="line">       14: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       17: ldc           #6                  // String synSay----</span><br><span class="line">       19: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       22: invokestatic  #8                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       25: invokevirtual #9                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       31: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       34: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">37</span>: aload_1</span><br><span class="line">       <span class="number">38</span>: monitorexit</span><br><span class="line">       <span class="number">39</span>: goto          <span class="number">47</span></span><br><span class="line">       <span class="number">42</span>: astore_2</span><br><span class="line">       <span class="number">43</span>: aload_1</span><br><span class="line">       <span class="number">44</span>: monitorexit</span><br><span class="line">       <span class="number">45</span>: aload_2</span><br><span class="line">       <span class="number">46</span>: athrow</span><br><span class="line">       <span class="number">47</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">7</span>    <span class="number">39</span>    <span class="number">42</span>   any</span><br><span class="line">           <span class="number">42</span>    <span class="number">45</span>    <span class="number">42</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">22</span>: <span class="number">7</span></span><br><span class="line">       line <span class="number">23</span>: <span class="number">37</span></span><br><span class="line">       line <span class="number">24</span>: <span class="number">47</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">48</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br><span class="line">     StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">       frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">         offset_delta = <span class="number">42</span></span><br><span class="line">         locals = [ class cn/T1, class java/lang/Object ]</span><br><span class="line">         stack = [ class java/lang/Throwable ]</span><br><span class="line">       frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">         offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现<code>synchronized</code>同步代码块是通过加<code>monitorenter</code>和<code>monitorexit</code>指令实现的。</p><p>每个对象都有个**监视器锁(<code>monitor</code>) **，当<code>monitor</code>被占用的时候就代表对象处于锁定状态，而<code>monitorenter</code>指令的作用就是获取<code>monitor</code>的所有权，<code>monitorexit</code>的作用是释放<code>monitor</code>的所有权，这两者的工作流程如下：</p><p><strong>monitorenter</strong>：</p><ol><li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li><li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li><li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，知道<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li></ol><p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p><h3><span id="同步方法">同步方法</span></h3><p>在方法上加上<code>synchronized</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">6</span>: dup</span><br><span class="line">        7: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       10: ldc           #5                  // String synSay----</span><br><span class="line">       12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       15: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       18: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       24: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       27: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">21</span>: <span class="number">30</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br></pre></td></tr></table></figure><p>从字节码上看，加有<code>synchronized</code>关键字的方法，常量池中比普通的方法多了个<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>就是根据这个标识来实现方法的同步。</p><p>当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p><h3><span id="两种同步方式区别">两种同步方式区别</span></h3><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong>。</p><p>而 <code>synchronized</code> 同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。</p><p><strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong></p><p>线程获取、释放<code>monitor</code>的过程如下：</p><p><img src="/article/java-synchronized/1578390033012java-synchronized_.png" alt></p><p>线程尝试获取<code>monitor</code>的所有权，如果获取失败说明<code>monitor</code>被其他线程占用，则将线程加入到的<strong>同步队列</strong>中，等待其他线程释放<code>monitor</code>，<strong>当其他线程释放<code>monitor</code>后，有可能刚好有线程来获取<code>monitor</code>的所有权，那么系统会将<code>monitor</code>的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以<code>synchronized</code>是非公平锁</strong>。如果线程获取<code>monitor</code>成功则进入到<code>monitor</code>中，并且将其进入数<code>+1</code>。</p><blockquote><p>关于什么是公平锁、非公平锁可以参考一下美团技术团队写的<a href="https://link.juejin.im?target=https%3A%2F%2Ftech.meituan.com%2F2018%2F11%2F15%2Fjava-lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a></p></blockquote><p>到这里我们也清楚了<code>synchronized</code>的语义底层是通过一个<code>monitor</code>的对象完成，其实<code>wait</code>、<code>notiyf</code>和<code>notifyAll</code>等方法也是依赖于<code>monitor</code>对象来完成的，<strong>这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常</strong></p><h2><span id="java对象的组成">Java对象的组成</span></h2><p>我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？</p><p>为了解开这个疑问，我们需要进入<strong>Java虚拟机(JVM)</strong> 的世界。在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p><p><img src="/article/java-synchronized/1578390964423java-synchronized_.png" alt></p><h3><span id="对象头">对象头</span></h3><p>对象头的数据长度在<code>32</code>位和<code>64</code>位(未开启压缩指针)的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。对象头由以下三个部分组成：<br><img src="/article/java-synchronized/1578391080054java-synchronized_.png" alt></p><ul><li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li><li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li></ul><p>在<code>32</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>5</code>种中的一种。</p><p><img src="/article/java-synchronized/1578391108895java-synchronized_.png" alt></p><p>在<code>64</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>2</code>种中的一种。</p><p><img src="/article/java-synchronized/1578391116559java-synchronized_.png" alt></p><p>这里重点注意<strong>是否偏向锁</strong>和<strong>锁标志位</strong>，这两个标识和<code>synchronized</code>的锁膨胀息息相关。</p><h3><span id="实例数据">实例数据</span></h3><p>储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。</p><h3><span id="对齐填充">对齐填充</span></h3><p><code>HotSpot</code>虚拟机的对齐方式为<code>8</code>字节对齐，即一个对象必须为<code>8</code>字节的整数倍，如果不是，则通过这个对齐填充来占位填充。</p><h2><span id="synchronized锁膨胀过程">synchronized锁膨胀过程</span></h2><p>上文介绍的 “<code>synchronized</code>实现原理” 实际是synchronized实现<strong>重量级锁的原理</strong>，那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？</p><p><strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>，如图：</p><p><img src="/article/java-synchronized/1578391201137java-synchronized_.png" alt></p><p><img src="/article/java-synchronized/1578391213485java-synchronized_.png" alt></p><p>那锁的状态为其它状态的时候是不是就没用上<code>monitor</code>对象？答案:是的。</p><p>这也是<code>JVM</code>对<code>synchronized</code>的优化，我们知道重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以<code>JVM</code>对<code>synchronized</code>做了优化，<code>JVM</code>先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用<code>monitor</code>对象。当然<code>JVM</code>对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p><p>那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。</p><h3><span id="锁的优化">锁的优化</span></h3><h4><span id="自旋锁和自适应性自旋锁">自旋锁和自适应性自旋锁</span></h4><p><strong>自旋</strong>：当有个线程<code>A</code>去请求某个锁的时候，这个锁正在被其它线程占用，但是线程<code>A</code>并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程<code>A</code>可以尝试一直请求锁，没必要被挂起放弃<code>CPU</code>时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程<code>A</code>自旋指定的时间还没有获得锁，仍然会被挂起。</p><p><strong>自适应性自旋</strong>：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。</p><p>反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p><h4><span id="锁消除">锁消除</span></h4><p>锁消除是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p><h4><span id="锁粗化">锁粗化</span></h4><p>在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是<strong>为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁</strong>。</p><h4><span id="轻量级锁">轻量级锁</span></h4><p>所谓<strong>轻量级锁</strong>是相对于使用底层操作系统<code>mutex</code>互斥原语实现同步的<strong>重量级锁</strong>而言的，因为轻量级锁同步的<strong>实现是基于对象头的Mark Word</strong>。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。</p><p><strong>获取锁过程</strong>：</p><ol><li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为&quot;01&quot;状态，是否为偏向锁为&quot;0&quot;)</strong>，虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li></ol><p><img src="/article/java-synchronized/1578391357996java-synchronized_.png" alt></p><ol><li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li><li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li><li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为&quot;00&quot;，即表示此对象处于轻量级锁的状态。</strong>。</li></ol><p><img src="/article/java-synchronized/1578391371386java-synchronized_.png" alt></p><ol><li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为&quot;10&quot;，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li></ol><p><img src="/article/java-synchronized/1578391379352java-synchronized_.png" alt></p><p><strong>释放锁的过程</strong>：</p><ol><li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li><li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h4><span id="偏向锁">偏向锁</span></h4><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，<strong>进一步提高程序的运行性能</strong>。如果说轻量级锁是在无竞争的情况下使用<code>CAS</code>操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不用做了。<strong>偏向锁默认是开启的，也可以关闭</strong>。</p><p>偏向锁&quot;偏&quot;，就是&quot;偏心&quot;的&quot;偏&quot;，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p><strong>获取锁的过程</strong>：</p><ol><li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li><li>如果是可偏向锁，则<strong>检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code></strong>，如果是则执行同步块，否则执行步骤<code>3</code>。</li><li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li><li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li></ol><p><strong>锁释放的过程</strong>：</p><ol><li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li><li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li><li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)</strong>，以允许其他线程竞争，如果<strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁<strong>升级为轻量级锁状态(00)</strong>。</li></ol><p><img src="/article/java-synchronized/1578391391238java-synchronized_.png" alt></p><h3><span id="锁的转换过程">锁的转换过程</span></h3><p>锁主要存在<code>4</code>种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。<strong>需要注意锁可以升级，但是不可以降级。</strong></p><p><img src="/article/java-synchronized/1578391399369java-synchronized_.png" alt></p><p>这里盗个图，这个图总结的挺好的！(图被压缩过了 看不清，可以打开这个地址查看高清图<a href="https://link.juejin.im?target=http%3A%2F%2Fwx2.sinaimg.cn%2Flarge%2Fe0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg" target="_blank" rel="noopener">&gt;&gt;高清图&lt;&lt;</a>)</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9246f01f2cb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h3><span id="三种锁的优缺点比较">三种锁的优缺点比较</span></h3><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a5f7ba6ea3333?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2><span id="参考">参考</span></h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Flkforce%2Farticle%2Fdetails%2F81128115%23%25E4%25B8%2580%25EF%25BC%258C%25E5%25AF%25B9%25E8%25B1%25A1%25E5%25A4%25B4" target="_blank" rel="noopener">Java的对象头和对象组成详解</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fliupeifeng3514%2Farticle%2Fdetails%2F79111565" target="_blank" rel="noopener">JVM（三）JVM中对象的内存布局详解</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fzhengbin%2Fp%2F6490953.html" target="_blank" rel="noopener">JVM——深入分析对象的内存布局</a></li><li><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f#heading-16" target="_blank" rel="noopener">啃碎并发（七）：深入分析Synchronized原理</a><br><a href="https://link.juejin.im?target=http%3A%2F%2Fbigdatadecode.club%2FJavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(2)</title>
      <link href="/article/Java-AQS2/"/>
      <url>/article/Java-AQS2/</url>
      
        <content type="html"><![CDATA[<h2><span id="aqs-共享功能的实现">AQS 共享功能的实现</span></h2><h2><span id="countdownlatch-的用法">CountDownLatch 的用法</span></h2><p>CountDownLatch，CountDownLatch 为 <code>java.util.concurrent</code>包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减 1 操作，并在计数器为 0 后调用 <code>await</code> 方法的线程被唤醒，从而实现多线程间的协作。它在多线程环境下的基本使用方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main thread 新建一个 CountDownLatch，并指制定一个初始大小 </span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 调用 await 方法后，main 线程将阻塞在这里，直到 countDownLatch 中的计数为 0 </span></span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"over"</span>);</span><br><span class="line"><span class="comment">//thread1</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread3</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br></pre></td></tr></table></figure><p>注意，线程 thread 1,2,3 各自调用 <code>countDown</code> 后，<code>countDownLatch</code>的计数为 <code>0，await</code> 方法返回，控制台输入“over”, 在此之前 main thread 会一直沉睡。<br>可以看到 <code>CountDownLatch</code> 的作用类似于一个“栏栅”，在 <code>CountDownLatch</code> 的计数为 0 前，调用 await 方法的线程将一直阻塞，直到 <code>CountDownLatch</code> 计数为 0，await 方法才会返回，<br>而 <code>CountDownLatch</code> 的 <code>countDown()</code> 方法则一般由各个线程调用，实现 <code>CountDownLatch</code> 计数的减 1。</p><h2><span id="countdownlatch-的实现">CountDownLatch 的实现</span></h2><h3><span id="构造函数">构造函数</span></h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和 <code>ReentrantLock</code> <code>类似，CountDownLatch</code> 内部也有一个叫做 <code>Sync</code> 的内部类，同样也是用它继承了 AQS。</p><h3><span id="await">await</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      <span class="comment">// 同理  tryAcquireShared 是实现类实现的 这一点和读写锁一样</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sync-共享锁">Sync 共享锁</span></h3><p>从方法名上看，这个方法的调用是响应线程的打断的，所以在前两行会检查下线程是否被打断。接着，尝试着获取共享锁，小于 0，表示获取失败，通过本系列的上半部分的解读， 我们知道 AQS 在获取锁的思路是，先尝试直接获取锁，如果失败会将当前线程放在队列中，按照 FIFO 的原则等待锁。而对于共享锁也是这个思路，如果和独占锁一致，这里的 <code>tryAcquireShared</code> 应该是个空方法，留给子类去判断，我们来看 <code>Sync</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123; setState(count);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState();&#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 state 变成 0 了，则返回 1，表示获取成功，否则返回 -1 则表示获取失败。</span></span><br><span class="line"><span class="comment">     * 看到这里，读者可能会发现， await 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 tryAcquireShared 呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，读者可能会发现， <code>await</code> 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 <code>tryAcquireShared</code> 呢？</p><p>回想下 <code>CountDownLatch</code> 的 <code>await</code> 方法是不是只能在主线程中调用？答案是否定的，<code>CountDownLatch</code> 的 <code>await</code> 方法可以在多个线程中调用，当 <code>CountDownLatch</code> 的计数器为 <code>0</code> 后，调用 <code>await</code> 的方法都会依次返回。 也就是说可以多个线程同时在等待 <code>await</code> 方法返回，所以它被设计成了实现 <code>tryAcquireShared</code> 方法，获取的是一个共享锁，锁在所有调用 <code>await</code> 方法的线程间共享，所以叫共享锁。</p><p>如果获取共享锁失败（返回了 -1，说明 <code>state</code> 不为 0，也就是 <code>CountDownLatch</code> 的计数器还不为 0），进入调用 <code>doAcquireSharedInterruptibly</code> 方法中，按照我们上述的猜想，应该是要将当前线程放入到队列中去。</p><p>在这之前，我们再回顾一下 AQS 队列的数据结构：AQS 是一个双向链表，通过节点中的 next，pre 变量分别指向当前节点后一个节点和前一个节点。其中，每个节点中都包含了一个线程和一个类型变量：表示当前节点是独占节点还是共享节点，头节点中的线程为正在占有锁的线程，而后的所有节点的线程表示为正在等待获取锁的线程。</p><p><img src="/article/Java-AQS2/1563765045994java-AQS_.png" alt></p><p>黄色节点为头节点，表示正在获取锁的节点，剩下的蓝色节点（Node1、Node2、Node3）为正在等待锁的节点，他们通过各自的 next、pre 变量分别指向前后节点，形成了 AQS 中的双向链表。每个线程被加上类型（共享还是独占）后便是一个 Node， 也就是本文中说的节点。<br>我再来看 <code>doAcquireSharedInterruptibly</code> 方法</p><h3><span id="sync-doacquiresharedinterruptibly-方法">Sync doAcquireSharedInterruptibly 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); </span><br><span class="line"><span class="comment">// 将当前线程包装为类型为 Node.SHARED 的节点，标示这是一个共享节点。</span></span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="comment">// 如果新建节点的前一个节点，就是 Head，说明当前节点是 AQS 队列中等待获取锁的第一个节点，</span></span><br><span class="line">            <span class="comment">// 按照 FIFO 的原则，可以直接尝试获取锁。</span></span><br><span class="line">              <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">              <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  setHeadAndPropagate(node, r); </span><br><span class="line">              <span class="comment">// 获取成功，需要将当前节点设置为 AQS 队列中的第一个节点，这是 AQS 的规则</span></span><br><span class="line">              <span class="comment">// 队列的头节点表示正在获取锁的节点 </span></span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 检查下是否需要将当前节点挂起 </span></span><br><span class="line">              parkAndCheckInterrupt()) </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">          cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几点需要说明的：</p><ol><li>setHeadAndPropagate 方法：<br>调用 setHeadAndPropagate 的方法的前提是 当前线程已经获取到了锁，且是第一个排队的节点，意味着和他的head 为空节点，<br>当第一个排队的线程获取到了 锁之后， 首要的任务就是<br>1、将自己弄成头结点，然后清空自己的节点为null<br>2、然后判断排队自己后边排队的节点，如果是共享模式的，那么唤醒这个节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);  <span class="comment">//将自己弄成头结点，然后清空自己的节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sync-doreleaseshared-方法">Sync doReleaseShared 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 这里为什么要 拿到head 因为共享锁是可以传播的，意思是如果某一个共享锁阻塞的线程被唤醒了</span></span><br><span class="line">      <span class="comment">// 那么意味着 排队链上的所有线程都应该被唤醒</span></span><br><span class="line">      <span class="comment">// 加入 当前线程是在 排队链的第n 个那么当唤醒的时候，我们要找到头部链</span></span><br><span class="line">      <span class="comment">// 如果 然后将head 链 唤醒，然后在 一次传播 </span></span><br><span class="line">      <span class="comment">// 如果 头结点是当前线程，那就意味着头结点已经被唤醒了或者已经持有锁了，那么意味着已经做过</span></span><br><span class="line">      <span class="comment">// 唤醒其他的操作了 详情看上面的代码 所有退出</span></span><br><span class="line">      <span class="comment">// 如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功</span></span><br><span class="line">      Node h = head;</span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; </span><br><span class="line">              <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) </span><br><span class="line">            <span class="comment">// 如果当前节点是 SIGNAL 意味着，它正在等待一个信号 可以理解为在已经是阻塞状态了，  </span></span><br><span class="line">              <span class="comment">// 或者说，它在等待被唤醒，因此做两件事，1 是重置 waitStatus 标志位，2 是重置成功后, 唤醒下一个节点。</span></span><br><span class="line">                  <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))  </span><br><span class="line"><span class="comment">// 如果本身头节点的 waitStatus 是出于重置状态（waitStatus==0）的，将其设置为“传播”状态。</span></span><br><span class="line"><span class="comment">// 意味着需要将状态向后一个节点传播。</span></span><br><span class="line">              <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要这么做呢？这就是共享功能和独占功能最不一样的地方，对于独占功能来说，有且只有一个线程（通常只对应一个节点，拿 ReentantLock 举例，如果当前持有锁的线程重复调用 lock() 方法，那根据本系列上半部分我们的介绍，我们知道，会被包装成多个节点在 AQS 的队列中，所以用一个线程来描述更准确），能够获取锁，但是对于共享功能来说。<br>共享的状态是可以被共享的，也就是意味着其他 AQS 队列中的其他节点也应能第一时间知道状态的变化。因此，一个节点获取到共享状态流程图是这样的：</p><p>例如，当多个线程调用了<code>await</code> 方法的时候，这时候在Sycn 中会有一个等队列如下图：<br><img src="/article/Java-AQS2/1564037960989Java-AQS2_.png" alt></p><p>Node1 变成了头节点然后调用 <code>unparkSuccessor</code>() 方法唤醒了 Node2、Node2 中持有的线程 A 出于上面流程图的 park node 的位置， 还记得 <code>doAcquireSharedInterruptibly</code> 里面的for循环吗，当Node2唤醒之后 会计入这个for循环当中，然后会判断当前node的 父节点，并唤醒。</p><p>线程 A 被唤醒后，重复黄色线条的流程，重新检查调用 <code>tryAcquireShared</code> 方法，看能否成功，如果成功，则又更改头节点，重复以上步骤，以实现节点自身获取共享锁成功后，唤醒下一个共享类型节点的操作，实现共享状态的向后传递。</p><ol><li>其实对于 doAcquireShared 方法，AQS 还提供了集中类似的实现：<br><img src="/article/Java-AQS2/1564041186249Java-AQS2_.png" alt><br>分别对应了：</li></ol><ul><li>带参数请求共享锁。 （忽略中断）</li><li>带参数请求共享锁，且响应中断。（每次循环时，会检查当前线程的中断状态，以实现对线程中断的响应）</li><li>带参数请求共享锁但是限制等待时间。（第二个参数设置超时时间，超出时间后，方法返回。）</li></ul><p><img src="/article/Java-AQS2/1564454733915Java-AQS2_.png" alt></p><h3><span id="sync-doacquiresharednanos方法">Sync doAcquireSharedNanos方法</span></h3><p>比较特别的为最后一个 doAcquireSharedNanos 方法，我们一起看下它怎么实现超时时间的控制的。<br>因为该方法和其余获取共享锁的方法逻辑是类似的，我用红色框圈出了它所不一样的地方，也就是实现超时时间控制的地方。<br>可以看到，其实就是在进入方法时，计算出了一个“deadline”，每次循环的时候用当前时间和“deadline”比较，大于“dealine”说明超时时间已到，直接返回方法。</p><p>注意，最后一个红框中的这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nanosTimeout &gt; spinForTimeoutThreshold</span><br></pre></td></tr></table></figure><p>从变量的字面意思可知，这是拿超时时间和超时自旋的最小作比较，在这里 Doug Lea 把超时自旋的阈值设置成了 1000ns, 即只有超时时间大于 1000ns 才会去挂起线程，否则，再次循环，以实现“自旋”操作。这是“自旋”在 AQS 中的应用之处。</p><h3><span id="countdown-方法">countDown 方法</span></h3><p>看完 await 方法，我们再来看下 countDown() 方法：</p><ul><li>countDown() 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Sync </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  同样先尝试去释放锁，tryReleaseShared 同样为空方法，留给子类自己去实现，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="tryreleaseshared-方法">tryReleaseShared 方法</span></h3><p>看一下  <code>tryReleaseShared</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">          <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>本文从 CountDownLatch 入手，深入分析了 AQS 关于共享锁方面的实现方式：</p><blockquote><p>如果获取共享锁失败后，将请求共享锁的线程封装成 Node 对象放入 AQS 的队列中，并挂起 Node 对象对应的线程，实现请求锁线程的等待操作。<br>待共享锁可以被获取后，从头节点开始，依次唤醒头节点及其以后的所有共享类型的节点。实现共享状态的传播。</p></blockquote><p>这里有几点值得注意：</p><ul><li>与 AQS 的独占功能一样，共享锁是否可以被获取的判断为空方法，交由子类去实现。</li><li>与 AQS 的独占功能不同，当锁被头节点获取后，独占功能是只有头节点获取锁，其余节点的线程继续沉睡，等待锁被释放后，才会唤醒下一个节点的线程，而共享功能是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒 AQS 队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li></ul><p><strong>以上的分析都是从 AQS 子类的角度去看待 AQS 的部分功能的，而如果直接看待 AQS，或许可以这么去解读：</strong></p><ul><li><p>首先，AQS 并不关心“是什么锁”，对于 AQS 来说它只是实现了一系列的用于判断“资源”是否可以访问的 API, 并且封装了在“访问资源”受限时将请求访问的线程的加入队列、挂起、唤醒等操作， AQS 只关心“资源不可以访问时，怎么处理？”、“资源是可以被同时访问，还是在同一时间只能被一个线程访问？”、“如果有线程等不及资源了，怎么从 AQS 的队列中退出？”等一系列围绕资源访问的问题，而至于“资源是否可以被访问？”这个问题则交给 AQS 的子类去实现。</p></li><li><p>当 AQS 的子类是实现独占功能时，例如 <code>ReentrantLock</code>，“资源是否可以被访问”被定义为只要 AQS 的 <code>state</code> 变量不为 0，并且持有锁的线程不是当前线程，则代表资源不能访问。</p></li><li><p>当 AQS 的子类是实现共享功能时，例如：CountDownLatch，“资源是否可以被访问”被定义为只要 AQS 的 <code>state</code> 变量不为 0，说明资源不能访问。</p></li></ul><p><strong>这是典型的将规则和操作分开的设计思路：规则子类定义，操作逻辑因为具有公用性，放在父类中去封装。</strong></p><p>当然，正式因为 AQS 只是关心“资源在什么条件下可被访问”，所以子类还可以同时使用 AQS 的共享功能和独占功能的 API 以实现更为复杂的功能。</p><p>比如：<code>ReentrantReadWriteLock</code>，我们知道 <code>ReentrantReadWriteLock</code> 的中也有一个叫 <code>Sync</code>的内部类继承了 <code>AQS</code>，而 <code>AQS</code> 的队列可以同时存放共享锁和独占锁，对于 <code>ReentrantReadWriteLock</code> 来说分别代表读锁和写锁，当队列中的头节点为读锁时，代表读操作可以执行，而写操作不能执行，因此请求写操作的线程会被挂起，当读操作依次推出后，写锁成为头节点，请求写操作的线程被唤醒，可以执行写操作，而此时的读请求将被封装成 Node 放入 AQS 的队列中。如此往复，实现读写锁的读写交替进行。</p><p>而本系列文章上半部分提到的 <code>FutureTask</code>，其实思路也是：封装一个存放线程执行结果的变量 A, 使用 AQS 的独占 API 实现线程对变量 A 的独占访问，判断规则是，线程没有执行完毕：call() 方法没有返回前，不能访问变量 A，或者是超时时间没到前不能访问变量 A(这就是 FutureTask 的 get 方法可以实现获取线程执行结果时，设置超时时间的原因)。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（上)</a></li><li><a href="https://www.infoq.cn/article/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下)</a></li><li><a href="https://www.jianshu.com/p/279baac48960" target="_blank" rel="noopener">java AQS的实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">深入学习java同步器AQS</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="http://codingdict.com/blog/article/2019/4/26/934.html" target="_blank" rel="noopener">http://codingdict.com/blog/article/2019/4/26/934.html</a></li><li><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86192135" target="_blank" rel="noopener">https://blog.csdn.net/Viscu/article/details/86192135</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程篇之锁的介绍</title>
      <link href="/article/java-lock-show/"/>
      <url>/article/java-lock-show/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>这篇文章介绍各种锁的分类。介绍的内容如下：</p><ol><li>公平锁 / 非公平锁</li><li>可重入锁 / 不可重入锁</li><li>独享锁 / 共享锁</li><li>互斥锁 / 读写锁</li><li>乐观锁 / 悲观锁</li><li>分段锁</li><li>偏向锁 / 轻量级锁 / 重量级锁</li><li>自旋锁</li></ol><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2><span id="锁的种类详解">锁的种类详解</span></h2><h2><span id="公平锁-非公平锁">公平锁 / 非公平锁</span></h2><ul><li>公平锁<br>公平锁是指多个线程按照申请锁的顺序来获取锁。</li><li>非公平锁<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</li><li>有可能，会造成优先级反转或者饥饿现象。</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。</li><li>非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</li></ul><p>具体可以参考<a href="https://icefrozen.github.io/article/java-AQS/" target="_blank" rel="noopener">JAVA多线程之AQS分析(1)</a></p><h2><span id="可重入锁-不可重入锁">可重入锁 / 不可重入锁</span></h2><ul><li>不可重入锁：只判断这个锁有没有被锁上，只要被锁上申请锁的线程都会被要求等待。实现简单</li><li>可重入锁：不仅判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上的时候，那么他依旧可以再次访问临界资源，并把加锁次数加一。</li></ul><p><code>synchronized</code>和<code>ReentrantLock</code>都是可重入锁。</p><ul><li><code>ReentrantLock</code>与<code>synchronized</code>比较：<ul><li>1.前者使用灵活，但是必须手动开启和释放锁</li><li>2.前者扩展性好，有时间锁等候（tryLock()可中断锁等候（lockInterruptibly()），锁投票等，适合用于高度竞争锁和多个条件变量的地方</li><li>3.前者提供了可轮询的锁请求，可以尝试去获取锁（tryLock( )），如果失败，则会释放已经获得的锁。有完善的错误恢复机制，可以避免死锁的发生。</li></ul></li></ul><h2><span id="乐观锁-悲观锁">乐观锁 / 悲观锁</span></h2><ul><li><p>悲观锁 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p></li><li><p>乐观锁 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式(CAS实现的)</p></li><li><p>使用场景<br>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。<br>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p></li><li><p>CAS算法：</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li><p>CAS 算法ABA的问题</p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &quot;ABA&quot;问题。</p><blockquote><p>JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就提供了此种能力，其中的 <code>compareAndSet</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></blockquote></li></ul><h2><span id="独享锁-共享锁">独享锁 / 共享锁</span></h2><ul><li>独享锁 是指该锁一次只能被一个线程所持有。</li><li>共享锁 是指该锁可被多个线程所持有。<br>对于<code>ReentrantLock</code>而言，其是独享锁。<br>但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。<br>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li></ul><h2><span id="互斥锁-读写锁">互斥锁 / 读写锁</span></h2><ul><li>互斥锁<br>一次只能一个线程拥有互斥锁，其他线程只有等待</li></ul><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。</p><ul><li><p>读写锁<br>读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。</p></li><li><p>java中的读写锁 <code>ReentrantReadWriteLock</code></p></li></ul><h2><span id="自旋锁">自旋锁</span></h2><ul><li>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。</li></ul><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，&quot;自旋&quot;一词就是因此而得名。</p><ul><li>存在问题<ul><li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li><li>自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li></ul></li><li>优点：<ul><li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li><li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li></ul></li></ul><h2><span id="偏向锁-轻量级锁-重量级锁">偏向锁 / 轻量级锁 / 重量级锁</span></h2><p>一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试失败,则分为两种情况：</p><ul><li>1，对象的偏向锁标志位为0（当前不是偏向锁），说明发生了竞争，已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁</li><li>2，偏向锁标志位为1，说明还是偏向锁不过请求的线程不是原来那个了。这时只需要使用CAS尝试把对象头偏向锁从原来那个线程指向目前求锁的线程。</li></ul><ul><li><p>本质：使用CAS取代<code>互斥同步</code>。</p></li><li><p>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。</p></li><li><p>锁膨胀</p></li><li><p>轻量级锁与重量级锁的比较：</p><ul><li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用<code>互斥同步</code>来保证线程的安全；</li><li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用<code>互斥同步</code>，而是使用CAS操作来获得锁，这样能减少<code>互斥同步</code>所使用的『互斥量』带来的性能开销。</li></ul></li><li><p>实现原理：<br>对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。Mark Word中有个标志位用来表示当前对象所处的状态。</p></li><li><p>偏向锁作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</p><ul><li><p>与轻量级锁的区别：</p><ul><li>轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；</li><li>而偏向锁是在无竞争的情况下完全取消同步。</li></ul></li><li><p>与轻量级锁的相同点：</p><ul><li>它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。</li></ul><blockquote><p>原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。<br>但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。<br>+ 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。偏向锁可以通过虚拟机的参数来控制它是否开启。</p></blockquote><blockquote><p>具体请参考<a href="https://icefrozen.github.io/article/java-synchronized/" target="_blank" rel="noopener">深入分析synchronized原理和锁膨胀过程</a></p></blockquote></li><li><p>三种对比<br><img src="/article/java-lock-show/1565944754578java-lock-show_.png" alt></p></li></ul></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">面试必备之乐观锁与悲观锁</a></li><li><a href="https://zhuanlan.zhihu.com/p/40729293" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></li><li><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></li><li><a href="https://maimai.cn/article/detail?fid=1231504957&amp;efid=TgPEQCFJ6KSa6rBIAyLHNg" target="_blank" rel="noopener">Java中15种锁的介绍！</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86252371" target="_blank" rel="noopener">JDK源码系列 ReentrantLock 公平锁和非公平锁的实现原理</a></li><li><a href="https://www.zhihu.com/question/55075763/answer/246516866" target="_blank" rel="noopener">Java 的偏向锁是怎么实现的？</a></li><li><a href="https://www.zhihu.com/question/39009953/answer/240514586" target="_blank" rel="noopener">jvm从轻量级锁膨胀到重量级锁是在什么时候发生的？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之 高性能IO浅析</title>
      <link href="/article/operating-system-io/"/>
      <url>/article/operating-system-io/</url>
      
        <content type="html"><![CDATA[<h2><span id="io模型分类">IO模型分类</span></h2><ul><li><strong>（1）同步阻塞IO（Blocking IO）</strong>：即传统的IO模型。</li><li><strong>（2）同步非阻塞IO（Non-blocking IO）</strong>：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li><li><strong>（3）IO多路复用（IO Multiplexing）</strong>：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。 有兴趣可以看一下<a href="https://icefrozen.github.io/article/operating-system-epoll/" target="_blank" rel="noopener">Epoll的原理</a>。</li><li><strong>（4）异步IO（Asynchronous IO）</strong>：即经典的Proactor设计模式，也称为异步非阻塞IO。</li></ul><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步的概念描述的是用户线程与内核的交互方式：</p><ul><li>同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；</li><li>而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li></ul><h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：</p><ul><li>阻塞是指IO操作需要彻底完成后才返回到用户空间；</li><li>而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</li></ul><h2><span id="同步阻塞io">同步阻塞IO</span></h2><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p><p><img src="/article/operating-system-io/1563243388124operating-system-io_.png" alt></p><p>如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。<br>用户线程使用同步阻塞IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  read(socket, buffer);</span><br><span class="line">  process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p><h2><span id="同步非阻塞io">同步非阻塞IO</span></h2><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。<br><img src="/article/operating-system-io/1563243655861operating-system-io_.png" alt></p><p>如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。<br>用户线程使用同步非阻塞IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(read(socket, buffer) != SUCCESS);</span><br><span class="line">    process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><h2><span id="io多路复用">IO多路复用</span></h2><h3><span id="什么是io多路复用">什么是IO多路复用</span></h3><p>关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。写操作类似。</p><p>操作系统的这个功能通过<code>select/poll/epoll/kqueue</code>之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程。</p><h3><span id="select-函数">select 函数</span></h3><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p><p><img src="/article/operating-system-io/1563243505125operating-system-io_.png" alt></p><p>如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。<br>当数据到达时，socket被激活(用户线程被唤起)，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p>用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    select(socket);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">                read(socket, buffer);</span><br><span class="line">                process(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</p><h4><span id="select-函数的缺点">select 函数的缺点：</span></h4><ol><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>select支持的文件描述符数量太小了，默认是1024</li></ol><h3><span id="poll">poll</span></h3><ul><li>poll 的方式和select 很大，但是没有1024的限制，我们可以简单的理解为select  向内核态传递数据的时候是通过数组的方式，这样一来就有限制，而poll 则是使用了 链表的方式，如此就可以避免了突破了1024的限制</li></ul><h3><span id="epoll">epoll</span></h3><ul><li>epoll的原理我已经在<a href="https://icefrozen.github.io/article/operating-system-epoll/" target="_blank" rel="noopener">Epoll的原理</a>这篇文章分析过了，这里组要讲一下epoll是如何解决select的三个问题的。</li></ul><h4><span id="epoll优点">epoll优点</span></h4><ul><li>epoll既然是对 <code>select</code> 和 <code>poll</code> 的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？<ul><li><p>我们先看一下 <code>epoll</code> 和 <code>select</code> 和poll的调用接口上的不同，<code>select</code>和<code>poll</code>都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，<code>epoll_create,epoll_ctl和epoll_wait</code>，<code>epoll_create</code>是创建一个 <code>epoll</code> 句柄；<code>epoll_ctl</code> 是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p></li><li><p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p></li><li><p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait 的工作实际上就是在这个就绪链表中查看有没有就绪的fd。</p></li><li><p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p></li></ul></li></ul><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p><h2><span id="reactor设计模式">Reactor设计模式</span></h2><h3><span id="rector解决了什么">Rector解决了什么</span></h3><p>它要解决什么问题呢？线程在真正处理请求之前首先需要从 socket 中读取网络请求，而在读取完成之前，线程本身被阻塞，不能做任何事，这就导致线程资源被占用，而线程资源本身是很珍贵的，尤其是在处理高并发请求时。</p><p>而 Reactor 模式指出，在等待 IO 时，线程可以先退出，这样就不会因为有线程在等待 IO 而占用资源。但是这样原先的执行流程就没法还原了，因此，我们可以利用<code>事件驱动的方式</code>，要求线程在退出之前向 event loop 注册回调函数，这样 IO 完成时 event loop 就可以调用回调函数完成剩余的操作。</p><p>所以说，Reactor 模式通过减少服务器的资源消耗，提高了并发的能力。</p><h3><span id="rector-实现">Rector 实现</span></h3><h4><span id="rector-设计理念">Rector 设计理念</span></h4><p><img src="/article/operating-system-io/1563244009489operating-system-io_.png" alt></p><p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle，我们可以简单理解为拥有 socket 这个对象</p><p>继承于EventHandler的子类可以对事件处理器的行为进行定制就是我们的具体的hander。</p><p>Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。 有些简单的世界中 Rector 处理时间循环的可以具体为一个Acceptor 类，用于accept接受 socket 链接。 而Rector 可以负责分发 具体相当于一个 dispatch 类似的组件。</p><p><img src="/article/operating-system-io/1563508418230operating-system-io_.png" alt></p><p>由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。<br>一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p><h4><span id="单线程-reactor-模式">单线程 Reactor 模式</span></h4><p><img src="/article/operating-system-io/1578539455022operating-system-io_.png" alt></p><p>在该种模式下我们使用的是一个单线程的 Reactor，acceptor() 处理器注册了 ACCEPT 事件，即连接事件，当有连接请求时 Reactor 会将其分发给 acceptor() 处理。</p><p>但在这种模式下，Reactor 线程不但要处理 accept()、read()、send()，连非IO业务也要处理，如果业务逻辑复杂，这可能会使 Reactor 线程无法处理其它事件的响应。</p><p>为了避免这种事情发生，我们需要把非IO业务逻辑处理交给子线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//阻塞等待事件</span></span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="comment">// 事件列表</span></span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        System.out.println(<span class="string">"select invoke:"</span> + select);</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            <span class="comment">//分发事件</span></span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dispatch"</span>);</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">//新链接建立，注册</span></span><br><span class="line">                register(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//读事件处理</span></span><br><span class="line">                read(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                <span class="comment">//写事件处理</span></span><br><span class="line">                wirte(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            clientChannel.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"data:"</span>+ Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wirte</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"register"</span>);</span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) key</span><br><span class="line">                    .channel();</span><br><span class="line">            <span class="comment">// 获得和客户端连接的通道</span></span><br><span class="line">            SocketChannel channel = server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//客户端通道注册到selector 上</span></span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="单线程-reactor-模式-线程池">单线程 Reactor 模式 + 线程池</span></h4><p><img src="/article/operating-system-io/1578539472242operating-system-io_.png" alt></p><p>通过加入工作线程池，把具体的逻辑操作交由子线程，提高了 Reactor 线程的IO响应时间，但是这样的模式还是存在着缺陷。</p><p>就是Reactor 线程要处理包括I/O的accept()、read()、write()以及connect()操作，当同时有大量的连接建立时，单线程的 Reactor性能会下降，然后可能会使大量客户端连接超时，最终使大量消息积压和连接超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            register.attach(<span class="keyword">new</span> Acceptor(register, selector));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Runnable runnable = (Runnable) (key.attachment());</span><br><span class="line">            <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        SelectionKey key;</span><br><span class="line">        Selector selector;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(SelectionKey key, Selector selector)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"register"</span>);</span><br><span class="line">                ServerSocketChannel server = (ServerSocketChannel) key</span><br><span class="line">                        .channel();</span><br><span class="line">                <span class="comment">// 获得和客户端连接的通道</span></span><br><span class="line">                SocketChannel c = server.accept();</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">new</span> MultiThreadHandler(c, selector);</span><br><span class="line">                    <span class="comment">//new Handler(c, selector);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run errro"</span>);</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读写业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, WRITING = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> state;</span><br><span class="line">        <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel socket, Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = READING;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            sk.attach(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (state == READING) &#123;</span><br><span class="line">                    read();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == WRITING) &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            process();</span><br><span class="line">            <span class="comment">//下一步处理写事件</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="keyword">this</span>.state = WRITING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            process();</span><br><span class="line">            <span class="comment">//下一步处理读事件</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            <span class="keyword">this</span>.state = READING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * task 业务处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadHandler</span><span class="params">(SocketChannel socket, Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(socket, selector);</span><br><span class="line">            <span class="comment">//多线程处理业务逻辑</span></span><br><span class="line">            executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">                    <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="多线程的-reactor-模式">多线程的 Reactor 模式</span></h4><p>在多线程的 Reactor 模式中，我们分为 mainReactor 和 subReactor，每一个 Reactor 线程都会有自己的 Selector 与不同的事件循环逻辑。</p><p>其中 mainReactor 主要负责接受客户的连接请求，然后将建立的 ScoketChannel 传递给 subReactor，由 subReactor 来完成和客户端的通信。</p><p>而 subReactor 一般会有多个，这可以很好的解决单线程 Reactor 模式下的瓶颈。</p><p><img src="/article/operating-system-io/1578539637647operating-system-io_.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIORector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIORector</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            register.attach(<span class="keyword">new</span> MultiWorkThreadAcceptor(serverSocket));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个是事件分发器，相当于Reactor 里的分发器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Runnable runnable = (Runnable) (key.attachment());</span><br><span class="line">            <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的Acceptor 相当于时间 接收器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiWorkThreadAcceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">        <span class="comment">// cpu线程数相同多work线程</span></span><br><span class="line">        <span class="keyword">int</span> workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        SubReactor[] workThreadHandlers = <span class="keyword">new</span> SubReactor[workCount];</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> nextHandler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiWorkThreadAcceptor</span><span class="params">(ServerSocketChannel serverSocket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.server = serverSocket;</span><br><span class="line">            nextHandler = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workThreadHandlers.length; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workThreadHandlers[i] = <span class="keyword">new</span> SubReactor();</span><br><span class="line">                    <span class="keyword">new</span> Thread(workThreadHandlers[i]).start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"MultiWorkThreadAcceptor error"</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"register"</span>);</span><br><span class="line">                <span class="comment">// 有socket 链接上来</span></span><br><span class="line">                SocketChannel c = server.accept();</span><br><span class="line">                <span class="comment">// 注册读写</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (c) &#123;</span><br><span class="line">                        <span class="comment">// 顺序获取SubReactor，然后注册channel</span></span><br><span class="line">                        SubReactor work = workThreadHandlers[nextHandler];</span><br><span class="line">                        <span class="comment">// 这里注册</span></span><br><span class="line">                        work.registerChannel(c);</span><br><span class="line">                        nextHandler++;</span><br><span class="line">                        <span class="keyword">if</span> (nextHandler &gt;= workThreadHandlers.length) &#123;</span><br><span class="line">                            nextHandler = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run errro"</span>);</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Selector mySelector;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(workCount);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 每个SubReactor 一个selector</span></span><br><span class="line">            <span class="keyword">this</span>.mySelector = SelectorProvider.provider().openSelector();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(SocketChannel c)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            registerChannel(c, <span class="keyword">new</span> MultiThreadHandler());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(SocketChannel c, Handler hander)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = c.register(mySelector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT);</span><br><span class="line">            register.attach(hander);</span><br><span class="line">            System.out.println(<span class="string">"registerChannel success!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每个SubReactor 自己做事件分派处理读写事件</span></span><br><span class="line">                    <span class="keyword">int</span> select = mySelector.selectNow();</span><br><span class="line">                    <span class="keyword">if</span> (select == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = mySelector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        MultiThreadHandler handler = (MultiThreadHandler) key.attachment();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        handler.hander(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"sub running error:"</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hander</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hander</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                read(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                write(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//下一步处理写事件</span></span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line">            SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="总结">总结</span></h4><p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p><h2><span id="异步io">异步IO</span></h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。</p><p>而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。<br>异步IO模型使用了Proactor设计模式实现了这一机制。</p><p><img src="/article/operating-system-io/1563627346572operating-system-io_.png" alt></p><p>如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。</p><p>AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。</p><p>虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p><p><img src="/article/operating-system-io/1563627447724operating-system-io_.png" alt></p><p>如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。<br>用户线程使用异步IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserCompletionHandler::handle_event(buffer) &#123;</span><br><span class="line">        process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    aio_read(socket, <span class="keyword">new</span> UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.zhihu.com/question/28594409/answer/52763082" target="_blank" rel="noopener">I/O多路复用技术（multiplexing）是什么？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之Epoll原理</title>
      <link href="/article/operating-system-epoll/"/>
      <url>/article/operating-system-epoll/</url>
      
        <content type="html"><![CDATA[<p>Epoll 很重要，但是 Epoll 与 Select 的区别是什么呢?Epoll 高效的原因是什么?</p><h2><span id="从网卡接收数据说起">从网卡接收数据说起</span></h2><h3><span id="网卡接收数据的过程">网卡接收数据的过程</span></h3><p>下边是一个典型的计算机结构图，计算机由 CPU、存储器(内存)与网络接口等部件组成，了解 <code>Epoll</code> 本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><p><img src="/article/operating-system-epoll/1562727855783operating-system-epoll_.png" alt><br>下图展示了网卡接收数据的过程：</p><ul><li>在 1 阶段，网卡收到网线传来的数据。</li><li>经过 2 阶段的硬件电路的传输。</li><li>最终 3 阶段将数据写入到内存中的某个地址上。</li><li>这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。</li></ul><h3><span id="中断机制">中断机制</span></h3><p>通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。</p><p>如何知道接收了数据?了解 Epoll 本质的第二步，要从 CPU 的角度来看数据接收。理解这个问题，要先了解一个概念：中断。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级(电容可以保存少许电量，供 CPU 运行很短的一小段时间)。</p><p>一般而言，由硬件产生的信号需要 CPU 立马做出回应，不然数据可能就丢失了，所以它的优先级很高。</p><p>CPU 理应中断掉正在执行的程序，去做出响应;当 CPU 完成对硬件的响应后，再重新执行用户程序。</p><p>中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><p><img src="/article/operating-system-epoll/1562727999511operating-system-epoll_.png" alt></p><p>以键盘为例，当用户按下键盘某个按键时，键盘会给 CPU 的中断引脚发出一个高电平，CPU 能够捕获这个信号，然后执行键盘中断程序。</p><p>下图展示了各种硬件通过中断与 CPU 交互的过程：</p><p><img src="/article/operating-system-epoll/1562728030652operating-system-epoll_.png" alt></p><p>现在可以回答“如何知道接收了数据?”这个问题了：当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><h3><span id="进程阻塞不占用-cpu-资源">进程阻塞不占用 CPU 资源</span></h3><p>了解 Epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件(如接收到网络数据)发生之前的等待状态，Recv、Select 和 Epoll 都是阻塞方法。</p><p>下边分析一下进程阻塞为什么不占用 CPU 资源?为简单起见，我们从普通的 Recv 接收开始分析，先看看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket </span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line"><span class="comment">//绑定 </span></span><br><span class="line">bind(s, ...) </span><br><span class="line"><span class="comment">//监听 </span></span><br><span class="line">listen(s, ...) </span><br><span class="line"><span class="comment">//接受客户端连接 </span></span><br><span class="line"><span class="keyword">int</span> c = accept(s, ...) </span><br><span class="line"><span class="comment">//接收客户端数据 </span></span><br><span class="line">recv(c, ...); </span><br><span class="line"><span class="comment">//将数据打印出来 </span></span><br><span class="line"><span class="built_in">printf</span>(...)</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 Socket 对象，依次调用 Bind、Listen 与 Accept，最后调用 Recv 接收数据。</p><p>Recv 是个阻塞方法，当程序运行到 Recv 时，它会一直等待，直到接收到数据才往下执行。那么阻塞的原理是什么?</p><h3><span id="工作队列">工作队列</span></h3><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。</p><p>运行状态是进程获得 CPU 使用权，正在执行代码的状态;等待状态是阻塞状态，比如上述程序运行到 Recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</p><p>操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><p><img src="/article/operating-system-epoll/1562729083970operating-system-epoll_.png" alt></p><h3><span id="等待队列">等待队列</span></h3><p>当进程 A 执行到创建 Socket 的语句时，操作系统会创建一个由文件系统管理的 Socket 对象(如下图)。<br><img src="/article/operating-system-epoll/1562729110268operating-system-epoll_.png" alt></p><ul><li><p>创建 Socket</p><p>这个 Socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 Socket 事件的进程。</p><p>当程序执行到 Recv 时，操作系统会将进程 A 从工作队列移动到该 Socket 的等待队列中(如下图)。</p><p><img src="/article/operating-system-epoll/1562729170077operating-system-epoll_.png" alt></p></li><li><p>Socket 的等待队列</p><p>由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。</p><blockquote><p>注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p></blockquote></li></ul><h3><span id="唤醒进程">唤醒进程</span></h3><p>当 Socket 接收到数据后，操作系统将该 Socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。</p><p>同时由于 Socket 的接收缓冲区已经有了数据，Recv 可以返回接收到的数据。</p><ul><li><p>内核接收网络数据全过程<br>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞 Recv 下，内核接收数据的全过程。</p><p><img src="/article/operating-system-epoll/1562729363577operating-system-epoll_.png" alt></p><p>如上图所示，进程在 Recv 阻塞期间：</p><ul><li>计算机收到了对端传送的数据(步骤 ①)</li><li>数据经由网卡传送到内存(步骤 ②)</li><li>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序(步骤 ③)</li><li>此处的中断程序主要有两项功能，先将网络数据写入到对应 Socket 的接收缓冲区里面(步骤 ④)，再唤醒进程 A(步骤 ⑤)，重新将进程 A 放入工作队列中。</li></ul></li><li><p>唤醒进程的过程如下图所示：<br><img src="/article/operating-system-epoll/1562729427475operating-system-epoll_.png" alt></p></li></ul><h3><span id="唤醒进程">唤醒进程</span></h3><p>以上是内核接收数据全过程，这里我们可能会思考两个问题：</p><ul><li>操作系统如何知道网络数据对应于哪个 Socket?</li><li>如何同时监视多个 Socket 的数据?</li></ul><ul><li>操作系统如何知道网络数据对应于哪个 Socket?</li></ul><p>因为一个 Socket 对应着一个端口号，而网络数据包中包含了 IP 和端口的信息，内核可以通过端口号找到对应的 Socket。当然，为了提高处理速度，操作系统会维护端口号到 Socket 的索引结构，以快速读取。</p><ul><li>如何同时监视多个 Socket 的数据?</li></ul><h2><span id="同时监视多个-socket-方法">同时监视多个 Socket 方法</span></h2><p>服务端需要管理多个客户端连接，而 Recv 只能监视单个 Socket，这种矛盾下，人们开始寻找监视多个 Socket 的方法。Epoll 的要义就是高效地监视多个 Socket。</p><p>从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如 Select 之于 Epoll。先理解不太高效的 Select，才能够更好地理解 Epoll 的本质。</p><p>假如能够预先传入一个 Socket 列表，如果列表中的 Socket 都没有数据，挂起进程，直到有一个 Socket 收到数据，唤醒进程。这种方法很直接，也是 Select 的设计思想。</p><p>为方便理解，我们先复习 Select 的用法。在下边的代码中，先准备一个数组 FDS，让 FDS 存放着所有需要监视的 Socket。</p><p>然后调用 Select，如果 FDS 中的所有 Socket 都没有数据，Select 会阻塞，直到有一个 Socket 接收到数据，Select 返回，唤醒进程。</p><p>用户可以遍历 FDS，通过 FD_ISSET 判断具体哪个 Socket 收到数据，然后做出处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123; </span><br><span class="line">            <span class="comment">//fds[i]的数据处理 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Select 的流程</li></ul><p>Select 的实现思路很直接，假如程序同时监视如下图的 Sock1、Sock2 和 Sock3 三个 Socket，那么在调用 Select 之后，操作系统把进程 A 分别加入这三个 Socket 的等待队列中。</p><p><img src="/article/operating-system-epoll/1562729629174operating-system-epoll_.png" alt></p><p>操作系统把进程 A 分别加入这三个 Socket 的等待队列中</p><p>当任何一个 Socket 收到数据后，中断程序将唤起进程。下图展示了 Sock2 接收到了数据的处理流程：</p><p><img src="/article/operating-system-epoll/1562729661910operating-system-epoll_.png" alt></p><p>Sock2 接收到了数据，中断程序唤起进程 A</p><p>注：Recv 和 Select 的中断回调可以设置成不同的内容。</p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：</p><p><img src="/article/operating-system-epoll/1562729681601operating-system-epoll_.png" alt></p><p>将进程 A 从所有等待队列中移除，再加入到工作队列里面</p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 Socket 接收了数据。程序只需遍历一遍 Socket 列表，就可以得到就绪的 Socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><ul><li>每次调用 Select 都需要将进程加入到所有监视 Socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。</li></ul><p>正是因为遍历操作开销大，出于效率的考量，才会规定 Select 的最大监视数量，默认只能监视 1024 个 Socket。</p><ul><li>进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次。<br>那么，有没有减少遍历的方法?有没有保存就绪 Socket 的方法?这两个问题便是 Epoll 技术要解决的。</li></ul><blockquote><p>补充说明：本节只解释了 Select 的一种情形。当程序调用 Select 时，内核会先遍历一遍 Socket，如果有一个以上的 Socket 接收缓冲区有数据，那么 Select 直接返回，不会阻塞。</p></blockquote><p>这也是为什么 Select 的返回值有可能大于 1 的原因之一。如果没有 Socket 有数据，进程才会阻塞。</p><h2><span id="epoll-的设计思路">Epoll 的设计思路</span></h2><p>Epoll 是在 Select 出现 N 多年后才被发明的，是 Select 和 Poll(Poll 和 Select 基本一样，有少量改进)的增强版本。Epoll 通过以下一些措施来改进效率：</p><h3><span id="措施一功能分离">措施一：功能分离</span></h3><p>Select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一<br><img src="/article/operating-system-epoll/1562729825016operating-system-epoll_.png" alt></p><p>相比 Select，Epoll 拆分了功能</p><p>如上图所示，每次调用 Select 都需要这两步操作，然而大多数应用场景中，需要监视的 Socket 相对固定，并不需要每次都修改。</p><p>Epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。</p><p>为方便理解后续的内容，我们先了解一下 Epoll 的用法。如下的代码中，先用 epoll_create 创建一个 Epoll 对象 Epfd，再通过 epoll_ctl 将需要监视的 Socket 添加到 Epfd 中，最后调用 epoll_wait 等待数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(...); </span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(...) </span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123; </span><br><span class="line">        <span class="comment">//处理 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="措施二就绪列表">措施二：就绪列表</span></h3><p>Select 低效的另一个原因在于程序不知道哪些 Socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 Socket，就能避免遍历。</p><p><img src="/article/operating-system-epoll/1562729924745operating-system-epoll_.png" alt></p><p>就绪列表示意图</p><p>如上图所示，计算机共有三个 Socket，收到数据的 Sock2 和 Sock3 被就绪列表 Rdlist 所引用。</p><p>当进程被唤醒后，只要获取 Rdlist 的内容，就能够知道哪些 Socket 收到数据。</p><h3><span id="epoll-的原理与工作流程">Epoll 的原理与工作流程</span></h3><p>本节会以示例和图表来讲解 Epoll 的原理和工作流程。</p><ul><li><p>创建 Epoll 对象</p><p>如下图所示，当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象(也就是程序中 Epfd 所代表的对象)。</p><p><img src="/article/operating-system-epoll/1562729950856operating-system-epoll_.png" alt></p><p>内核创建 eventpoll 对象</p><p>eventpoll 对象也是文件系统中的一员，和 Socket 一样，它也会有等待队列。</p><p>创建一个代表该 Epoll 的 eventpoll 对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</p></li><li><p>维护监视列表</p><p>创建 Epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 Socket。以添加 Socket 为例。</p><p><img src="/article/operating-system-epoll/1562730099033operating-system-epoll_.png" alt></p><p>添加所要监听的 Socket</p><p>如上图，如果通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll 添加到这三个 Socket 的等待队列中。</p><p>当 Socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</p></li><li><p>接收数据</p><p>当 Socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 Socket 引用。<br><img src="/article/operating-system-epoll/1562730158957operating-system-epoll_.png" alt></p><p>给就绪列表添加引用</p><p>如上图展示的是 Sock2 和 Sock3 收到数据后，中断程序让 Rdlist 引用这两个 Socket。</p><p>eventpoll 对象相当于 Socket 和进程之间的中介，Socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p><p>当程序执行到 epoll_wait 时，如果 Rdlist 已经引用了 Socket，那么 epoll_wait 直接返回，如果 Rdlist 为空，阻塞进程。</p></li><li><p>阻塞和唤醒进程</p><p>假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。</p><p><img src="/article/operating-system-epoll/1562730841047operating-system-epoll_.png" alt></p></li><li><p>epoll_wait 阻塞进程</p><p>如上图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</p><p>当 Socket 接收到数据，中断程序一方面修改 Rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态(如下图)。</p><p><img src="/article/operating-system-epoll/1562730871184operating-system-epoll_.png" alt></p></li><li><p>Epoll 唤醒进程</p><p>也因为 Rdlist 的存在，进程 A 可以知道哪些 Socket 发生了变化。</p><p>Epoll 的实现细节<br>至此，相信读者对 Epoll 的本质已经有一定的了解。但我们还需要知道 eventpoll 的数据结构是什么样子?</p><p>此外，就绪队列应该使用什么数据结构?eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 Socket?</p><p><img src="/article/operating-system-epoll/1562730925725operating-system-epoll_.png" alt></p></li></ul><p>如上图所示，eventpoll 包含了 Lock、MTX、WQ(等待队列)与 Rdlist 等成员，其中 Rdlist 和 RBR 是我们所关心的。</p><h3><span id="就绪列表的数据结构">就绪列表的数据结构</span></h3><p>就绪列表引用着就绪的 Socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视 Socket，也可能随时删除。</p><p>当删除时，若该 Socket 已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</p><p>双向链表就是这样一种数据结构，Epoll 使用双向链表来实现就绪队列(对应上图的 Rdlist)。</p><h3><span id="索引结构">索引结构</span></h3><p>既然 Epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 Socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。</p><p>红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是 O(log(N))，效率较好，Epoll 使用了红黑树作为索引结构(对应上图的 RBR)。</p><blockquote><p>注：因为操作系统要兼顾多种功能，以及有更多需要保存的数据，Rdlist 并非直接引用 Socket，而是通过 Epitem 间接引用，红黑树的节点也是 Epitem 对象。</p></blockquote><p>同样，文件系统也并非直接引用着 Socket。为方便理解，本文中省略了一些间接结构。</p><h2><span id="总结">总结</span></h2><p>Epoll 在 Select 和 Poll 的基础上引入了 eventpoll 作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。</p><p>这里也以表格形式简单对比一下 Select、Poll 与 Epoll，结束此文。希望读者能有所收获。</p><h2><span id="参考链接">参考链接</span></h2><p><a href="http://developer.51cto.com/art/201906/597307.htm" target="_blank" rel="noopener">查看原文</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(1)</title>
      <link href="/article/java-memory-model/"/>
      <url>/article/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2><span id="为什么要有内存模型">为什么要有内存模型</span></h2><h2><span id="cpu缓存">CPU缓存</span></h2><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（<code>L1</code>），二级缓存（<code>L3</code>），部分高端CPU还具有三级缓存（<code>L3</code>），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：<strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong>。单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><p>下图为一个单CPU双核的缓存结构。<br><img src="/article/java-memory-model/1562587586971java-memory-model_.png" alt></p><h2><span id="多线程下缓存一致性问题">多线程下缓存一致性问题</span></h2><ul><li><p>单线程</p><blockquote><p>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p></blockquote></li><li><p>单核CPU，多线程。</p><blockquote><p>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p></blockquote></li><li><p>多核CPU, 多线程。</p><blockquote><p>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。在CPU和主存之间增加缓存，在多线程场景下就可能存在。缓存一致性问题**，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p></blockquote><p><img src="/article/java-memory-model/1562587658569java-memory-model_.png" alt></p></li></ul><h2><span id="处理器优化和指令重排">处理器优化和指令重排</span></h2><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p><h3><span id="编译器重排">编译器重排</span></h3><p>下面我们简单看一个编译器重排的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>             线程 <span class="number">2</span></span><br><span class="line"><span class="number">1</span>： x2 = a ;      <span class="number">3</span>: x1 = b ;</span><br><span class="line"><span class="number">2</span>: b = <span class="number">1</span>;         <span class="number">4</span>: a = <span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>两个线程同时执行，分别有1、2、3、4四段执行代码，其中1、2属于线程1 ， 3、4属于线程2 ，从程序的执行顺序上看，似乎不太可能出现x1 = 1 和x2 = 2 的情况，但实际上这种情况是有可能发现的，因为如果编译器对这段程序代码执行重排优化后，可能出现下列情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span>              线程 <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: b = <span class="number">1</span>;          <span class="number">4</span>: a = <span class="number">2</span> ; </span><br><span class="line"><span class="number">1</span>：x2 = a ;        <span class="number">3</span>: x1 = b ;</span><br></pre></td></tr></table></figure><p>这种执行顺序下就有可能出现x1 = 1 和x2 = 2 的情况，这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。</p><h3><span id="处理器指令重排">处理器指令重排</span></h3><p>先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下</p><ul><li>取指 IF</li><li>译码和取寄存器操作数 ID</li><li>执行或者有效地址计算 EX</li><li>存储器访问 MEM</li><li>写回 WB</li></ul><p>CPU在工作时，需要将上述指令分为多个步骤依次执行(注意硬件不同有可能不一样),由于每一个步会使用到不同的硬件操作，比如取指时会只有PC寄存器和存储器，译码时会执行到指令寄存器组，执行时会执行ALU(算术逻辑单元)、写回时使用到寄存器组。为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下：</p><p><img src="/article/java-memory-model/1562642803915java-memory-model_.png" alt></p><p>从图中可以看出当指令1还未执行完成时，第2条指令便利用空闲的硬件开始执行，这样做是有好处的，如果每个步骤花费1ms，那么如果第2条指令需要等待第1条指令执行完成后再执行的话，则需要等待5ms，但如果使用流水线技术的话，指令2只需等待1ms就可以开始执行了，这样就能大大提升CPU的执行性能。</p><p>虽然流水线技术可以大大提升CPU的性能，但不幸的是一旦出现流水中断，所有硬件设备将会进入一轮停顿期，当再次弥补中断点可能需要几个周期，这样性能损失也会很大，就好比工厂组装手机的流水线，一旦某个零件组装中断，那么该零件往后的工人都有可能进入一轮或者几轮等待组装零件的过程。因此我们需要尽量阻止指令中断的情况，指令重排就是其中一种优化中断的手段，我们通过一个例子来阐明指令重排是如何阻止流水线技术中断的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c ;</span><br><span class="line">d = e + f ;</span><br></pre></td></tr></table></figure><p>下面通过汇编指令展示了上述代码在CPU执行的处理过程</p><p><img src="https://img-blog.csdn.net/20170611002708717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><ul><li><p>LW指令 表示 load，其中LW R1,b表示把b的值加载到寄存器R1中</p></li><li><p>LW R2,c 表示把c的值加载到寄存器R2中</p></li><li><p>ADD 指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。</p></li><li><p>SW 表示 store 即将 R3寄存器的值保持到变量a中</p></li><li><p>LW R4,e 表示把e的值加载到寄存器R4中</p></li><li><p>LW R5,f 表示把f的值加载到寄存器R5中</p></li><li><p>SUB 指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。</p></li><li><p>SW d,R6 表示将R6寄存器的值保持到变量d中</p></li></ul><p>上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？</p><p>这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。</p><p>前面阐述过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把LW R4,e 和 LW R5,f 移动到前面执行，毕竟LW R4,e 和 LW R5,f执行并没有数据依赖关系，对他们有数据依赖关系的SUB R6,R5,R4指令在R4,R5加载完成后才执行的，没有影响，过程如下：</p><p><img src="/article/java-memory-model/1562642816423java-memory-model_.png" alt></p><p>正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。关于编译器重排以及指令重排(这两种重排我们后面统一称为指令重排)相关内容已阐述清晰了，我们必须意识到对于单线程而已指令重排几乎不会带来任何影响，比竟重排的前提是保证串行语义执行的一致性，但对于多线程环境而已，指令重排就可能导致严重的程序轮序执行问题，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，同时存在线程A和线程B对该实例对象进行操作，其中A线程调用写入方法，而B线程调用读取方法，由于指令重排等原因，可能导致程序执行顺序变为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A                    线程B</span><br><span class="line">writer：                 read：</span><br><span class="line">1:flag = true;           1:flag = true;</span><br><span class="line">2:a = 1;                 2: a = 0 ; //误读</span><br></pre></td></tr></table></figure><p>由于指令重排的原因，线程A的flag置为true被提前执行了，而a赋值为1的程序还未执行完，此时线程B，恰好读取flag的值为true，直接获取a的值（此时B线程并不知道a为0）并执行i赋值操作，结果i的值为1，而不是预期的2，这就是多线程环境下，指令重排导致的程序乱序执行的结果。因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性。</p><h2><span id="java内存模型即java-memory-model简称jmm">Java内存模型(即Java Memory Model，简称JMM)</span></h2><h2><span id="简介">简介</span></h2><p>本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">PDF文档</a></p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图</p><p><img src="/article/java-memory-model/1562642839101java-memory-model_.png" alt></p><h2><span id="并发编程的问题">并发编程的问题</span></h2><ul><li>JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。</li><li>JMM是围绕<strong>原子性，有序性、可见性</strong>展开的。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下</li></ul><ul><li><p>主内存</p><p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p></li><li><p>工作内存</p><p>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p></li></ul><p>对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（<code>boolean,byte,short,char,int,long,float,double</code>），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。</p><p>但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。</p><p>简单示意图如下所示：<br><img src="/article/java-memory-model/1562642879150java-memory-model_.png" alt></p><h2><span id="jmm存在的必要性">JMM存在的必要性</span></h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。</p><p>如下图，主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？</p><p>答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。</p><p><img src="/article/java-memory-model/1562642895574java-memory-model_.png" alt></p><h2><span id="java内存模型的承诺">Java内存模型的承诺</span></h2><ul><li><p><strong>原子性</strong>：原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p><p>比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量。</p></li><li><p><strong>可见性</strong>：理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值</p></li><li><p><strong>有序性</strong>  有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p></li></ul><h2><span id="java内存模型与缓存一致性的联系">Java内存模型与缓存一致性的联系</span></h2><p>缓存一致性问题其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的，<strong>指令重排</strong>即会导致有<strong>序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2><span id="jmm解决缓存一致性问题的方案">JMM解决缓存一致性问题的方案</span></h2><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。<strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</strong> 它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用.</p><ul><li><p>原子性问题，除了JVM自身提供的对<strong>基本数据类型读写操作的原子性</strong>外，对于方法级别或者代码块级别的原子性操作，可以使用<strong>synchronized</strong>关键字或者重入锁(<strong>ReentrantLock</strong>)保证程序执行的原子性。关于<code>synchronized</code>的详解，看博主另外一篇文章( 深入理解Java并发之synchronized实现原理)。</p></li><li><p>而工作内存与主内存同步延迟现象导致的可见性问题，可以使用<code>synchronized</code>关键字或者<code>volatile</code>关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。</p></li><li><p>对于指令重排导致的可见性问题和有序性问题，则可以利用<code>volatile</code>关键字解决，因为<code>volatile</code>的另外一个作用就是禁止重排序优化，关于<code>volatile</code>稍后会进一步分析。</p></li></ul><p>除了靠<code>sychronized</code>和<code>volatile</code>关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套<code>happens-before</code> 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。</p><h3><span id="happens-before-原则">happens-before 原则</span></h3><p>倘若在程序开发中，仅靠<code>sychronized</code>和<code>volatile</code>关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下</p><ul><li><p><strong>程序顺序原则</strong>，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p></li><li><p><strong>锁规则</strong></p><p>解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p></li><li><p><strong>volatile规则</strong></p><p>volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</p></li><li><p>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</p></li><li><p><strong>传递性 A先于B ，B先于C 那么A必然先于C</strong></p></li><li><p><strong>线程终止规则</strong></p><p>线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p></li><li><p><strong>线程中断规则</strong></p><p>对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p></li><li><p>对象终结规则 对象的构造函数执行，结束先于finalize()方法</p></li></ul><p>上述8条原则无需手动添加任何同步手段(synchronized|volatile)即可达到效果，下面我们结合前面的案例演示这8条原则如何判断线程是否安全，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的道理，存在两条线程A和B，线程A调用实例对象的writer()方法，而线程B调用实例对象的read()方法，线程A先启动而线程B后启动，那么线程B读取到的i值是多少呢？</p><p>现在依据8条原则，由于存在两条线程同时调用，因此程序次序原则不合适。writer()方法和read()方法都没有使用同步手段，锁规则也不合适。没有使用volatile关键字，volatile变量原则不适应。</p><p>线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性和本次测试案例也不合适。线程A和线程B的启动时间虽然有先后，但线程B执行结果却是不确定，也是说上述代码没有适合8条原则中的任意一条，也没有使用任何同步手段，所以上述的操作是线程不安全的，因此线程B读取的值自然也是不确定的。修复这个问题的方式很简单，要么给writer()方法和read()方法添加同步手段，如synchronized或者给变量flag添加volatile关键字，确保线程A修改的值对线程B总是可见。</p><h3><span id="as-if-serial">as-if-serial</span></h3><h3><span id="volatile内存语义">volatile内存语义</span></h3><p>i变量的任何改变都会立马反应到其他线程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="volatile禁止重排优化">volatile禁止重排优化</span></h3><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(<code>Memory Barrier</code>）。</p><p>关于<code>Memory Barrier</code> 我会在写一篇博文详细探讨他的实现方式。只需要知道，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p><p><code>Memory Barrier</code>的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的<code>instance</code>不为<code>null</code>时，<code>instance</code>的引用对象可能没有完成初始化。因为<code>instance = new DoubleCheckLock()</code>;可以分为以下3步完成(伪代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null</span></span><br></pre></td></tr></table></figure><p>由于步骤1和步骤2间可能会重排序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象</span></span><br></pre></td></tr></table></figure><p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问<code>instance</code>不为<code>null</code>时，由于<code>instance</code>实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用<code>volatile</code>禁止<code>instance</code>变量被执行指令重排优化即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁止指令重排优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br></pre></td></tr></table></figure><p>参考:</p><ul><li><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">全面理解Java内存模型(JMM)及volatile关键字</a></li><li><a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf" target="_blank" rel="noopener">JSR133中文版1.pdf</a></li><li><a href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html" target="_blank" rel="noopener">Why Memory Barriers</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(1)</title>
      <link href="/article/tcpip-overview/"/>
      <url>/article/tcpip-overview/</url>
      
        <content type="html"><![CDATA[<h1><span id="一-计算机网络体系结构分层">一、 计算机网络体系结构分层</span></h1><p><img src="/article/tcpip-overview/1561949241852tcpip-overview_.png" alt></p><p>七层网络模型是一个理想的模型，而TCP/IP 则是从中演变而来</p><h1><span id="二-tcpip-基础">二、 TCP/IP 基础</span></h1><h2><span id="1tcpip-模型">1.TCP/IP 模型</span></h2><p><img src="/article/tcpip-overview/1561949339710tcpip-overview_.png" alt></p><h2><span id="2-tcpip-的具体含义">2. TCP/IP 的具体含义</span></h2><p>TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><h2><span id="3-数据包">3. 数据包</span></h2><p>包、帧、数据包、段、消息<br>以上五个术语都用来表述数据的单位，大致区分如下：</p><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位。</li></ul><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="/article/tcpip-overview/1561949470260tcpip-overview_.png" alt></p><h2><span id="4-数据处理流程">4. 数据处理流程</span></h2><p>下图以用户 a 向用户 b 发送邮件为例子：<br><img src="/article/tcpip-overview/1561949594954tcpip-overview_.png" alt></p><p>数据处理流程</p><ul><li><p>① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p></li><li><p>② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p></li><li><p>③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p></li><li><p>④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p></li><li><p>⑤ 网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p></li><li><p>⑥ IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p></li><li><p>⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p></li><li><p>⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p></li></ul><h1><span id="三-传输层中的-tcp-和-udp">三、传输层中的 TCP 和 UDP</span></h1><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><ul><li><p>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“<strong>流控制（流量控制）</strong>”、“<strong>拥塞控制</strong>”、<strong>提高网络利用率</strong>等众多功能。</p></li><li><p>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p></li></ul><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p><h2><span id="1-端口号">1. 端口号</span></h2><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h3><span id="11-根据端口号识别应用">1.1 根据端口号识别应用</span></h3><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="/article/tcpip-overview/1561949956557tcpip-overview_.png" alt="通过端口号识别应用"></p><h3><span id="12-通过-ip-地址-端口号-协议号进行通信识别">1.2 通过 IP 地址、端口号、协议号进行通信识别</span></h3><p>通过端口号、IP地址、协议号进行通信识别</p><ul><li><p>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</p></li><li><p>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p></li></ul><h3><span id="13-端口号的确定">1.3 端口号的确定</span></h3><p>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p><p><strong>时序分配法</strong>：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</p><h3><span id="14-端口号与协议">1.4 端口号与协议</span></h3><p>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。<br>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p><h2><span id="2-udp">2. UDP</span></h2><ul><li><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</p></li><li><p>出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</p></li><li><p>此外，传输途中出现丢包，UDP 也不负责重发。</p></li><li><p>甚至当包的到达顺序出现乱序时也没有纠正的功能。<br>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p></li></ul><p>UDP 常用于一下几个方面：</p><ul><li>1.包总量较少的通信（DNS、SNMP等）；</li><li>2.视频、音频等多媒体通信（即时通信）；</li><li>3.限定于 LAN 等特定网络中的应用通信；</li><li>4.广播通信（广播、多播）。</li></ul><h2><span id="3-tcp">3. TCP</span></h2><p>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能。</p><ul><li><p>进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</p></li><li><p>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p></li><li><p>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过<code>检验和、序列号、确认应答、重发控制、连接管理以及窗口控制</code>等机制实现）。</p></li></ul><h3><span id="31-三次握手重点">3.1 三次握手（重点）</span></h3><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p><p><img src="/article/tcpip-overview/1561951414718tcpip-overview_.png" alt></p><ul><li><p><strong>第一次握手</strong>：客户端将标志位<code>SYN</code>置为1，随机产生一个值<code>seq=J</code>，并将该数据包发送给服务器端，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p></li><li><p><strong>第二次握手</strong>：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将标志位<code>SYN</code>和<code>ACK</code>都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p></li><li><p><strong>第三次握手</strong>：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p></li></ul><h4><span id="几点问题">几点问题</span></h4><ul><li><p>seq=J 随机号</p><blockquote><p>TCP握手采用随机序列号（不完全随机，而是随着时间流逝而线性增长，到了2^32尽头再回滚），为的就是让攻击者更难以猜测sequence number，因为伪造的sequence number不在合法范围内，而被接收方丢弃，增加安全性。</p></blockquote></li><li><p>ack=J+1 确认机制</p><blockquote><p>报文不一定会按发送的时序到达目标，所以要加一</p></blockquote></li><li><p>SYN 攻击</p><blockquote><p>SYN攻击。client伪造大量随机ip，向server发送SYN=1，seq=X的第一步的连接请求，server给不存在的ip发送SYN=1，ACK=1，ack=X+1,seq=Y响应，由于client的ip不是实际存在的，所以server发出的消息不能到达，server不断的重试直到超时，那么server的连接队列会被占满，正常的TCP握手请求就无法到达server，影响了正常的连接请求，导致网络阻塞或者server系统瘫痪。这种SYN攻击通过命令netstat -nap | grep SYN_RECV可以查出来.</p></blockquote><blockquote><p>于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p></blockquote><blockquote><p>请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</p></blockquote></li></ul><h3><span id="32-四次挥手重点">3.2 四次挥手（重点）</span></h3><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p><img src="/article/tcpip-overview/1561952951862tcpip-overview_.png" alt></p><p>四次挥手</p><p>中断连接端可以是客户端，也可以是服务器端。</p><ul><li><p><strong>第一次挥手</strong>: 客户端发送一个<code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入<code>FIN_WAIT_1</code>状态。意思是说&quot;我客户端没有数据要发给你了&quot;，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p></li><li><p><strong>第二次挥手</strong>: 服务器端收到FIN后，先发送<code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入<code>FIN_WAIT_2</code> 状态，继续等待服务器端的FIN报文。</p></li><li><p><strong>第三次挥手</strong> :当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入<code>LAST_ACK</code>状态。</p></li><li><p><strong>第四次挥手</strong>: 客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送<code>ack=N+1</code>后进入<code>TIME_WAIT</code>状态，如果Server端没有收到<code>ACK</code>则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</p></li></ul><h3><span id="33-tcp超时与重传机制">3.3 TCP超时与重传机制</span></h3><p><img src="/article/tcpip-overview/1562118945313tcpip-overview_.png" alt></p><p>TCP协议是一种面向连接的可靠的传输层协议，它保证了数据的可靠传输，对于一些出错，超时丢包等问题TCP设计的超时与重传机制。</p><p><strong>其基本原理</strong>：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><p>这里比较重要的是重传超时时间，怎样设置这个定时器的时间（RTO），从而保证对网络资源最小的浪费。因为若RTO太小，可能有些报文只是遇到拥堵或网络不好延迟较大而已，这样就会造成不必要的重传。太大的话，使发送端需要等待过长的时间才能发现数据丢失，影响网络传输效率。</p><p>由于不同的网络情况不一样，不可能设置一样的RTO，实际中RTO是根据网络中的 <code>RTT</code>（传输往返时间）来自适应调整的。 这里就不展开了。</p><h3><span id="34-tcp流量控制">3.4 TCP流量控制</span></h3><p>图解：</p><p><img src="/article/tcpip-overview/1562037078236tcpip-overview_.png" alt></p><ul><li>滑动窗口协议</li></ul><p>TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。</p><p><img src="/article/tcpip-overview/1562039919707tcpip-overview_.png" alt></p><p>TCP消息确认机制如上图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备B定期发送给A一条发送限制参数，制约设备A一次能发送的消息最大数量。设备B可以对该参数进行调整，以控制设备A的数据流。</p><p>为了提高速度，TCP并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用message ID字段，而是使用的片段内最后一个字节的sequence number。因此一次可以处理不同的字节数，这一数量即为片段内的sequence number。</p><ul><li><ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；</li></ol></li><li><ol start="2"><li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li></ol></li><li><ol start="3"><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li></ol></li><li><ol start="4"><li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol></li></ul><p>我们来看一个例子：</p><ul><li><strong>TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为<code>20</code></strong>：</li></ul><p><img src="/article/tcpip-overview/1562040200219tcpip-overview_.png" alt></p><ul><li><strong>A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组</strong>：</li></ul><p><img src="/article/tcpip-overview/1562040234614tcpip-overview_.png" alt></p><ul><li><strong>只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递</strong></li></ul><p><img src="/article/tcpip-overview/1562041418982tcpip-overview_.png" alt></p><ul><li><p>回退协议</p><ul><li>TCP片段重传计时器以及重传队列:<br>检测丢失片段并对之重传的方法概念上是很简单的。每一次发送一个片段，就开启一个重传计时器。计时器有一个初始值并随时间递减。如果在片段接收到确认之前计时器超时，就重传片段。TCP使用了这一基本技术，但实现方式稍有不同。原因在于为了提高效率需要一次处理多个未被确认的片段，以保证每一个在恰当的时间重传。TCP按照以下特定顺序工作：</li></ul></li><li><p>比特滑动窗口协议</p><p>滑动窗口协议的理论，实际应用中又有不同。首先就是停等协议(stop－and－wait)，这时接受方的窗口和发送方的窗口大小都是1，1个比特就够表示了，所以也叫1比特滑动窗口协议。发送方这时自然发送每次只能发送一个，并且必须等待这个数据包的ACK，才能发送下一个。虽然在效率上比较低，带宽利用率明显较低，不过在网络环境较差，或是带宽本身很低的情况下，还是适用的。看下面的流程图：</p></li><li><p>退后N帧协议</p><p>停等协议虽然实现简单，也能较好的适用恶劣的网络环境，但是显然效率太低。所以有了后退n协议，这也是滑动窗口协议真正的用处，这里发送的窗口大小为n，接受方的窗口仍然为1。具体看下面的图，这里假设n=9：      首先发送方一口气发送10个数据帧，前面两个帧正确返回了，数据帧2出现了错误，这时发送方被迫重新发送2-8这7个帧，接受方也必须丢弃之前接受的3-8这几个帧。      后退n协议的好处无疑是提高了效率，但是一旦网络情况糟糕，则会导致大量数据重发，反而不如上面的停等协议，实际上这是很常见的，<br><img src="/article/tcpip-overview/1562119313949tcpip-overview_.png" alt></p></li><li><p>选择重传协议（Fast Retransmit）</p><p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p><p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p><p><img src="/article/tcpip-overview/1562043567516tcpip-overview_.png" alt></p><p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p></li></ul><ul><li><p>SACK 方法</p><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p><p><img src="/article/tcpip-overview/1562119794860tcpip-overview_.png" alt></p><p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p><p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p><p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》</p></li></ul><h3><span id="35-tcp拥塞控制">3.5 TCP拥塞控制</span></h3><ol><li>慢开始（slow start）<br>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</li></ol><p>慢启动的算法如下(cwnd全称Congestion Window)：</p><ul><li><p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p></li><li><p>2）每当收到一个ACK，cwnd++; 呈线性上升</p></li><li><p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p></li><li><p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p></li></ul><p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p><p><img src="/article/tcpip-overview/1562120996693tcpip-overview_.png" alt></p><ol start="2"><li>拥塞避免（Congestion Avoidance）</li></ol><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p><ul><li><p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p></li><li><p>2）当每过一个RTT时，cwnd = cwnd + 1</p></li></ul><p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p><ol start="3"><li><p>快速重传（fast retransmit）<br>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认</p><p><img src="/article/tcpip-overview/1562121439564tcpip-overview_.png" alt></p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%</p></li></ol><ol start="4"><li><p>快速回复（fast recovery）</p><ul><li><p>1:当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p></li><li><p>2:由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p></li><li><p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p></li></ul><p><img src="/article/tcpip-overview/1562121516316tcpip-overview_.png" alt></p><p>实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用,采用这样的拥塞控制方法使得TCP的性能有明显的改进</p></li></ol><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之数据结构篇——树（2）</title>
      <link href="/article/data-structure-tree-b-puls/"/>
      <url>/article/data-structure-tree-b-puls/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><span style="font-family: 方正姚体; font-size: large;">概诉 </span></p><hr><h2><span id="b-树的定义">B+ 树的定义</span></h2><p><img src="/article/data-structure-tree-b-puls/1577764304776data-structure-tree-b-puls_.png" alt></p><p>关于B树的阶数和度数已经在上一篇<a href="https://icefrozen.github.io/article/B-Tree-And-B-Tree/" target="_blank" rel="noopener">算法探秘系列之数据结构篇——树（1）</a></p><p><span style="font-family: 仿宋; font-size: large;">除此之外B+树还有以下的要求。</span></p><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</span></p></li></ul><p> </p><h2><span id="b-树的操作">B+ 树的操作</span></h2><h1><span id="一-b树的插入操作"><span style="font-family: 黑体; font-size: x-large;">一、B+树的插入操作</span></span></h1><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</span></p></li></ul><p><span style="font-family: 仿宋; font-size: large;">下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">a）空树中插入5</span></p><p><img src="/article/data-structure-tree-b-puls/1577764324380data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">b）依次插入8，10，15</span></p><p><img src="/article/data-structure-tree-b-puls/1577764335394data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">c）插入16</span></p><p><img src="/article/data-structure-tree-b-puls/1577764346561data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764357872data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">d）插入17</span></p><p><img src="/article/data-structure-tree-b-puls/1577764368991data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">e）插入18，插入后如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764378857data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764389302data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数满足条件，插入结束。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">f）插入若干数据后</span></p><p><img src="/article/data-structure-tree-b-puls/1577764399238data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">g）在上图中插入7，结果如下图所示 </span></p><p><img src="/article/data-structure-tree-b-puls/1577764406347data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764418069data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764428601data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数满足条件，插入结束。</span></p><p> </p><h1><span id="二-b树的删除操作"><span style="font-family: 黑体;"><span style="font-size: x-large;">二、B+树的删除操作</span></span></span></h1><p><span style="font-family: 仿宋; font-size: large;">如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</span></p><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</span></p></li></ul><p><span style="font-family: 仿宋; font-size: large;">注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</span></p><p><span style="font-family: 仿宋; font-size: large;">下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">a）初始状态</span></p><p><img src="/article/data-structure-tree-b-puls/1577764441677data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">b）删除22,删除后结果如下图</span></p><p><img src="/article/data-structure-tree-b-puls/1577764449973data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">删除后叶子结点中key的个数大于等于2，删除结束</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">c）删除15，删除后的结果如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764460004data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764479201data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">d）删除7，删除后的结果如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764487719data-structure-tree-b-puls_.png" alt><br><span style="font-family: 仿宋; font-size: large;">当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764500392data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764509124data-structure-tree-b-puls_.png" alt></p><h4><span id> </span></h4><h4><span id="3参考内容"><span style="font-family: 黑体; font-size: large; font-weight: normal;">3.参考内容</span></span></h4><p>[1] <a href="https://www.cnblogs.com/wade-luffy/p/6292784.html" target="_blank" rel="noopener">B+树介绍</a><br>[2] <a href="http://hedengcheng.com/?p=525" target="_blank" rel="noopener">从MySQL Bug#67718浅谈B+树索引的分裂优化</a><br>[3] <a href="https://www.jianshu.com/p/6f68d3c118d6" target="_blank" rel="noopener">B+树的几点总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之概率随机算法(1)</title>
      <link href="/article/bloomfilter/"/>
      <url>/article/bloomfilter/</url>
      
        <content type="html"><![CDATA[<h2><span id="什么是布隆过滤器">什么是布隆过滤器</span></h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h2><span id="实现原理">实现原理</span></h2><h3><span id="hashmap-的问题">HashMap 的问题</span></h3><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p><h3><span id="布隆过滤器数据结构">布隆过滤器数据结构</span></h3><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br><img src="/article/bloomfilter/1561976816306bloomfilter_.png" alt></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：<br><img src="/article/bloomfilter/1561977049305bloomfilter_.png" alt></p><p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/article/bloomfilter/1561977074282bloomfilter_.png" alt></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><h4><span id="支持删除么">支持删除么</span></h4><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。</p><p>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。</p><h4><span id="false-positives-概率推导">False positives 概率推导</span></h4><p>假设 Hash 函数以等概率条件选择并设置 Bit Array 中的某一位，<code>m</code> 是该位数组的大小，<code>k</code> 是 <code>Hash</code> 函数的个数，那么位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是:</p><div align="center"><p><img src="/article/bloomfilter/1561977732449bloomfilter_.png" alt></p></div><p>那么在所有 k 次 Hash 操作后该位都没有被置 “1” 的概率是：</p><div align="center"><p><img src="/article/bloomfilter/1561977826148bloomfilter_.png" alt></p></div><p>如果我们插入了 n 个元素，那么某一位仍然为 “0” 的概率是</p><div align="center"><p><img src="/article/bloomfilter/1561977842227bloomfilter_.png" alt></p></div><p>因而该位为 &quot;1&quot;的概率是：</p><div align="center"><p><img src="/article/bloomfilter/1561977861881bloomfilter_.png" alt></p></div><p>现在检测某一元素是否在该集合中。标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 “1”，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定：</p><div align="center"><p><img src="/article/bloomfilter/1561977925870bloomfilter_.png" alt></p></div>其中：<div align="center"><p><img src="/article/bloomfilter/1561979531108bloomfilter_.png" alt></p></div><p>其实上述结果是在假定由每个 Hash 计算出需要设置的位（bit） 的位置是相互独立为前提计算出来的，不难看出，随着 m （位数组大小）的增加，假正例（False Positives）的概率会下降，同时随着插入元素个数 n 的增加，False Positives的概率又会上升，对于给定的m，n，如何选择Hash函数个数 k 由以下公式确定：</p><div align="center"><p><img src="/article/bloomfilter/1561979719773bloomfilter_.png" alt></p></div><h4><span id="k-值的估算">K 值的估算</span></h4><div align="center"><p><img src="/article/bloomfilter/1561981022666bloomfilter_.png" alt></p></div><h4><span id="bloom-filter内存占用">Bloom Filter内存占用</span></h4><p><img src="/article/bloomfilter/1561982659598bloomfilter_.png" alt></p><h4><span id="结论">结论</span></h4><p>当 K 为一下值的时候 误差率最小</p><div align="center"><p><img src="/article/bloomfilter/1561979719773bloomfilter_.png" alt></p></div>此时的误差为：<div align="center"><p><img src="/article/bloomfilter/1561979726393bloomfilter_.png" alt></p></div><p>此时的 M 即空间消耗为：</p><div align="center"><p><img src="/article/bloomfilter/1561979739269bloomfilter_.png" alt></p></div><h2><span id="布隆过滤器的应用场景">布隆过滤器的应用场景</span></h2><ul><li>大数据去重</li><li>网页爬虫对URL的去重，避免爬取相同的URL地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li><li>缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Redis </tag>
            
            <tag> 概率随机算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之数据结构篇——树（1）</title>
      <link href="/article/B-Tree-And-B-Tree/"/>
      <url>/article/B-Tree-And-B-Tree/</url>
      
        <content type="html"><![CDATA[<p><strong><em>注意：首先需要说明的一点是：B-树就是B树，没有所谓的B减树</em></strong></p><h1><span id="引言">引言</span></h1><p>我们都知道二叉查找树的查找的时间复杂度是Ｏ(log N)，其查找效率已经足够高了，那为什么还有Ｂ树和Ｂ＋树的出现呢？难道它两的时间复杂度比二叉查找树还小吗？</p><p>答案当然不是，Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是磁盘ＩＯ，众所周知ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。<br>　　所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是：</p><ul><li>(1)、<strong>每个节点存储多个元素</strong></li><li>(2)、<strong>摒弃二叉树结构，采用多叉树</strong></li></ul><p>这样就引出来了一个新的查找树结构 ——多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B~树)自然可以使得数据的查找效率保证在O(logN)这样的对数级别上。即多路平衡查找树</p><p>下面来具体介绍一下<code>B树（Balance Tree）</code>，</p><h1><span id="b树">Ｂ树</span></h1><h3><span id="b树的定义">B树的定义</span></h3><p>一个m阶的B树具有如下几个<strong>特征</strong>：B树中所有结点的孩子结点最大值称为B树的阶，通常用m表示。一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集。<br>这里 k 表示为度，而m 表示为阶数</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含<code>k-1</code>个元素和<code>k</code>个孩子，其中 <code>ceil（m/2） ≤ k ≤ m</code></li><li>每一个叶子节点都包含<code>k-1</code>个元素，其中 <code>ceil（m/2） ≤ k ≤ m</code></li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中<code>k-1</code>个元素正好是k个孩子包含的元素的值域划分</li><li>每个结点的结构为：<code>（n，A0，K1，A1，K2，A2，… ，Kn，An）</code>其中，<code>Ki(1≤i≤n)</code>为关键字，且<code>Ki&lt;Ki+1(1≤i≤n-1)</code>。<br><code>Ai(0≤i≤n)</code>为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于<code>Ki+1</code>。<code>n</code>为结点中关键字的个数，满足<code>ceil(m/2)-1≤n≤m-1</code>。</li></ol><h3><span id="示例三阶b树">示例：三阶B树</span></h3><p><img src="/article/B-Tree-And-B-Tree/1559615879973B-Tree-And-B-Tree_.png" alt></p><h3><span id="b树的两种定义">B树的两种定义</span></h3><p>B树的两种定义，一种是算法导论中的度数说；另一种是维基百科的阶数说。</p><p><strong>度数</strong>：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。<br><strong>阶数</strong>：（Order）阶定义为一个节点的子节点数目的最大值。（自带最大值属性）<br>然后再结合B树来理解具体含义：</p><h3><span id="度数与阶数的区别">度数与阶数的区别</span></h3><p>每个节点（结点）所包含的关键字个数有上界和下界。用一个被称为B树的<code>最小度数（minmum degree</code>）的固定整数<code>t&gt;=2</code>来表示这些界。</p><p><strong>a . 除根节点外每个节点至少包含 t-1 个关键字；至少有t个孩子。</strong><br><strong>b . 每个节点至多可包含 2t-1 个关键字，至多 2t 个孩子节点。</strong></p><p>比如当t=2时，每个内部节点可以有2，3，4个孩子。此时该B树的阶为4。</p><p><strong>至于这两种定义的差别请参考知乎<a href="https://www.zhihu.com/question/19836260" target="_blank" rel="noopener">为什么 B-tree 在不同著作中度的定义有一定差别？</a></strong></p><p>我这里只做简单的介绍，度的定义用来优化阶的定义，主要却别在于，阶数只能定义一个节点满和不满的情况，而度则是在基础上对应了 不满，半满，和全满的情况。 半满对应阶数的满情况，当节点达到全满的情况下才去分裂节点，这样既能满足b树的平衡，用能减少分裂带来的需要找到父节点所带来的开销，毕竟b树的应用场景还是数据库的索引。</p><h2><span id="查询">查询</span></h2><p>以上图为例：若查询的数值为５：</p><ul><li><strong>第一次磁盘ＩＯ</strong>：在内存中定位（与17、35比较），比17小，左子树；</li><li><strong>第二次磁盘ＩＯ</strong>：在内存中定位（与８、12比较），比８小，左子树；</li><li><strong>第三次磁盘ＩＯ</strong>：在内存中定位（与3、5比较），找到5，终止。</li></ul><p>整个过程中，我们可以看出：比较的次数并不比二叉查找树少，尤其适当某一节点中的数据很多时，但是磁盘IO的次数却是大大减少。比较是在内存中进行的，相比于磁盘IO的速度，比较的耗时几乎可以忽略。所以当树的高度足够低的话，就可以极大的提高效率。相比之下，节点中的元素多点也没关系，仅仅是多了几次内存交互而已，只要不超过磁盘页的大小即可。</p><h2><span id="插入">插入</span></h2><h3><span id="插入逻辑">插入逻辑</span></h3><p>对度数为<code>ｋ</code>的<code>m</code>阶B树，新结点一般是插在叶子层。通过检索可以确定关键码应插入的结点位置。然后分两种情况讨论：</p><ol><li>如果根节点的关键字 等于 <code>2k - 1</code> 则根节点分裂（）</li><li>循环找到B树要插入的叶节点（因为插入总发生在叶子节点）<br>在插入过程中会遇到节点数 满足 <code>2k - 1</code>的节点，遇到这样的节点就要分裂（以度数<code>k</code>为中心点分裂）。当分裂完成之后，必然会产生<code>t</code> 和 <code>t - 1</code> 关键字的两个节点，而分裂的节点又会上升到父节点当中去，所以，父节点的关键字数不能等于 <code>2k - 1</code>否则将不匹配B数的定义</li><li>当经过第二步完成的时候，必然会找到一个叶子节点，其关键字 小于等于 <code>2k - 1</code>，然后插入改节点。注意这里面的关键字可以是 小于，也可以是等于。</li></ol><p>注意：  为什么没有用阶数m用于区分原因就是，当<code>m</code> 数是一个固定的数字，没有缓冲边界。所以，一定<code>m</code> 满足了某种特定的条件，则必须要要分裂，分裂导致的父节点关键字+1 可能会引起父节点的分裂。一次类推，导致这种分裂将会一直想上直到根节点，在索引中目的就是要减少内存页的置换次数，如果一直分裂到父节点，意味着内存页面的置换需要一直进行到父节点。因此，为了减少这次的置换调用，算法导论中用了度数来替代阶数的定义，这样就是的每个非叶子节点的关键字个数从放宽了一个限制，在每次插入的时候，在进行分裂，这样就避免了上述多余一次的调用。</p><h3><span id="插入举例">插入举例</span></h3><p>例如：<br>我们以<code>[13, 3, 17, 10, 4, 12, 19, 9, 15, 18, 8, 2, 0, 6, 1, 16, 7, 11, 5, 14]</code> 序列来插入</p><p>例如：<br><img src="/article/B-Tree-And-B-Tree/1561375198045B-Tree-And-B-Tree_.png" alt></p><h4><span id="插入">插入</span></h4><p>插入逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,key)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(self.root) == self.degree * <span class="number">2</span> - <span class="number">1</span>:</span><br><span class="line">        <span class="comment">## 分裂根节点</span></span><br><span class="line">        self.root = self.root.split(node(isLeaf=<span class="literal">False</span>),self.degree)</span><br><span class="line">        self.nodeNum +=<span class="number">2</span></span><br><span class="line">    nd = self.root</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        idx = nd.findKey(key) <span class="comment"># 找到key 的位置</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt; len(nd) <span class="keyword">and</span> nd[idx] == key:<span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 插入操作总在叶子节点发生</span></span><br><span class="line">        <span class="keyword">if</span> nd.isLeafNode():</span><br><span class="line">            nd.insert(idx,key)</span><br><span class="line">            self.keyNum+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chd = nd.getChd(idx)</span><br><span class="line">            <span class="comment"># 当节点分裂只会，chd 就已经在树中被阻断了，因此这边要记下来，应为chd的child 毕竟</span></span><br><span class="line">            <span class="keyword">if</span> len(chd) == self.degree*<span class="number">2</span><span class="number">-1</span>: </span><br><span class="line">                <span class="comment"># split 返回的其实是chd 的parent_node 很为在split 就已经处理过了parent</span></span><br><span class="line">                <span class="comment"># 所以下次插入的key的寻找节点还要在这里开始</span></span><br><span class="line">                nd = chd.split(nd,self.degree)</span><br><span class="line">                self.nodeNum +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nd = chd</span><br></pre></td></tr></table></figure><h4><span id="分裂">分裂</span></h4><p>我们来看分裂的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self,prt,t)</span>:</span></span><br><span class="line">    <span class="comment"># 度数 可以用来分割节点   prt 为parent_node</span></span><br><span class="line">    k = self[t<span class="number">-1</span>]</span><br><span class="line">    nd1 = node()</span><br><span class="line">    nd2 = node()</span><br><span class="line">    nd1.keys,nd2.keys = self[:t<span class="number">-1</span>], self[t:] <span class="comment"># note that t is 1 bigger than  key index</span></span><br><span class="line">    nd1.isLeaf = nd2.isLeaf = self.isLeaf</span><br><span class="line">    <span class="comment"># 非叶子节点的分裂</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.isLeaf: </span><br><span class="line">        <span class="comment"># note that  children index is one bigger than key index, and all children included</span></span><br><span class="line">        nd1.children, nd2.children = self.children[<span class="number">0</span>:t], self.children[t:] </span><br><span class="line">    <span class="comment"># connect them to parent</span></span><br><span class="line">    idx = prt.findKey(k)</span><br><span class="line">    <span class="keyword">if</span> prt.children !=[]: prt.children.remove(self) <span class="comment"># remove the original node</span></span><br><span class="line">    prt.insert(idx,k,nd2)</span><br><span class="line">    prt.insert(idx,nd = nd1)</span><br><span class="line">    <span class="keyword">return</span> prt</span><br></pre></td></tr></table></figure><h4><span id="最后结果">最后结果</span></h4><p>最后的树结构如下<br><img src="/article/B-Tree-And-B-Tree/1561375618993B-Tree-And-B-Tree_.png" alt></p><h2><span id="删除">删除</span></h2><p>Ｂ树中关键字的删除比插入更复杂，在这里，只介绍其中的一种方法：</p><p>在B树上删除关键字k的过程分两步完成： <strong>找出该关键字所在的结点。然后根据 <code>k</code>所在结点是否为叶子结点有不同的处理方法。</strong></p><h4><span id="第一步-找出删除节点">第一步 找出删除节点</span></h4><ul><li><strong>若该结点为<code>非叶结点</code></strong>，<ol><li>找到被删除的<code>key</code>所在的节点。</li><li>在<code>key</code>节点所在的子树找到叶节点,并找出改叶节点的最大的关键字<code>Y</code>,并记录下查找的节点的路径。</li><li>替换这个<code>Y</code>,当前<code>key</code></li><li>然后依次从后往前遍历节点路径中不满足定义的节点，然后根据情况左选右选或者合并，用来保持b树的平衡。</li></ol></li></ul><h4><span id="第一步-由小到大自平衡">第一步 由小到大自平衡</span></h4><ul><li><p>如果被删关键字所在结点的原关键字个数小于<code>k - 1</code>，说明删去该关键字后该结点不满足B树的定义。</p></li><li><p>自平衡的过程就是想兄弟或者父母借节点，使得父兄组成的树中是自平衡的，这个时候会有如下几种情况</p><ul><li>兄弟关键字个数大于 <code>k</code></li><li>左边和右边关键字个数都小于等于 <code>k</code></li></ul></li><li><p><strong>兄弟关键字个数大于 <code>k</code></strong><br>则可将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在结点中。然后将上升的左右节点根据情况连接到改节点的左右孩子上</p></li></ul><p>例如： 删除<code>3</code> 这个节点</p><p><img src="/article/B-Tree-And-B-Tree/1561377183013B-Tree-And-B-Tree_.png" alt></p><ul><li><p><strong>左边和右边关键字个数都小于等于 <code>k</code></strong></p><p>1、 将兄弟节点合并成一个节点<br>2、 将父节点拿下一个来放到这个新节点当中<br>3、 删除父节点拿下来的这个<code>key</code><br>4、 然后父节点在自平衡一下</p></li></ul><p>例子： 我们来看一下 删除<code>3</code>后在接近这删除<code>2</code></p><ul><li>第一步：删除节点 这个时候我们路保存了路径<br><img src="/article/B-Tree-And-B-Tree/1561379292282B-Tree-And-B-Tree_.png" alt></li><li>第二部，兄弟节点过少，无法满足平衡，合并兄弟节点，将父节点拿下来</li><li>第三部（左旋转），这个父节点（1,2的父节点） 再次自平衡，将root 的4 拿下来，root节点的下一个孩子的最小值拿上来8，然后，然后8的左孩子给到 1，2 父节点的右孩子<br><img src="/article/B-Tree-And-B-Tree/1561379255788B-Tree-And-B-Tree_.png" alt></li></ul><p>总之，设所删关键字为非终端结点中的Ki，则可以指针Ai所指子树中的最小关键字Y代替Ki，然后在相应结点中删除Y。对任意关键字的删除都可以转化为对最下层关键字的删除。</p><p>我们来看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebalance</span><span class="params">(self,fathers)</span>:</span></span><br><span class="line">    <span class="comment"># fatners 表示 这个节点，key 节点位置 父节点的指针</span></span><br><span class="line">    nd,keyIdx,chdIdx = fathers.pop()</span><br><span class="line">    <span class="keyword">while</span> len(nd)&lt;self.degree - <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 当节点已经不平衡的时候 找到他的父节点</span></span><br><span class="line">        prt,keyIdx,chdIdx = fathers[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 左边兄弟</span></span><br><span class="line">        lbro = [] <span class="keyword">if</span> chdIdx==<span class="number">0</span> <span class="keyword">else</span> prt.getChd(chdIdx<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右边的兄弟</span></span><br><span class="line">        rbro = [] <span class="keyword">if</span> chdIdx==len(prt) <span class="keyword">else</span> prt.getChd(chdIdx+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果左右兄弟都没有到 degree 则两个兄弟合并</span></span><br><span class="line">        <span class="keyword">if</span> len(lbro) &lt; self.degree <span class="keyword">and</span> len(rbro) &lt; self.degree:  <span class="comment"># merge two deficient nodes </span></span><br><span class="line">            beforeNode,afterNode = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">            <span class="comment"># 把父亲的 keyindex 拿下来，然后在想左边兄弟借一个key</span></span><br><span class="line">            <span class="keyword">if</span> lbro ==[]:</span><br><span class="line">                keyIdx = chdIdx</span><br><span class="line">                beforeNode,afterNode = nd,rbro</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果左边的兄弟为空 则把这个节点和右边的节点合并</span></span><br><span class="line">                beforeNode,afterNode = lbro,nd</span><br><span class="line">                keyIdx = chdIdx<span class="number">-1</span>      <span class="comment"># important, when choosing </span></span><br><span class="line">            keys = beforeNode[:]+[prt[keyIdx]]+afterNode[:]</span><br><span class="line">            <span class="comment"># 合并节点的孩子</span></span><br><span class="line">            children = beforeNode.getChildren() + afterNode.getChildren()</span><br><span class="line">            isLeaf = beforeNode.isLeafNode()</span><br><span class="line">            prt.delChd(keyIdx+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">del</span> prt[keyIdx]</span><br><span class="line">            nd.update(keys,isLeaf,children)</span><br><span class="line">            prt.children[keyIdx]=nd</span><br><span class="line">            self.nodeNum -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> len(lbro)&gt;=self.degree:  <span class="comment"># rotate  when only one sibling is deficient</span></span><br><span class="line">            <span class="comment"># 右旋转</span></span><br><span class="line">            keyIdx = chdIdx<span class="number">-1</span></span><br><span class="line">            nd.insert(<span class="number">0</span>,prt[keyIdx])    <span class="comment"># rotate keys</span></span><br><span class="line">            prt[keyIdx] =  lbro[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span> lbro[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nd.isLeafNode():     <span class="comment"># if not leaf, move children</span></span><br><span class="line">                nd.insert(<span class="number">0</span>,nd=lbro.getChd(<span class="number">-1</span>))</span><br><span class="line">                lbro.delChd(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左旋转 父节点拿下一个key 父节点右边第一个子树的根节点上升一个节点</span></span><br><span class="line">            <span class="comment"># 上升的一个节点左孩子链接到当前孩子的右子树当中去</span></span><br><span class="line">            keyIdx = chdIdx</span><br><span class="line">            nd.insert(len(nd),prt[keyIdx])    <span class="comment"># rotate keys</span></span><br><span class="line">            prt[keyIdx] =  rbro[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">del</span> rbro[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nd.isLeafNode():     <span class="comment"># if not leaf, move children</span></span><br><span class="line">                <span class="comment">#note that insert(-1,ele) will make the ele be the last second one</span></span><br><span class="line">                nd.insert(len(nd),nd=rbro.getChd(<span class="number">0</span>))</span><br><span class="line">                rbro.delChd(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> len(fathers)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.root)==<span class="number">0</span>: </span><br><span class="line">                self.root = nd</span><br><span class="line">                self.nodeNum -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nd,i,j = fathers.pop()</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>①、B树主要用于文件系统以及部分数据库索引，例如： MongoDB。而大部分关系数据库则使用B+树做索引，例如：mysql数据库；<br>　　②、从查找效率考虑一般要求B树的阶数m &gt;= 3;<br>　　③、B-树上算法的执行时间主要由读、写磁盘的次数来决定，故一次I/O操作应读写尽可能多的信息。因此B-树的结点规模一般以一个磁盘页为单位。一个结点包含的关键字及其孩子个数取决于磁盘页的大小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁的实现 redis篇</title>
      <link href="/article/distributed-redis-lock/"/>
      <url>/article/distributed-redis-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>在大多数的情况下，我们需要对一个共享资源进行写操作，在分布式的环境下，对于资源的写操作的互斥性就显得尤为重要。由于生产环境对redis有很多依赖，所以最近在分布式锁的实现上进行了一些调研。</p><p>对于锁的安全性，一直是分布式领域不可逃避的话题，一个分布式锁的实现在网上所以下，就会发现，这些文章的思路大体相近，给出的实现算法也看似合乎逻辑，但当我们着手去实现它们的时候，却发现如果你越是仔细推敲，疑虑也就越来越多。</p><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者antirez之间就发生过一场争论。由于对这个问题一直以来比较关注，所以我前些日子仔细阅读了与这场争论相关的资料。这场争论的大概过程是这样的：为了规范各家对基于Redis的分布式锁的实现，Redis的作者提出了一个更安全的实现，叫做<code>Redlock</code>。有一天，Martin Kleppmann写了一篇<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">blog</a>，分析了Redlock在安全性上存在的一些问题。</p><p>本文结合redsiion 的对分布式锁的单点的实现机制，在结合集群下的Redlock的实现机制，分析一下分布式锁在现阶段出现的问题。</p><h2><span id="基于单redis节点的分布式锁">基于单Redis节点的分布式锁</span></h2><h2><span id="一-redisson的简单应用">一、Redisson的简单应用</span></h2><p>Redisson的官网，看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。下面给大家看一段简单的使用代码片段，先直观的感受一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br><span class="line">lock.lock()</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><h2><span id="二-redisson实现redis分布式锁的底层原理">二、Redisson实现Redis分布式锁的底层原理</span></h2><p>好的，接下来就通过一张手绘图，给大家说说Redisson这个开源框架对Redis分布式锁的实现原理。</p><p><img src="/article/distributed-redis-lock/1561904661761distributed-redis-lock_.png" alt></p><h3><span id="1加锁机制">（1）加锁机制</span></h3><p>如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。这里注意，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段lua脚本到redis上，因为可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。那段lua脚本如下所示：</p><p><img src="/article/distributed-redis-lock/1561904682972distributed-redis-lock_.png" alt></p><p>那么，这段lua脚本是什么意思呢？这里KEYS[1]代表的是你加锁的那个key，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(&quot;myLock&quot;);</span><br></pre></td></tr></table></figure><p>这里你自己设置了加锁的那个锁key就是<code>myLock</code>。<br><code>ARGV[1]</code>代表的就是锁key的默认生存时间，默认30秒。<br><code>ARGV[2]</code>代表的是加锁的客户端的ID，类似于下面这样：<br><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：hset myLock</p><p><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylock:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span>:<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p><p>这里一定要增加一个myLock的生存时间。否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。</p><h3><span id="2锁互斥机制">（2）锁互斥机制</span></h3><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h3><span id="3watch-dog自动延期机制">（3）watch dog自动延期机制</span></h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h3><span id="4可重入加锁机制">（4）可重入加锁机制</span></h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？比如下面这种代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br><span class="line">lock.lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// coding</span></span><br><span class="line">lock.lock()</span><br><span class="line"><span class="comment">// coding</span></span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="comment">//codeing</span></span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><p>这时我们来分析一下上面那段lua脚本。第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</p><p>此时就会执行可重入加锁的逻辑，他会用：</p><p>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1  ，通过这个命令，对客户端1的加锁次数，累加1。此时myLock数据结构变为下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylock:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p><h3><span id="5释放锁机制">（5）释放锁机制</span></h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：“del myLock”命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的分布式锁的开源Redisson框架的实现机制。</p><p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p><h3><span id="6上述redis分布式锁的缺点">（6）上述Redis分布式锁的缺点</span></h3><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</p><p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p><p>所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</p><h2><span id="基于分布式redis的redlock-的分布式锁的实现机制">基于分布式redis的RedLock 的分布式锁的实现机制</span></h2><p>由于前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此提出了新的分布式锁的算法<code>Redlock</code>，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><h4><span id="加锁过程">加锁过程</span></h4><ul><li>获取当前时间（毫秒数）。</li><li>按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同, 为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</li></ul><ul><li><p>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p></li><li><p>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p></li><li><p>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即<strong>向所有</strong>Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p></li></ul><blockquote><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p></blockquote><h4><span id="redlock-出现的问题">Redlock 出现的问题</span></h4><h5><span id="崩溃重启">崩溃重启</span></h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><ul><li>客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</li><li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li><li>节点C重启后，客户端2锁住了C, D, E，获取锁成功。</li></ul><p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p><strong>延迟重启(delayed restarts)</strong> 的概念。</p><p>也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5><span id="客户端长期阻塞导致锁过期">客户端长期阻塞导致锁过期</span></h5><p>假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。</p><p>客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p><p><img src="/article/distributed-redis-lock/1561904900083distributed-redis-lock_.png" alt></p><p>系统环境太复杂，仍然有很多原因导致进程的pause，比如虚存造成的缺页故障(page fault)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果, 即客户端进程卡死的问题。</p><p><strong>fencing token</strong> 解决方案</p><p>fencing token是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图</p><p><img src="/article/distributed-redis-lock/1561904882527distributed-redis-lock_.png" alt><br>在上图中，客户端1先获取到的锁，因此有一个较小的fencing token，等于33，而客户端2后获取到的锁，有一个较大的fencing token，等于34。客户端1从GC pause中恢复过来之后，依然是向存储服务发送访问请求，但是带了fencing token = 33。存储服务发现它之前已经处理过34的请求，所以会拒绝掉这次33的请求。这样就避免了冲突。</p><h5><span id="时钟跳转以及网络延迟">时钟跳转以及网络延迟</span></h5><p>对于时钟的过分依赖也将会导致redlock分布式锁的一些问题，首先给出了下面的两个例子（还是假设有5个Redis节点A, B, C, D, E）：</p><ul><li><p><strong>时钟跳转</strong></p><ul><li>客户端1从Redis节点A, B, C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。</li><li>节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。</li><li>客户端2从Redis节点C, D, E成功获取了同一个资源的锁（多数节点）。</li><li>客户端1和客户端2现在都认为自己持有了锁。</li></ul></li><li><p><strong>网络延迟</strong></p><ul><li>客户端1向Redis节点A, B, C, D, E发起锁请求。</li><li>各个Redis节点已经把请求结果返回给了客户端1，但客户端1在收到请求结果之前进入了长时间的GC pause。</li><li>在所有的Redis节点上，锁过期了。</li><li>客户端2在A, B, C, D, E上获取到了锁。</li><li>客户端1从GC pause从恢复，收到了前面第2步来自各个Redis节点的请求结果。客户端1认为自己成功获取到了锁。<br>+客户端1和客户端2现在都认为自己持有了锁。</li></ul></li></ul><p>时钟跳跃的时候，举了两个可能造成时钟跳跃的具体例子：</p><ul><li>系统管理员手动修改了时钟。</li><li>从NTP服务收到了一个大的时钟更新事件。</li></ul><p>对于这个方面的解决是：</p><ul><li>手动修改时钟这种人为原因，不要那么做就是了。否则的话，如果有人手动修改Raft协议的持久化日志，那么就算是Raft协议它也没法正常工作了。</li><li>使用一个不会进行“跳跃”式调整系统时钟的ntpd程序（可能是通过恰当的配置），对于时钟的修改通过多次微小的调整来完成。</li></ul><p>另外一个是个网络延迟，网络延迟目前在分布式锁中没有较好的解决方案，即所有的分布式系统当中都将面临这个问题，而redlock的作者也明确表示过。</p><h2><span id="分布式锁的结论">分布式锁的结论</span></h2><p>在Martin的文章中，还有一个很有见地的观点，就是对锁的用途的区分。他把锁的用途分为两种：</p><ul><li><p>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email。</p></li><li><p>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其它严重的问题。<br>最后，Martin得出了如下的结论：</p></li><li><p>如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock则是个过重的实现(heavyweight)。</p></li><li><p>如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。而且，它没有一个机制能够提供fencing token。那应该使用什么技术呢？Martin认为，应该考虑类似Zookeeper的方案，或者支持事务的数据库。</p></li></ul><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（上）？</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（下）？</a></li><li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">how to do distributed lockin</a></li><li><a href="https://carlosbecker.com/posts/distributed-locks-redis" target="_blank" rel="noopener">Distributed Locking with Redis</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之动态规划（2）</title>
      <link href="/article/knapsack-problem/"/>
      <url>/article/knapsack-problem/</url>
      
        <content type="html"><![CDATA[<h2><span id="背包问题">背包问题</span></h2><p>有N件物品和一个容量为V的背包。第i件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可使价值总和最大。</p><h3><span id="问题分类">问题分类</span></h3><ul><li>01背包问题  如果<code>N</code>个物品每个物品只能使用一次，则成为01背包问题</li><li>完全背包问题 如果N<code>N</code>个物品每个物品可以使用无限次，则为完全背包问题</li></ul><h3><span id="问题的解法">问题的解法</span></h3><ul><li>暴力搜索解法（递归解法）</li><li>动态规划解法</li><li>优化后的动态规划（滚动数组，自下而上）</li></ul><h2><span id="01背包问题">01背包问题</span></h2><blockquote><p>有N件物品和一个容量为V的背包。第i件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可使价值总和最大。 每件物品只能使用1次</p></blockquote><p><img src="/article/knapsack-problem/1559184539388knapsack-problem_.png" alt></p><h3><span id="问题分析">问题分析</span></h3><ul><li>设 C(i,w) 为 当物品有<code>i</code>个的时候, 且背包重量在 w 的情况下 取得的最大值。那么考虑第 <code>i</code> 个物品，无外乎两种可能：选，或者不选。<ul><li>不选的话，背包的容量不变，改变为问题 <code>C(i -1, w)</code>；</li><li>选的话，背包的容量变小，改变为问题 <code>C(i -1, w- w[i])</code> 。<br>最优方案就是比较这两种方案，哪个会更好些：<br>我们来看状态方程</li></ul></li></ul><p><img src="/article/knapsack-problem/1559191080552knapsack-problem_.png" alt></p><ul><li><p>如何理解这个方程：</p><p>假设 我们有 <code>c[3,4]</code> 和 w <code>[5,10]</code> ,<code>i[0,1] i</code> 我们放每个元素的名称。</p><p>首先对于<code>0</code> 这个元素 重量为<code>5</code> 价值为<code>3</code>。<br>假设<br>我们要求 <code>C(1,5)</code> 代表  在背包重量为<code>5</code> 的情况下 从 <code>0,1</code>中选择价值最大的。 直观的结果当让是<code>3</code>了。</p></li><li><p>分析过程<br>按照上述公式 当我要求 <code>C(1,5)</code> 的时候，对于<code>1</code>这个元素有两种求法</p><ul><li><code>1</code> 这个元素被选中</li><li><code>1</code> 这个元素没有被选中</li></ul><p>如果<code>1</code> 被选中了，则背包的重量要减去<code>1</code>的重量<code>10</code>那么在接下来的问题就变成 在 <code>C(0,5 - 10) + 4</code>（4 是用于1已经被选中了，所以原问题就变成了在子问题基础上 加上 已经选中的价值）  但是 <code>C(0, -5)</code> 不可能存在，所以 <code>1</code> 不能选 所以 有了 <code>C(0,5)</code> 的子问题</p></li><li><p>我们在看一个更复杂的例子：</p><p><code>ps = [12,3,1,3,6]</code></p><p><code>ws = [5,4,7,2,6]</code></p><p><code>i = [0,1,2,3,4]</code>   （物品的代号）</p><p><code>W = 10</code></p><p>我们依旧定义问题 <code>C(4, 10)</code><br>根据公式，我们来公式<br><img src="/article/knapsack-problem/1559211607230knapsack-problem_.png" alt></p><p>下面是具体的分析过程<br><code>4</code> 被选中<br><img src="/article/knapsack-problem/1559277486742knapsack-problem_.png" alt></p><p><code>4</code> 没有被选中<br><img src="/article/knapsack-problem/1559277542327knapsack-problem_.png" alt></p><p>求<code>C(4, 10)</code></p><ul><li>如果<code>4</code> 号元素被选中了，则进入子问题构成的问题<br><code>C(4 -1, 10 - ws[4]) + ps[4]</code></li><li>如果<code>4</code> 号元素 没有被选中，则进入第个子问题<code>C(4 -1, 10</code></li><li>这两个我们要取得最大的结果 才符合要求</li><li>处理边界 当<code>i</code> 和<code>v</code> 有一个小于<code>0</code> 的时候 这个问题都是不存在的</li></ul></li></ul><h3><span id="代码实现">代码实现</span></h3><h4><span id="递归写法">递归写法</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 -1 背包问题 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> v &gt;= w:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> idx &gt; len(ps) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>       </span><br><span class="line">    <span class="comment"># 如果选中该物品 太大 则放弃选中 原因就是 如果返回0 则会参与下边的运算max 会使得 ps[idx] + 0 会直接返回 ps[idx] 的值导致问题错误</span></span><br><span class="line">    <span class="keyword">if</span> ws[idx] + v &gt; w:</span><br><span class="line">        <span class="keyword">return</span> package0_1(idx+<span class="number">1</span>, v, w, ws, ps)</span><br><span class="line">    <span class="keyword">return</span>  max(ps[idx] + package0_1(idx+<span class="number">1</span>, v + ws[idx], w, ws, ps), package0_1(idx+<span class="number">1</span>, v, w, ws, ps))</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret = package0_1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, ws, ps) </span><br><span class="line">ret = <span class="number">15</span></span><br></pre></td></tr></table></figure><h4><span id="动态规划写法">动态规划写法</span></h4><ul><li><p>中间结果的保存</p><p>由于我们的问题是<code>C(i,w)</code> <code>i</code> 和<code>w</code> 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   由于我们的问题是`C(i,w)` `i` 和`w` 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    max_idx = len(ps)</span><br><span class="line">    ret_mid = [[ <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(w + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(max_idx)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">package0_1_inner_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= w:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> idx &gt; max_idx - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret_mid[idx][v] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ret_mid[idx][v]</span><br><span class="line">        ret_tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> ws[idx] + v &gt; w:</span><br><span class="line">            ret_tmp = package0_1_inner_1(idx + <span class="number">1</span>,v, w, ws, ps)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret_tmp = max(ps[idx] + package0_1_inner_1(idx+<span class="number">1</span>,v + ws[idx], w, ws, ps),package0_1_inner_1(idx+<span class="number">1</span>,v, w, ws, ps))</span><br><span class="line">        ret_mid[idx][v] = ret_tmp</span><br><span class="line">        <span class="keyword">return</span> ret_mid[idx][v]</span><br><span class="line">    </span><br><span class="line">    ret = package0_1_inner_1(idx, v, w, ws, ps)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret = package0_1_dynamic_1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, ws, ps) </span><br><span class="line">ret = <span class="number">15</span></span><br></pre></td></tr></table></figure><ul><li>优化分析<br>如果我们打印 ret_mid</li></ul><table><thead><tr><th>v/i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>15</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td></tr><tr><td>1</td><td>9</td><td>None</td><td>None</td><td>None</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td></tr><tr><td>2</td><td>9</td><td>None</td><td>None</td><td>None</td><td>6</td><td>3</td><td>None</td><td>None</td><td>None</td><td>0</td><td>None</td></tr><tr><td>3</td><td>9</td><td>None</td><td>None</td><td>None</td><td>6</td><td>3</td><td>None</td><td>3</td><td>None</td><td>0</td><td>None</td></tr><tr><td>4</td><td>6</td><td>None</td><td>6</td><td>None</td><td>6</td><td>0</td><td>0</td><td>0</td><td>None</td><td>0</td><td>None</td></tr></tbody></table><p>这个表格的意思是，当我们选中 背包选中<code>0</code> 的时候 且这个时候背包的总量为 <code>0</code>的时候 最大的价值 为<code>15</code> 既<code>C（0，0）</code>的含义<br>同理<code>C(1,0)</code>的意思是 没有选中 <code>0</code>  且 选中 <code>1</code>和 不选 <code>1</code>的价值最大的值</p><p>我们分析一下 如果我要求 <code>C(i,w)</code> 但是需要依赖于 <code>C(i+1,?)</code> 这里用<code>?</code> 表示只需要行数据。 那么需要上面数组 <code>C(i+1,?)</code> 的结果<br>也就是说 我们的 ret_mid[i] 要依赖于 ret_mid[i+1] 的结果 这个时候 我们的 <code>ret_mid[i+1]</code>  还没有被算出来<br>如果我们反转一下， 是否能计算将这个顺序 倒置一下，比如说让<code>ret_mid[i]</code> 依赖于 <code>ret_mid[i - 1]</code> 这样依赖，我们算到了<code>ret_mid[0]</code> 的时候，就可以被 <code>ret_mid[1]</code> 复用结果了。</p><p>我们来看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   由于我们的问题是`C(i,w)` `i` 和`w` 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</span></span><br><span class="line"><span class="comment">#   idx 变成了 物品数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_2</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    <span class="comment"># 刚开始为 物品的数量</span></span><br><span class="line">    ret_mid = [[ <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(v)] <span class="keyword">for</span> j <span class="keyword">in</span> range(idx + <span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">package0_1_inner_2</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt; <span class="number">0</span> <span class="keyword">or</span> v &lt; <span class="number">0</span>:           <span class="comment"># 这里我们做了处理 如果为0 则证明还有东西没有选的 因为 0 也是一个物品</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        print(idx,v)</span><br><span class="line">        <span class="keyword">if</span> ret_mid[idx][v - <span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:       <span class="comment"># v 的长度要减一 因为你传递过来的是 背包上线 当背包上线是10 的时候 对应 9号位置</span></span><br><span class="line">            <span class="keyword">return</span> ret_mid[idx][v - <span class="number">1</span>]</span><br><span class="line">        ret_tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span>  v - ws[idx] &lt; <span class="number">0</span>:        <span class="comment"># 表示剩下的已经不足装下现在的东西了</span></span><br><span class="line">            ret_tmp = package0_1_inner_2(idx - <span class="number">1</span>,v, w, ws, ps)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret_tmp = max(ps[idx] + package0_1_inner_2(idx - <span class="number">1</span>,v - ws[idx], w, ws, ps),package0_1_inner_2(idx - <span class="number">1</span>,v, w, ws, ps))</span><br><span class="line">        ret_mid[idx][v<span class="number">-1</span>] = ret_tmp</span><br><span class="line">        <span class="keyword">return</span> ret_mid[idx][v<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    ret = package0_1_inner_2(idx, v, w, ws, ps)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret3 = package0_1_dynamic_2(<span class="number">4</span>, <span class="number">10</span>, <span class="number">10</span>, ws, ps)</span><br><span class="line"><span class="comment"># ret = 15</span></span><br></pre></td></tr></table></figure><p>我们看到下面的ret_mid 数据</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>None</td><td>12</td><td>None</td><td>12</td><td>None</td><td>12</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>None</td><td>None</td><td>None</td><td>12</td><td>None</td><td>15</td></tr><tr><td>2</td><td>None</td><td>0</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>12</td><td>None</td><td>15</td></tr><tr><td>3</td><td>None</td><td>None</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>15</td></tr><tr><td>4</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>15</td></tr></tbody></table><p>看一下依赖关系</p><p><img src="/article/knapsack-problem/1559276755945knapsack-problem_.png" alt></p><p>我们根据这个图发现<br>第<code>4</code>行的图依赖于 <code>3</code>行的图数据 而第<code>3</code>行的数据依赖于第<code>2</code>行的数据 如果这样的话那么我们是不是可只用 两行数据来算出结果<br>级 <code>i</code> 行数据依赖于 <code>i -1</code> 行 ， 我们可以利用<code>滚动数组</code>的方法优化空间，也可以用<code>自下而上</code>的优化方法来优化</p><p>滚动数组的方式 好优化 只需要 将<code>idx % 2</code>就可以了</p><p>下面我来用自下而上的</p><p>来看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_3</span><span class="params">(v, ws, ps)</span>:</span></span><br><span class="line">    max_idx = len(ws)       <span class="comment"># 物品数量</span></span><br><span class="line">    ret_mid = []</span><br><span class="line">    <span class="comment"># 初始化0 0 节点</span></span><br><span class="line">    ret_zero = [<span class="number">0</span>  <span class="keyword">for</span> i <span class="keyword">in</span> range(v + <span class="number">1</span>)]</span><br><span class="line">    ret_mid.insert(<span class="number">0</span>, ret_zero)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,max_idx + <span class="number">1</span>):     </span><br><span class="line">        ret_item = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(v + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> vi <span class="keyword">in</span> range(<span class="number">0</span>, v + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ws[i<span class="number">-1</span>] &gt; vi:</span><br><span class="line">                ret_item[vi] = ret_mid[i - <span class="number">1</span>][vi]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret_item[vi]= max(ret_mid[i - <span class="number">1</span>][vi - ws[i - <span class="number">1</span>]] + ps[i - <span class="number">1</span>], ret_mid[i - <span class="number">1</span>][vi])</span><br><span class="line">        ret_mid.insert(i,ret_item)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret_mid[max_idx][v]</span><br></pre></td></tr></table></figure><p>运行如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret3 = package0_1_dynamic_3(<span class="number">10</span>, ws, ps)</span><br><span class="line">print(ret3)</span><br></pre></td></tr></table></figure><p>来看中间结果</p><table><thead><tr><th>i/v</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>12</td><td>12</td><td>12</td><td>12</td><td>12</td><td>12</td></tr><tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>12</td><td>12</td><td>12</td><td>12</td><td>15</td><td>15</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>12</td><td>12</td><td>12</td><td>12</td><td>15</td><td>15</td></tr><tr><td>4</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>5</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td>15</td></tr></tbody></table><h4><span id="总结">总结</span></h4><p>动态规划的主要难点就是如何划分问题，将大问题拆解为子问题之后，分析子问题和原问题的最优解，然后根据问题描述拆分通项公式，最后在分析计算的冗余度。对于逻辑分析能力是个很好的锻炼。</p><h2><span id="完全背包问题">完全背包问题</span></h2><pre><code>敬请期待</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之动态规划（1）</title>
      <link href="/article/dynamic-programming/"/>
      <url>/article/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><p>动态规划一般可分为</p><ul><li><p>线性动规</p></li><li><p>区域动规</p></li><li><p>树形动规</p></li><li><p>背包动规四类。</p></li><li><p>举例：</p><blockquote><p><code>线性动规</code>：拦截导弹(最大递减数列)，合唱队形，挖地雷，建学校，剑客决斗等；</p></blockquote><blockquote><p><code>区域动规</code>：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</p></blockquote><blockquote><p><code>树形动规</code>：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</p></blockquote><blockquote><p><code>背包问题</code>：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶等；</p></blockquote></li></ul><h2><span id="基本概念">基本概念</span></h2><h3><span id="动态规划过程">动态规划过程</span></h3><p><strong>每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</strong></p><p>动态规划算法与分治法类似，<code>其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</code>。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，<code>有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</code>。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><p>态规划经常常使用于解决最优化问题，这些问题多表现为<code>多阶段决策</code>。</p><h3><span id="关于多阶段决策">关于多阶段决策：</span></h3><p>在实际中，人们经常遇到这样一类决策问题，即因为过程的特殊性，能够将决策的全过程根据时间或空间划分若干个联系的阶段。而在各阶段中。人们都须要作出方案的选择。我们称之为<code>决策</code>。</p><p>而且当一个阶段的决策之后，经常影响到下一个阶段的决策，从而影响整个过程的活动。这样，各个阶段所确定的决策就构成一个决策序列，常称之为<code>策略</code>。</p><p>因为各个阶段可供选择的决策往往不止一个。因而就可能有很多决策以供选择，这些可供选择的策略构成一个集合，我们称之为同意<code>策略集合</code>（简称策略集合）。每一个策略都对应地确定一种活动的效果。我们假定这个效果能够用数量来衡量。</p><p>因为不同的策略经常导致不同的效果，因此，怎样在同意策略集合中选择一个策略，使其在预定的标准下达到最好的效果。经常是人们所关心的问题。我们称这种策略为最优策略，这类问题就称为<strong>多阶段决策问题</strong>。</p><ul><li><strong>多阶段决策问题举例：机器负荷分配问题</strong></li></ul><p>某种机器能够在高低两种不同的负荷下进行生产。在高负荷下生产时。产品的年产量g和投入生产的机器数量x的关系为g=g(x)，这时的年完善率为a，即假设年初完善机器数为x，到年终时完善的机器数为a*x(0&lt;a&lt;1)；在低负荷下生产时，产品的年产量h和投入生产的机器数量y的关系为h=h(y)。对应的完善率为b(0&lt;b&lt;0)。且a&lt;b。</p><p>假定開始生产时完善的机器熟练度为s1。要制定一个五年计划，确定每年投入高、低两种负荷生产的完善机器数量，使5年内产品的总产量达到最大。这是一个多阶段决策问题。</p><p>显然能够将全过程划分为5个阶段（一年一个阶段），每一个阶段開始时要确定投入高、低两种负荷下生产的完善机器数，并且上一个阶段的决策必定影响到下一个阶段的生产状态。决策的目标是使产品的总产量达到最大。这个问题常常使用数学方法建模，结合线性规划等知识来进行解决。</p><h2><span id="动态规划的适用条件">动态规划的适用条件</span></h2><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足<code>最优化原理</code>和<code>无后效性</code>。</p><ol><li><p><strong>最优化原理（最优子结构性质）</strong> ：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有<code>最优子结构性质</code>。</p></li><li><p><strong>无后效性</strong>：无后效性将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为<code>无后效性</code>。</p></li><li><p><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ol><h2><span id="求解的基本步骤">求解的基本步骤</span></h2><p></p><ol><li><p><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>**确定状态和状态变量：**将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p></li><li><p><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p></li></ol><p>实际应用中可以按以下几个简化的步骤进行设计：</p><ul><li><strong>(1) 分析最优解的性质，并刻画其结构特征。</strong></li><li><strong>(2) 递归的定义最优解。</strong></li><li><strong>(3) 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。</strong></li><li><strong>(4) 根据计算优值时得到的信息，构造问题的最优解。</strong></li></ul><h2><span id="实战分析">实战分析</span></h2><h3><span id="1-斐波那契数列">1. 斐波那契数列</span></h3><ul><li><p>问题描述</p><blockquote><p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。<br>数列的前两项为 0 和 1  指的是这样一个数列：0、1、1、2、3、5 … 我们要求<br>(每一项为 前两项的和)</p></blockquote></li><li><p>递归写法（直观的解法）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_recursion</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib_recursion(n<span class="number">-1</span>)+fib_recursion(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure></li><li><p>分析问题<br>因为通项公式为 <code>f(n) = f(n-1) + f(n-2)</code></p><p>我们看适用条件</p><ul><li><strong>最优子结构性质</strong>：<code>f(n)</code> 问问题<code>f(n-1)</code> 为子问题，所以一个<code>n</code> 的问题可以拆解成两个子问题<code>n-1</code> 和<code>n-2</code> 当子问题得到最优，那么原问题的最优解也得出。</li><li><strong>无后效性</strong>：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li><li><strong>子问题的重叠性</strong> 我们根据一张图来看一下重复计算的问题<br><img src="/article/dynamic-programming/1558927988639dynamic-programming_.png" alt></li></ul><p>这张图详细讲解了利用递归思想的求解<code>fib(5)</code> 的过程,我们需要先知道<code>fib(4)</code> 和 <code>fib(3)</code>；而<code>fib(4)</code> 需要知道<code>fib(3)</code> 和<code>fib(2)</code>；<code>fib(3)</code> 则需要知道<code>fib(2)</code> 和 <code>fib (1)</code>；<code>fib(3)</code> 则需要…<br>我们可以看到 <code>fib(3)</code> <code>fib(2)</code> 被计算了多次，浪费了很多时间。</p></li><li><p>时间优化<br>我们一个中间结果，保存已经计算过的结果</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中间结果的方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_mid_result</span><span class="params">(n)</span>:</span></span><br><span class="line">    mid_ret = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        mid_ret.append(<span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mid_ret[n] != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> mid_ret[n]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        mid_ret[n] = fib_recursion(n<span class="number">-1</span>)+fib_recursion(n<span class="number">-2</span>)</span><br><span class="line">        <span class="keyword">return</span> mid_ret[n]</span><br><span class="line">    <span class="keyword">return</span> fib(n)</span><br></pre></td></tr></table></figure></li><li><p>空间优化</p><ul><li><p>中间队列优化</p><p>我们来看中间队列，由于我们的每一项是根据前两项得到的，换句话说，我们<code>n</code> 只依赖于前两项，这样依赖，我们的中间结果就不在需要那么多的空间来存贮。所以我们只需要两个数来，分别是 <code>n-1</code> 和<code>n -2</code> 就能得出结论。</p></li><li><p>字底向上：</p><p>我们上面的实现方式都是自顶向下的实现方式，如果考虑自定向上的方式，我们就可以避免是用递归。<br>例如，我们可以先算 <code>f(0)</code>和 <code>f(1)</code> 然后<code>f(2)</code> 就可以用 <code>f(0) + f(1)</code> 来得到结果 在根据 <code>f(1) + f(2)</code>得到f(3)</p><p>来看代码。</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_bottom_up</span><span class="params">(n)</span>:</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        pre , next = next, pre + next</span><br><span class="line">        n-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></li></ul><h3><span id="2-剪绳子">2. 剪绳子</span></h3><ul><li><p>问题描述</p><blockquote><p>把一根长度为 n 的绳子剪成 m 段，并且使得每段的长度的乘积最大（n, m 均为整数）</p></blockquote></li><li><p>分析问题</p><p>假设我们剪一刀，使得一根长度为<code>i</code>，一个长度为 <code>n-1</code>,他们的乘积 <code>i * n-1</code>如果这个时候，乘积结果是最大的，则直接返回。</p><p>当时实际上往往 将<code>i</code>这段绳子还能拆分，拆分的结果乘积 i 这个数本身还要大<br>所以我们的要解决的问题就变成了<br>求<code>F(n) = max(F(i) * F(n - 1))</code>，要使得  <code>f(n)</code> 最大 那必须要让 <code>f(i)</code> 和 <code>f(n-i)</code>得到最大值</p><p>我们用列举:</p><table><thead><tr><th>n</th><th>分段序列</th><th>最大乘积</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>不需要拆分</td></tr><tr><td>2</td><td>1,1</td><td>2</td><td>不需要拆分</td></tr><tr><td>3</td><td>1,2</td><td>3</td><td>不需要拆分</td></tr><tr><td>4</td><td>[1,3] [2,2]</td><td>4</td><td></td></tr><tr><td>5</td><td>[1,4] [2,3]</td><td>6</td><td></td></tr></tbody></table></li></ul><p>按着这个思路 当<code>n &lt;= 3</code> 的时候 不用切,当<code>n &gt; 4</code>的时候 才需要切割</p><ul><li><strong>一般写法(递归写法)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment">### 不用切割，返回的是自身长度</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 切割几次</span></span><br><span class="line">    split_number = n//<span class="number">2</span></span><br><span class="line">    max_ret = n;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,split_number+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        max_ret = max(ecursive(i)*ecursive(n-i),max_ret)</span><br><span class="line">    <span class="keyword">return</span> max_ret</span><br></pre></td></tr></table></figure><ul><li><p>优化分析<br>这个优化分如同第一题的分析一样，只不过第一题的加法改成了乘法，本质上是一样的。<br>接下来我们来看加了中间结果的优化方法</p><ul><li><strong>动态优化写法：时间优化，保留计算结果</strong></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 优化后的 递归算法 保留已经计算过的结果</span></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive2</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result.get(l) != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result[l]</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    split_number = l//<span class="number">2</span></span><br><span class="line">    max_ret = l;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,split_number+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        max_ret = max(ecursive2(i)*ecursive2(l-i),max_ret)</span><br><span class="line">    result[l] = max_ret</span><br><span class="line">    <span class="keyword">return</span> max_ret</span><br></pre></td></tr></table></figure><ul><li><strong>字底向上写法</strong></li></ul><p><img src="/article/dynamic-programming/1559027638643dynamic-programming_.png" alt><br>假如入我们要计算<br><code>e(6)</code>那么我们首先要计算 <code>e(1)</code> 和  <code>e(5)</code></p><ol><li>因为 1，2，3 比较特殊 是不需要剪的 所以我们从 第4个开始</li><li>首先我们得到一个初始化数组 里面的元素为 [0,1,2,3]</li><li>计算 e(4)  拆分得到  <code>e(4) = e(1) * e(3) ... e(2) * e(2)</code>，找出最大的赋值给第四个元素 这个时候 数组就变成了 [0,1,2,3,4]  这个数组的概念为 [e(1),e(2),e(3),e(4)]</li><li>这个时候 计算<code>e(5)</code> 重复上述过程</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive3</span><span class="params">(l)</span>:</span></span><br><span class="line">    ret_mid = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> ret_mid[l]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,l + <span class="number">1</span>):</span><br><span class="line">        max_mid_ret = i</span><br><span class="line">        ret_mid.append(max_mid_ret)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,i//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            max_mid_ret = max(ret_mid[n] * ret_mid[i - n],max_mid_ret)</span><br><span class="line">        ret_mid[i] = max_mid_ret</span><br><span class="line">    <span class="keyword">return</span> ret_mid[l]</span><br></pre></td></tr></table></figure><ul><li><strong>贪婪算法写法</strong><br>当<code>n</code>大于等于5时，我们尽可能多的剪长度为<code>3</code>的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 为什么选<code>2，3</code>为最小的子问题？因为2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。 为什么选长度为<code>3</code>？因为当<code>n≥5</code>时，3(n−3)≥2(n−2)</li></ul><p>其实为什么要选2和3,来看证明<br><strong>证明</strong>： <code>n&lt;4</code>的情况不必说，我们假设<code>n&gt;=5</code>。这里的思想是把剪绳子划归为若干个子问题，每一剪就划分为两个子问题。当<code>n&gt;=</code>5时，若剪为长度为<code>a</code>与<code>n-a</code>的两段更优，即<code>a(n-a)&gt;n</code>，其中<code>1&lt;=a&lt;n</code></p><p>推导如下：</p><p><img src="/article/dynamic-programming/1559028801966dynamic-programming_.png" alt></p><p>令<code>f(n)=(a-1)n-a^2</code>  由于<code>a-1&gt;=0</code>，<code>f(n)</code>单调递增。当<code>n=5</code>时，<code>f(n)</code>取得最小值为<code>f(5)=(a-1)*5-a^2</code>。要使最小值大于0，接下来求<code>a</code>的取值范围，令方程<code>(a-1)*5-a^2=0</code>，可用求根公式解得<code>a</code>为<code>2,3</code>（取整）。<br>换句话说 当解中出现2，3 的时候 总能让函数递增，也就是是剪出来的数 大于本身长度。</p><p><img src="/article/dynamic-programming/1559029025348dynamic-programming_.png" alt></p><p><strong>来看实现</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span> <span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 3出现的次数</span></span><br><span class="line">    time_3  = l // <span class="number">3</span> </span><br><span class="line">    <span class="keyword">if</span> l % <span class="number">3</span> == <span class="number">1</span>:      <span class="comment">#如果剩下4 则4分为 2 2</span></span><br><span class="line">        time_3 -= <span class="number">1</span></span><br><span class="line">    time_2 = (l - time_3 * <span class="number">3</span>) // <span class="number">2</span></span><br><span class="line">    print(time_2,time_3)</span><br><span class="line">    ret = math.pow(<span class="number">3</span>,time_3)</span><br><span class="line">    <span class="keyword">if</span> time_2 != <span class="number">0</span>:</span><br><span class="line">        ret + math.pow(<span class="number">2</span>, time_2)</span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></li></ul><h3><span id="3-背包问题">3. 背包问题</span></h3><pre><code>由于篇幅问题</code></pre><h3><span id="4-抢劫问题">4. 抢劫问题</span></h3><h3><span id="5-小兵向前冲">5. 小兵向前冲</span></h3><h3><span id="6-最大递减数列">6. 最大递减数列</span></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(3)</title>
      <link href="/article/distributed-redis-data-structure-skip-zip-list/"/>
      <url>/article/distributed-redis-data-structure-skip-zip-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h1><span id="跳表">跳表</span></h1><p>–</p><h2><span id="跳表的结构">跳表的结构</span></h2><p>跳跃表（skiplist）是一种随机化的数据， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p><p>以下是个典型的跳跃表例子（图片来自维基百科）：<br><img src="/article/distributed-redis-data-structure-skip-zip-list/1561702628780distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>从图中可以看到， 跳跃表主要由以下部分构成：</p><ul><li><code>表头（head）：负责维护跳跃表的节点指针。</code></li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li></ul><p>为了满足自身的功能需要， <code>Redis</code> 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p><ul><li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的 score 值可以相同。</li><li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查 <code>member</code> ：当 <code>score</code> 值可以重复时，单靠 <code>score</code> 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。</li><li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 <code>ZREVRANGE</code> 或 <code>ZREVRANGEBYSCORE</code> 这类以逆序处理有序集的命令时，就会用到这个属性。</li></ul><p>跳表的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h2><span id="跳表的应用">跳表的应用</span></h2><p>和字典、链表或者字符串这几种在 Redis 中大量使用的数据结构不同， 跳跃表在 Redis 的唯一作用， 就是实现有序集数据类型。<br>跳跃表将指向有序集的 score 值和 member 域的指针作为元素， 并以 score 值为索引， 对有序集元素进行排序。<br>举个例子， 以下代码创建了一个带有 3 个元素的有序集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD s 6 x 10 y 15 z</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE s 0 -1 WITHSCORES</span></span><br><span class="line">1) "x"</span><br><span class="line">2) "6"</span><br><span class="line">3) "y"</span><br><span class="line">4) "10"</span><br><span class="line">5) "z"</span><br><span class="line">6) "15"</span><br></pre></td></tr></table></figure><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561702897381distributed-redis-data-structure-skip-zip-list_.png" alt></p><p><strong>为了方便展示， 在图片中我们直接将 member 和 score 值包含在表节点中， 但是在实际的定义中， 因为跳跃表要和另一个实现有序集的结构（字典）分享 member 和 score 值， 所以跳跃表只保存指向 member 和 score 的指针。</strong></p><h1><span id="压缩表">压缩表</span></h1><h2><span id="简介">简介</span></h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p><h2><span id="结构">结构</span></h2><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p><p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703120380distributed-redis-data-structure-skip-zip-list_.png" alt></p><table border="1" class="docutils"><colgroup><col width="11%"><col width="13%"><col width="11%"><col width="65%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">属性</th><th class="head">类型</th><th class="head">长度</th><th class="head">用途</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">zlbytes</span></code></td><td><code class="docutils literal"><span class="pre">uint32_t</span></code></td><td><code class="docutils literal"><span class="pre">4</span></code> 字节</td><td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 <code class="docutils literal"><span class="pre">zlend</span></code> 的位置时使用。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">zltail</span></code></td><td><code class="docutils literal"><span class="pre">uint32_t</span></code></td><td><code class="docutils literal"><span class="pre">4</span></code> 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">zllen</span></code></td><td><code class="docutils literal"><span class="pre">uint16_t</span></code></td><td><code class="docutils literal"><span class="pre">2</span></code> 字节</td><td>记录了压缩列表包含的节点数量：当这个属性的值小于 <code class="docutils literal"><span class="pre">UINT16_MAX</span></code> （<code class="docutils literal"><span class="pre">65535</span></code>）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 <code class="docutils literal"><span class="pre">UINT16_MAX</span></code> 时，节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">entryX</span></code></td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">zlend</span></code></td><td><code class="docutils literal"><span class="pre">uint8_t</span></code></td><td><code class="docutils literal"><span class="pre">1</span></code> 字节</td><td>特殊值 <code class="docutils literal"><span class="pre">0xFF</span></code> （十进制 <code class="docutils literal"><span class="pre">255</span></code> ），用于标记压缩列表的末端。</td></tr></tbody></table><p>图 7-2 展示了一个压缩列表示例：</p><ul><li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li><li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列+ 表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li><li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703205387distributed-redis-data-structure-skip-zip-list_.png" alt></p><h2><span id="压缩列表节点的构成">压缩列表节点的构成</span></h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li><li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li><li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li>4 位长，介于 0 至 12 之间的无符号整数；</li><li>1 字节长的有符号整数；</li><li>3 字节长的有符号整数；</li><li>int16_t 类型整数；</li><li>int32_t 类型整数；</li><li>int64_t 类型整数。</li></ul><p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成， 如图 7-4 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703498906distributed-redis-data-structure-skip-zip-list_.png" alt></p><h3><span id="previous_entry_length">previous_entry_length</span></h3><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p><p><code>previous_entry_length</code> 属性的长度可以是 1 字节或者 5 字节：</p><ul><li><p>如果前一节点的长度小于 254 字节， 那么 <code>previous_entry_length</code> 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</p></li><li><p>如果前一节点的长度大于等于 254 字节， 那么 <code>previous_entry_length</code> 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</p></li></ul><p>图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703612934distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703626097distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 <code>previous_entry_length</code> 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p><h3><span id="encoding">encoding</span></h3><p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p><ul><li><p>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</p></li><li><p>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 <code>content</code> 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</p></li></ul><p>表 7-2 记录了所有可用的字节数组编码， 而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703731706distributed-redis-data-structure-skip-zip-list_.png" alt></p><h3><span id="content">content</span></h3><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p><p>图 7-9 展示了一个保存字节数组的节点示例：</p><ul><li>编码的最高两位 00 表示节点保存的是一个字节数组；</li><li>编码的后六位 001011 记录了字节数组的长度 11 ；</li><li>content 属性保存着节点的值 “hello world” 。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703790975distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>图 7-10 展示了一个保存整数值的节点示例：</p><ul><li>编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</li><li>content 属性保存着节点的值 10086 。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703826960distributed-redis-data-structure-skip-zip-list_.png" alt></p><h2><span id="连锁更新">连锁更新</span></h2><p>前面说过， 每个节点的 previous_entry_length 属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。</li></ul><p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN ， 如图 7-11 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703296154distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>因为 e1 至 eN 的所有节点的长度都小于 254 字节， 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性， 换句话说， e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的。</p><p>这时， 如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点， 那么 new 将成为 e1 的前置节点， 如图 7-12 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703910904distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p><p>现在， 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间， 在为 previous_entry_length 属性新增四个字节的空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间， 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p><p>因此， 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 e2 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p><p>正如扩展 e1 引发了对 e2 的扩展一样， 扩展 e2 也会引发对 e3 的扩展， 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 eN 为止。</p><p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703978763distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p><p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p><ul><li><p>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</p></li><li><p>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</p></li></ul><p>因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法之空间亚线性算法（二）</title>
      <link href="/article/most-frequent-number-in-stream/"/>
      <url>/article/most-frequent-number-in-stream/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><a href="https://icefrozen.github.io/article/reservoir-sampling/" target="_blank" rel="noopener">水库抽样算法</a> 样算法虽然是抽样算法却不是近似算法。本节分享一下有限内存利用近似解求数据流中最频繁的元素。</p><p>Misra-Gries算法是频繁项挖掘中一个著名的算法。频繁项就是那些在数据流中出现频率最高的数据项。频繁项挖掘，这个看似简单的任务却是很多复杂算法的基础，同时也有着广泛的应用。</p><p>对于频繁项挖掘而言，一个简单的想法是，为所有的数据项分配计数器，当一个数据项到达，我们即增加相应计数器的值。但当数据流的规模较大时，出于内存的限制，我们往往不可能为每个数据项分配计数器。而Misra-Gries算法则是以一种清奇的思路解决了这个问题，实现了在内存受限的情况下，以较小的错误率统计数据流中的频繁项。</p><h5><span id="问题描述">问题描述</span></h5><ul><li><p>先讲解一下大数据的数据流模型特点：</p><ul><li>数据只能扫描1次或几次；</li><li>能够使用的内存是有限的（内存&lt;&lt;数据规模）；</li><li>希望通过维护一个内存结果（数据流概要）来给出相关性质的一个评估；</li></ul></li></ul><p>总结来说：<strong>数据要快速处理；空间亚线性。</strong></p><ul><li><p>问题描述</p><ul><li>输入：大数据流序列&lt;x1,x2,x3… …&gt;。</li><li>输出：找出数据流中当前扫描的元素序列中出现最频繁的元素的信息。</li></ul></li><li><p>问题定义</p><p><strong><em>对于流<img src="/article/most-frequent-number-in-stream/1560856790132most-frequent-number-in-stream_.png" alt> 隐式地定义了一个频率向量f=(f1,…,fn)。注意f1+…+fn=m。</em></strong></p><p><strong><em>对于一个参数k，输出集合<img src="/article/most-frequent-number-in-stream/1560856883155most-frequent-number-in-stream_.png" alt></em></strong></p></li></ul><pre><code>频繁元素问题有广泛的应用。在网络当中找到“elephant flow”、ip地址等，在搜索引擎中找到频繁查询，可以给这些最频繁的查询做一些优化。在应用当中求频繁元素时有一个假设，即**Zipf原则:典型的频率分布是高度偏斜的，只有少数频繁元素，大多数元素是非常不频繁的**。这个假设是合法的，根据统计一般最多10%的元素占元素总个数的90%。</code></pre><h2><span id="问题分析">问题分析</span></h2><ul><li><p>举个简单的例子，例如<br>输入 ： <code>&lt;32,12,14,32,7,12,32,7,6,12,4&gt;</code> 其中 <code>n=6，k=3，m=11</code></p><ul><li>算法如下：<ol><li>对于接收到的元素x，如果已经为其分配计数器，则把相应计数器加1；</li><li>如果没有相应计数器，但计数器个数少于k,就为其分配计数器，并设为1，意味着内存中还有空间；</li><li>如果当前计数器的个数为k，说明内存已经满了，则把所有计数器减1，然后删除取值为0的计数器，这样内存就又有空间了，再依次处理下一个。</li></ol></li></ul></li><li><p>计算过程如下</p><ul><li><ol><li>接收<code>32</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="2"><li>接收<code>12</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;</code>，<code>&lt;12,1&gt;</code>。</li></ol></li><li><ol start="3"><li>接收<code>14</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;,&lt;14,1&gt;</code>。</li></ol></li><li><ol start="4"><li>接收<code>32，32</code>对应计数器加<code>1</code>，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;,&lt;14,1&gt;</code>。</li></ol></li><li><ol start="5"><li>接收<code>7，7</code>不在内存当中，需要为其分配新的计数器，但是内存没有空间了。这时将所有计数器减<code>1</code>，然后把值为<code>0</code>的计数器删除，这时候，<code>12</code>和<code>14</code>的计数器就没有了。注意此时不将<code>7</code>的计数器加<code>1</code>,内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="6"><li>接收<code>12</code>，内存又有空间，为其重新分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;</code>。</li></ol></li><li><ol start="7"><li>接收<code>32，32</code>对应计数器加<code>1</code>，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;</code>。</li></ol></li><li><ol start="8"><li>接收<code>7</code>，为其分配计数器，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;,&lt;7,1&gt;</code>。</li></ol></li><li><ol start="9"><li>接收<code>6</code>，这时候内存满了，把所有计数器减<code>1</code>，然后把值为<code>0</code>的计数器删除,内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="10"><li>接收<code>12</code>，内存又有空间，为其再重新分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;</code>。</li></ol><p>这时候，将内存里最后的数据定为x出现的次数，计数器在内存中将x返回，没有则返回0。很显然这种方法低估了计数问题，32出现了3次，但是最后只返回1次。</p></li></ul></li></ul><h2><span id="算法精确性分析">算法精确性分析</span></h2><p><img src="/article/most-frequent-number-in-stream/1560858227232most-frequent-number-in-stream_.png" alt><br><img src="/article/most-frequent-number-in-stream/1560858254559most-frequent-number-in-stream_.png" alt></p><h2><span id="代码实现">代码实现</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(total = <span class="number">2000</span>)</span>:</span></span><br><span class="line">    data = np.random.zipf(<span class="number">2</span>, total)</span><br><span class="line">    count_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        oldValue = count_map.get(value, <span class="number">0</span>)</span><br><span class="line">        oldValue +=<span class="number">1</span></span><br><span class="line">        count_map[value] = oldValue</span><br><span class="line">    <span class="keyword">return</span> data,count_map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">misra_gries</span><span class="params">(S,k)</span>:</span></span><br><span class="line">    c = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> c:</span><br><span class="line">            c[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> len(c)&lt;k<span class="number">-1</span>:</span><br><span class="line">            c[i]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> list(c):</span><br><span class="line">                c[j]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c[j]==<span class="number">0</span>:</span><br><span class="line">                    c.pop(j)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s, cmap = getData()</span><br><span class="line">    result = misra_gries(s, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    print(result)</span><br><span class="line">    print(result.keys())</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 空间亚线性算法 </tag>
            
            <tag> 大数据算法篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法之空间亚线性算法(一)</title>
      <link href="/article/reservoir-sampling/"/>
      <url>/article/reservoir-sampling/</url>
      
        <content type="html"><![CDATA[<h2><span id="问题描述">问题描述</span></h2><ul><li>输入：一组数据，大小未知</li><li>输出：这组数据的K个均匀抽取</li><li>要求：仅扫描一次</li><li>总体要求：从N个元素中随机的抽取k个元素，其中N无法确定，保证每个元素抽到的概率相同</li></ul><h2><span id="问题难点">问题难点</span></h2><p>首先明确什么叫均匀抽样，就是每个数据被等概率抽取呗。即当样本总体为n 时候，每个样本被抽取的概率为1/n,如果要抽取k个元素，那么每个样本被抽到的概率为k/n。但是我们实现不知道总体的数量n。如果就只有n=K个元素，可用空间正好也是K，那我们正好把K个数据都保存起来，但是如果n&gt;K呢？要想均匀抽样，概率当然是</p><h2><span id="问题解析">问题解析</span></h2><h3><span id="思路分析">思路分析</span></h3><p>假设我们有一个数据流，分别是1，2，3，起初我们并不知道这个数据流的大小。 我们要从中随机抽取一个数字，如果是均匀的抽取，每个数字被抽到的概率为1/3,首先我们需要新建一个数组，由于我们只需要取一个数据，所以数组的长度为1,现在我们有</p><ul><li>未知数据流 data_stream = [1,2,3]</li><li>样本数组 sample = []  (长度为1)</li></ul><p>我们开始读取数据1</p><ol><li><code>sample : [1]</code>, 假设 这个时候结束，那么样本被抽取的概率为 1，既100%被抽到</li><li>再次读取数据<code>2</code> <code>sample=[1,2]</code>,由于我们只需要一个数据，所以1 和 2 必须淘汰一个，那么如何淘汰呢？假设读到2就已经结束了，那么总体就变成了2个，2个这个时候，那么每个样本被抽取的概率就要变成1/2 才符合要求。这个时候，我们需要让2 以1/2的概率被淘汰，这样1和2被留下的概率就相等，都是1/2 满足要求。</li><li>再次读取数据3 <code>sample=[?,3]</code> 因为在第二步，我们已经淘汰了1和2 所以这里用？表示被留下的那个数 即 1 或者 2。 这个时候，我们应该如何淘汰3 才能让<code>1，2，3</code> 等概率被淘汰呢？<br>现在样本变成了3个，那么如果要满足提议，那必须让3 以1/3的概率留下，让3以2/3概率淘汰,那么这样来看<ul><li>？（1或者2）被留下的概率为(?留下，3淘汰)1/2 * 2/3</li><li>3 被留下的 概率为 1/3</li><li>这样刚好满足题意</li></ul></li></ol><ul><li>依次类推。</li></ul><p>来看证明：<br><img src="/article/reservoir-sampling/1558588073391reservoir-sampling_.png" alt></p><p>这里做个说明：1 - 1/(i+1) = i/(i+1)  表示没有被选中的概率.<br>总结起来就是一句话每个数取到的概率等于取到该数且取不到该数后面所有数的概率。<br>如：取到第10个数的概率等于取到第十个数且取不到第11到第n个数的概率<br>现在我们回到较复杂的情况,也就是如何在一个N个数（开始不知道N是几）中随机取M个数。其实思想是一样的，就是先取出前M个，然后对后面的开始每个以(k/(i))的概率进行替换，这样我们得到的就是所要的结果，证明如下：</p><p><img src="/article/reservoir-sampling/1558588262938reservoir-sampling_.png" alt></p><h4><span id="思路推广">思路推广</span></h4><ul><li>从一个数据流中获取数据，保存在k个数组当中。</li><li>数据流中前K个数值直接保存在数组中</li><li>后面的在来的数据i 以 k/n 的概率 替换数组中的随机一个</li></ul><h2><span id="代码实现">代码实现</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReservoirSampling</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.sample = []</span><br><span class="line">        self.k = k</span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addItem</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        i = len(self.sample)</span><br><span class="line">        <span class="keyword">if</span> i &lt; self.k:</span><br><span class="line">            self.sample.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            M = int(random.uniform(<span class="number">0</span>, self.time + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> M &lt; self.k :</span><br><span class="line">                self.sample[M] = item</span><br><span class="line">        self.time +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSample</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.sample</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self,count_arrray)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [self.sample.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> count_arrray]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(array_item_total, k)</span>:</span></span><br><span class="line">    a = np.array([[i]*array_item_total <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)])<span class="comment">#生成等量的0，1，2</span></span><br><span class="line">    L0 = a[<span class="number">0</span>]</span><br><span class="line">    L1 = a[<span class="number">1</span>]</span><br><span class="line">    L2 = a[<span class="number">2</span>]</span><br><span class="line">    rs = ReservoirSampling(k)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L0:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 1"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L1:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 2"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L2:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 3"</span>)</span><br><span class="line">    l1 = [<span class="string">'value=%d'</span>% x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    plt.pie(rs.count([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]),labels=l1,labeldistance=<span class="number">0.1</span>,autopct=<span class="string">'%1.2f%%'</span>)</span><br><span class="line">    plt.title(<span class="string">"Reservoir sampling"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test(<span class="number">10000</span>,<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>看一下结果<br><img src="/article/reservoir-sampling/1558678959053reservoir-sampling_.png" alt></p><h2><span id="总结">总结</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 空间亚线性算法 </tag>
            
            <tag> 大数据算法篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(4)</title>
      <link href="/article/distributed-redis-data-structure-object/"/>
      <url>/article/distributed-redis-data-structure-object/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="简介">简介</span></h2><p>我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。</p><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p><h2><span id="结构">结构</span></h2><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p><p>举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 “msg” 的对象， 而键值对的值则是一个包含了字符串值 “hello world” 的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2><span id="类型">类型</span></h2><p>对象的 type 属性记录了对象的类型， 这个属性的值可以是表 8-1 列出的常量的其中一个。</p><table border="1" class="docutils"><colgroup><col width="38%"><col width="62%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">类型常量</th><th class="head">对象的名称</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td>字符串对象</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td>列表对象</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td>哈希对象</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td>集合对象</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td>有序集合对象</td></tr></tbody></table><p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，<br>诸如此类。</li></ul><p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键为字符串对象，值为列表对象</span></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br></pre></td></tr></table></figure><p>表 8-2    不同类型值对象的 <span class="xref std std-ref">TYPE</span> 命令输出</p><table border="1" class="docutils"><colgroup><col width="20%"><col width="35%"><col width="45%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">对象</th><th class="head">对象 <code class="docutils literal"><span class="pre">type</span></code> 属性的值</th><th class="head"><span class="xref std std-ref">TYPE</span> 命令的输出</th></tr></thead><tbody valign="top"><tr class="row-even"><td>字符串对象</td><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">"string"</span></code></td></tr><tr class="row-odd"><td>列表对象</td><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">"list"</span></code></td></tr><tr class="row-even"><td>哈希对象</td><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">"hash"</span></code></td></tr><tr class="row-odd"><td>集合对象</td><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">"set"</span></code></td></tr><tr class="row-even"><td>有序集合对象</td><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">"zset"</span></code></td></tr></tbody></table><h2><span id="编码和底层实现">编码和底层实现</span></h2><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p><p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p><p>表 8-3    对象的编码</p><table border="1" class="docutils"><colgroup><col width="33%"><col width="67%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">编码常量</th><th class="head">编码所对应的底层数据结构</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td><code class="docutils literal"><span class="pre">long</span></code> 类型的整数</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td><code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td>简单动态字符串</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>字典</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td>双端链表</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>压缩列表</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td>整数集合</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td>跳跃表和字典</td></tr></tbody></table><p>每种类型的对象都至少使用了两种不同的编码，表 8-4 列出了每种类型的对象可以使用的编码。</p><table border="1" class="docutils"><colgroup><col width="17%"><col width="28%"><col width="54%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">类型</th><th class="head">编码</th><th class="head">对象</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td>使用整数值实现的字符串对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td>使用 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串实现的字符串对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td>使用简单动态字符串实现的字符串对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的列表对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td>使用双端链表实现的列表对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的哈希对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>使用字典实现的哈希对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td>使用整数集合实现的集合对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>使用字典实现的集合对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的有序集合对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td>使用跳跃表和字典实现的有序集合对象。</td></tr></tbody></table><p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello wrold"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line"><span class="string">"embstr"</span></span><br></pre></td></tr></table></figure><p>表 8-5 列出了不同编码的对象所对应的 <span class="xref std std-ref">OBJECT ENCODING</span> 命令输出。</p><table border="1" class="docutils"><colgroup><col width="35%"><col width="27%"><col width="38%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">对象所使用的底层数据结构</th><th class="head">编码常量</th><th class="head"><span class="xref std std-ref">OBJECT ENCODING</span> 命令输出</th></tr></thead><tbody valign="top"><tr class="row-even"><td>整数</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td><code class="docutils literal"><span class="pre">"int"</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串（SDS）</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td><code class="docutils literal"><span class="pre">"embstr"</span></code></td></tr><tr class="row-even"><td>简单动态字符串</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td><code class="docutils literal"><span class="pre">"raw"</span></code></td></tr><tr class="row-odd"><td>字典</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td><code class="docutils literal"><span class="pre">"hashtable"</span></code></td></tr><tr class="row-even"><td>双端链表</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td><code class="docutils literal"><span class="pre">"linkedlist"</span></code></td></tr><tr class="row-odd"><td>压缩列表</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td><code class="docutils literal"><span class="pre">"ziplist"</span></code></td></tr><tr class="row-even"><td>整数集合</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td><code class="docutils literal"><span class="pre">"intset"</span></code></td></tr><tr class="row-odd"><td>跳跃表和字典</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td><code class="docutils literal"><span class="pre">"skiplist"</span></code></td></tr></tbody></table><p>通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p><p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p><ul><li><p>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</p></li><li><p>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</p></li><li><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p></li></ul><p>在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8使用@sun.misc.Contended避免伪共享</title>
      <link href="/article/reduce-cache-contention/"/>
      <url>/article/reduce-cache-contention/</url>
      
        <content type="html"><![CDATA[<hr><h2><span id="什么是伪共享">什么是伪共享</span></h2><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p><p>缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p><p>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解缓存行和对象的内存布局。<a href="https://www.jianshu.com/p/900554f11881" target="_blank" rel="noopener">理解CPU Cache</a>和<a href="https://icefrozen.github.io/article/java-mem-objecat/" target="_blank" rel="noopener">Java对象内存布局</a>。</p><p>下面的图说明了伪共享的问题：<br><img src="/article/reduce-cache-contention/1557738129608Reduce-Cache-Contention_.png" alt></p><p>假设在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p><h2><span id="避免伪共享">避免伪共享</span></h2><p>假设有一个类中，只有一个long类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时定义一个VolatileLong类型的数组，然后让多个线程同时并发访问这个数组，这时可以想到，在多个线程同时处理数据时，数组中的多个VolatileLong对象可能存在同一个缓存行中，通过上文可知，这种情况就是伪共享。</p><p>怎么样避免呢？在Java 7之前，可以在属性的前后进行padding，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>文章中结尾对paddign的分析可知，由于都是long类型的变量，这里就是按照声明的顺序分配内存，那么这可以保证在同一个缓存行中只有一个VolatileLong对象。</p><p>在Java 8中，提供了@sun.misc.Contended注解来避免伪共享，原理是在使用此注解的对象或字段的前后各增加128字节大小的padding，使用2倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。具体可以参考<a href="https://link.jianshu.com?t=http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a>。</p><p>下面用代码来看一下加padding和不加的效果：</p><blockquote><p>运行环境：JDK 1.8，macOS 10.12.4，2.2 GHz Intel Core i7，四核-八线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs = <span class="keyword">new</span> VolatileLong[NUM_THREADS];</span><br><span class="line"><span class="comment">//    private static VolatileLong2[] longs = new VolatileLong2[NUM_THREADS];</span></span><br><span class="line"><span class="comment">//    private static VolatileLong3[] longs = new VolatileLong3[NUM_THREADS];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> VolatileLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        runTest();</span><br><span class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// long padding避免false sharing</span></span><br><span class="line">    <span class="comment">// 按理说jdk7以后long padding应该被优化掉了，但是从测试结果看padding仍然起作用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jdk8新特性，Contended注解避免false sharing</span></span><br><span class="line"><span class="comment">     * Restricted on user classpath</span></span><br><span class="line"><span class="comment">     * Unlock: -XX:-RestrictContended</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong3</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VolatileLong对象只有一个long类型的字段，VolatileLong2加了padding，下面分别执行看下时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duration = 57293259577</span><br><span class="line">duration = 4679059000</span><br></pre></td></tr></table></figure><p>没加padding时用了大概57秒，加padding后用时大概4.6秒，可见加padding后有效果了。</p><p>在Java8中提供了@sun.misc.Contended来避免伪共享，例如这里的VolatileLong3，在运行时需要设置JVM启动参数<code>-XX:-RestrictContended</code>，运行一下结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration = 4756952426</span><br></pre></td></tr></table></figure><p>结果与加padding的时间差不多。</p><p>下面看一下VolatileLong对象在运行时的内存大小（参考<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>）：</p><p><img src="/article/reduce-cache-contention/1557738622454Reduce-Cache-Contention_.png" alt></p><p>再来看下VolatileLong2对象在运行时的内存大小：</p><p><img src="/article/reduce-cache-contention/1557738646359Reduce-Cache-Contention_.png" alt></p><p>因为多了14个long类型的变量，所以24+8*14=136字节。</p><p>下面再来看下使用@sun.misc.Contended注解后的对象内存大小：</p><p><img src="/article/reduce-cache-contention/1557738659924Reduce-Cache-Contention_.png" alt></p><p>在堆内存中并没有看到对变量进行padding，大小与VolatileLong对象是一样的。</p><p>这就奇怪了，看起来与VolatileLong没什么不一样，但看一下内存的地址，用十六进制算一下，两个VolatileLong对象地址相差24字节，而两个VolatileLong3对象地址相差280字节。这就是前面提到的@sun.misc.Contended注解会在对象或字段的前后各增加128字节大小的padding，那么padding的大小就是256字节，再加上对象的大小24字节，结果就是280字节，所以确实是增加padding了。</p><h2><span id="八线程运行比四线程运行还快">八线程运行比四线程运行还快？</span></h2><p>根据上面的代码，把NUM_THREADS改为8，测试看下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VolatileLong:  44305002641</span><br><span class="line">VolatileLong2: 7100172492</span><br><span class="line">VolatileLong3: 7335024041</span><br></pre></td></tr></table></figure><p>可以看到，加了padding和@sun.misc.Contended注解的运行时间多了不到1倍，而VolatileLong运行的时间比线程数是4的时候还要短，这是为什么呢？</p><p>再说一下，我的CPU是四核八线程，每个核有一个L1 Cache，那么我的环境一共有4个L1 Cache，所以，2个CPU线程会共享同一个L1 Cache；由于VolatileLong对象占用24字节内存，而代码中VolatileLong对象是保存在数组中的，所以内存是连续的，2个VolatileLong对象的大小是48字节，这样一来，对于缓存行大小是64字节来说，每个缓存行只能存放2个VolatileLong对象。</p><p>通过上面的分析可知，伪共享发生在L3 Cache，如果每个核操作的数据不在同一个缓存行中，那么就会避免伪共享的发生，所以，8个线程的情况下其实是CPU线程共享了L1 Cache，所以执行的时间可能比4线程的情况还要短。下面看下执行时4线程和8线程的CPU使用情况：</p><p><img src="/article/reduce-cache-contention/1557741617009Reduce-Cache-Contention_.png" alt></p><p>可以看到，在4线程时，线程被平均分配到了4个核中，这样一来，L1 Cache肯定是不能共享的，这时会发生伪共享；而8线程时，每个核都使用了2个线程，这时L1 Cache是可以共享的，如果线程1和线程2在同一个核心中，线程1修改了L1 的数据，此时L2 可以感知并获取，这样一来就会减少对L3 的穿透，这在一定程度上能减少伪共享的发生，从而时间会变短（也不一定，但总体来说8线程的情况与4线程的运行时间几乎不会向加padding和注解的方式差那么多）。</p><h2><span id="sunmisccontended注解">@sun.misc.Contended注解</span></h2><p>上文中将@sun.misc.Contended注解用在了对象上，@sun.misc.Contended注解还可以指定某个字段，并且可以为字段进行分组，下面通过代码来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Options: </span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:-RestrictContended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println("offset-a: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("a")));</span><br><span class="line">        System.out.println("offset-b: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("b")));</span><br><span class="line">        System.out.println("offset-c: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("c")));</span><br><span class="line">        System.out.println("offset-d: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是使用到了classmexer.jar，可以参考<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>中的说明。</p><p>这里在变量b和c中使用了@sun.misc.Contended注解，并将这两个变量分为1组，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset-a: 16</span><br><span class="line">offset-b: 152</span><br><span class="line">offset-c: 160</span><br><span class="line">offset-d: 12</span><br><span class="line">Shallow Size: 296 bytes</span><br><span class="line">Retained Size: 296 bytes</span><br></pre></td></tr></table></figure><p>可见int类型的变量的偏移地址是12，也就是在对象头后面，因为它正好是4个字节，然后是变量a。<code>@sun.misc.Contended</code>注解的变量会加到对象的最后面，这里就是b和c了，那么b的偏移地址是152，之前说过<code>@sun.misc.Contended</code>注解会在变量前后各加128字节，而byte类型的变量a分配完内存后这时起始地址应该是从17开始，因为byte类型占1字节，那么应该补齐到24，所以b的起始地址是24+128=152，而c的前面并不用加128字节，因为b和c被分为了同一组。</p><p>我们算一下c分配完内存后，这时的地址应该到了168，然后再加128字节，最后大小就是296。内存结构如下：</p><p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | c:160~168 | — | 168~296 |</p><p>现在把b和c分配到不同的组中，代码做如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:-RestrictContended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"b"</span>)</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println("offset-a: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("a")));</span><br><span class="line">        System.out.println("offset-b: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("b")));</span><br><span class="line">        System.out.println("offset-c: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("c")));</span><br><span class="line">        System.out.println("offset-d: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset-a: 16</span><br><span class="line">offset-b: 152</span><br><span class="line">offset-c: 288</span><br><span class="line">offset-d: 12</span><br><span class="line">Shallow Size: 424 bytes</span><br><span class="line">Retained Size: 424 bytes</span><br></pre></td></tr></table></figure><p>可以看到，这时b和c中增加了128字节的padding，结构也就变成了：</p><p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | 160~288 | — | c:288~296 | — | 296~424 |</p><h2><span id="原文地址">原文地址</span></h2><p><img src="https://www.jianshu.com/p/c3c108c3dcfd" alt="原文地址"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/article/java-class-loader/"/>
      <url>/article/java-class-loader/</url>
      
        <content type="html"><![CDATA[<h2><span id="java类加载机制的七个阶段">Java类加载机制的七个阶段</span></h2><p>当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行<code>java Demo</code>命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：<strong>加载、验证、准备、解析、初始化、使用、卸载。</strong></p><h3><span id="加载">加载</span></h3><p>下面是对于加载过程最为官方的描述。</p><blockquote><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p></blockquote><p>其实加载阶段用一句话来说就是：把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。</p><h3><span id="验证">验证</span></h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：</p><ul><li>**JVM规范校验。**JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 <code>0x cafe bene</code>开头，主次版本号是否在当前虚拟机处理范围之内等。</li><li>**代码逻辑校验。**JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。</li></ul><p>当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。</p><h3><span id="准备重点">准备（重点）</span></h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。</p><h4><span id="内存分配的对象">内存分配的对象。</span></h4><p>Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</p><p>例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> factor = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> String website = <span class="string">"www.cnblogs.com/chanshuyi"</span>;</span><br></pre></td></tr></table></figure><h4><span id="初始化的类型">初始化的类型</span></h4><p>在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。</p><p>例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sector = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p><h3><span id="解析">解析</span></h3><p>当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p><p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p><h3><span id="初始化重点">初始化（重点）</span></h3><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p><ul><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：</li></ul><ul><li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li></ul><h3><span id="使用">使用</span></h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。</p><h3><span id="卸载">卸载</span></h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello ShuYi."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">书的静态代码块</span><br><span class="line">Hello ShuYi.</span><br></pre></td></tr></table></figure><h3><span id="分析例子">分析例子</span></h3><p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类），我们会进行类的初始化。<br>在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法</p><ul><li><p>类初始化方法</p><p>编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法<strong>类初始化方法一般在类初始化的时候执行。</strong><br>上面的这个例子，其类初始化方法就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象初始化方法</p><p>编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法**对象初始化方法一般在实例化类对象的时候执行。**上面这个例子，其对象初始化方法&lt;就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br></pre></td></tr></table></figure><p>类初始化方法  和 对象初始化方法之后，我们再来看这个例子，我们就不难得出上面的答案了。其实上面的这个例子其实没有执行对象初始化方法,因为我们确实没有进行 Book 类对象的实例化。如果你在 main 方法中增加 new Book() 语句，你会发现对象的初始化方法执行了！</p></li></ul><h2><span id="实战分析">实战分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爷爷在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> factor = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爸爸~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"儿子在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是儿子~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸的岁数:"</span> + Son.factor);  <span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">爷爷在静态代码块</span><br><span class="line">爸爸在静态代码块</span><br><span class="line">爸爸的岁数:25</span><br></pre></td></tr></table></figure><p>也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？</p><p>**这是因为对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）。**因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>对面上面的这个例子，我们可以从入口开始分析一路分析下去：</p><ul><li>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。</li><li>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。</li><li>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。</li></ul><p>我们再来看一下一个更复杂点的例子，看看输出结果是啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爷爷在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grandpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爷爷~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爸爸~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"儿子在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是儿子~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son();  <span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">爷爷在静态代码块</span><br><span class="line">爸爸在静态代码块</span><br><span class="line">儿子在静态代码块</span><br><span class="line">我是爷爷~</span><br><span class="line">我是爸爸~</span><br><span class="line">我是儿子~`</span><br></pre></td></tr></table></figure><p>让我们仔细来分析一下上面代码的执行流程：</p><ul><li>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。</li><li>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷~」、「我是爸爸~」、「我是儿子~」。</li></ul><p>下面给大家看一个特殊点的例子，有点难哦！</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子的输出结果是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">书的普通代码块</span><br><span class="line">书的构造方法</span><br><span class="line">price=110,amount=0</span><br><span class="line">书的静态代码块</span><br><span class="line">书的静态方法</span><br></pre></td></tr></table></figure><p>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。<br>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。</p><ul><li>当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。</li><li>当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器</li><li>JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器</li></ul><p>对于 Book 类，其类构造方法可以简单表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span></span><br></pre></td></tr></table></figure><p>于是首先执行<code>static Book book = new Book();</code>这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器，收集后的对象构造器 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">Book()</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">    System.out.println(<span class="string">"price="</span> + price +<span class="string">", amount="</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。</p><p>当类实例化完成之后，JVM 继续进行类构造器的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();  <span class="comment">//完成类实例化</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br></pre></td></tr></table></figure><p>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。</p><ul><li>到这里，类的初始化已经完成，JVM 执行 main 方法的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    staticFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即输出：「书的静态方法」。</p><h2><span id="方法论">方法论</span></h2><p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p><ul><li>**确定类变量的初始值。**在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</li><li>**初始化入口方法。**当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器，之后初始化对象构造器</li><li>**初始化类构造器。**JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</li><li>**初始化对象构造器。**JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</li></ul><p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(2)</title>
      <link href="/article/distributed-redis-data-structure-dict/"/>
      <url>/article/distributed-redis-data-structure-dict/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="结构">结构</span></h2><p>Redis 的 Hash 类型键使用以下两种数据结构作为底层实现:</p><ul><li>字典；</li><li>压缩列表；</li></ul><p>因为压缩列表比字典更节省内存， 所以程序在创建新 Hash 键时， 默认使用压缩列表作为底层实现， 当有需要时， 程序才会将底层实现从压缩列表转换到字典。</p><h2><span id="dict哈希表">Dict哈希表</span></h2><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p></li><li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p></li><li><p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p></li></ul><p>图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。<br><img src="/article/distributed-redis-data-structure-dict/1561628837627distributed-redis-data-structure-dict_.png" alt></p><h2><span id="dict节点">Dict节点</span></h2><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>举个例子， 图 4-2 就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。</p><p><img src="/article/distributed-redis-data-structure-dict/1561630405037distributed-redis-data-structure-dict_.png" alt></p><h2><span id="dict-结构">Dict 结构</span></h2><p>Redis 中的字典由 dict.h/dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><blockquote><p>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。<br>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p></li><li><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p></li></ul><p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：</p><p><img src="/article/distributed-redis-data-structure-dict/1561630558107distributed-redis-data-structure-dict_.png" alt></p><h2><span id="哈希算法以及解决冲突">哈希算法以及解决冲突</span></h2><ul><li>哈希算法</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><ul><li><p>解决冲突</p><p>在哈希表实现中， 当两个不同的键拥有相同的哈希值时， 称这两个键发生碰撞（collision）， 而哈希表实现必须想办法对碰撞进行处理。</p><p>字典哈希表所使用的碰撞解决方法被称之为链地址法： 这种方法使用链表将多个哈希值相同的节点串连在一起， 从而解决冲突问题。</p><p><img src="/article/distributed-redis-data-structure-dict/1561631101522distributed-redis-data-structure-dict_.png" alt></p></li></ul><h2><span id="rehash">rehash</span></h2><h3><span id="rehash-发生的原因">rehash 发生的原因</span></h3><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>其中哈希表的负载因子可以通过公式：</p><p><strong>负载因子 = 哈希表已保存节点数量 / 哈希表大小</strong><br><code>load_factor = ht[0].used / ht[0].size</code><br>计算得出。<br>比如说， 对于一个大小为 4 ， 包含 4 个键值对的哈希表来说， 这个哈希表的负载因子为：</p><p><code>load_factor = 4 / 4 = 1</code><br>又比如说， 对于一个大小为 512 ， 包含 256 个键值对的哈希表来说， 这个哈希表的负载因子为：</p><p><code>load_factor = 256 / 512 = 0.5</code></p><p>根据 <code>BGSAVE</code> 命令或 <code>BGREWRITEAOF</code> 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 <code>BGSAVE</code> 命令或 <code>BGREWRITEAOF</code> 命令的过程中， <code>Redis</code> 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制<code>（copy-on-write）</code>技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p><p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p><h3><span id="rehash-过程">rehash 过程</span></h3><ul><li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p></li><li><p>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；<br>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</p></li><li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p></li><li><p>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。<br>举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：</p></li><li><p>ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。</p></li><li><p>将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。</p></li><li><p>释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</p></li></ul><p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。</p><p><img src="/article/distributed-redis-data-structure-dict/1561631365627distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631373754distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631382607distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631389393distributed-redis-data-structure-dict_.png" alt></p><h2><span id="渐进式rehash">渐进式rehash</span></h2><p>在上一节，我们了解了字典的 rehash 过程， 需要特别指出的是， rehash 程序并不是在激活之后，就马上执行直到完成的， 而是分多次、渐进式地完成的。</p><p>假设这样一个场景：在一个有很多键值对的字典里， 某个用户在添加新键值对时触发了 rehash 过程， 如果这个 rehash 过程必须将所有键值对迁移完毕之后才将结果返回给用户， 这样的处理方式将是非常不友好的。</p><p>另一方面， 要求服务器必须阻塞直到 rehash 完成， 这对于 Redis 服务器本身也是不能接受的。</p><p>为了解决这个问题， Redis 使用了渐进式（incremental）的 rehash 方式： 通过将 rehash 分散到多个步骤中进行， 从而避免了集中式的计算。</p><p>渐进式 rehash 主要由 <code>_dictRehashStep</code> 和 <code>dictRehashMilliseconds</code> 两个函数进行：</p><p><code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash ；<br><code>dictRehashMilliseconds</code> 则由 Redis 服务器常规任务程序（server cron job）执行，用于对数据库字典进行主动 rehash ；<br><code>_dictRehashStep</code><br>每次执行 <code>_dictRehashStep</code> ， ht[0]-&gt;table 哈希表第一个不为空的索引上的所有节点就会全部迁移到 ht[1]-&gt;table 。</p><p>在 rehash 开始进行之后（d-&gt;rehashidx 不为 -1）， 每次执行一次添加、查找、删除操作， <code>_dictRehashStep</code> 都会被执行一</p><p><img src="/article/distributed-redis-data-structure-dict/1561631651242distributed-redis-data-structure-dict_.png" alt></p><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p><p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p><h2><span id="字典的收缩">字典的收缩</span></h2><p>扩展 rehash 和收缩 rehash 执行完全相同的过程， 一个 rehash 是扩展还是收缩字典， 关键在于新分配的 ht[1]-&gt;table 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查字典的使用率是否低于系统允许的最小比率</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 是的话返回 1 ，否则返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表已用节点数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当哈希表的大小大于 DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    <span class="comment">// 并且字典的填充率低于 REDIS_HT_MINFILL 时</span></span><br><span class="line">    <span class="comment">// 返回 1</span></span><br><span class="line">    <span class="keyword">return</span> (size &amp;&amp; used &amp;&amp; size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; REDIS_HT_MINFILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下， <code>REDIS_HT_MINFILL</code> 的值为 <code>10</code> ， 也即是说， 当字典的填充率低于 <code>10%</code> 时， 程序就可以对这个字典进行收缩操作了。</p><p>字典收缩和字典扩展的一个区别是：</p><ul><li>字典的扩展操作是自动触发的（不管是自动扩展还是强制扩展）；</li><li>而字典的收缩操作则是由程序手动执行。</li></ul><p>因此， 使用字典的程序可以决定何时对字典进行收缩：</p><ul><li>当字典用于实现哈希键的时候， 每次从字典中删除一个键值对， 程序就会执行一次 <code>htNeedsResize</code> 函数， 如果字典达到了收缩的标准， 程序将立即对字典进行收缩；</li><li>当字典用于实现数据库键空间（key space）的时候， 收缩的时机由 redis.c/tryResizeHashTables 函数决定。</li></ul><h2><span id="字典的迭代">字典的迭代</span></h2><p>字典带有自己的迭代器实现 —— 对字典进行迭代实际上就是对字典所使用的哈希表进行迭代：<br>迭代器首先迭代字典的第一个哈希表，然后，如果 rehash 正在进行的话，就继续对第二个哈希表进行迭代。</p><ul><li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点。</li><li>当这个索引迭代完了，继续查找下一个不为空的索引，如此反覆，直到整个哈希表都迭代完为止。</li></ul><p>整个迭代过程可以用伪代码表示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_dict</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代 0 号哈希表</span></span><br><span class="line">    iter_table(ht[0]-&gt;table)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果正在执行 rehash ，那么也迭代 1 号哈希表</span></span><br><span class="line">    if dict.is_rehashing(): iter_table(ht[1]-&gt;table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_table</span><span class="params">(table)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历哈希表上的所有索引</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> table:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 跳过空索引</span></span><br><span class="line">        <span class="keyword">if</span> table[index].empty():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历索引上的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> table[index]:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理节点</span></span><br><span class="line">            do_something_with(node)</span><br></pre></td></tr></table></figure><p>字典的迭代器有两种：</p><ul><li>安全迭代器：在迭代进行过程中，可以对字典进行修改。</li><li>不安全迭代器：在迭代进行过程中，不对字典进行修改。</li></ul><p>以下是迭代器的数据结构定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 字典迭代器</span><br><span class="line"> */</span><br><span class="line">typedef struct dictIterator &#123;</span><br><span class="line"></span><br><span class="line">    dict *d;                // 正在迭代的字典</span><br><span class="line"></span><br><span class="line">    int table,              // 正在迭代的哈希表的号码（<span class="number">0</span> 或者 <span class="number">1</span>）</span><br><span class="line">        index,              // 正在迭代的哈希表数组的索引</span><br><span class="line">        safe;               // 是否安全？</span><br><span class="line"></span><br><span class="line">    dictEntry *entry,       // 当前哈希节点</span><br><span class="line">              *nextEntry;   // 当前哈希节点的后继节点</span><br><span class="line"></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><h2><span id="api">API</span></h2><table border="1" class="docutils"><colgroup><col width="21%"><col width="47%"><col width="32%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictCreate</span></code></td><td>创建一个新的字典。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictAdd</span></code></td><td>将给定的键值对添加到字典里面。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictReplace</span></code></td><td>将给定的键值对添加到字典里面，如果键已经存在于字典，那么用新值取代原有的值。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictFetchValue</span></code></td><td>返回给定键的值。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictGetRandomKey</span></code></td><td>从字典中随机返回一个键值对。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictDelete</span></code></td><td>从字典中删除给定键所对应的键值对。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictRelease</span></code></td><td>释放给定字典，以及字典中包含的所有键值对。</td><td><span class="math">O(N)</span> ，<code class="docutils literal"><span class="pre">N</span></code> 为字典包含的键值对数量。</td></tr></tbody></table><h3><span id="skiplist与平衡树-哈希表的比较">skiplist与平衡树、哈希表的比较</span></h3><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li></ul><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(1)</title>
      <link href="/article/distributed-redis-data-structure-sds-link/"/>
      <url>/article/distributed-redis-data-structure-sds-link/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="sds">SDS</span></h2><h2><span id="sds-简介">SDS 简介</span></h2><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p><p>举个例子， 如果客户端执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2><span id="sds-结构">SDS 结构</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图 2-1 展示了一个 SDS 示例：</p><ul><li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561604606909distributed-redis-data-structure-sds-link_.png" alt></p><p>图 2-2 展示了另一个 SDS 示例:</p><ul><li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 “Redis” 。</li><li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 buf 数组分配了五字节未使用空间， 所以它的 free 属性的值为 5 （图中使用五个空格来表示五字节的未使用空间）。</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561604660662distributed-redis-data-structure-sds-link_.png" alt></p><h2><span id="sds-结构与c字符串的不同">SDS 结构与C字符串的不同</span></h2><h3><span id="常数获取字符串长度"><strong>常数获取字符串长度</strong></span></h3><p>由于结构当中已经存贮了字符串的长度，所以当需要获取字符串长度的时候，直接返回,时间复杂度O(1)。</p><h3><span id="杜绝缓冲去溢出"><strong>杜绝缓冲去溢出</strong></span></h3><p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性</p><p>当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p><h3><span id="减少字符串修改的分配次数"><strong>减少字符串修改的分配次数</strong></span></h3><p>正如前两个小节所说， 因为 C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。</p><p>因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p><ul><li><p>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</p></li><li><p>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</p></li></ul><p>为了减少空间分配的性能消耗，redis有一下集中策略来管理空间分配</p><h4><span id="空间预分配">空间预分配</span></h4><p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p><p>其中， 额外分配的未使用空间数量由以下公式决定：</p><ul><li><p>如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。</p><blockquote><p>举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。</p></blockquote></li><li><p>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。</p><blockquote><p>举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。</p></blockquote></li></ul><p>通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。</p><h4><span id="惰性空间释放">惰性空间释放</span></h4><p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。</p><p>举个例子， sdstrim 函数接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</p><p>比如对于图 2-14 所示的 SDS 值 s 来说， 执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdstrim(s, "XY");   // 移除 SDS 字符串中的所有 'X' 和 'Y'</span><br></pre></td></tr></table></figure><p><img src="/article/distributed-redis-data-structure-sds-link/1561609102007distributed-redis-data-structure-sds-link_.png" alt></p><p><img src="/article/distributed-redis-data-structure-sds-link/1561609109129distributed-redis-data-structure-sds-link_.png" alt></p><h3><span id="二进制安全"><strong>二进制安全</strong></span></h3><p>所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p><p>这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</p><p>比如说， 使用 SDS 来保存之前提到的特殊数据格式就没有任何问题， 因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束.</p><h2><span id="sds-api">SDS API</span></h2><table border="1" class="docutils"><colgroup><col width="17%"><col width="35%"><col width="49%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsnew</span></code></td><td>创建一个包含给定 C 字符串的 SDS 。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为给定 C 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsempty</span></code></td><td>创建一个不包含任何内容的空 SDS 。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsfree</span></code></td><td>释放给定的 SDS 。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdslen</span></code></td><td>返回 SDS 的已使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code class="docutils literal"><span class="pre">len</span></code> 属性来直接获得，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsavail</span></code></td><td>返回 SDS 的未使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code class="docutils literal"><span class="pre">free</span></code> 属性来直接获得，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsdup</span></code></td><td>创建一个给定 SDS 的副本（copy）。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为给定 SDS 的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsclear</span></code></td><td>清空 SDS 保存的字符串内容。</td><td>因为惰性空间释放策略，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscat</span></code></td><td>将给定 C 字符串拼接到 SDS字符串的末尾。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被拼接 C 字符串的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdscatsds</span></code></td><td>将给定 SDS 字符串拼接到另一个 SDS字符串的末尾。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被拼接 SDS 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscpy</span></code></td><td>将给定的 C 字符串复制到 SDS 里面，覆盖 SDS 原有的字符串。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被复制 C 字符串的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsgrowzero</span></code></td><td>用空字符将 SDS 扩展至给定长度。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为扩展新增的字节数。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsrange</span></code></td><td>保留 SDS 给定区间内的数据，不在区间内的数据会被覆盖或清除。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被保留数据的字节数。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdstrim</span></code></td><td>接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C字符串中出现过的字符。</td><td><span class="math">O(M*N)</span> ， <code class="docutils literal"><span class="pre">M</span></code> 为 SDS 的长度，<code class="docutils literal"><span class="pre">N</span></code> 为给定 C 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscmp</span></code></td><td>对比两个 SDS 字符串是否相同。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为两个 SDS 中较短的那个 SDS的长度。</td></tr></tbody></table><h2><span id="链表">链表</span></h2><h2><span id="链表结构">链表结构</span></h2><p>每个链表节点使用一个 adlist.h/listNode 结构来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode</span><br></pre></td></tr></table></figure><p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。</p><p><img src="/article/distributed-redis-data-structure-sds-link/1561609442948distributed-redis-data-structure-sds-link_.png" alt></p><p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>图 3-2 是由一个 list 结构和三个 listNode 结构组成的链表：</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561609514761distributed-redis-data-structure-sds-link_.png" alt></p><h2><span id="链表api">链表API</span></h2><table border="1" class="docutils"><colgroup><col width="20%"><col width="44%"><col width="35%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetDupMethod</span></code></td><td>将给定的函数设置为链表的节点值复制函数。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetDupMethod</span></code></td><td>返回链表当前正在使用的节点值复制函数。</td><td>复制函数可以通过链表的 <code class="docutils literal"><span class="pre">dup</span></code> 属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetFreeMethod</span></code></td><td>将给定的函数设置为链表的节点值释放函数。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetFree</span></code></td><td>返回链表当前正在使用的节点值释放函数。</td><td>释放函数可以通过链表的 <code class="docutils literal"><span class="pre">free</span></code> 属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetMatchMethod</span></code></td><td>将给定的函数设置为链表的节点值对比函数。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetMatchMethod</span></code></td><td>返回链表当前正在使用的节点值对比函数。</td><td>对比函数可以通过链表的 <code class="docutils literal"><span class="pre">match</span></code>属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listLength</span></code></td><td>返回链表的长度（包含了多少个节点）。</td><td>链表长度可以通过链表的  <code class="docutils literal"><span class="pre">len</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listFirst</span></code></td><td>返回链表的表头节点。</td><td>表头节点可以通过链表的 <code class="docutils literal"><span class="pre">head</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listLast</span></code></td><td>返回链表的表尾节点。</td><td>表尾节点可以通过链表的 <code class="docutils literal"><span class="pre">tail</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listPrevNode</span></code></td><td>返回给定节点的前置节点。</td><td>前置节点可以通过节点的 <code class="docutils literal"><span class="pre">prev</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listNextNode</span></code></td><td>返回给定节点的后置节点。</td><td>后置节点可以通过节点的 <code class="docutils literal"><span class="pre">next</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listNodeValue</span></code></td><td>返回给定节点目前正在保存的值。</td><td>节点值可以通过节点的 <code class="docutils literal"><span class="pre">value</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listCreate</span></code></td><td>创建一个不包含任何节点的新链表。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listAddNodeHead</span></code></td><td>将一个包含给定值的新节点添加到给定链表的表头。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listAddNodeTail</span></code></td><td>将一个包含给定值的新节点添加到给定链表的表尾。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listInsertNode</span></code></td><td>将一个包含给定值的新节点添加到给定节点的之前或者之后。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSearchKey</span></code></td><td>查找并返回链表中包含给定值的节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listIndex</span></code></td><td>返回链表在给定索引上的节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listDelNode</span></code></td><td>从链表中删除给定节点。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listRotate</span></code></td><td>将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，成为新的表头节点。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listDup</span></code></td><td>复制一个给定链表的副本。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listRelease</span></code></td><td>释放给定链表，以及链表中的所有节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析系列(2)</title>
      <link href="/article/forbid-foreach-add-or-move/"/>
      <url>/article/forbid-foreach-add-or-move/</url>
      
        <content type="html"><![CDATA[<p>在阿里巴巴Java开发手册中，有这样一条规定：</p><p><img src="/article/forbid-foreach-add-or-move/1555993054426forbid-foreach-add-or-move_.png" alt></p><h3><span id="foreach循环">foreach循环</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型t 元素变量x : 遍历对象obj)&#123; </span><br><span class="line">     引用了x的java语句; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例演示了 普通for循环 和 foreach循环使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用ImmutableList初始化一个List</span></span><br><span class="line">    List&lt;String&gt; userNames = ImmutableList.of(<span class="string">"Hollis"</span>, <span class="string">"hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"H"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"使用for循环遍历List"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userNames.size(); i++) &#123;</span><br><span class="line">        System.out.println(userNames.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"使用foreach遍历List"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用for循环遍历List</span><br><span class="line">Hollis</span><br><span class="line">hollis</span><br><span class="line">HollisChuang</span><br><span class="line">H</span><br><span class="line">使用foreach遍历List</span><br><span class="line">Hollis</span><br><span class="line">hollis</span><br><span class="line">HollisChuang</span><br><span class="line">H</span><br></pre></td></tr></table></figure><p>可以看到，使用foreach语法遍历集合或者数组的时候，可以起到和普通for循环同样的效果，并且代码更加简洁。所以，foreach循环也通常也被称为增强for循环。<br>其实，增强for循环也是Java给我们提供的一个语法糖，如果将以上代码编译后的class文件进行反编译（使用jad工具）的话，可以得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = userNames.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    String userName = (String)iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(userName.equals(<span class="string">"Hollis"</span>))</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>可以发现，原本的增强for循环，其实是依赖了while循环和Iterator实现的。（请记住这种实现方式，后面会用到！）</p><h3><span id="问题重现">问题重现</span></h3><p>规范中指出不让我们在foreach循环中对集合元素做add/remove操作，那么，我们尝试着做一下看看会发生什么问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双括弧语法（double-brace syntax）建立并初始化一个List</span></span><br><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userNames.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userNames.get(i).equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>以上代码，首先使用双括弧语法（double-brace syntax）建立并初始化一个List，其中包含四个字符串，分别是Hollis、hollis、HollisChuang和H。</p><p>然后使用普通for循环对List进行遍历，删除List中元素内容等于Hollis的元素。然后输出List，输出结果如下：</p><pre><code>[hollis, HollisChuang, H]</code></pre><p>以上是哪使用普通的for循环在遍历的同时进行删除，那么，我们再看下，如果使用增强for循环的话会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>以上代码，使用增强for循环遍历元素，并尝试删除其中的Hollis字符串元素。运行以上代码，会抛出以下异常：<code>java.util.ConcurrentModificationException</code><br>之所以会出现这个异常，是因为触发了一个Java集合的错误检测机制——<code>fail-fast</code> 。</p><h3><span id="fail-fast">fail-fast</span></h3><p>接下来，我们就来分析下在增强for循环中add/remove元素的时候会抛出java.util.ConcurrentModificationException的原因，即解释下到底什么是fail-fast进制，fail-fast的原理等。</p><p>fail-fast，即快速失败，它是Java集合的一种错误检测机制。当多个线程对集合（非fail-safe的集合类）进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException（当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。</p><p><strong>同时需要注意的是，即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。</strong></p><p>那么，在增强for循环进行元素删除，是如何违反了规则的呢？</p><p>要分析这个问题，我们先将增强for循环这个语法糖进行解糖，得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用ImmutableList初始化一个List</span></span><br><span class="line">    List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">"Hollis"</span>);</span><br><span class="line">        add(<span class="string">"hollis"</span>);</span><br><span class="line">        add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">        add(<span class="string">"H"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Iterator iterator = userNames.iterator();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        String userName = (String)iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(userName.equals(<span class="string">"Hollis"</span>))</span><br><span class="line">            userNames.remove(userName);</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(userNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行以上代码，同样会抛出异常。我们来看一下<code>ConcurrentModificationException</code>的完整堆栈：</p><p><img src="/article/forbid-foreach-add-or-move/1555993429782forbid-foreach-add-or-move_.png" alt></p><p>通过异常堆栈我们可以到，异常发生的调用链ForEachDemo的第23行，<code>Iterator.next</code> 调用了 <code>Iterator.checkForComodification</code>方法 ，而异常就是checkForComodification方法中抛出的。</p><p>其实，经过debug后，我们可以发现，如果remove代码没有被执行过，iterator.next这一行是一直没报错的。抛异常的时机也正是remove执行之后的的那一次next方法的调用。</p><p>我们直接看下checkForComodification方法的代码，看下抛出异常的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，<code>modCount != expectedModCount</code>的时候，就会抛出<code>ConcurrentModificationException</code>。</p><p>那么，就来看一下，remove/add 操作室如何导致modCount和expectedModCount不相等的吧。</p><h3><span id="removeadd-做了什么">remove/add 做了什么</span></h3><p>首先，我们要搞清楚的是，到底modCount和expectedModCount这两个变量都是个什么东西。</p><p>通过翻源码，我们可以发现：</p><ul><li>modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。</li><li>expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator方法被调用的时候初始化的。只有通过迭代器对集合进行操作，该值才会改变。</li><li>Itr是一个Iterator的实现，使用ArrayList.iterator方法可以获取到的迭代器就是Itr类的实例。</li></ul><p>他们之间的关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，看到这里，大概很多人都能猜到为什么remove/add 操作之后，会导致expectedModCount和modCount不想等了。</p><p>通过翻阅代码，我们也可以发现，remove方法核心逻辑如下：</p><p><img src="/article/forbid-foreach-add-or-move/1555993489849forbid-foreach-add-or-move_.png" alt></p><p>可以看到，它只修改了modCount，并没有对expectedModCount做任何操作。</p><p>简单总结一下，之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改！</p><h3><span id="正确姿势">正确姿势</span></h3><p>至此，我们介绍清楚了不能在foreach循环体中直接对集合进行add/remove操作的原因。</p><p>但是，很多时候，我们是有需求需要过滤集合的，比如删除其中一部分元素，那么应该如何做呢？有几种方法可供参考：</p><p><strong>1、直接使用普通for循环进行操作</strong></p><p>我们说不能在foreach中进行，但是使用普通的for循环还是可以的，因为普通for循环并没有用到Iterator的遍历，所以压根就没有进行<code>fail-fast</code>的检验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userNames.get(i).equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>这种方案其实存在一个问题，那就是remove操作会改变List中元素的下标，可能存在漏删的情况。<br><strong>2、直接使用Iterator进行操作</strong></p><p>除了直接使用普通for循环以外，我们还可以直接使用Iterator提供的remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">Iterator iterator = userNames.iterator();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>如果直接使用Iterator提供的remove方法，那么就可以修改到expectedModCount的值。那么就不会再抛出异常了。其实现代码如下：</p><p><img src="/article/forbid-foreach-add-or-move/1555993589126forbid-foreach-add-or-move_.png" alt></p><p><strong>3、使用Java 8中提供的filter过滤</strong></p><p>Java 8中可以把集合转换成流，对于流有一种filter操作， 可以对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">userNames = userNames.stream().filter(userName -&gt; !userName.equals(<span class="string">"Hollis"</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p><strong>4、使用增强for循环其实也可以</strong></p><p>如果，我们非常确定在一个集合中，某个即将删除的元素只包含一个的话， 比如对Set进行操作，那么其实也是可以使用增强for循环的，只要在删除之后，立刻结束循环体，不要再继续进行遍历就可以了，也就是说不让代码执行到下一次的next方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p><strong>5、直接使用fail-safe的集合类</strong></p><p>在Java中，除了一些普通的集合类以外，还有一些采用了fail-safe机制的集合类。这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedDeque&lt;String&gt; userNames = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h2><span id="总结">总结</span></h2><p>我们使用的增强for循环，其实是Java提供的语法糖，其实现原理是借助Iterator进行元素的遍历。</p><p>但是如果在遍历过程中，不通过Iterator，而是通过集合类自身的方法对集合进行添加/删除操作。那么在Iterator进行下一次的遍历时，经检测发现有一次集合的修改操作并未通过自身进行，那么可能是发生了并发被其他线程执行的，这时候就会抛出异常，来提示用户可能发生了并发修改，这就是所谓的fail-fast机制。</p><p>当然还是有很多种方法可以解决这类问题的。比如使用普通for循环、使用Iterator进行元素删除、使用Stream的filter、使用fail-safe的类等。</p><p>原文链接：<br><img src="https://juejin.im/post/5c8717ad5188257dda56c381" alt="https://juejin.im/post/5c8717ad5188257dda56c381"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(1)</title>
      <link href="/article/java-AQS/"/>
      <url>/article/java-AQS/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>谈到并发，不得不谈<code>ReentrantLock</code>；而谈到<code>ReentrantLock</code>，不得不谈<code>AbstractQueuedSynchronized（AQS</code>）！,类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的<code>ReentrantLock/Semaphore/CountDownLatch</code>…。我们以<code>ReentrantLock</code>作为讲解切入点。</p><ul><li>AQS 思维导图</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-31/61115865.jpg" alt></p><h2><span id="aos详解">AOS详解</span></h2><h2><span id="什么是aqs">什么是AQS</span></h2><p>AQS的全称为（AbstractQueuedSynchronizer),是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器</p><h2><span id="aqs与reentrantlock的关系">AQS与ReentrantLock的关系</span></h2><p><code>ReentrantLock</code> 会保证<code>do something</code>在同一时间只有一个线程在执行这段代码，或者说，同一时刻只有一个线程的 <code>lock</code> 方法会返回。其余线程会被挂起，直到获取锁。</p><p>从这里可以看出，其实 <code>ReentrantLock</code> 实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。没错，<code>ReentrantLock</code> 使用的就是 AQS 的独占 API 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// do somethings</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>我们来看 lock的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock 方法是调用的是 <code>sync.lock()</code> 的方法。而<code>Sync</code>是 <code>ReentrantLock</code> 的一个继承了<code>AbstractQueuedSynchronizer</code> 的一个内部类<br>这里的Sync定义了一个抽象类，目的就是要让继承类来实现他的lock方法。<code>ReentrantLock</code>  有公平和非公平的锁机制，所以在该类的代码中，我们可以看到他继承了Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>继承关系如下<br><img src="/article/java-AQS/sync.png" alt></p><h2><span id="aqs-的原理">AQS 的原理</span></h2><p>所以，具体的同步机制就是Sync的具体实现类来管理的。要了解Sync的原理，我们首先要先了解他的父类 <code>AbstractQueuedSynchronizer</code> （AQS）</p><p>AQS核心思想是</p><ul><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</li></ul><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>AQS 的功能可以分为两类：<strong>独占功能</strong>和<strong>共享功能</strong>，它的所有子类中，要么实现并使用了它独占功能的 API，要么使用了共享锁的功能，而不会同时使用两套 API，即便是它最有名的子类 ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套 API 来实现的。</p><h2><span id="abstractqueuedsynchronizer-分析">AbstractQueuedSynchronizer 分析</span></h2><p><code>AbstractQueuedSynchronizer</code> 类图如下<br><img src="/article/java-AQS/AQS.jpg" alt></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/CLH.png" alt></p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;<span class="comment">/*... */</span>&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//同步状态</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    状态信息通过protected类型的getState，setState，compareAndSetState进行操作返回同步状态的当前值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置同步状态的值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><h2><span id="sync的实现公平锁和非公平锁">Sync的实现公平锁和非公平锁</span></h2><p><strong>公平锁</strong>：每个线程抢占锁的顺序为先后调用 lock 方法的顺序依次获取锁，类似于排队吃饭。</p><p><strong>非公平锁</strong>：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用 lock 方法的先后顺序无关。</p><h3><span id="公平锁的实现">公平锁的实现</span></h3><p>我们来看一下公平锁的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);   <span class="comment">// 在AbstractQueuedSynchronizer 类当中实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="comment">// 在AbstractQueuedSynchronizer 实现的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表示的是 一个 <code>volatile</code> 修饰的标志位叫做<code>key</code> ，用来表示有没有线程拿走了锁（<code>tryAcquire</code>），当锁不存在的时候，将线程放到一个安全的队列，队列里维护一堆被挂起的线程，当锁被归还时，能通知到这些被挂起的线程，可以来竞争获取锁了。</p><ul><li><p>获取到锁的情景<br>我们来看 <code>tryAcquire</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer 留空了，需要让子类去实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FairSync 子类实现的 获取锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();     <span class="comment">// 拿到标志位</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果队列中没有其他线程  说明没有线程正在占有锁！</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">//修改一下状态位，注意：这里的 acquires 是在 lock 的时候传递来的，从上面的图中可以知道，这个值是写死的 1</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 如果通过 CAS 操作将状态为更新成功则代表当前线程获取锁，因此，将当前线程设置到 AQS 的一个变量中，说明这个线程拿走了锁。</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不为 0 意味着，锁已经被拿走了，但是，因为 ReentrantLock 是重入锁，是可以重复 lock,unlock 的，只要成对出现行。一次。这里还要再判断一次 获取锁的线程是不是当前请求锁的线程。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是的，累加在 state 字段上就可以了。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有获取到锁的情景</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 如果 已经有一个线程获取到了锁，但是没有线程排队</span></span><br><span class="line">    <span class="comment">// 即 AQS head == tail == null</span></span><br><span class="line">    <span class="comment">// 这里就是 tail == null 因此 这里执行enq方法</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 表示目前没有线程争抢 pred 节点 如果有 则执行enq方法</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 因为end 发生 addWaiter 当中，必定是获取锁失败的情况下</span></span><br><span class="line">        <span class="comment">// 所以为tail 为空 表示有线程获取到了锁，所以这里新建了一个</span></span><br><span class="line">        <span class="comment">// 当head 为空的时候 head 会新建一个Node 节点 治理 head = tail = Node(empty)</span></span><br><span class="line">        <span class="comment">// Node 节点 然后在  acquireQueued 方法中获取到锁的线程set到了head 当中 完成更新</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当首节点为新建好之后 会变成如下  Node(empty) -&gt; &lt;- Node 这样</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AQS 节点的变化</p><ul><li><p>当我们只有一个线程进行加锁的时候 如果加锁成功，即是<code>tryAcquire</code> 进行 <code>hasQueuedPredecessors</code> 的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首个线程进行竞争的时候， AQS 的tail 和 head 均为空 则会走判断 h!=t 则表示 加锁成功，直接返回。</span></span><br><span class="line">    <span class="comment">// 当第二个线程来竞争的时候 发现法 statue 不是 0， 则直接进入大 addWaiter 的排队进程中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 head == tail 的时候 证明 头结点已经有一个 在排队了</span></span><br><span class="line">    <span class="comment">// 这里有个问题 h &lt;-&gt; t  h -&gt; next == null 为什么表示 不需要排队，</span></span><br><span class="line">    <span class="comment">// 这里涉及到解锁的过程</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用当前线程去构造一个 <code>Node</code> 对象，<code>mode</code> 是一个表示 <code>Node</code> 类型的字段，仅仅表示这个节点是独占的，还是共享的，或者说，AQS 的这个队列中，哪些节点是独占的，哪些是共享的。(这里 lock 调用的是 AQS 独占的 API，当然，可以写死是独占状态的节点。)</p></li><li><p>创建好节点后，将节点加入到队列尾部，此处，在队列不为空的时候，先尝试通过 cas 方式修改尾节点为最新的节点，如果修改失败，意味着有并发，这个时候才会进入 enq 中死循环，“自旋”方式修改。</p></li><li><p>将线程的节点接入到队里中后，当然还需要做一件事: 将当前线程挂起！这个事，由 acquireQueued 来做。</p></li></ul></li><li><p>Node节点类型<br>在解释 <code>acquireQueued</code> 之前，我们需要先看下 AQS 中队列的内存结构，我们知道，队列由 Node 类型的节点组成，其中至少有两个变量，一个封装线程，一个封装节点类型。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;         <span class="comment">// 节点类型</span></span><br><span class="line">    <span class="keyword">this</span>.thread = thread;           <span class="comment">// 封装的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上，它的内存结构是这样的（第一次节点插入时，第一个节点是一个空节点，代表有一个线程已经获取锁，事实上，队列的第一个节点就是代表持有锁的节点）：</p><p><img src="/article/java-AQS/1563765045994java-AQS_.png" alt></p><p>黄色节点为队列默认的头节点，每次有线程竞争失败，进入队列后其实都是插入到队列的尾节点（tail 后面）后面。这个从 enq 方法可以看出来，上文中有提到 enq 方法为将节点插入队列的方法:</p></li><li><p>循环获取锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        仔细看看这个方法是个无限循环，感觉如果p == head &amp;&amp; tryAcquire(arg)条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 这里的 表示 他的上一个节点 如果排队成功 那么 node 的上一个节点应该是有的 头结点 始终是个Node(empty)</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前的节点是 head 说明他是队列中第一个“有效的”节点，因此尝试获取，上文中有提到这个类是交给子类去扩展的。</span></span><br><span class="line">                setHead(node);<span class="comment">// 成功后，将上图中的黄色节点移除，Node1 变成头节点。 也就是将头结点变成 empty</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;             <span class="comment">// 这里返回 false  表示上层方法不需要改变 当前线程的 interrupted 状态</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; </span><br><span class="line">                <span class="comment">// 否则，检查前一个节点的状态为，看当前获取锁失败的线程是否需要挂起。</span></span><br><span class="line">                parkAndCheckInterrupt()) </span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment">                上面的方法是调用 LockSupport.park（this）</span></span><br><span class="line"><span class="comment">                如前面所述，LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。当然也不是马上把请求不到锁的线程进行阻塞，还要检查该线程的状态，比如如果该线程处于Cancel状态则没有必要，具体的检查在shouldParkAfterFailedAcquire中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果有异常 </span></span><br><span class="line">            cancelAcquire(node);<span class="comment">// 取消请求，对应到队列操作，就是将当前节点从队列中移除。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code> 节点中，除了存储当前线程，节点类型，队列中前后元素的变量，还有一个叫 <code>waitStatus</code> 的变量，改变量用于描述节点的状态，为什么需要这个状态呢？</p><p>原因是：</p><ul><li>AQS 的队列中，在有并发时，肯定会存取一定数量的节点，每个节点代表了一个线程的状态，有的线程可能“等不及”获取锁了，需要放弃竞争，退出队列，有的线程在等待一些条件满足，满足后才恢复执行（这里的描述很像某个 J.U.C 包下的工具类，ReentrankLock 的 Condition，事实上，Condition 同样也是 AQS 的子类）等等，总之，各个线程有各个线程的状态，但总需要一个变量来描述它，这个变量就叫 waitStatus, 它有四种状态：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 代表无状态</span></span><br><span class="line"><span class="comment">/** 节点取消  因为超时或中断，该线程已经被取消 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 节点等待触发 线程的后继线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 等待条件触发 表明该线程被处于条件队列，就是因为调用了&gt;- Condition.await而被阻塞 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/** 节点状态需要向后传播  传播共享锁*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>只有当前节点的前一个节点为 <code>SIGNAL</code> 时，才能当前节点才能被挂起。</p><ul><li>规则1：如果前继的节点状态为<code>SIGNAL</code>，表明当前节点需要<code>unpark</code>，则返回成功，此时<code>acquireQueued</code>方法的第12行（<code>parkAndCheckInterrupt</code>）将导致线程阻塞</li><li>规则2：如果前继节点状态为<code>CANCELLED</code>(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，<code>acquireQueued</code>方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</li><li>规则3：如果前继节点状态为非<code>SIGNA</code>L、非<code>CANCELLED</code>，则设置前继的状态为<code>SIGNAL</code>，返回false后进入<code>acquireQueued</code>的无限循环，与规则2同</li><li>总体看来，<code>shouldParkAfterFailedAcquire</code>就是靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于<code>CANCELLED</code>状态，则顺便删除这些节点重新构造队列。</li></ul><p>我们来看一下代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">// 如果前继的节点状态为`SIGNAL`，表明当前节点需要`unpark` 返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前继节点状态为`CANCELLED`(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，</span></span><br><span class="line">        <span class="comment">// 返回false，`acquireQueued`方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前继节点状态为非`SIGNA`L、非`CANCELLED`，则设置前继的状态为`SIGNAL`，返回false后进入`acquireQueued`的无限循环，</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>到此为止，一个线程对于锁的一次竞争才告于段落，结果有两种</p><ul><li>要么成功获取到锁（不用进入到 AQS 队列中</li><li>要么，获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁</li></ul><p>值得注意的是，AQS 的队列为 FIFO 队列，所以，每次被 CPU 假唤醒，且当前线程不是出在头节点的位置，也是会被挂起的。AQS 通过这样的方式，实现了竞争的排队策略</p><ul><li><p>释放锁</p><p>我们来看一下释放锁的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer 当中定义的</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 同样 release 由实现类来实现 这里用是Sync抽象类的实现</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// 释放锁，成功后，找到 AQS 的头节点，并唤醒它即可：</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sync 的实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常。</span></span><br><span class="line">      <span class="comment">// 这段可以理解为没有 lock 直接unlock 则会直接报错</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 因为是重入的关系，不是每次释放锁 c 都等于 0，直到最后一次释放锁时，才通知 AQS 不需要再记录哪个线程正在获取锁。</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新状态</span></span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当发现 锁已经需要释放的时候，我们调用 <code>unparkSuccessor</code> 寻找的顺序是从队列尾部开始往前去找的最前面的一个 waitStatus 小于 0 的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">     Node s = node.next;</span><br><span class="line">     <span class="comment">// 从尾到头寻找最后一个节点 表示 s是个沉睡的节点 </span></span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 找到第一个阻塞的节点</span></span><br><span class="line">         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                 s = t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>到此，<code>ReentrantLock</code>的 <code>lock</code> 和 <code>unlock</code> 方法已经基本解析完毕了，唯独还剩下一个非公平锁 <code>NonfairSync</code> 没说，其实，它和公平锁的唯一区别就是获取锁的方式不同，一个是按前后顺序一次获取锁，一个是抢占式的获取锁，那 ReentrantLock 是怎么实现的呢？再看两段代码：</p><h3><span id="非公平锁的实现">非公平锁的实现</span></h3><p>非公平锁的 lock 方法的处理方式是: 在 <code>lock</code> 的时候先直接 <code>cas</code> 修改一次 <code>state</code> 变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Sync 的非公平锁获取方式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 抢占式获取锁 这里是和公平锁的区别</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*!hasQueuedPredecessors() &amp;&amp;*/</span>compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（上)</a></li><li><a href="https://www.infoq.cn/article/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下)</a></li><li><a href="https://www.jianshu.com/p/279baac48960" target="_blank" rel="noopener">java AQS的实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">深入学习java同步器AQS</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="http://codingdict.com/blog/article/2019/4/26/934.html" target="_blank" rel="noopener">http://codingdict.com/blog/article/2019/4/26/934.html</a></li><li><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86192135" target="_blank" rel="noopener">https://blog.csdn.net/Viscu/article/details/86192135</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳定性保证</title>
      <link href="/article/spikability-applications-ability-to/"/>
      <url>/article/spikability-applications-ability-to/</url>
      
        <content type="html"><![CDATA[<p>我最近参与讨论了很多有关应用程序如何处理高负载的能力，这个为的核心在于如何在,如何在不浪费大量的特定资源的情况下保持程序的稳定性，而这些特定的资源只会流量峰值的时候起作用。</p><p>很多应用服务，这样的典型case 十分差常见，例如：<br>博客应用程序可能会在每次发文后出现峰值。再比如，博客应用程序可能会在每次发布的帖子上出现峰值。<br>像Groupon或One Kings Lane这样的日交易比较活跃的网站，每当发布一个新产品时，都会经历巨大的流量高峰。<br>而One Kings Lane 的优势在于他们确切的知道流量峰值的出现时间：每天早上8点。让我们使用日常交易网站作为例子，因为它是一个众所周知的问题。</p><h2><span id="解决方案1更多资源">解决方案1:更多资源</span></h2><p>解决这个问题的一个方法是总是有过剩的容量等待峰值。如果您能够估计出在任何给定的一天中您同时拥有的最大流量，那么就可以保持足够的服务器运行来处理最大负载。有了这个解决方案，总是可以利用超出本日最大值的额外容量来预防即将今天的峰值来临。</p><h2><span id="解决方案2峰值时禁用某些特性俗称降级">解决方案2:峰值时禁用某些特性（俗称降级）</span></h2><p>当流量峰值出现的时候，超过了你应用程序的负载能力，可以选择禁用某些特性或者使用应用程序的“轻量级”备份版本，Groupon 和 Google 都推荐这么做。这之所以有效，是因为他以牺牲了应用的部分功能的代价，来降低应用的负载，所以这并不是最佳的选择</p><h2><span id="解决方案3自动伸缩俗称扩容">解决方案3:自动伸缩（俗称扩容）</span></h2><p>当流量激增时，可以通过快速自动地启动新的服务器来处理他们。看起来很棒了，但实施起来确实困难重重。首先，设置自动缩放系统需要花费大量的精力。其次，它必须能够非常迅速地利用这些额外的资源，如果太慢，你的系统可能已经崩溃了。再次，自动扩展程序决定是时候销毁那些额外的实例之前，还有可能出现资源利用不充分的问题。如果你的峰值出现在随机时间，你最终会一直向上和向下伸缩。</p><h2><span id="解决方案4使用消息队列">解决方案4:使用消息队列</span></h2><p>消息队列作用之一就是流量削峰。当负载教轻的时，队列总是空的。当负载峰值，队列开始被逐步填满，而我们的应用程序可以稳步的按照自己的处理速度来逐步处理这些消息，当让如果队列持续增长，我们也可以通过启动更多的服务器也就是消费方来消耗队列。<br>这不仅避免了不必要的费资也不必禁用站点/应用程序的任何功能。<br>至于消息队列还能解决什么问题，可以参考我另一篇博文<a href="https://jasonlees.netlify.com/article/why-mq/" target="_blank" rel="noopener">MQ可以解决哪些实际问题?</a></p><p>原文地址</p><p><a href="%5Bspikability-applications-ability-to%5D(https://blog.iron.io/spikability-applications-ability-to/)">Spikability – An Application’s Ability to Handle Unknown and/or Inconsistent Load</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 稳定性 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ可以解决哪些实际问题?</title>
      <link href="/article/why-mq/"/>
      <url>/article/why-mq/</url>
      
        <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。消息中间件到底该如何使用，何时使用这是一个问题，胡乱地使用消息中间件增加了系统的复杂度，如果用不好消息中间件还不如不用。</p><h2><span id="1-消息队列通讯模式">1. 消息队列通讯模式</span></h2><h3><span id="点对点通讯">点对点通讯：</span></h3><p>点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</p><h3><span id="多点广播">多点广播：</span></h3><p>MQ适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点(DestinationList)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</p><h3><span id="发布订阅publishsubscribe模式">发布/订阅(Publish/Subscribe)模式：</span></h3><p>发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQEventBroker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。</p><h3><span id="群集cluster">群集(Cluster)：</span></h3><p>为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</p><h2><span id="使用消息队列的理由">使用消息队列的理由</span></h2><ul><li>解耦</li><li>冗余</li><li>扩展性</li><li>灵活性 &amp; 峰值处理能力</li><li>可恢复性</li><li>送达保证</li><li>排序保证</li><li>缓冲</li><li>理解数据流</li><li>异步通讯</li></ul><h3><span id="解耦">解耦</span></h3><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h3><span id="冗余">冗余</span></h3><p>有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。<span>消息队列</span>把数据进行持久化直到它们已经被完全处理，<span>通过这一方式规避了数据丢失风险。在<span>被许多消息队列所采用的</span>&quot;插入</span>-获取-删除&quot;范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</p><h3><span id="扩展性">扩展性</span></h3><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h2><span id="灵活性-amp-峰值处理能力">灵活性 &amp; 峰值处理能力</span></h2><p>当你的应用上了Hacker News的首页，你将发现访问流量攀升到一个不同寻常的水平。在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。请查看我们<a href="http://blog.iron.io/2012/06/spikability-applications-ability-to.html" target="_blank" rel="noopener">关于峰值处理能力的博客文章</a>了解更多此方面的信息。</p><h3><span id="可恢复性">可恢复性</span></h3><p>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</p><h3><span id="送达保证">送达保证</span></h3><p>消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个&quot;只送达一次&quot;保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是&quot;预定&quot;了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</p><h3><span id="排序保证">排序保证</span></h3><p>在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。<span><span style="line-height:21px;">IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索<span style="font-family:'微软雅黑', Verdana, sans-serif, '宋体';line-height:21px;">他们</span>的位置。</span></span></p><h3><span id="缓冲">缓冲</span></h3><p><span><span style="line-height:21px;">在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行–写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</span></span></p><h3><span id="理解数据流">理解数据流</span></h3><p>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</p><h3><span id="异步通信">异步通信</span></h3><p>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p><h2><span id="2消息队列应用场景">2.消息队列应用场景</span></h2><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。</p><h3><span id="异步处理">异步处理</span></h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种</p><span style="color:#ff0000;"> 1.串行的方式；2.并行方式</span><ol><li>串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。<br><img src="/article/why-mq/1554865262348why-mq_.png" alt></li></ol><ol start="2"><li>并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间<br><img src="/article/why-mq/1554865317050why-mq_.png" alt></li></ol><p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p><p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）</p><p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p><p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="/article/why-mq/1554865377893why-mq_.png" alt></p><p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。</p><h3><span id="应用解耦">应用解耦</span></h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="/article/why-mq/1554865447767why-mq_.png" alt></p><p>传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合</p><p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：<br><img src="/article/why-mq/1554865489619why-mq_.png" alt></p><p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p><p>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作</p><p>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p><h3><span id="流量削锋">流量削锋</span></h3><p>流量削锋也是消息队列中的常用场景，<span style="color:#ff0000;">一般在秒杀或团抢活动中使用广泛</span>。</p><p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p><p>a、可以控制活动的人数</p><p>b、可以缓解短时间内高流量压垮应用<br><img src="/article/why-mq/1554865555458why-mq_.png" alt></p><p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。</p><p>秒杀业务根据消息队列中的请求信息，再做后续处理</p><h3><span id="日志处理">日志处理</span></h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下<br><img src="/article/why-mq/1554865583034why-mq_.png" alt></p><p>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列</p><p>Kafka消息队列，负责日志数据的接收，存储和转发</p><p>日志处理应用：订阅并消费kafka队列中的日志数据</p><h3><span id="消息通讯">消息通讯</span></h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在<span style="color:#ff0000;">纯的消息通讯</span>。比如实现点对点消息队列，或者聊天室等<br><span style="color:#ff0000;">点对点通讯：</span><br><img src="/article/why-mq/1554865619033why-mq_.png" alt></p><p>客户端A和客户端B使用同一队列，进行消息通讯。</p><p><span style="color:#ff0000;">聊天室通讯：</span><br><img src="/article/why-mq/1554865634868why-mq_.png" alt></p><p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p><p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p><h2><span id="3-消息中间件示例">3. 消息中间件示例</span></h2><h3><span id="电商系统">电商系统</span></h3><p><img src="/article/why-mq/1554865663446why-mq_.png" alt></p><p>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。</p><p>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）</p><p>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。</p><p>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p><h3><span id="日志收集系统">日志收集系统</span></h3><p><img src="/article/why-mq/1554865773681why-mq_.png" alt></p><p>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p><p>Zookeeper注册中心，提出负载均衡和地址查找服务</p><p>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列</p><p>Kafka集群：接收，路由，存储，转发等消息处理</p><p>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据</p><p>以下是新浪kafka日志处理应用案例：转自（<a href="http://cloud.51cto.com/art/201507/484338.htm%EF%BC%89" target="_blank" rel="noopener">http://cloud.51cto.com/art/201507/484338.htm）</a></p><p><img src="/article/why-mq/1554865925768why-mq_.png" alt></p><p><span>(1)Kafka</span>：接收用户日志的消息队列</p><p><span>(2)Logstash</span>：做日志解析，统一成JSON输出给Elasticsearch</p><p><span>(3)Elasticsearch</span>：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能</p><p><span>(4)Kibana</span>：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因</p><h2><span id="4jms消息服务">4.JMS消息服务</span></h2><p>讲消息队列就不得不提JMS 。JMS（JAVA Message Service，java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>在EJB架构中，有消息bean可以无缝的与JM消息服务集成。在J2EE架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p><h3><span id="消息模型">消息模型</span></h3><p>在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。</p><h4><span id="p2p模式">P2P模式</span></h4><p><img src="/article/why-mq/1554865986120why-mq_.png" alt></p><p>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点</p><p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</p><p>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</p><p>接收者在成功接收消息之后需向队列应答成功</p><p>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。</p><h4><span id="pubsub模式">Pub/Sub模式</span></h4><p><img src="/article/why-mq/1554866112435why-mq_.png" alt>S</p><p>包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p>Pub/Sub的特点</p><p>每个消息可以有多个消费者</p><p>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</p><p>为了消费消息，订阅者必须保持运行的状态</p><p>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p><p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</p><h3><span id="消息消费">消息消费</span></h3><p>在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。</p><p>（1）同步</p><p>订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；</p><p>（2）异步</p><p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><p>JNDI：Java命名和目录接口,是一种标准的Java命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p><p>JNDI在JMS中起到查找和访问发送目标或消息来源的作用。</p><h2><span id="5常用消息队列"><strong>5.常用消息队列</strong></span></h2><p>一般商用的容器，比如WebLogic，JBoss，都支持JMS标准，开发上很方便。但免费的比如Tomcat，Jetty等则需要使用第三方的消息中间件。本部分内容介绍常用的消息中间件（Active MQ,Rabbit MQ，Zero MQ,Kafka）以及他们的特点。</p><h3><span id="activemq">ActiveMQ</span></h3><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p><p><strong>ActiveMQ特性如下：</strong></p><ul><li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li> 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li><li> 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li><li> 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群，客户端-服务器，点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider，进行测试</li></ul><h3><span id="rabbitmq">RabbitMQ</span></h3><p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。结构图如下：</p><p><img src="/article/why-mq/1554866238609why-mq_.png" alt></p><p><strong>几个重要概念：</strong></p><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p><strong>消息队列的使用过程，如下：</strong></p><ul><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ul><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。</p><h3><span id="zeromq">ZeroMQ</span></h3><p>号称史上最快的消息队列，它实际类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。</p><p>引用官方的说法： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入<a href="http://lib.csdn.net/base/linux" title="Linux知识库" target="_blank" rel="noopener">Linux</a>内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一<br>层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”</p><p><strong>特点是：</strong></p><ul><li><p>高性能，非持久化</p></li><li><p>跨平台：支持Linux、Windows、OS X等</p></li><li><p>多语言支持； C、C++、Java、.NET、Python等30多种开发语言</p></li><li><p>可单独部署或集成到应用中使用</p></li><li><p>可作为Socket通信库使用</p></li></ul><p>与RabbitMQ相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，更像一个底层的网络通讯库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。支持“Request-Reply “，”Publisher-Subscriber“，”Parallel Pipeline”三种基本模型和扩展模型。</p><p><strong>ZeroMQ高性能设计要点：</strong></p><p>1、无锁的队列模型</p><p>   对于跨线程间的交互（用户端和session）之间的数据交换通道pipe，采用无锁的队列<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" target="_blank" rel="noopener">算法</a>CAS；在pipe两端注册有异步事件，在读或者写消息到pipe的时，会自动触发读写事件。</p><p>2、批量处理的算法</p><p>   对于传统的消息处理，每个消息在发送和接收的时候，都需要系统的调用，这样对于大量的消息，系统的开销比较大，zeroMQ对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。</p><p>3、多核下的线程绑定，无须CPU切换</p><p>   区别于传统的多线程并发模式，信号量或者临界区， zeroMQ充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的CPU切换开销。</p><h3><span id="kafka">Kafka</span></h3><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。</p><p><strong>Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</strong></p><ul><li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）</li><li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息</li><li>支持通过Kafka服务器和消费机集群来分区消息</li><li>支持Hadoop并行数据加载</li></ul><p><strong>Kafka相关概念</strong></p><ul><li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker[5]</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer：负责发布消息到Kafka broker</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li></ul><p><span style="color:#990000;">一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用。</span></p><h2><span id="6使用消息队列需要考虑的问题">6.使用消息队列需要考虑的问题</span></h2><h3><span id="你也许并不需要消息队列">你也许并不需要消息队列</span></h3><p>消息队列是一个能让你获得容错性，分布式，解耦等架构能力的系统。纸上谈兵的话，它看起来还不错。</p><p>或许消息列队在你的应用中有不少适用的场景。你可以看下这篇关于消息队列优点的文章，看看到底有哪些合适的场景。但可不要因为说&quot;能解耦那太好了”就轻易使用它。我们来看一个例子——你希望你的邮件发送和订单处理互相解耦。</p><p>因此你发送一个消息到消息队列里，然后邮件处理系统取出这个消息并发送邮件。那你在一个独立的单classpath的应用中怎么实现呢？让你的订单处理服务依赖于一个邮件服务，然后调用sendEmail()方法，而不是sendToMQ()方法。如果你使用了消息队列，你需要定义一个两个系统都能识别的消息格式 ；如果你不使用消息队列，那么你得定义一个方法签名。它们有什么本质的区别吗？其实没有。</p><p>不过你可能还有别的消费者想要对某个指定的消息进行额外的处理？这的确是可能发生的，而并不只是针对我们这里说到的这个项目而已。尽管确有可能，但相比添加另一个方法调用而言，它可能并不值当。耦合？是的。不过这个耦合并没有什么不方便的。</p><p>那我应该如何处理峰值流量？你可以通过消息队列将请求放到一个持久化队列中，然后再一并处理它们。这是一个非常有用的特性，不过它也受限于几个 因素——你的请求是在UI后台处理，还是需要即时响应？serlvet容器的线程池某种程度上可以当作是一个队列，用户最终会拿到响应，但是得需要等待（如果线程的超时时间过短的话，请求可能会丢失）。</p><p>你可以使用一个内存队列来存储那些较重的请求（得在UI后台进行处理）。不过注意了，你的队列并不是默认高可用的。比如说，如果一个消息队列节点挂掉了，你的消息就丢失了。因此，不去使用应用节点内的内存队列，而是去使用一个消息队列，这可能并没有什么优势。</p><p>消息队列使得我们可以进行异步处理——这的确是个有用的特性。你不希望在用户等待的时候做一些很重的操作。不过你也可以使用一个内存队列，或者简单地启动一个新的线程（比如Spring的@Async注解）。这样又有另一个问题——如果消息丢失的话是否有问题？如果你应用处理请求的节点挂了，你可以进行恢复吗？你会发现这事会经常发生，如果不保证所有消息都处理到的话，很难保证功能的正确性。因此，仅将较重的调用进行异步处理是比较可取的。</p><p>把消息放到队列以便让另一个组件来进行处理，对于这个场景，如果消息丢失是无法接受的 ，这也有一个很简单的解决方案——数据库。你可以把一条processed=false的数据存储到数据库中。然后再运行一个调度作业，将所有未处理的记录挑选出来，异步地进行处理。当处理完成的时候，将标记设为true。我经常用这个方法，包括在一些大型的线上系统中，它也工作得挺好的。</p><p>这样你还能不断地对你的应用节点进行扩展，只要它们的内存中没有任何的持久化状态的话。不管你是否使用了消息队列都可以（临时的内存处理队列并不属于持久化状态）。</p><p>为什么我要给经常用到的消息队列提供一些备选方案？因为如果你由于不恰当的原因选择了它，那么消息队列可能会成为一个负担。它们并非如想像中那样容易使用。首先，它有一个学习曲线。一般来说，你集成的组件切分得越多，就越容易出现问题。其次，还有一个设置及配置的成本。比如说，当消息队列需要在一个集群中运行的话，比如说多个数据中心，那么这就变得复杂了。</p><p>高可用性并不是上来就有的——默认它是不会打开的。还有就是你的应用节点如何连接到消息队列？通过一个刷新的连接池，或者使用短生命周期的DNS记录，还是通过一个负载均衡器？你的队列可能还有许多配置项，大小是多少，行为是怎样的（消费者需不需要确认接受，要不要通知处理失败，多个消费者能够取到同一个消息吗，消息有没有TTL，等等）同时还有网络及消息传递的开销，尤其是现在大家都喜欢用XML或者JSON来传输消息。如果你过度地使用了消息队列，那么它会增加你系统的延时。</p><p>最后一点，但并不是最次要的——如果出现问题的话，使用消息队列会让问题跟踪变得异常困难。你没法在IDE中看到所谓的调用层次，因为一旦你发送消息到队列里了，你就得自己去查找它在哪里处理的了。这可不是听起来那么简单的。你看到了吧，它会给你增加许多的复杂性，以及许多需要注意的东西。</p><p>通常而言，在某些上下文中，消息队列还是非常有用的。当它们的确适合的话，我也会在项目中使用它们——比方说，我们不想丢失消息，但又希望能快速地进行处理。我也见过它在一些不太常见的场景中使用的情况，比如说只有一个应用节点来进行消费，不管是哪个节点投递过来的消息。你还可以看下stackoverflow上的这个问题。还有一些使用场景就是，或许你的确需要进行多语言间的通信，又或者你的数据流已经过于复杂了，不使用新的消息消费者而是增加新方法调用的话代价会很大。</p><p>我想说的是那句老掉牙的真理“杀鸡焉用牛刀”。如果你不是很确定已经没有别的更容易管理和维护的方法，一定要使用消息队列的话，最好不要使用它。不要因为”万一它有用呢“而去用它——只有你确实觉得需要的话再去使用。因为很有可能，就像这里说到的这个项目一样，消息队列其实是没有必要的。</p><h3><span id="62如何避免消息丢失">6.2如何避免消息丢失</span></h3><p>选择能够支持消息持久化的MQ方案。如：ActiveMQ、RabbitMQ等，给消息一个处理状态如：process=false。</p><p>还可以使用缓存方案做：如Redis，它本身也是支持持久化的。</p><h2><span id="7本文参考资料来源">7.本文参考资料来源</span></h2><ul><li>消息队列MQ的原理及实现方法：<a href="http://blog.csdn.net/lzq_csdn_th/article/details/51945408" target="_blank" rel="noopener">http://blog.csdn.net/lzq_csdn_th/article/details/51945408</a></li><li>关于消息队列的使用：<a href="http://www.cnblogs.com/linjiqin/p/5720865.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/5720865.html</a></li><li>消息队列使用的四种场景介绍：<a href="http://blog.csdn.net/cws1214/article/details/52922267" target="_blank" rel="noopener">http://blog.csdn.net/cws1214/article/details/52922267</a></li><li>使用消息队列的十个理由：<a href="http://www.oschina.net/translate/top-10-uses-for-message-queue?p=2" target="_blank" rel="noopener">http://www.oschina.net/translate/top-10-uses-for-message-queue?p=2</a></li><li>国外的一款消息队列IronMQ：<a href="http://iron.io/products/mq?rc=blog_mq_t10" target="_blank" rel="noopener">http://iron.io/products/mq?rc=blog_mq_t10</a></li><li>你可能并不需要消息队列：<a href="http://kb.cnblogs.com/page/212710/" target="_blank" rel="noopener">http://kb.cnblogs.com/page/212710/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解java泛型</title>
      <link href="/article/Generics/"/>
      <url>/article/Generics/</url>
      
        <content type="html"><![CDATA[<h2><span id="泛型是什么">泛型是什么</span></h2><p>一说到泛型，大伙肯定不会陌生，我们代码里面有很多类似这样的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;T&gt;</span><br></pre></td></tr></table></figure><p>ArrayList就是个泛型类，我们通过设定不同的类型，可以往集合里面存储不同类型的数据类型（而且只能存储设定的数据类型，这是泛型的优势之一）。“泛型”简单的意思就是泛指的类型（参数化类型）。想象下这样的场景：如果我们现在要写一个容器类（支持数据增删查询的），我们写了支持String类型的，后面还需要写支持Integer类型的。然后呢？Doubel、Float、各种自定义类型？这样重复代码太多了，而且这些容器的算法都是一致的。我们可以通过泛指一种类型T,来代替我们之前需要的所有类型，把我们需要的类型作为参数传递到容器里面，这样我们算法只需要写一套就可以适应所有的类型。最典型的的例子就是ArrayList了，这个集合我们无论传递什么数据类型，它都能很好的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    elements[size++]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码灵活性很高，所有的类型都可以向上转型为Object类，这样我们就可以往里面存储各种类型的数据了。的确Java在泛型出现之前，也是这么做的。但是这样的有一个问题：如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。例如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyList myList=<span class="keyword">new</span> MyList();</span><br><span class="line">myList.add(<span class="string">"A"</span>);</span><br><span class="line">myList.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));</span><br><span class="line">System.out.println((String)myList.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>我们在这个集合里面存储了多个类型（某些情况下容器可能会存储多种类型的数据），如果数据量较多，转型的时候难免会出现异常，而这些都是无法在编译期得知的。而泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。</p><h2><span id="java泛型介绍">Java泛型介绍</span></h2><p>下面我们来介绍Java泛型的相关内容，下面会介绍以下几个方面：</p><ul><li>Java泛型类</li><li>Java泛型方法</li><li>Java泛型接口</li><li>Java泛型擦除及其相关内容</li><li>Java泛型通配符</li></ul><h3><span id="java泛型类">Java泛型类</span></h3><p>类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于&lt;K,V&gt;,&lt;T,E,K&gt;等。这样我们就可以在类里面使用定义的类型参数。<br>泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了</p><h3><span id="java泛型方法">Java泛型方法</span></h3><p>前面我们介绍的泛型是作用于整个类的，现在我们来介绍泛型方法。泛型方法既可以存在于泛型类中，也可以存在于普通的类中。<font color="red">如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。</font>下面我们通过例子来看一下泛型方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getData</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 泛型方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">PrinterInfo</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataHolder&lt;String&gt; dataHolder=<span class="keyword">new</span> DataHolder&lt;&gt;();</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">1</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="string">"AAAAA"</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">8.88f</span>);</span><br></pre></td></tr></table></figure><p>我们来看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">AAAAA</span><br><span class="line">8.88</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们看到我们是在一个泛型类里面定义了一个泛型方法printInfo。通过传入不同的数据类型，我们都可以打印出来。在这个方法里面，我们定义了类型参数E。这个E和泛型类里面的T两者之间是没有关系的。</p><p>这个泛型方法依然可以传入Double、Float等类型的数据。泛型方法里面的类型参数T和泛型类里面的类型参数是不一样的类型，从上面的调用方式，我们也可以看出，泛型方法printInfo不受我们DataHolder中泛型类型参数是String的影响。<br>我们来总结下泛型方法的几个基本特征：</p><ul><li>public与返回值中间非常重要，可以理解为声明此方法为泛型方法。</li><li>只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li><li>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</li><li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</li></ul><h3><span id="java泛型接口">Java泛型接口</span></h3><p>Java泛型接口的定义和Java泛型类基本相同，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处有两点需要注意：</p><ul><li>泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    即：class DataHolder implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment">    * 如果不声明泛型，如：class DataHolder implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子我们看到，实现类里面的所有T的地方都需要实现为String。</p><h3><span id="java泛型擦除及其相关内容">Java泛型擦除及其相关内容</span></h3><p>我们下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class1.equals(class2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。我们来看一个更彻底的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">House</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用代码及输出</span></span><br><span class="line">    List&lt;Table&gt; tableList = <span class="keyword">new</span> ArrayList&lt;Table&gt;();</span><br><span class="line">    Map&lt;Room, Table&gt; maps = <span class="keyword">new</span> HashMap&lt;Room, Table&gt;();</span><br><span class="line">    House&lt;Room&gt; house = <span class="keyword">new</span> House&lt;Room&gt;();</span><br><span class="line">    Particle&lt;Long, Double&gt; particle = <span class="keyword">new</span> Particle&lt;Long, Double&gt;();</span><br><span class="line">    System.out.println(Arrays.toString(tableList.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(maps.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(house.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(particle.getClass().getTypeParameters()));</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K, V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION, MOMENTUM]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面的代码里，我们想在运行时获取类的类型参数，但是我们看到返回的都是“形参”。在运行期我们是获取不到任何已经声明的类型信息的。</p><p><font color="red">注意： 编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。<br></font></p><p>泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。下面的例子中，可以把泛型参数T当作HasF类型来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到HasF类型。</p><h4><span id="java泛型擦除的原理">Java泛型擦除的原理</span></h4><p>我们通过例子来看一下，先看一个非泛型的版本：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SimpleHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class SimpleHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们给出一个泛型的版本，从字节码的角度来看看:</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//GenericHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; holder = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenericHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T obj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class GenericHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译过程中，类型变量的信息是能拿到的。所以，set方法在编译器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用类型为Object类型。<font color="red">为了“还原”返回结果的类型，编译器在get之后添加了类型转换。所以，在GenericHolder.class文件main方法主体第18行有一处类型转换的逻辑。它是编译器自动帮我们加进去的。</font></p><p>所以在泛型类对象读取和写入的位置为我们做了处理，为代码添加约束。</p><h4><span id="java泛型擦除的缺陷及补救措施">Java泛型擦除的缺陷及补救措施</span></h4><p>泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = (T) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们有什么办法来补救呢？下面介绍几种方法来一一解决上面出现的问题。</p><h5><span id="类型判断问题">类型判断问题</span></h5><p>我们可以通过下面的代码来解决泛型的类型信息由于擦除无法进行类型判断的问题：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类型判断封装类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        classType=type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classType.isInstance(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法我们可以这样调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericType&lt;A&gt; genericType=new GenericType&lt;&gt;(A.class);</span><br><span class="line">System.out.println(&quot;------------&quot;);</span><br><span class="line">System.out.println(genericType.isInstance(new A()));</span><br><span class="line">System.out.println(genericType.isInstance(new B()));</span><br></pre></td></tr></table></figure><p>我们通过记录类型参数的Class对象，然后通过这个Class对象进行类型判断。</p><h5><span id="创建类型实例">创建类型实例</span></h5><p>泛型代码中不能new T()的原因有两个，一是因为擦除，不能确定类型；而是无法确定T是否包含无参构造函数。为了避免这两个问题，我们使用显式的工厂模式：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法来创建实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creater</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    instance=f.create();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer integer=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过工厂模式+泛型方法来创建实例对象，上面代码中我们创建了一个IntegerFactory工厂，用来创建Integer实例，以后代码有变动的话，我们可以添加新的工厂类型即可。<br>调用代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creater&lt;Integer&gt; creater=new Creater&lt;&gt;();</span><br><span class="line">System.out.println(creater.newInstance(new IntegerFactory()));</span><br></pre></td></tr></table></figure><h5><span id="创建泛型数组">创建泛型数组</span></h5><p>一般不建议创建泛型数组。尽量使用ArrayList来代替泛型数组。但是在这里还是给出一种创建泛型数组的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用的还是传参数类型，利用类型的newInstance方法创建实例的方式。</p><h3><span id="java泛型的通配符">Java泛型的通配符</span></h3><h4><span id="上界通配符lt-extends-tgt">上界通配符&lt;? extends T&gt;</span></h4><p>我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们定义一个盘子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们定义一个水果盘子，理论上水果盘子里，当然可以存在苹果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>你会发现这段代码无法进行编译。装苹果的盘子”无法转换成“装水果的盘子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert from Plate&lt;Apple&gt; to Plate&lt;Fruit&gt;</span><br></pre></td></tr></table></figure><p>从上面代码我们知道，就算容器中的类型之间存在继承关系，但是Plate和Plate两个容器之间是不存在继承关系的。 在这种情况下，Java就设计成Plate&lt;? extend Fruit&gt;来让两个容器之间存在继承关系。我们上面的代码就可以进行赋值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());</span><br></pre></td></tr></table></figure><pre><code>我们通过一个更加详细的例子来看一下上界的界限：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面这个类层次中，Plate&lt;? extend Fruit&gt;，覆盖下面的蓝色部分：</p><p><img src="/article/Generics/1554717847002Generics_.png" alt></p><p>如果我们往盘子里面添加数据，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.set(new Fruit());</span><br><span class="line">p.set(new Apple());</span><br></pre></td></tr></table></figure><p>你会发现无法往里面设置数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。<font color="red">&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效</font><br>原因是：</p><p>Java编译期只知道容器里面存放的是Fruit和它的派生类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。<br>但是上界通配符是允许读取操作的。例如代码：</p><p>但是上界通配符是允许读取操作的。例如代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit fruit=p.get();</span><br><span class="line">Object object=p.get();</span><br></pre></td></tr></table></figure><p>这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其派生类，那么获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。</p><h4><span id="下界通配符lt-super-tgt">下界通配符&lt;? super T&gt;</span></h4><p>下界通配符的意思是容器中只能存放T及其T的基类类型的数据。我们还是以上面类层次的来看，&lt;? super Fruit&gt;覆盖下面的红色部分：</p><p><img src="/article/Generics/1554718229543Generics_.png" alt></p><p>原因是：</p><p>下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。</p><h4><span id="pecs原则">PECS原则</span></h4><p>最后简单介绍下Effective Java这本书里面介绍的PECS原则。<br><font color="red"></font><br><font color="red"><br></font></p><p><font color="red">*   上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</font></p><p>*   <font color="red">下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。<br></font></p><h4><span id="ltgt无限通配符">&lt;?&gt;无限通配符</span></h4><p>无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。但它是有作用的，原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List类型的引用中，不能向其中添加Object, 而List类型的引用就可以添加Object类型的变量。</p><font color="red">最后提醒一下的就是，List与List并不等同，List是List的子类。还有不能往List&lt;?&gt; list里添加任意对象，除了null。</font><font color="red"></font>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 替换PermGem 为 Meta Space</title>
      <link href="/article/java-meta-space-instand-of-perm-space/"/>
      <url>/article/java-meta-space-instand-of-perm-space/</url>
      
        <content type="html"><![CDATA[<h2><span id="背景">背景</span></h2><p><a target="_blank"></a></p><h3><span id="永久代permgen在哪里">永久代（PermGen）在哪里？</span></h3><p>根据，hotspot jvm结构如下(虚拟机栈和本地方法栈合一起了)：</p><p><img src="/article/java-meta-space-instand-of-perm-space/1553223919610java-meta-space-instand-of-perm-space_.png" alt></p><p><span style="color:#ff0000;">上图引自网络，但有个问题：方法区和heap堆都是线程共享的内存区域。</span></p><p><strong><span style="color:#ff0000;">关于方法区和永久代：</span></strong></p><p>在HotSpot JVM中，这次讨论的**<span style="color:#ff0000;">永久代</span>**，就是上图的方法区（JVM规范中称为方法区）。<a href="https://www.baidu.com/s?wd=%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《Java虚拟机规范》</a>只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。</p><h3><span id="jdk8永久代的废弃">JDK8永久代的废弃</span></h3><p>JDK8 永久代变化如下图：</p><p><img src="/article/java-meta-space-instand-of-perm-space/1553223971295java-meta-space-instand-of-perm-space_.png" alt></p><ol><li><p><a href="https://www.baidu.com/s?wd=%E6%96%B0%E7%94%9F%E4%BB%A3&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新生代</a>：Eden+From Survivor+To Survivor</p></li><li><p>老年代：OldGen</p></li><li><p><span style="color:#ff0000;">永久代（方法区的实现） : PermGen-----&gt;替换为Metaspace(本地内存中)</span></p></li></ol><p> </p><p>###二、为什么废弃永久代（PermGen）</p><h3><span id="官方说明">官方说明</span></h3><p>参照JEP122：<a href="http://openjdk.java.net/jeps/122%EF%BC%8C%E5%8E%9F%E6%96%87%E6%88%AA%E5%8F%96%EF%BC%9A" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122，原文截取：</a></p><h2><span id="motivation">Motivation</span></h2><blockquote><p>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p></blockquote><blockquote><p> 即：<span style="color:#ff0000;">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</span><br><a target="_blank"></a></p></blockquote><h3><span id="现实使用中易出问题">现实使用中易出问题</span></h3><p>由于永久代内存经常不够用或发生内存泄露，爆出异常_java.lang.OutOfMemoryError: PermGen_</p><p>##三、深入理解元空间（Metaspace）</p><h3><span id="元空间的内存大小">元空间的内存大小</span></h3><p>元空间是方法区的在HotSpot jvm 中的实现，<span style="color:#000000;">方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 </span></p><p><span style="color:#ff0000;">元空间的本质和永久代类似，都是对JVM规范中方法区的实现</span>。<span style="font-size:12px;"><span style="color:#333333;">不过**<span style="color:#ff0000;">元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</span>**</span></span>，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。<br><a target="_blank"></a></p><h3><span id="常用配置参数">常用配置参数</span></h3><ol><li>MetaspaceSize</li></ol><blockquote><p>初始化的Metaspace大小，<span style="color:#ff0000;">控制元空间发生GC的阈值</span>。GC后，动态增加或降低<span style="color:#ff0000;">MetaspaceSize</span>。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用<a href="http://lib.csdn.net/base/javase" title="Java SE知识库" target="_blank" rel="noopener">Java</a> -XX:+PrintFlagsInitial命令查看本机的初始化参数</p></blockquote><ol start="2"><li><span style="color:#ff0000;">MaxMetaspaceSize</span></li></ol><blockquote><p>限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。</p></blockquote><ol start="3"><li><span style="color:#ff0000;">MinMetaspaceFreeRatio</span></li></ol><blockquote><p>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。</p></blockquote><ol start="4"><li><span style="color:#ff0000;">MaxMetasaceFreeRatio</span></li></ol><blockquote><p>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。</p></blockquote><ol start="5"><li>MaxMetaspaceExpansion</li></ol><blockquote><p>Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。</p></blockquote><ol start="6"><li>MinMetaspaceExpansion</li></ol><blockquote><p>Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。</p></blockquote><h3><span id="元空间的另一个优势">元空间的另一个优势</span></h3><ul><li><p>共享元空间</p><p>HotSpot的永久代：原来的jar包及你自己项目的class存放的内存空间，这部分空间是固定的，启动参数里面permSize确定，如果你的jar包很多，经常会遇到永久代溢出，且每个项目都会占用自己的permGen空间，改成用元空间后，各个项目会共享同样的class内存空间。</p></li><li><p>提高GC的性能</p><ul><li>Full GC中，元数据指向元数据的那些指针都不用再扫描了。很多复杂的元数据扫描的代码（尤其是CMS里面的那些）都删除了。</li><li>元空间只有少量的指针指向Java堆。这包括：类的元数据中指向java/lang/Class实例的指针;数组类的元数据中，指向java/lang/Class集合的指针。</li><li>没有元数据压缩的开销</li><li>减少了根对象的扫描（不再扫描虚拟机里面的已加载类的字典以及其它的内部哈希表）减少了Full GC的时间</li><li>G1回收器中，并发标记阶段完成后可以进行类的卸载</li><li></li></ul></li></ul><h2><span id="四-总结">四 总结</span></h2><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/article/my_blog_begin/"/>
      <url>/article/my_blog_begin/</url>
      
        <content type="html"><![CDATA[<h2><span id="hexo">Hexo</span></h2><hr><p>Hexo被称为是最佳的静态博客程序之一，然而其繁琐的环境搭建、构建，发布过程，让很多人望之却步.转而使用了传统的WordPress等博客程序，抛开维护成本不说，本着折腾一切的心态<br>最终研究出了一套完善的自动部署方案。</p><h2><span id="如何实现优雅的发布">如何实现优雅的发布</span></h2><hr><p>就目前而言，Hexo发布的方式有以下几种：</p><ul><li>原始方式，即在本地搭建相关环境，编写md文件后，手动hexo g生成静态文件，然后通过hexo deploy发布到Github Pages；</li><li>利用Github + Webhook来实现自动发布</li><li>使用第三方的Hexo-Client、Hexo-Admin等程序<br>使用Travis CI持续部署Hexo。</li><li>使用Netlify进行优雅地持续部署。详见：<a href="https://www.netlify.com" target="_blank" rel="noopener">https://www.netlify.com</a></li></ul><h2><span id="我的部署方案">我的部署方案</span></h2><hr><p>我的部署方案主要是基于第三种的。</p><ul><li><p>简要流程</p><ol><li>使用Github登陆Netlify。</li><li>使用StaticGen一键初始化Hexo仓库。</li><li>将Hexo源码仓库Clone到本地，调整网站配置，编写文章。</li><li>本地无需Nodejs、NPM、Hexo环境，修改完成后Push到Github，Netlify检测到仓库变更后实现自动部署。</li></ol><p>在Netlify整个部署过程中, 你只需要提交代码, 其余的master部署预览(包括MR的预览), HTTPS证书, 静态资源的优化与CDN加速, 部署消息通知。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(7)</title>
      <link href="/article/java-gc1-gc/"/>
      <url>/article/java-gc1-gc/</url>
      
        <content type="html"><![CDATA[<h2><span id="g1-概要">G1 概要</span></h2><h3><span id="g1-的特点">G1 的特点</span></h3><h4><span id="garbage-first">Garbage First</span></h4><p>G1的设计原则是&quot;首先收集尽可能多的垃圾(Garbage First)&quot;。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</p><h4><span id="空间整理">空间整理</span></h4><p>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</p><h4><span id="动态扩展空间">动态扩展空间</span></h4><p>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</p><h4><span id="局部回收">局部回收</span></h4><p>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p><h3><span id="g1-内存模型">G1 内存模型</span></h3><h4><span id="region-分区">Region (分区)</span></h4><p><img src="/article/java-gc1-gc/1556095002973java-gc1-gc_.png" alt></p><p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p><p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p><h4><span id="card-table">Card Table</span></h4><p>为了支持高频率的新生代的回收，虚拟机使用一种叫做卡表（Card Table）的数据结构，卡表作为一个比特位的集合，每一个比特位可以用来表示某一区域中的所有对象是否持有新生代对象的引用。</p><p>在每个Region内部又被分成了若干个大小为512 Byte卡片(Card Page)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p><p>基于卡表（Card Table）的设计，通常将堆空间划分为一系列2次幂大小的卡页（Card Page）。</p><p>首先，计算对象引用所在卡页的卡表索引号。将地址右移9位，相当于用地址除以512（2的9次方）。可以这么理解，假设卡表卡页的起始地址为0，那么卡表项0、1、2对应的卡页起始地址分别为0、512、1024（卡表项索引号乘以卡页512字节）。</p><p>其次，通过卡表索引号，设置对应卡标识为dirty。</p><p><img src="/article/java-gc1-gc/1556097761564java-gc1-gc_.png" alt></p><h4><span id="remember-set-rset">Remember Set (RSet)</span></h4><p>我们知道判断对象是否存活需要从GC ROOTS结点出发，从GC ROOTS结点可达的对象就是存活的。在YGC时，老年代中的对象是不回收的，也就意味着GC ROOTS里面应包含了老年代中的对象。但扫描整个老年代会很耗费时间，势必影响整个GC的性能！。所以在CMS中使用了Card Table的结构，里面记录了老年代对象到新生代引用。Card Table的结构是一个连续的byte[]数组，扫描Card Table的时间比扫描整个老年代的代价要小很多！</p><p>G1也参照了这个思路，不过采用了一种新的数据结构 Remembered Set 简称Rset。RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。每个Region都有一个对应的Rset。</p><p><img src="/article/java-gc1-gc/1556095318179java-gc1-gc_.png" alt></p><h4><span id="per-region-table">Per Region Table</span></h4><p>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常&quot;受欢迎&quot;，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p><ul><li>稀少：直接记录引用对象的卡片索引</li><li>细粒度：记录引用对象的分区索引</li><li>粗粒度：只记录引用情况，每个分区对应一个比特位</li></ul><p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p><h4><span id="humongous-region-大对象区间">Humongous Region (大对象区间)</span></h4><p>正因为无论是 Young Generation 还是 Old Generation，在 GC 的时候都会有 object 拷贝。Young Generation 一方面是将 object 从 Eden 拷贝到 Survivor ，另一方面是拷贝晋升的 object 到 Old 区。这种拷贝过程对特别大的 object 来说就很不经济。</p><p>G1 中 Region 大小最小是 1MB，最大是 32MB。具体多大会根据 Heap 大小做设置，它是尽力去保证整个 Heap 被划分为大约 2048 个 Region。比如如果 Heap 有 16G，算下来 16G / 2048 = 8MB 即一个 Region 大概是 8MB。当然 2048 个 Region 也不是绝对的，如果 Heap 特别大或者特别小，Region 总数是可以超过或小于 2048。Region 总数也能通过参数精确设置 <code>-XX:G1HeapRegionSize=n</code>。</p><p>回到 Humongous Object，G1 中内存占用超过当前单个 Region 50% 的 Object 就叫 Humongous Object，G1 对他们有单独的处理。</p><p>Humongous Object 分配时会根据这个 object 大小，在 available regions 中找足够放下这个 object 的连续的数个 region，专门分配给这个 Humongous object 使用。如果找不到这么个连续的 region，G1 会直接使用 fail-safe 的 FGC 来清理并 compact heap。</p><p>理解这里不先进行 YGC 或 OGC 的原因是 YGC 和 OGC 很多过程都是 concurrent 的，这个时候 Humongous Object 无法分配内存，无法让应用线程继续运行，必须执行完全的 STW 收集一次内存才行。</p><p>正因为无论是 Young Generation 还是 Old Generation，在 GC 的时候都会有 object 拷贝。Young Generation 一方面是将 object 从 Eden 拷贝到 Survivor ，另一方面是拷贝晋升的 object 到 Old 区。这种拷贝过程对特别大的 object 来说就很不经济。</p><p>G1 中 Region 大小最小是 1MB，最大是 32MB。具体多大会根据 Heap 大小做设置，它是尽力去保证整个 Heap 被划分为大约 2048 个 Region。比如如果 Heap 有 16G，算下来 16G / 2048 = 8MB 即一个 Region 大概是 8MB。当然 2048 个 Region 也不是绝对的，如果 Heap 特别大或者特别小，Region 总数是可以超过或小于 2048。Region 总数也能通过参数精确设置 -XX:G1HeapRegionSize=n。</p><p>回到 Humongous Object，G1 中内存占用超过当前单个 Region 50% 的 Object 就叫 Humongous Object，G1 对他们有单独的处理。</p><p>Humongous Object 分配时会根据这个 object 大小，在 available regions 中找足够放下这个 object 的连续的数个 region，专门分配给这个 Humongous object 使用。如果找不到这么个连续的 region，G1 会直接使用 fail-safe 的 FGC 来清理并 compact heap。</p><p>理解这里不先进行 YGC 或 OGC 的原因是 YGC 和 OGC 很多过程都是 concurrent 的，这个时候 Humongous Object 无法分配内存，无法让应用线程继续运行，必须执行完全的 STW 收集一次内存才行。</p><h2><span id="g1-回收过程">G1 回收过程</span></h2><h3><span id="g1-收集的四个过程">G1 收集的四个过程</span></h3><ol><li>年轻代收集</li><li>并发收集，和应用线程同时执行</li><li>混合式垃圾收集</li><li>必要时的 Full GC</li></ol><h4><span id="young-gc年轻代收集">Young GC（年轻代收集）</span></h4><p>年轻代是由Eden和Survivor两个区间组成的，那么当Eden区间无法在分配空间时，Young GC被触发了。GC需要把所有的存活对象从Eden区间移动到Survivor区间(拷贝算法),原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中,从而晋级到新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉，被放入空闲队列当中去</p><p>在每一次年轻代回收暂停期间，G1 GC计算当前年轻代大小需要扩展或者压缩的总量，例如增加或者删除空闲区间、统计RSet大小、当前最大可用年轻代、当前最小可用年轻代、设置停顿目标等。因此，我们可以认为这个过程在回收停顿结束后是一个重新调整年轻代的过程。可以通过<code>-XX:+PrintGCDetails</code>选项的运行来查看具体数据。</p><p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量<code>-XX:TargetSurvivorRatio</code>(默认50%)、最大任期阈值<code>-XX:MaxTenuringThreshold</code>(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p><h4><span id="concurrent-mark-start-并发收集阶段">concurrent-mark-start （并发收集阶段）</span></h4><p>这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p><ul><li><p>并发标记触发条件</p><ul><li>整个堆的使用率达到了阈值 （IHOP：<code>InitiatingHeapOccupancyPercent</code>).</li><li>晋升空间（old regions）达到阈值（<code>G1ReservePercent</code>）</li><li>大对象的分配</li></ul></li><li><p>并发标记的过程</p><ul><li><p>Initial Mark 初始标记</p><p>负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要STW。<br>事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p></li><li><p>Root Region Scanning 根区域扫描<br>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p></li><li><p>Concurrent Marking 并发标记<br>并发标记依赖于 <a href>STAB</a><br>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p></li><li><p>重新标记（remark eq final mark）</p><p>重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数<code>-XX:ParallelGCThread</code>可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p></li><li><p>清理阶段（clean up）</p><p>紧挨着重新标记阶段的清除(Clean)阶段也是STW的。清理阶段真正回收的内存很小，截止到这个阶段,G1垃圾收集器主要是标记处哪些老年代分区可以回收，将老年代按照它们的存活度（liveness）从小到大排列。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p><p>1、RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数<code>-XX:+PrintAdaptiveSizePolicy</code>可以开启打印启发式算法决策细节；</p><p>2、整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</p><p>3、识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</p></li></ul></li></ul><p>经过global concurrent marking，collector就知道哪些Region有存活的对象。并将那些完全可回收的Region(没有存活对象)收集起来加入到可分配Region队列，实现对该部分内存的回收。对于有存活对象的Region，G1会根据统计模型找处收益最高、开销不超过用户指定的上限的若干Region进行对象回收。这些选中被回收的Region组成的集合就叫做collection set 简称Cset！</p><p>在MIXGC中的Cset是选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。</p><p>在YGC中的Cset是选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。</p><p>YGC与MIXGC都是采用多线程复制清除，整个过程会STW。 G1的低延迟原理在于其回收的区域变得精确并且范围变小了。</p><h4><span id="mixed-gc">Mixed GC</span></h4><ul><li>Mixed GC 何时触发<br>remark 阶段完毕后，G1 就完成了对整个 heap 的标记，能知道整个 heap 中有哪些 object 是 live 的。在接下来的几次 YGC 中，会从待收集的所有 Region 中依次选出 GC 效率最高的 Region 组成本次回收的 CSet，来执行 GC，也即 Mixed GC. “GC 效率最高” 一般是有两个指标，一个是 Region 内 live object 多少，live object 占空间最少的 Region，GC 效率越高。即 Garbage 越多的 Region，GC 效率越高。这也是 Garbage First 的由来。 下图是一个mixed gc 的时序图</li></ul><p><img src="/article/java-gc1-gc/1557030961130java-gc1-gc_.png" alt></p><h4><span id="full-gc">FULL GC</span></h4><p>转移失败的担保机制 Full GC</p><p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p><p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p><p>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区<br>从老年代分区转移存活对象时，无法找到可用的空闲分区<br>分配巨型对象时在老年代无法找到足够的连续分区<br>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p><h2><span id="参考">参考:</span></h2><p><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://zhuanlan.zhihu.com/p/52841787" target="_blank" rel="noopener">G1 收集器原理理解与分析</a></p><p>G1读书笔记<br>g1 的四个阶段</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(3)</title>
      <link href="/article/Java-garbage-collection-analysis-3/"/>
      <url>/article/Java-garbage-collection-analysis-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一篇介绍了GC的各种垃圾收集器的算法，本节详细讨论几个细节问题。</p><h2><span id="gc-roots详解">GC Roots详解</span></h2><p>GC ROOTs包含了那些对象</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI （即 native 方法）引用的对象。</li><li>分代回收算法中非当前GC年代的其他对象。</li></ol><h2><span id="如何识别垃圾对象">如何识别“垃圾对象”？</span></h2><h3><span id="为什么需要引用">为什么需要引用？</span></h3><p>如前所述：在最早的JVM实现里，使用“跟踪回收”算法从GC ROOTS出发，按照广度或者深度方式遍历所有与GC ROOTS可达的对象，针对那些GC不可达的垃圾对象进行回收。但随着Java的演进，针对最早这种比较简单的GC方式逐渐暴露出一些不能覆盖的情景，比如：某些场景下使用方希望在回收具体对象的同时还能辅助回收这个对象绑定的一些资源（比如socket、堆外内存等）、某些场景下希望使用的堆内缓存组件能尽量缓存更多的数据但又不会导致OOM。考虑到上述类似的使用场景，从JDK 1.2开始，JDK引入了<code>软引用（SoftReference）、弱引用（WeakReference）、幻象引用（PhantomReference）、Final引用（FinalReference</code>）四种新的引用来支持一些新的特性。</p><p>对象创建时，可以通过不同的引用来对对象进行封装，GC时，当真正的业务对象除了这个引用外没有其他GC ROOTS可达的时候，JVM会根据引用类型和GC类型（是否是Full GC）来对这个“真实对象”进行一些特殊处理，<br>比如：回收这个对象绑定的其他资源、比如根据GC类型来觉得是否本次要把对象进行回收等。</p><p><img src="https://coldwalker.com/images/gc_intro/1119937-20190130111221088-1473128563.png" alt="a5b1bd167692a29a29d2e09a75211e0c.png"></p><h3><span id="gc如何识别和处理引用">GC如何识别和处理引用？</span></h3><p>“真实对象”创建时，可以通过Reference来对“真实对象”进行封装引用，然后通过一些方法保证这个引用GC ROOTS可达（比如封装完“真实对象”后将这个引用加入到一个静态链表中），JVM垃圾回收器硬编码识别</p><ul><li>SoftReference，</li><li>WeakReference，</li><li>PhantomReference，</li><li>Final引用（FinalReference）</li></ul><p>这些具体的类，GC过程中，识别查找到引用对象没有被其他强引用使用的Reference，然后添加到Reference类的pending链表，这个pending链表由GC来维护，通过Reference类的一个静态的pending变量（链表头）和一个实例变量discovered（链表下一节点）来实现；Reference有一个高优先级的ReferenceHandler线程，这个线程不停的从pending链表中取出待处理的Reference进行处理：有的放到Reference各自的ReferenceQueue队列里供使用者进行处理（如：PhantomReference和WeakReference）、有的直接调用固定的处理方法进行清理（如：Cleaner）。</p><h3><span id="reference类">Reference类：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T referent; <span class="comment">// 引用所指向的真实对象</span></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue; <span class="comment">//引用处理列表</span></span><br><span class="line">    <span class="comment">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">    *     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">    *   otherwise:   NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM ，指向pending链表下一个节点</span></span><br><span class="line"><span class="comment">    * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment">    * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment">    * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;  <span class="comment">//静态的链表头</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">            <span class="comment">// so that we don't get into trouble later in the run loop if there's</span></span><br><span class="line">            <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">            ensureClassInitialized(InterruptedException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//死循环执行</span></span><br><span class="line">                tryHandlePending(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">        Reference&lt;Object&gt; r;</span><br><span class="line">        Cleaner c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span><br><span class="line">                    <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span><br><span class="line">                    c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                    <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                    <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// retry if waited</span></span><br><span class="line">                    <span class="keyword">return</span> waitForNotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">            <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">            <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">            <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span><br><span class="line">            <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fast path for cleaners</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.clean();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类加载完就起好最高优先级的ReferenceHandler</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">            tgn != <span class="keyword">null</span>;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">        Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">        <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">        * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceQueue可以由使用方通过Reference的构造方法指定传入，如果没有指定，从pending链表取出的Reference都enqueue到全局的一个ENQUEUED队列中。ReferenceQueue的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new reference-object queue.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceQueue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends S&gt; r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> Null&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> Null&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">            <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">            head = r;</span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="引用种类">引用种类</span></h3><h4><span id="强引用">强引用</span></h4><p>最常见的引用方式。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>上面的obj就是一个指向Object对象的强引用<br>强引用如果有到GC ROOTS的路径，那么这个引用指向的对象在GC时不能被回收。</p><blockquote><p>在实际使用中，除了强引用，可能还需要一些其他特殊类型的引用，比如有些缓存对象，是可以在内存不足时来回收的，这样通过丰富的引用类型，能让内存在实际使用时更灵活，整体业务稳定性更好。jdk 1.2后，对引用概念进行了扩充，增加了其他4种类型的引用，在java.lang.ref包下，分别为：<code>SoftReference、WeakReference、PhantomReference、FinalReference</code>。</p></blockquote><h4><span id="软引用softreference">软引用（SoftReference）</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; str = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>软引用是比强引用稍弱的一种引用，普通的GC并不会回收软引用，只有在即将OOM的时候（也就是最后一次Full GC）的时候才会回收软引用指向的对象。所以，软引用比较适合用来实现不是特别重要的缓存，比如guava cache就支持软引用类型的存储值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果只是普通增量GC，不回收软引用</span></span><br><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//否则，触发Full GC，但还不回收软引用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果还是内存不够时，会触发一次回收所有软引用的Full GC，再不行就OOM</span></span><br><span class="line">gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="弱引用weakreference">弱引用（WeakReference）</span></h4><p>弱引用比软引用的引用级别更低一些，GC时，如果一个对象从GC ROOTS出发，只有弱引用指向没有其他（强引用或软引用）指向时，这个对象就会在本次GC被回收掉。</p><p>弱引用最常见的使用情景是WeakHashMap，WeakHashMap里面的Entry是一个弱引用，这个弱引用指向Map的Key，如果这个Key没有被其他”强引用“或者”软引用“引用时，GC会干掉这个Key对象，同时将这个Entry对象放入WeakHashMap的ReferenceQueue中等待被处理，当WeakHashMap的get、put等方法被调用时，会通过expungeStaleEntries方法把这个ReferenceQueue的Entry对象的value置空并调整Entry链表摘取当前Entry，这样下次GC时就能回收掉value的对象了。</p><blockquote><p>一般在需要控制内存使用但又想尽量用到更多内存的场景下使用。比如tomcat的ConcurrentCache就用到了WeakHashMap来作为分级缓存，可以在内存充足的情况下，缓存尽量多的数据，同时又不会导致OOM。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">        <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="幻象引用phantomreference">幻象引用（PhantomReference）</span></h4><p>幻象引用是比弱引用的级别更低的一种，和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。<br>PhantomReference的回收处理过程如下：</p><p>GC时，高优先级的ReferenceHandler线程将这个PhantomReference放到它自身的静态ReferenceQueue中，然后PhantomReference的实现子类一般会有一个线程在不断轮询这个ReferenceQueue，从queue中取出PhantomReference并调用它自己实现的清理方法来释放它所指向对象的占用的一些特定资源并把PhantomReference自身从ReferenceQueue中干掉，这样下次GC时这个幻象引用本身和它指向的对象也能够被GC掉。</p><p>实际场景中，一般幻象引用用于对象需要被清理时，除了指向的对象本身外，还需要额外释放这个对象占用的其他资源的场景。比如DB连接池使用PhantomReference来释放底层的socket资源，比如DirectByteBuffer使用PhantomReference来释放底层占用的堆外内存。</p><ul><li>举例：</li></ul><p>DirectByteBuffer使用PhantomReference管理堆外内存释放的过程如下：</p><ul><li>每个DirectByteBuffer在生成时会绑定一个Cleaner对象，这个Cleaner对象是一个PhantomReference</li><li>当JVM GC时发现那些除了Cleaner幻象引用外已没有其他引用的DirectByteBuffer时，就会把这些Cleaner对象放到Reference这个类的pending列表里.</li><li>Reference类维护了一条ReferenceHandler的高优先级线程，这条线程会不断去轮询待处理的pending列表，如果是Cleaner对象就调用这个对象的clean方法进行清理（<em>这里需要注意的是：Cleaner是一种特殊的PhantomReference，它实际的清理工作是由ReferenceHandler线程直接执行的，不需要自己再维护一个清理的线程</em>）</li><li>clean方法里其实是调用初始化Cleaner时绑定的Deallocator间接使用unsafe.freeMemory来进行堆外内存的释放和Bits里全局堆外内存使用量的更新。</li></ul><h4><span id="final引用phantomreference">Final引用（PhantomReference）</span></h4><p>FinalReference &amp; Finalizer</p><p>在java.lang.ref包下，除了上面四种引用，还有一个非公开的FinalReference引用以及它的一个子类Finalizer。实际上，FinalReference 代表的正是 Java 中的强引用，如这样的代码 :<br><code>Bean bean = new Bean();</code></p><p>在虚拟机的实现过程中，实际采用了 FinalReference 类对其进行引用。而 Finalizer，除了作为一个实现类外，更是在虚拟机中实现一个 FinalizerThread，以使虚拟机能够在所有的强引用被解除后实现内存清理。</p><ul><li><p>Finalizer的工作过程：<br>GC过程中，当一个强引用对象bean没有了引用被标记为可回收时，如果这个bean对象的类定义了finalize方法，那么这个对象被绑定到一个Finalizer引用上，这个Finalizer引用会被前面讲过的ReferenceHandler线程将引用自身加入到Finalizer静态的ReferenceQueue中，同时Finalizer对象自带的静态的优先级为8（比普通线程优先级高但比ReferenceHandler优先级低）的FinalizerThread线程会轮询这个ReferenceQueue中的Finalizer引用，然后调用它的runFinalizer方法，最终调到了绑定的那个bean对象的finalize方法，当finalize方法的逻辑都执行完后，这个bean对象才会在下次GC时被回收。</p></li><li><p>这里有几个需要注意的点：</p><ul><li><p>1. 在CPU资源比较紧张的情况下，由于FinalizerThread线程优先级较低，可能由于得不到时间片而导致finalize的方法执行延迟或者缓慢。最终可能导致bean对象真正占用的资源释放不确定性提高，另外也可能会导致由于bean对象无法回收导致Full GC甚至OOM。</p></li><li><p>2. 底层的bean对象至少需要2次GC才会被回收。第一次GC只是标记后将处理任务提交给FinalizerThread线程去执行，当FinalizerThread执行完finalize方法后才会在下次GC时回收bean对象，FinalizerThread执行期间可能经历多次GC。</p></li><li><p>3. 和PhantomReference不同，由于Finalizer引用最终的释放依赖对象的finalize方法的实现，在finalize里实际上可以访问到引用的对象本身，所以如果在finalize方法里让其他对象又引用了当前对象，这样会导致这个本应该被回收的对象复活。</p></li></ul></li></ul><p>高优先级的ReferenceHandler线程将Finalizer引用加入到Finalizer类的静态ReferenceQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FinalizerThread线程处理：<ul><li>1. 将当前Finalizer引用从ReferenceQueue里删除</li><li>2. 执行Finalizer引用的runFinalizer来触发bean对象的清除操作</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (running) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    Finalizer f = (Finalizer)queue.remove();</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                        <span class="comment">// ignore and continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jla.invokeFinalize实际调用了bean对象的finalize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span><br><span class="line">            remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object finalizee = <span class="keyword">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span><br><span class="line"><span class="comment">                the chances of false retention with a conservative GC */</span></span><br><span class="line">                finalizee = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>finalize方法里将其他引用指向bean对象本身，导致bean对象复活</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Other.ref = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在PhantomReference实现中，由于get方法默认返回null，因此PhantomReference创建后就不能再访问它的referent，因此不存在死对象复活的问题。所以，尽量使用PhantomReference来替代原来Finalizer的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="gc过程是如何具体处理引用">GC过程是如何具体处理引用?</span></h2><p>GC时，各垃圾收集器都会在过程中，先找到当前回收代中那些”指向的referent除了当前引用外没有其他强引用使用了”的引用，然后对所有类型的Reference（soft、weak、phantom、final）进行进一步筛选和排除处理，最后，在GC的最后阶段，将待处理的Reference入队到Reference的pendingList等待ReferHandler线程来善后。</p><h3><span id="发现引用">发现引用</span></h3><ul><li><strong>“引用发现”这个过程的主要工作：_找出当前回收代中的可能需要被回收的这些引用。</strong><br>如ParNew垃圾回收器中的Ref»发现-标记»过程（parNewGeneration.cpp）：<br>先处理roots触发，引用到的对象都拷贝到to space，然后通过par_scan_state.evacuate_followers_closure().do_void()在to space里遍历全部年轻代存活对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_roots(_gen-&gt;level(),</span><br><span class="line">                         <span class="keyword">true</span>,  <span class="comment">// Process younger gens, if any,</span></span><br><span class="line">                                <span class="comment">// as strong roots.</span></span><br><span class="line">                         <span class="keyword">false</span>, <span class="comment">// no scope; this is parallel code</span></span><br><span class="line">                         GenCollectedHeap::SO_ScavengeCodeCache,</span><br><span class="line">                         GenCollectedHeap::StrongAndWeakRoots,</span><br><span class="line">                         &amp;par_scan_state.to_space_root_closure(),</span><br><span class="line">                         &amp;par_scan_state.older_gen_closure(),</span><br><span class="line">                         &amp;cld_scan_closure);</span><br><span class="line"></span><br><span class="line">  par_scan_state.end_strong_roots();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "evacuate followers".</span></span><br><span class="line">  par_scan_state.evacuate_followers_closure().do_void();</span><br></pre></td></tr></table></figure><ul><li>EvacuateFollowersClosureGeneral::do_void方法主要执行父类DefNewGeneration的oop_since_save_marks_iterate方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DefNewGeneration::                                         \</span><br><span class="line">    oop_since_save_marks_iterate##nv_suffix(OopClosureType* cl) &#123;   \</span><br><span class="line">    cl-&gt;set_generation(<span class="keyword">this</span>);                                     \</span><br><span class="line">    eden()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">    to()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);            \</span><br><span class="line">    from()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">    cl-&gt;reset_generation();                                       \</span><br><span class="line">    save_marks();                                                 \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>.space的oop_since_save_marks_iterate会调用每一个对象的oop_iterate</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">void</span> ContiguousSpace::                                                    \</span><br><span class="line">     oop_since_save_marks_iterate##nv_suffix(OopClosureType* blk) &#123;            \</span><br><span class="line">       HeapWord* t;                                                            \</span><br><span class="line">       HeapWord* p = saved_mark_word();                                        \</span><br><span class="line">       <span class="keyword">assert</span>(p != NULL, <span class="string">"expected saved mark"</span>);                               \</span><br><span class="line">                                                                               \</span><br><span class="line">       <span class="keyword">const</span> intx interval = PrefetchScanIntervalInBytes;                      \</span><br><span class="line">       <span class="keyword">do</span> &#123;                                                                    \</span><br><span class="line">         t = top();                                                            \</span><br><span class="line">         <span class="keyword">while</span> (p &lt; t) &#123;                                                       \</span><br><span class="line">           Prefetch::write(p, interval);                                       \</span><br><span class="line">           debug_only(HeapWord* prev = p);                                     \</span><br><span class="line">           oop m = oop(p);                                                     \</span><br><span class="line">           p += m-&gt;oop_iterate(blk);                                           \</span><br><span class="line">         &#125;                                                                     \</span><br><span class="line">       &#125; <span class="keyword">while</span> (t &lt; top());                                                    \</span><br><span class="line">                                                                               \</span><br><span class="line">       set_saved_mark_word(p);                                                 \</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">``` </span><br><span class="line">+ .oop是堆上对象的基类，它的oop\_iterate实际上会调到对应类的oop\_oop\_iterate##nv\_suffix方法，对于引用类型的对象，会走到InstanceRefKlass的op\_oop\_iterate##nv_suffix的方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    inline <span class="keyword">int</span> oopDesc::oop_iterate(OopClosureType* blk) &#123;                     \</span><br><span class="line">       SpecializationStats::record_call();                                      \</span><br><span class="line">       return klass()-&gt;oop_oop_iterate##nv_suffix(this, blk);               \</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>InstanceRefKlass的oop_oop_iterate##nv_suffix会调用InstanceRefKlass_SPECIALIZED_OOP_ITERATE这个语句块。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InstanceRefKlass::                                                          \</span><br><span class="line">    oop_oop_iterate##nv_suffix(oop obj, OopClosureType* closure) &#123;                  \</span><br><span class="line">    <span class="comment">/* Get size before changing pointers */</span>                                       \</span><br><span class="line">    SpecializationStats::record_iterate_call##nv_suffix(SpecializationStats::irk);\</span><br><span class="line">                                                                                    \</span><br><span class="line">    int size = InstanceKlass::oop_oop_iterate##nv_suffix(obj, closure);           \</span><br><span class="line">                                                                                    \</span><br><span class="line">    <span class="keyword">if</span> (UseCompressedOops) &#123;                                                      \</span><br><span class="line">        InstanceRefKlass_SPECIALIZED_OOP_ITERATE(narrowOop, nv_suffix, contains);   \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        InstanceRefKlass_SPECIALIZED_OOP_ITERATE(oop, nv_suffix, contains);         \</span><br><span class="line">    &#125;                                                                             \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在InstanceRefKlass_SPECIALIZED_OOP_ITERATE这个语句块中，这里会执行最终的»引用发现»discover_reference方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define InstanceRefKlass_SPECIALIZED_OOP_ITERATE(T, nv_suffix, contains)        \</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;is_gc_marked() &amp;&amp; (rp != NULL) &amp;&amp;                            \</span><br><span class="line">        rp-&gt;discover_reference(obj, reference_type())) &#123;                        \</span><br><span class="line">        <span class="keyword">return</span> size;                                                              \</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>discover_reference方法中，只收集那些还“存活的”、“reference是在当前回收代的”、“引用的真实对象还不确定是否被其他强引用的”的引用，会真正操作Reference的discovered字段来维护»发现»的引用链表。</p><p>PS：这里“发现”引用的阶段有两种情况需要考虑：</p><ul><li><p>1. 如果是引用指向的对象先被GC扫描到被强引用了，那么引用以及它所指向的对象都不会被“发现”（而是随后连同引用和指向对象都被copy到To区）。</p></li><li><p>2. 如果是引用本身先被GC扫描到，那么这里的“发现”阶段还是会把引用先加入到discovered链表中并将引用搬到To区（但不动引用指向的对象），等GC后，在后面“处理”引用的阶段会遍历这个discovered链表，找出那些除了自己外还有其他“强引用”指向referent对象的引用（这个referent对象由于有强引用已经被copy到To区了），然后从discovered链表删除自己并更新引用指向的对象地址，这样后续就不用再处理了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool ReferenceProcessor::discover_reference(oop obj, ReferenceType rt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//只收集那些“引用的真实对象暂时还不确定是否被其他强引用的”的引用</span></span><br><span class="line">    <span class="comment">// We only discover references whose referents are not (yet)</span></span><br><span class="line">      <span class="comment">// known to be strongly reachable.</span></span><br><span class="line">      <span class="keyword">if</span> (is_alive_non_header() != NULL) &#123;</span><br><span class="line">        verify_referent(obj);</span><br><span class="line">        <span class="keyword">if</span> (is_alive_non_header()-&gt;do_object_b(java_lang_ref_Reference::referent(obj))) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// referent is reachable</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将找到的各种引用加入到收集的引用列表</span></span><br><span class="line">    <span class="keyword">if</span> (_discovery_is_mt) &#123;</span><br><span class="line">        add_to_discovered_list_mt(*list, obj, discovered_addr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We do a raw store here: the field will be visited later when processing</span></span><br><span class="line">        <span class="comment">// the discovered references.</span></span><br><span class="line">        oop current_head = list-&gt;head();</span><br><span class="line">        <span class="comment">// The last ref must have its discovered field pointing to itself.</span></span><br><span class="line">        oop next_discovered = (current_head != NULL) ? current_head : obj;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">assert</span>(discovered == NULL, <span class="string">"control point invariant"</span>);</span><br><span class="line">        oop_store_raw(discovered_addr, next_discovered);</span><br><span class="line">        list-&gt;set_head(obj);</span><br><span class="line">        list-&gt;inc_length(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">          gclog_or_tty-&gt;print_cr(<span class="string">"Discovered reference ("</span> INTPTR_FORMAT <span class="string">": %s)"</span>,</span><br><span class="line">                                    (<span class="keyword">void</span> *)obj, obj-&gt;klass()-&gt;internal_name());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="处理引用">处理引用</span></h3><p>针对之前»发现»的引用，GC过程还会通过ReferenceProcessor的process_discovered_references来对所有类型的Reference（soft、weak、phantom、final）进行处理，处理步骤分成3个阶段，主要工作：根据GC策略来过滤软引用、过滤GC后那些referent还存活的引用 、根据不同引用类型决定是否马上解除对referent的引用（如弱引用、软引用和Cleaner在这里直接清理了对referent的引用，而幻象引用和Final引用这里先不清除，因为后面还需要用到）。</p><p>还是是ParNew回收器为例，GC时，在完成“引用发现”后，会通过process_discovered_references方法对引用进行处理，最后GC完成内存回收后再将Reference加入到pending列表中以便后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ParNewGeneration::collect(bool   full,</span><br><span class="line">                                bool   clear_all_soft_refs,</span><br><span class="line">                                size_t size,</span><br><span class="line">                                bool   is_tlab) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">//处理引用</span></span><br><span class="line">       <span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">        <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">        stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                                  &amp;evacuate_followers, &amp;task_executor,</span><br><span class="line">                                                  _gc_timer, gc_tracer.gc_id());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread_state_set.flush();</span><br><span class="line">            gch-&gt;set_par_threads(<span class="number">0</span>);  <span class="comment">// 0 ==&gt; non-parallel.</span></span><br><span class="line">            gch-&gt;save_marks();</span><br><span class="line">            stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                                      &amp;evacuate_followers, NULL,</span><br><span class="line">                                                      _gc_timer, gc_tracer.gc_id());</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">//通过将当前引用列表附到原来的pending链表以便ReferenceHandler线程的善后处理</span></span><br><span class="line">        rp-&gt;set_enqueuing_is_done(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">            <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">            rp-&gt;enqueue_discovered_references(&amp;task_executor);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp-&gt;enqueue_discovered_references(NULL);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>GC完成时，处理”被发现“的引用的方法process_discovered_references主要实现在referenceProcessor.cpp的process_discovered_reflist中，包括三个阶段。</p><ul><li>1. 第一个阶段只处理软引用：因为软引用普通GC时是不能回收处理的，所以需要从discovered链表中移除所有不存活但是还不能被回收的软引用；</li><li>2. 第二阶段处理所有引用：从discoverd链表移除那些GC时»发现»阶段还不确定referent有没有被其他强引用但现在GC遍历完了确定»有被强引用»的引用。</li><li>3. 第三阶段处理剩下引用的referent：根据clear_referent的值决定是否将对referent的引用解除，方便下一次GC时回收referent。 （比如Final和Phantom是先不解除引用的，因为后续还要用；Weak是可以解除的）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ReferenceProcessor::process_discovered_reflist(</span><br><span class="line">       DiscoveredList               refs_lists[],</span><br><span class="line">       ReferencePolicy*             policy,</span><br><span class="line">       bool                         clear_referent,</span><br><span class="line">       BoolObjectClosure*           is_alive,</span><br><span class="line">       OopClosure*                  keep_alive,</span><br><span class="line">       VoidClosure*                 complete_gc,</span><br><span class="line">       AbstractRefProcTaskExecutor* task_executor)&#123;  </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// Phase 1 (soft refs only):</span></span><br><span class="line">        <span class="comment">// . Traverse the list and remove any SoftReferences whose</span></span><br><span class="line">        <span class="comment">//   referents are not alive, but that should be kept alive for</span></span><br><span class="line">        <span class="comment">//   policy reasons. Keep alive the transitive closure of all</span></span><br><span class="line">        <span class="comment">//   such referents.</span></span><br><span class="line">       <span class="keyword">if</span> (policy != NULL) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">           <span class="function">RefProcPhase1Task <span class="title">phase1</span><span class="params">(*<span class="keyword">this</span>, refs_lists, policy, <span class="keyword">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">           task_executor-&gt;execute(phase1);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">             process_phase1(refs_lists[i], policy,</span><br><span class="line">                            is_alive, keep_alive, complete_gc);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// policy == NULL</span></span><br><span class="line">         <span class="keyword">assert</span>(refs_lists != _discoveredSoftRefs,</span><br><span class="line">                <span class="string">"Policy must be specified for soft references."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// Phase 2:</span></span><br><span class="line">       <span class="comment">// . Traverse the list and remove any refs whose referents are alive.</span></span><br><span class="line">       <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">         <span class="function">RefProcPhase2Task <span class="title">phase2</span><span class="params">(*<span class="keyword">this</span>, refs_lists, !discovery_is_atomic()</span> <span class="comment">/*marks_oops_alive*/</span>)</span>;</span><br><span class="line">         task_executor-&gt;execute(phase2);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">           process_phase2(refs_lists[i], is_alive, keep_alive, complete_gc);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">          <span class="comment">// Phase 3:</span></span><br><span class="line">       <span class="comment">// . Traverse the list and process referents as appropriate.</span></span><br><span class="line">       <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">         <span class="function">RefProcPhase3Task <span class="title">phase3</span><span class="params">(*<span class="keyword">this</span>, refs_lists, clear_referent, <span class="keyword">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">         task_executor-&gt;execute(phase3);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">           process_phase3(refs_lists[i], clear_referent,</span><br><span class="line">                          is_alive, keep_alive, complete_gc);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>处理完引用后，GC回收完内存后，在结束阶段会通过ReferenceProcessor的enqueue_discovered_references方法来将处理过的引用通过pending链表来进行入队列，这样ReferenceHandler才能把队列里的Reference对象从pending链表取出后写入到ReferenceQueue或者进行clean（Cleaner）操作。enqueue_discovered_references会根据是否使用压缩指针选择不同的enqueue_discovered_ref_helper()模板函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool ReferenceProcessor::enqueue_discovered_references(AbstractRefProcTaskExecutor* task_executor) &#123;</span><br><span class="line">   NOT_PRODUCT(verify_ok_to_handle_reflists());</span><br><span class="line">   <span class="keyword">if</span> (UseCompressedOops) &#123;</span><br><span class="line">     <span class="keyword">return</span> enqueue_discovered_ref_helper&lt;narrowOop&gt;(<span class="keyword">this</span>, task_executor);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> enqueue_discovered_ref_helper&lt;oop&gt;(<span class="keyword">this</span>, task_executor);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>pending_list_addr是Reference类的pending链表的首元素地址，enqueue_discovered_reflists过程会把符合的引用加入到这个链表，ReferenceHandler则从pending链表取出引用后放入ReferenceQueue或直接处理（Cleaner）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">enqueue_discovered_ref_helper</span><span class="params">(ReferenceProcessor* ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        AbstractRefProcTaskExecutor* task_executor)</span> </span>&#123;</span><br><span class="line">    T* pending_list_addr = (T*)java_lang_ref_Reference::pending_list_addr();</span><br><span class="line">    T old_pending_list_value = *pending_list_addr;</span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(pending_list_addr, oopDesc::load_decode_heap_oop(pending_list_addr));</span><br><span class="line">    ref-&gt;enqueue_discovered_reflists((HeapWord*)pending_list_addr, task_executor);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ref-&gt;disable_discovery();</span><br><span class="line">    <span class="keyword">return</span> old_pending_list_value != *pending_list_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多线程和单线程处理方式，由-XX:+ParallelRefProcEnabled控制，默认单线程，实际处理代码在enqueue_discovered_reflist中，主要逻辑如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ReferenceProcessor::enqueue_discovered_reflist(DiscoveredList&amp; refs_list,</span><br><span class="line">                                                         HeapWord* pending_list_addr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pending_list_uses_discovered_field()) &#123; <span class="comment">// New behavior</span></span><br><span class="line">    <span class="comment">// Walk down the list, self-looping the next field</span></span><br><span class="line">    <span class="comment">// so that the References are not considered active.</span></span><br><span class="line">    <span class="keyword">while</span> (obj != next_d) &#123;</span><br><span class="line">    obj = next_d;</span><br><span class="line">    <span class="keyword">assert</span>(obj-&gt;is_instanceRef(), <span class="string">"should be reference object"</span>);</span><br><span class="line">    next_d = java_lang_ref_Reference::discovered(obj);</span><br><span class="line">    <span class="keyword">if</span> (TraceReferenceGC &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print_cr(<span class="string">"        obj "</span> INTPTR_FORMAT <span class="string">"/next_d "</span> INTPTR_FORMAT,</span><br><span class="line">                                (<span class="keyword">void</span> *)obj, (<span class="keyword">void</span> *)next_d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(java_lang_ref_Reference::next(obj) == NULL,</span><br><span class="line">            <span class="string">"Reference not active; should not be discovered"</span>);</span><br><span class="line">    <span class="comment">// Self-loop next, so as to make Ref not active.</span></span><br><span class="line">    java_lang_ref_Reference::set_next_raw(obj, obj);</span><br><span class="line">    <span class="keyword">if</span> (next_d != obj) &#123;</span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(java_lang_ref_Reference::discovered_addr(obj), next_d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is the last object.</span></span><br><span class="line">        <span class="comment">// Swap refs_list into pending_list_addr and</span></span><br><span class="line">        <span class="comment">// set obj's discovered to what we read from pending_list_addr.</span></span><br><span class="line">        oop old = oopDesc::atomic_exchange_oop(refs_list.head(), pending_list_addr);</span><br><span class="line">        <span class="comment">// Need post-barrier on pending_list_addr. See enqueue_discovered_ref_helper() above.</span></span><br><span class="line">        java_lang_ref_Reference::set_discovered_raw(obj, old); <span class="comment">// old may be NULL</span></span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(java_lang_ref_Reference::discovered_addr(obj), old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://coldwalker.com/images/gc_intro/image-20180819185503111.png" alt="04dd63008299487f05620952f0bd5dff.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(2)</title>
      <link href="/article/Java-garbage-collection-analysis-2/"/>
      <url>/article/Java-garbage-collection-analysis-2/</url>
      
        <content type="html"><![CDATA[<h3><span id="为什么需要gc">为什么需要GC？</span></h3><p>当程序创建对象、数组等引用类型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何引用变量引用时，这块内存就变成垃圾，等待垃圾回收机制进行回收。在C和C++中，垃圾的回收是由程序员来手动执行，虽然实时性比较好，但由于内存分配和回收代码繁琐，较容易出错，内存泄露问题比较常见。于是一些语言如Java、python、Go等，通过程序实现了自动化内存管理来解决垃圾回收问题，从而降低了在这些语言中内存使用的门槛。另外，由于GC有一定的滞后性，在一些实时性较高或者内存吃紧的（单片机开发）软件中，还是有不少采用人工回收垃圾的案例。</p><p><em>GC的一些特点：</em><br>1. GC只负责回收内存中的对象，不回收物理资源（如文件流、socket等）。<br>2. 程序无法精确控制GC的运行，GC只会在合适的时候进行。</p><p><em>PS：1其实也是由于2的GC的不确定性导致的，比如一个socket占用了某个端口，当使用完后GC并不会立刻回收这个socket，当需要再用到这个端口的socket时，就会报错。</em></p><h3><span id="gc实现的两种常见方式">GC实现的两种常见方式</span></h3><h4><span id="引用计数reference-counting">引用计数（Reference Counting）</span></h4><p>引用计数的实现比较简单，核心就是给每一个对象增加一个引用计数器，当另一个对象引用当前对象时就给当前对象的引用计数+1，当有对象不再引用当前对象时，就将引用计数-1，当前对象的引用计数变成0时，递归地将该对象引用的子对象的引用计数-1，并把当前对象使用的内存区域释放到空闲链表中。<br><img src="https://coldwalker.com/images/gc_intro/refcount.gif" alt="6efac91db597f7d968d53f68c99e32d4.gif"></p><p><em>引用计数算法的优点：</em></p><ol><li><p>引用归0时可立即回收垃圾，实时性好。</p></li><li><p>应用执行和垃圾回收“自然、依次”发生，GC开销分布在各次应用执行中，最大暂停时间消减（虽然GC次数增加）。</p></li><li><p>执行效率高，“事件触发”机制避免了整堆扫描标记的耗时。</p></li></ol><p><em>引用计数算法的缺点：</em></p><ol><li><p>循环引用问题无法解决，导致垃圾回收不彻底。</p></li><li><p>需要额外的存储空间来存放每一个对象的引用计数。</p></li><li><p>频繁的计数增减带来的高并发和本身需要的操作原子性的开销较大。</p></li><li><p>引用计数归0时，可能会级联删除大量对象，造成GC耗时不平稳。</p></li></ol><p><em>以上可知，基于引用计数的GC在实时性和执行效率方面有较大优势，类似 python、perl、swift等语言都使用引用计数算法来实现GC。但由于引用计数GC存在高并发时的性能较低等问题，因此，对性能要求较高的系统在实现时一般不会采用引用计数算法，而是使用和应用隔离的“跟踪回收”方式来实现GC。</em></p><h4><span id="跟踪回收">跟踪回收</span></h4><p>跟踪回收是一种独立于应用程序外的GC方式，定期运行来检查垃圾。跟踪回收通过被称为“GC ROOTS”的对象开始，不断通过深度或者广度遍历的方式来跟踪标记所有”可达的对象“，然后其他“GC ROOTS不可达对象”的未标记对象就被视为垃圾，会被统一回收。跟踪回收是目前被广泛使用的技术，如：Java、Go、.net等都使用跟踪的方式来进行垃圾回收。</p><p><em>跟踪回收的GC方式在具体的算法实现上，主要包括以下几种垃圾回收算法：</em></p><h5><span id="标记-清除mark-sweep">标记-清除（mark-sweep)</span></h5><p>标记清除算法主要分两个阶段：</p><ol><li><p>第一阶段，从GC ROOTS开始进行遍历，标记所有可直达或间接到达的对象为“使用中”。</p></li><li><p>第二阶段，扫描整体内存，对上一阶段标记的“使用中”的对象进行回收。<br><img src="https://coldwalker.com/images/gc_intro/A73996FF-5E0A-42D5-AE6B-73D25A1FD000.jpg" alt="3ded3d0575a91f8dfde31dc446642d56.jpeg"></p></li></ol><p>原始的标记-清除算法有不少问题，比如：</p><ol><li><p>GC期间，整个业务线程都会被挂起，暂停时间较长。</p></li><li><p>内存容易出现碎片，多次GC后可用连续内存问题明显。</p></li><li><p>GC的STW（Stop The World）的时间和heap大小正相关。</p></li></ol><p>因此在标记-清除算法的基础上，又产生了很多基于标记-清除的衍生算法来优化这些问题。比如：</p><h6><span id="并发的标记-清除算法">并发的标记-清除算法</span></h6><p>标记-清除过程实际上大部分时间Collector（GC线程）是可以和Mutator（应用程序线程）并发执行，大部分的工作都在并发阶段完成，真正需要暂停应用线程的阶段只需要来解决并发过程中变化的那部分对象即可，从而并不需要整个回收阶段都block住应用线程。比如CMS垃圾回收器除了Init-Mark阶段和Final-Mark阶段外，其他阶段都是可以并发执行的。</p><h6><span id="标记整理算法">标记–整理算法</span></h6><p>针对内存容易出现碎片的问题，衍生的Mark-Compact算法通过将sweep过程替换成compact过程，每次GC都会对内存进行一次移动整理。</p><p><em>标记-整理算法一般分3部分：</em></p><p>a. 先在mark阶段标记存活对象。<br>b. 遍历heap计算出存活对象将要移动到的新位置。<br>c. 将存活对象真正移动到新位置并更新存活对象中被指向移动对象的指针。<br><img src="https://coldwalker.com/images/gc_intro/CD89A12E-1A37-4269-B102-66ADB27404BB.jpg" alt="a0da00148bc1a9638f5ea4256f3c0b1e.jpeg"></p><p>由过程可知，标记-整理算法的compact阶段的耗时是和存活对象的多少成正比的。而且虽然解决了碎片的问题，但实际需要多次遍历heap、移动对象、更新指针，所以耗时上会比标记-清除算法要更长一些。所以默认情况下一些垃圾回收器CMS并不直接使用mark-compact算法，而是当由于存在碎片导致发生Full GC时才会使用基于mark-compact算法来进行内存整理。</p><blockquote><p>PS：当然从另一个方面看，mark-compact阶段由于解决了内存碎片问题，在应用线程申请内存的时候就可以用“指针碰撞”（pointer bumping）方式来快速完成内存分配，如果碎片较多，“指针碰撞”就会较大概率导致多次指针挪动，就不适合了，这样就只能使用分配速度更慢的类似freelist的方式来进行内存的管理和分配。</p></blockquote><h5><span id="复制-收集copying-gc">复制-收集（Copying GC)</span></h5><p>由于标记-清除算法存在碎片化的问题，标记-整理算法又由于需要多次遍历heap效率较低，因此“复制-收集”算法采用了一个空间换时间的方式来解决上面的问题。“复制-收集”算法的工作过程如下：</p><ol><li><p>将可用内存分成大小相等的两块，from space和 to space。</p></li><li><p>同一时刻只有from space会被使用。</p></li><li><p>GC时，将from space内存活的对象拷贝到to space</p></li><li><p>拷贝完成后，from space和to space交换身份<br><img src="https://coldwalker.com/images/gc_intro/E583CCB7-47DF-4CE4-8945-8AC2E8135706.jpg" alt="1290c3eb4092bd52de293fbe1be152cb.jpeg"></p></li></ol><blockquote><p>由“复制-收集”算法的实现可知，虽然这种算法比较简单高效，而且没有碎片问题。但一个比较明显的代价就是：应用程序实际可用的内存会被减半。另外，“复制-收集”算法很大一部分工作在于将存活对象移动到to space，因此它的时间开销和存活对象的数量成正比。</p></blockquote><p><em>上面介绍了主流几种“跟踪回收”类GC的具体实现算法，每一种算法都有其擅长和不足的地方，因此在实际的GC算法选择中，会根据不同的场景和特性选择不同的算法实现，从而将每种算法“扬长避短”。后面我会再继续分析现代化的GC如何进一步优化这些算法过程。</em></p><hr><h4><span id="标记-压缩-mark-compact">标记-压缩 （Mark-Compact）</span></h4><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。<br><img src="/article/Java-garbage-collection-analysis-2/1562814680550Java-garbage-collection-analysis-2_.png" alt></p><h3><span id="垃圾回收器">垃圾回收器</span></h3><p>GC算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。新生代垃圾收集器有Serial、ParNew、Parallel Scavenge、G1，属于老年代的垃圾收集器有CMS、Serial Old、Parallel Old和G1。其中的G1是一种既可以对新生代对象也可以对老年代对象进行回收的垃圾收集器。大部分垃圾回收器之间能相互配合来发挥各自的优势。</p><p><img src="https://coldwalker.com/images/gc_intro/6073827-904b301be72b9f5a.jpg.png" alt="85a94c88d8d3662165484268f0449723.png"></p><h6><span id="serial收集器">Serial收集器</span></h6><p>Serial收集器是最古老、最基本的一种垃圾回收器，采用单线程来进行垃圾回收。新生代回收采用复制算法，回收的整个过程会暂停业务线程（STW）。</p><blockquote><p><em>Serial收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：简单高效，拥有很高的单线程收集效率<br>应用：Client模式下的默认新生代收集器<br>参数控制：-XX:+UseSerialGC</p></blockquote><p><img src="https://coldwalker.com/images/gc_intro/6073827-42feae7608310929.png" alt="56c88d3322821a6d6af5909213e888a5.png"></p><h6><span id="parnew收集器">ParNew收集器</span></h6><p>ParNew收集器也是一个新生代垃圾回收器，可以看成是Serial收集器的多线程版本，也是采用复制算法来进行收集，回收整个过程也是暂停业务线程（STW）的，但由于是多线程并行执行的，所以在多CPU机器上一般会比Serial收集器快很多。</p><blockquote><p><em>ParNew收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：在CPU多的情况下，拥有比Serial更好的效果。单CPU环境下Serial效果更好<br>应用：许多运行在Server模式下的虚拟机中首选的新生代收集器<br>参数控制：<br>-XX:+UseParNewGC<br>-XX:ParallelGCThreads (限制线程数量)</p></blockquote><p><img src="https://coldwalker.com/images/gc_intro/img_97ff89bcbbc18cd50ba5287850435f43.png" alt="97ff89bcbbc18cd50ba5287850435f43.png"></p><h6><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h6><p>和ParNew收集器类似，Parallel Scavenge收集器也是一个新生代垃圾回收器，但和ParNew收集器不同的是Parallel Scavenge收集器更多关注的是可控制的吞吐量，支持自适应调节策略。</p><blockquote><p>吞吐量 = 运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)</p></blockquote><p>Parallel Scavenge收集器提供几个参数控制垃圾回收的执行：</p><p>-XX:MaxGCPauseMillis<br>最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。</p><p>-XX:GCTimeRatio<br>垃圾回收时间与总时间占比（默认是99%）。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。</p><p>-XX:UseAdaptiveSizePolicy<br>开启动态自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整上面两个参数以提供最合适的停顿时间或者最大吞吐量。</p><blockquote><p><em>Parallel Scavenge收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：在CPU多的情况下，拥有比Serial更好的效果；对暂停时间和吞吐量能精细化控制。<br>应用：指定使用<br>参数控制：-XX:+UseParallelGC</p></blockquote><h6><span id="serial-old收集器">Serial Old收集器</span></h6><p>老年代的收集器，与上面的Serial一样是单线程回收，不同的是算法用的是标记-整理（Mark-Compact），整个过程和Serial收集器一样都会暂停业务线程。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br><img src="https://coldwalker.com/images/gc_intro/serial-old.png" alt="0207d0a7741701cf070520c4f97f065e.png"></p><h6><span id="parallel-old收集器">Parallel Old收集器</span></h6><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，JDK 1.6开始推出的，它使用多线程和“标记-整理”算法进行垃圾回收。通常与Parallel Scavenge收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。<br><img src="https://coldwalker.com/images/gc_intro/parallel-old.png" alt="754b629778258dd09ede56a2a9f304b2.png"></p><h6><span id="cms收集器">CMS收集器</span></h6><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的多线程并发收集器，基于“标记-清除”算法实现。CMS垃圾回收器将垃圾回收分成多个阶段，某些阶段可以和业务线程并发执行，这些并发阶段主要来做一些准备工作，这些准备工作能缩小最终的暂停阶段（Init-Mark和Remark）的时间，而且在暂停业务线程的两个阶段也由于多线程并行暂停时间控制也较好，是目前对用户响应时间敏感的且堆大小适中（太大、太小都不好）的应用广泛采用的年老代垃圾回收器。默认配合ParNew回收器作为新生代垃圾回收器。</p><blockquote><p><em>CMS收集器的7个阶段：</em><br>初始标记（CMS initial mark）<br>并发标记（CMS concurrent mark）<br>并发预清理（CMS concurrent-preclean）<br>并发可取消的预清理 （CMS concurrent-abortable-preclean）<br>重新标记（CMS remark）<br>并发清除（CMS concurrent sweep）<br>并发重置（CMS concurrent-reset）</p></blockquote><p><img src="/article/Java-garbage-collection-analysis-2/1552636717386Java-garbage-collection-analysis-2_.png" alt></p><p><em>PS：这个盗的图稍微有点问题，从jdk 1.8开始，initial mark阶段也是多线程并行执行的，可以通过-XX:+CMSParallelInitialMarkEnabled参数控制。</em></p><p><strong>CMS收集器的特性总结：</strong></p><ul><li><p>收集过程：部分阶段和业务线程并发执行，部分阶段暂停所有业务线程</p></li><li><p>算法：标记-清除算法</p></li><li><p>优点：并发收集、低停顿</p></li><li><p>缺点：清除算法会产生空间碎片、并发阶段会降低吞吐量、无法即时处理并发阶段产生的“浮动垃圾”</p></li><li><p>应用：指定使用</p></li><li><p>参数控制：</p><blockquote><p>-XX:+UseConcMarkSweepGC（是否采用CMS回收器）<br>-XX:+UseCMSInitiatingOccupancyOnly（JVM是否基于运行时收集的数据来启动CMS垃圾收集周期还是只根据初始设置来启动）<br>-XX:CMSInitiatingOccupancyFraction=80 （old区在使用了n%的后开始启动CMS backgroud GC）<br>-XX:ConcGCThreads=4 （并发CMS阶段采用多线程时使用的线程数）<br>-XX:+CMSConcurrentMTEnabled （并发阶段是否采用多线程）<br>-XX:+CMSParallelInitialMarkEnabled （初始标记阶段是否采用多线程并行执行）<br>-XX:+CMSParallelRemarkEnabled （重新标记阶段是否采用多线程并行执行）<br>-XX:+UseCMSCompactAtFullCollection （是否允许Full GC时采用整理算法）<br>-XX:CMSFullGCsBeforeCompaction=0 （采用整理算法前需要Full GC次数达到一定阈值）<br>-XX:+CMSClassUnloadingEnabled （GC过程也对永久代进行垃圾回收）<br>-XX:ExplicitGCInvokesConcurrent （允许显示的系统GC调用）<br>-XX:+CMSScavengeBeforeRemark （CMS重新标记阶段之前是否尝试对年轻代进行一次回收，能有效降低remark的时间）<br>-XX:+CMSIncrementalMode （增量模式，基本不开启，cpu资源少时可尝试）<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses （当有系统GC调用时，永久代也被包括进CMS垃圾回收的范围内）</p></blockquote></li></ul><h6><span id="g1收集器">G1收集器</span></h6><p>G1（Garbage First）收集器在JDK 1.7版本正式启用，在JDK 9中，G1被提议设置为默认垃圾收集器。应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：</p><ul><li><p>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</p></li><li><p>G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p></li></ul><p>与前面介绍回收器只能工作在年轻代或者年老代不同的是，G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p><img src="https://coldwalker.com/images/gc_intro/2184951-715388c6f6799bd9.png" alt="ba1807ea0d2b5304a7ad7ba2eb73f1f1.png"></p><blockquote><p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p></blockquote><p>G1收集器有三种GC模式：</p><ul><li><p>Young GC：</p><p>发生在年轻代的Region，所有eden类型的Region被分配完时，触发Young GC，将存活对象从eden的Region拷贝到survior类型的Region或者晋升到old Region，然后根据历史统计信息和用户定义的暂停时间来动态调整eden Region和survivor Region的个数，从而尽量让下一次GC的回收时间满足用户期望。和ParNew一样YGC采用的“复制-收集”算法。</p></li><li><p>Mixed GC：</p><p>STW阶段，类似CMS一样当old类型的Region占用达到一定阈值的时候，G1会触发一次全局“标记”动作，统计得出收集收益高的老年代Region。“标记”工作完成后，在每次YGC之后或者再次发生Mixed GC前，JVM会检查整个堆的垃圾占比是否达到G1HeapWastePercent的阈值，如果达到了，下次就会触发一次Mixed GC（<em>一次标记后可能会分多次进行Mixed GC</em>）。</p><p>Mixed GC并不仅仅是一次老年代GC，不仅进行正常的YGC回收整个young区，同时也会选择部分old Region也进行回收，和YGC一样，Mixed GC也是采用的“复制-收集”算法作为清除策略，因此整个G1垃圾回收不会存在和CMS一样的内存碎片问题。Mixed GC步骤包括 “标记”和“回收”两部分。</p></li><li><p>Full gc：</p><p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。</p></li></ul><p>其中YGC和ParNew等回收器的过程类似，比较简单，采用的是»复制-收集»算法，Mixed GC部分过程和CMS也比较相似，略有不同，Mixed GC分为»标记»和»回收»两大阶段。</p><p>Mixed GC的“标记”过程如下：</p><ol><li><p><strong>initial mark（初始标记）</strong>：会暂停所有线程，标记出所有可以直接从GC roots可以到达的对象，这是在Young GC的暂停收集阶段顺带进行的。因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p></li><li><p><strong>concurrent-root-region-scan（扫描根引用区）</strong>：找出所有的GC Roots的Region, 然后从这些Region开始标记可到达的对象，是一个并发阶段。</p></li><li><p><strong>concurrent marking（并发标记</strong>）：和CMS的并发标记阶段类似，这个阶段G1递归寻找整个堆的存活对象，是和业务线程并发执行的。</p></li><li><p><strong>remark（最终标记）</strong>：STW的阶段，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p></li><li><p><strong>clean up（清理阶段</strong>）：marking的最后一个阶段，G1统计各个Region的活跃性，完全没有存活对象的Region直接放入空闲可用Region列表中，然后会找出mixed GC的Region候选列表。</p></li></ol><p>Mixed GC的“回收”过程如下：</p><ol><li><p>选择所有young regions进行年轻代回收年轻代回收。</p></li><li><p>选取标记阶段之前标记出来的老年代的垃圾最多的部分区块，结合用户“期望”的GC Pause耗时相关，选取收益最大的部分Region进行回收，整个老年代标记完后可能会分多次Mixed GC执行，直到标记后的垃圾分区占比低于“堆废物占比”，之后再恢复到常规的年轻代垃圾收集，然后当堆的使用满足“触发标记周期阈值”会最终再次启动并发周期，进行下一轮循环。</p></li></ol><p><strong>G1常用参数</strong></p><ul><li><p>-XX:G1HeapRegionSize=n</p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p></li><li><p>-XX:MaxGCPauseMillis=200</p><p>为所需的最长暂停时间设置目标值。默认值是 200 毫秒。指定的值不适用于您的堆大小。</p></li><li><p>-XX:G1NewSizePercent=5</p><p>设置要用作年轻代大小最小值的堆百分比。默认值是 Java 堆的 5%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了</p></li><li><p>-XX:DefaultMinNewGenPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1MaxNewSizePercent=60</p><p>设置要用作年轻代大小最大值的堆大小百分比。默认值是 Java 堆的 60%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了 -XX:DefaultMaxNewGenPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:ParallelGCThreads=n</p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p></li><li><p>-XX:ConcGCThreads=n</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p></li><li><p>-XX:InitiatingHeapOccupancyPercent=45</p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p></li><li><p>-XX:G1MixedGCLiveThresholdPercent=65</p><p>为混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了</p></li><li><p>-XX:G1OldCSetRegionLiveThresholdPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1HeapWastePercent=10</p><p>设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，Java HotSpot VM 不会启动混合垃圾回收周期。默认值是 10%。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1MixedGCCountTarget=8</p><p>设置标记周期完成后，对存活数据上限为 G1MixedGCLIveThresholdPercent 的旧区域执行混合垃圾回收的目标次数。默认值是 8 次混合垃圾回收。混合回收的目标是要控制在此目标次数以内。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1OldCSetRegionThresholdPercent=10</p><p>设置混合垃圾回收期间要回收的最大旧区域数。默认值是 Java 堆的 10%。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1ReservePercent=10</p><p>设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%。增加或减少百分比时，请确保对总的 Java 堆调整相同的量。Java HotSpot VM build 23 中没有此设置。</p></li></ul><hr><p><em>参考：</em><br><a href="http://120.52.51.16/www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf" target="_blank" rel="noopener">垃圾回收统一理论</a><br><a href="http://www.math.grin.edu/~rebelsky/Courses/CS302/99S/Presentations/GC/" target="_blank" rel="noopener">Introduction to Garbage Collection</a><br><a href="https://hllvm-group.iteye.com/group/topic/38223" target="_blank" rel="noopener">R大：并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为</a><br><a href="https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html" target="_blank" rel="noopener">垃圾优先型垃圾回收器调优</a><br><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All" target="_blank" rel="noopener">G1: One Garbage Collector To Rule Them All</a><br><a href="http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/" target="_blank" rel="noopener">JDK源码阅读-Reference</a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(1)</title>
      <link href="/article/Java_garbage_collection_analysis/"/>
      <url>/article/Java_garbage_collection_analysis/</url>
      
        <content type="html"><![CDATA[<h3><span id="java虚拟机内存管理">Java虚拟机内存管理</span></h3><p>Java虚拟机把内存分为几个不同的数据区，如下：</p><p><img src="/article/Java_garbage_collection_analysis/1.png" alt></p><h4><span id="java栈">Java栈</span></h4><p>JVM规范要求：每个Java线程拥有自己私有独享的JVM栈，JVM栈随着线程启动产生，线程结束而消亡。栈区内存由编译器自动分配释放，线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），栈以帧为单位保存线程的状态，栈帧负责存储局部变量变量表、操作数栈、动态链接和方法返回地址等信息。</p><h5><span id="栈帧">栈帧</span></h5><ul><li><p>栈帧的概念</p><blockquote><p>用来存储数据和部分过程结果的数据结构，也用来处理动态连接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。</p></blockquote></li><li><p>拟机把内存分为几个不同的数据区，如下：</p><p><img src="/article/Java_garbage_collection_analysis/2.png" alt></p></li></ul><h6><span id="1局部变量表">1.局部变量表</span></h6><p>局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。</p><p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)<br>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了。</p><p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储。</p><h6><span id="2-操作数栈">2. 操作数栈</span></h6><p>操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><h6><span id="3动态连接">3.动态连接</span></h6><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。</p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。</p><p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p><h6><span id="4方法返回">4.方法返回</span></h6><p>当一个方法开始执行时，可能有两种方式退出该方法：</p><ul><li><p>正常完成出口</p></li><li><p>异常完成出口</p></li></ul><p>正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</p><p>异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p><p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出。<br>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。</p><p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。<br>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p><h5><span id="jvm栈的限制">JVM栈的限制</span></h5><p>虽然JVM栈拥有存取速度快，无并发等优势，但它更多的是一种运行时的单位，代表的是程序处理的逻辑。但也存在一些缺陷。<br>1. 由于JVM栈的压栈入栈操作是LIFO（Last-In-First-Out）的，导致的一个问题是：限制了某一个方法的栈帧的生命周期不能超过其调用者。这样对于多线程共享的变量无法在栈中实现。<br>2. 另外的一个问题是：栈帧中的数据大小在编译期必须确定，对于需要大小动态变化的对象无法很好支持。因此JVM栈中主要存放一些大小确定的基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。</p><p><em>因此需要新的内存管理策略-堆管理。</em></p><h4><span id="java堆">Java堆</span></h4><p>Java堆是被所有线程共享的一块内存区域，负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放，在Java中，堆的内存由JVM来自动管理。<br><em>一个典型的java对象的创建过程和在堆中分配过程如下：</em><br><img src="/article/Java_garbage_collection_analysis/1552013740412Java_garbage_collection_analysis_.png" alt></p><h3><span id="堆内存分配方式">堆内存分配方式</span></h3><h4><span id="堆内存">堆内存</span></h4><p>堆内存分配方式分为“指针碰撞”与“空闲列表”两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h5><span id="指针碰撞bump-the-pointer">指针碰撞（Bump the Pointer）</span></h5><p>如果堆内存是完全工整的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。比如ParNew、Serial、G1这种带整理的垃圾回收器，由它们负责回收的区域就采用“指针碰撞”方式来进行内存分配。</p><p><img src="/article/Java_garbage_collection_analysis/1552014318198Java_garbage_collection_analysis_.png" alt></p><h5><span id="空闲列表free-list">空闲列表（free list)</span></h5><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。像CMS垃圾回收器回收后并不对内存进行整理，因此老年代会存在较多的碎片，这样当需要在老年代进行内存分配是，采用的是“空闲列表”的方式。</p><p><img src="/article/Java_garbage_collection_analysis/1552014402454Java_garbage_collection_analysis_.png" alt></p><h4><span id="堆内存分配并发问题">堆内存分配并发问题</span></h4><p>由于堆内存是多线程共享的，因此不管哪种堆分配方式，都不可避免的存在并发问题。JVM主要采用两种方案来解决并发问题：</p><h5><span id="同步处理">同步处理</span></h5><p>JVM采用CAS（Compare and Swap）乐观锁 + 重试机制 来保证多线程更新free list的原子性。</p><h5><span id="tlabthread-local-allocation-buffer">TLAB（Thread Local Allocation Buffer）</span></h5><p>JVM运行中，内存分配是一个比较频繁的动作，同步处理带来的失败重试会对分配性能有较大影响，因此，从java 1.6开始引入了TLAB技术，可以通过-XX:+/-UseTLAB来开启或者关闭（默认是开启的）。TLAB线程的一块私有内存，在线程初始化时，从堆中申请一块指定大小的内存。当前线程需要申请内存时，先从自己的TLAB中分配，容量不够时再通过同步处理从Eden区申请。这样从TLAB中分配时没有并发问题，能大幅提升分配效率。</p><h5><span id="tlab上分配过程">TLAB上分配过程</span></h5><p>TLAB的管理是依靠三个指针：start、end、top。start与end标记了Eden中被该TLAB管理的区域，该区域不会被其他线程分配内存所使用，top是分配指针，开始时指向start的位置，随着内存分配的进行，慢慢向end靠近，当撞上end时触发TLAB refill。每次</p><p>内存中Eden的结构大体为：<br><img src="/article/Java_garbage_collection_analysis/1552014552034Java_garbage_collection_analysis_.png" alt><br>TLAB中分配规则（开启UseTLAB情况下）：</p><ol><li><p>TLAB剩余空间大于待分配对象大小，直接在TLAB上分配返回。</p></li><li><p>如果TLAB剩余空间放不下对象，同时TLAB剩余空间大小 大于允许的浪费阈值（refill_waste），那么本次放弃在TLAB上分配，直接在eden区进行慢分配，TLAB剩余空间留着下次继续使用。</p></li><li><p>如果TLAB剩余空间放不下对象，同时TLAB剩余空间大小 小于允许的浪费阈值，那么进入到“慢分配”过程：<br>a. 丢弃当前TLAB。<br>b. 从eden区裸空间重新分配一个新TLAB，然后对象再在新TLAB上分配。（这里从eden区新申请TLAB时，如果eden区空间不够，会触发YGC。）</p></li></ol><p><img src="/article/Java_garbage_collection_analysis/1552014605838Java_garbage_collection_analysis_.png" alt></p><p><em>几点需要注意的地方：</em></p><ol><li><p>开启TLAB情况下，TLAB占用eden区空间比较小，默认只有Eden空间的1%，可以通过 _-XX:TLABWasteTargetPercent_来调整。</p></li><li><p>默认情况下，TLAB大小和refill_waste阈值都是由JVM在运行时根据“历史统计信息”动态计算出来的，比如一个线程内存分配申请很频繁，可能该线程的TLAB就会更大。如果不想让系统自动调整，可以通过JVM参数来控制：</p><ul><li><p>-XX:-ResizeTLAB （禁用TLAB size的动态调整策略）</p></li><li><p>-XX:TLABSize （指定固定的TLAB size）</p></li><li><p>TLABRefillWasteFraction （可浪费阈值，默认是64：可浪费1/64的TLAB空间)</p></li></ul></li></ol><h3><span id="栈上分配">栈上分配</span></h3><p>以上可知，一般情况下JVM中对象都是在堆中进行内存分配，但是在堆中分配内存虽然有TLAB类似的技术能降低同步带来的开销，但还是存在较多在TLAB上分配不了的情况，另外，堆中分配的对象在生命周期结束后需要专门的垃圾回收器来清理，和栈中内存“方法退出即可销毁”的分配回收相比效率较低。</p><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。为提升第二阶段的执行速度，引入了JIT技术（Just-in-time Compilation），JIT其中主要的工作包括：</p><ul><li><p>“热点代码检测”；</p></li><li><p>热点代码编译优化（逃逸分析、锁消除、锁膨胀、方法内联、空值检查消除等）；</p></li><li><p>缓存热点代码编译后的机器指令；</p></li></ul><p><em>其中编译优化中采用的一种重要技术“逃逸分析”就是优化部分堆上分配为“栈上分配”的基础优化。</em></p><h4><span id="逃逸分析">逃逸分析</span></h4><p>逃逸分析(Escape Analysis)是一种代码分析，通过动态分析对象的作用域，可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸。</p><ul><li><p>方法逃逸 方法中定义的对象被外部方法引用（如：作为调用参数或者返回值被其他方法引用到）；</p></li><li><p>线程逃逸 对象可以被其他线程访问到（如：实例变量、类变量等）</p></li></ul><p>通过 -XX:+DoEscapeAnalysis 参数来控制“逃逸分析”是否开启，jdk 1.8下默认开启。</p><p><em>对于“无法逃逸”的对象，JIT编译器可以对代码进行优化，主要有以下几种优化方式：</em></p><h5><span id="同步消除">同步消除</span></h5><p>线程同步的消耗较大，通过“逃逸分析”，如果确定一个对象不会被其他线程访问到，那对这个对象的读写就不会存在并发问题，因此可以清除该对象的同步锁。</p><p><em>如下示例：该对象的同步锁在编译优化阶段去掉了，提升执行性能。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        System.out.println(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>通过 -XX:+EliminateLocks 参数来控制“同步消除”是否开启，jdk 1.8下默认开启。</em></p><h5><span id="标量替换">标量替换</span></h5><p>JIT经过“逃逸分析”发现一个对象只在方法内部使用不会被外界访问时，会在编译优化过程中把这个对象的成员变量拆解成若干个原始数据类型的标量来进行替代，这个过程就是“标量替换”。通过这种方式就能间接实现堆上对象不用在堆上分配而是通过替代的标量在栈上分配了。</p><p><em>如下示例：经过标量替换后，User对象被替换成两个标量了，从而避免在堆上进行分配。</em></p><pre><code class="language-java">    public void sayHi() {        User user = new User(1, 14100L);        System.out.println(&quot;Say Hi to:&quot; + user.uid + &quot;,&quot; + user.staffNum);    }    class User {        private int uid;        private long staffNum;    }        public void sayHi() {        int uid = 1;        long staffNum = 14100L;        System.out.println(&quot;Say Hi to:&quot; + uid + &quot;,&quot; + staffNum);    }</code></pre><p><em>通过 -XX:+EliminateAllocations 参数来控制“标量替换”是否开启，jdk 1.8下默认开启。</em></p><h5><span id="栈上分配">栈上分配</span></h5><p>如果确定一个对象不会逃逸出方法之外，那么让对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧的出栈而销毁。目前JVM没有实现真正的“栈上分配”，而是通过“标量替换”来间接实现的。</p><h3><span id="总结">总结</span></h3><p>由以上整理可知，虚拟机对象分配流程大概如下：首先如果开启栈上分配，JVM会先进行栈上分配，如果没有开启栈上分配或则不符合条件的则会进行TLAB分配，如果TLAB分配不成功，再尝试在eden区分配，如果对象满足了直接进入老年代的条件，那就直接分配在老年代。在eden区和老年代分配主要通过“指针碰撞”和“空闲列表”两种方式实现，通过CAS解决堆上“非TLAB方式分配”的并发问题。</p><p><img src="/article/Java_garbage_collection_analysis/1552015190523Java_garbage_collection_analysis_.png" alt></p><hr><p><em>参考:</em><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析系列（1）</title>
      <link href="/article/java-hash-map/"/>
      <url>/article/java-hash-map/</url>
      
        <content type="html"><![CDATA[<h2><span id="map-类继承图">MAP 类继承图</span></h2><p><img src="/article/java-hash-map/1557200957110java-hash-map_.png" alt></p><h3><span id="hashmap">HashMap：</span></h3><ul><li>KV结构，高效</li><li>无序</li><li>key为null，但是只允许有一个key为null，再次说明，</li><li>HashMap不是线程安全的。</li></ul><h3><span id="linkedhashmap">LinkedHashMap：</span></h3><p>LinkedHashMap是HashMap的子类，它将保持记录的插入顺序。</p><h3><span id="treemap">TreeMap：</span></h3><p>TreeMap实现了SortedMap接口，很明显，他将对插入的记录排序，</p><h2><span id="hashmap-内部结构">HashMap 内部结构</span></h2><p>首先来看一下HashMap内部结构是什么样子的。通过观察源码，可以发现HashMap在实现上使用了数组+链表+红黑树三种数据结构</p><p><img src="/article/java-hash-map/1557201231442java-hash-map_.png" alt></p><p>HashMap是通过计算key的hashCode来找到记录的存储位置的，那因为hash函数不会台完美的原因，势必要造成多个记录的key的hashCode一样的情况，上图展示了这种情况，完美情况下，我们希望每一个数组位置上仅有一个记录，但是很多情况下一个数组位置上会落入多个记录，也就是哈希冲突。<br>解决哈希冲突的方法主要有开发地址和链地址，HashMap采用了后者，将hashCode相同的记录放在同一个数组位置上，多个hashCode相同的记录被存储在一条链表上，我们知道，链表上的查询复杂的为O(N)，当这个N很大的时候也就成了瓶颈，所以HashMap在链表的长度大于8的时候就会将链表转换为红黑树这种数据结构，红黑树的查询效率高达O(lgN)，也就是说，复杂度降了一个数量级，完全可以适用于实际生产环境。下面是链表节点数据结构的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//哈希值，HashMap用这个值来确定记录的位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">//记录key</span></span><br><span class="line">        V value; <span class="comment">//记录value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">//链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是上面图中展示的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>这个table就是存储数据的数组，上面图中的每个黑色的球是一个Node。下面展示了几个重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="keyword">int</span> threshold;    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，HashMap的哈希桶table的大小必须为2的n次方，也就是说必须为合数，初始大小为16，下文中将会说明为什么一定要是2的n次方。size字段的意思是当前记录数量，loadFactor是负载因子，默认为0.75，而threshold是作为扩容的阈值而存在的，它是由负载银子决定的。下面的方法是返回与给定数值最接近的2的n次方的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2><span id="hashmap如何确定记录的table位置">HashMap如何确定记录的table位置</span></h2><p>下面的方法hash展示了HashMap是如何计算记录的hashCode值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的hash方法仅仅是第一步，它只是计算出了hashCode值，但是还可以确定table中的index，接下来的一步需要做的就是根据hashCode来定位index，也就是需要对hashCode取模（hashCode % length），length是table的长度，但是我们知道，取模运算是较为复杂的计算，是非常耗时的计算，那有没有方法不通过取模计算而达到取模的效果呢，答案是肯定的，上文中提到，table的长度必然是2的n次方，这点很重要，HashMap通过设定table的长度为2的n次方，在取模的时候就可以通过下面的算法来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hashCode &amp; (length -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在length总是2的n次方的前提下，上面的算法等效于hashCode%length，但是现在通过使用&amp;代替了%，而&amp;的效率要远比%高</p><h2><span id="hashmap插入元素的过程详解">HashMap插入元素的过程详解</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>过程的详细分析</p><ul><li>首先判断table是否为null或者长度为0，如果是，那么调用方法resize来初始化table，resize的细节将在下文中进行分析，这个方法用来对HashMap的table数组扩容，它将发生在初始化table以及table中的记录数量达到阈值之后。</li><li>然后计算记录的hashCode，以及根据上文中提到的方法来计算记录在table中的index，如果发现index未知上为null，则调用newNode来创建一个新的链表节点，然后放在table的index位置上，此时表面没有哈希冲突。</li><li>如果table的index位置不为空，那么说明造成了哈希冲突，这时候如果记录和index位置上的记录相等，则直接覆盖，否则继续判断</li><li>如果index位置上的节点TreeNode，如果是，那么说明此时的index位置上是一颗红黑树，需要调用putTreeVal方法来将这新的记录插入到红黑树中去。否则走下面的逻辑。</li><li>如果index位置上的节点类型不是TreeNode，那么说明此位置上的哈希冲突还没有达到阈值，还是一个链表结构，那么就根据插入链表插入新节点的算法来找到合适的位置插入，这里面需要注意的是，新插入的记录会覆盖老的记录，如果这个新的记录是首次插入，那么就会插入到该index位置上链表的最尾部，这里面还需要一次判断，如果插入了新的节点之后达到了阈值，那么就需要调用方法+treeifyBin来讲链表转化为红黑树。</li><li>在插入完成之后，哈希桶中记录的数量是否达到了哈希桶设置的阈值，如果达到了，那么就需要调用方法resize来扩容。</li></ul><h2><span id="hashmap扩容resize方法详解">HashMap扩容resize方法详解</span></h2><p>上文分析了HashMap的put方法的细节，其中提到，当初始化table以及记录数量达到阈值之时会触发HashMap的扩容，而扩容是通过方法resize来进行的，下面来分析一下resize方法是如何工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面展示了resize方法的细节，可以看到扩容的实现时较为复杂的，但是我们知道所谓扩容，就是新申请一个较大容量的数组table，然后将原来的table中的内容都重新计算哈希落到新的数组table中来，然后将老的table释放掉。这里面有两个关键点，一个是新哈希数组的申请以及老哈希数组的释放，另外一个是重新计算记录的哈希值以将其插入到新的table中去。首先第一个问题是，扩容会扩大到多少，通过观察上面的代码可以确定，每次扩容都会扩大table的容量为原来的两倍，当然有一个最大值，如果HashMap的容量已经达到最大值了，那么就不会再进行扩容操作了。第二个问题是HashMap是如何在扩容之后将记录从老的table迁移到新的table中来的。上文中已经提到，table的长度确保是2的n次方，那么有意思的是，每次扩容容量变为原来的两倍，那么一个记录在新table中的位置要么就和原来一样，要么就需要迁移到(oldCap + index)的位置上。下面简单来证明一下这个算法的正确性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设原来的table大小为4，那么扩容之后会变为8，那么对于一个元素A来说，如果他的hashCode值为3，那么他在原来的table</span><br><span class="line">上的位置为(3 &amp; 3) = 3,那么新位置呢？(3 &amp; 7) = 3,这种情况下元素A的index和原来的index是一致的不用变。再来看一个</span><br><span class="line">元素B，他的hashCode值为47，那么在原来table中的位置为(47 &amp; 3) = 3，在新table中的位置为(47 &amp; 7) = 7，也就</span><br><span class="line">是（3 + 4），正好偏移了oldCap个单位。</span><br></pre></td></tr></table></figure><p>之所以可以这么算是因为<br>还是上面的两个元素A和B，哈希值分别为<code>3</code>和<code>47</code>，在table长度为4的情况下，因为<code>3</code> 二进制为 <code>11</code>，所以A和B会有两位参与运算来<br>获得index，A和B的二进制分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 ： 11</span><br><span class="line">47： 101111</span><br></pre></td></tr></table></figure><p>在table的length为4的前提下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3-&gt; 11 &amp; 11 = 3</span><br><span class="line">47-&gt; 000011 &amp; 101111 = 3</span><br></pre></td></tr></table></figure><p>在扩容后，length变为8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3-&gt; 011 &amp; 111 = 3</span><br><span class="line">47-&gt; 10111 &amp; 00111 = 7</span><br></pre></td></tr></table></figure><p>对于<code>3</code>来说，新增的参与运算的位为<code>0</code>，所以index不变，而对于47来说，新增的参与运算的位为<code>1</code>，所以<br><code>index</code>需要变为(<code>index</code> + <code>oldCap</code>)</p><h2><span id="hashmap获取记录操作详解">HashMap获取记录操作详解</span></h2><p>首先，因为可能会发生哈希冲突，所以我们需要获取的记录可能会存储在一个链表上，也可能存储在一棵红黑树上，这需要实际判断，所以，获取操作首先应该就算记录的hashCode，然后根据hashCode来计算在table中的index，然后判断该数组位置上是一条链表还是一棵红黑树，如果是链表，那么就遍历链表来找到我们需要的记录，否则如果是一棵红黑树，那么就通过遍历这棵红黑树找到我们需要的记录.</p><p>当然，寻找记录可能会找不到，因为可能我们获取的记录根本就不存在，那么就要返回null暗示用户，当然，HashMap返回null不仅可以代表没有这个记录的信息之外，还可以代表该记录key对应着的value就是null，所以你不能通过HashMap是否返回null来判断HashMap中是否有相应的记录，如果你有类似的需求，你应该调用HashMap的方法：containsKey，这个方法将在下文中进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先会获得当前table的一个快照，然后根据需要查找的记录的key的hashCode来定位到table中的index，如果该位置为null，说明没有没有记录落到该位置上，也就不存在我们查找的记录，直接返回null。如果该位置不为null，说明至少有一个记录落到该位置上来，那么就判断该位置的第一个记录是否使我们查找的记录，如果是则直接返回，否则，根据该index上是一条链表还是一棵红黑树来分别查找我们需要的记录，找到则返回记录，否则返回null。下面来看一下如何判断HashMap中是否有一个记录的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用了getNode来从table中获得一个Node，返回null，说明不存在该记录，否则存在，containsKey方法和get方法都是通过调用getNode方法来进行的，但是他们的区别在于get方法在判断得到的Node不为null的情况下任然可能返回null，因为Node的value可能为null，所以应该在合适的时候调用合适的方法。</p><h2><span id="hashmap删除记录详解">HashMap删除记录详解</span></h2><p>现在来看一下HashMap是如何实现删除一个记录的。下面首先展示了相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过记录的hashCode来找到他在table中的index，因为最后需要返回被删除节点的值，所以需要记录被删除的节点。当然记录被删除的节点也是有意义的，比如对于table中的index位置上为一条链表的情况来说，我们只需要记住需要删除的Node，然后真正删除的时候就可以只需要操作该node就可以了，当然对于链表的相关操作详解将在另外的篇章中进行。以及红黑树等高级数据结构的分析总结也会在新的篇章中介绍，目前只需要知道HashMap通过在合适的时候使用不同的数据结构来达到高效的目的就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(2)-- Java对象内存布局</title>
      <link href="/article/java-mem-objecat/"/>
      <url>/article/java-mem-objecat/</url>
      
        <content type="html"><![CDATA[<h1><span id="java对象内存布局">Java对象内存布局</span></h1><p>我们知道在Java中基本数据类型的大小，例如int类型占4个字节、long类型占8个字节，那么Integer对象和Long对象会占用多少内存呢？本文介绍一下Java对象在堆中的内存结构以及对象大小的计算。</p><h2><span id="对象的内存布局">对象的内存布局</span></h2><p>一个Java对象在内存中包括对象头、实例数据和补齐填充3个部分：</p><p><img src="/article/java-mem-objecat/1552620309961java-mem-objecat_.png" alt></p><h3><span id="对象头">对象头</span></h3><ul><li><strong>Mark Word</strong>：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；</li><li><strong>Class Pointer</strong>：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节；</li><li><strong>Length</strong>：如果是数组对象，还有一个保存数组长度的空间，占4个字节；</li></ul><h3><span id="对象实际数据">对象实际数据</span></h3><p>对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）。</p><table><thead><tr><th>Primitive Type</th><th>Memory Required(bytes)</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr></tbody></table><p><em>对于reference类型来说，在32位系统上占用4bytes, 在64位系统上占用8bytes。</em></p><h3><span id="对齐填充">对齐填充</span></h3><p>Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。例如，一个包含两个属性的对象：int和byte，这个对象需要占用8+4+1=13个字节，这时就需要加上大小为3字节的padding进行8字节对齐，最终占用大小为16个字节。</p><p>注意：以上对64位操作系统的描述是未开启指针压缩的情况，关于指针压缩会在下文中介绍。</p><h2><span id="对象头分析">对象头分析</span></h2><h3><span id="对象头占用空间大小">对象头占用空间大小</span></h3><p>这里说明一下32位系统和64位系统中对象所占用内存空间的大小：</p><ul><li>在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;</li><li>在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;</li><li>64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，<code>MarkWord</code>是8字节，对象头为12字节;</li><li>如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组<code>MarkWord</code>为4字节（64位未开启指针压缩的为8字节）;</li><li>静态属性不算在对象大小内。</li></ul><h3><span id="对象头分析">对象头分析</span></h3><p>HotSpot虚拟机的对象头(Object Header)包括两部分信息</p><ul><li><p>第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p></li><li><p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p></li></ul><p>在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示：</p><p><img src="/article/java-mem-objecat/java-mem-objecat-223902.png" alt></p><p>在 64 位系统及 64 位 JVM 下，开启指针压缩，那么头部存放 Class 指针的空间大小还是4字节，而 Mark Word 区域会变大，变成 8 字节，也就是头部最少为 12 字节，如下表所示：</p><p><img src="/article/java-mem-objecat/java-mem-objecat-224343.png" alt></p><p>这里几个概念</p><ul><li>unused：未使用的</li><li>epoch: 验证偏向锁有效性的时间戳</li><li>cmd_free : cms垃圾收集器相关 可不用关心</li></ul><p>关于偏向锁和重量解锁等相关的，这里不做讨论， 感兴趣的请参见我另外一篇博文<a href="https://icefrozen.github.io/article/java-synchronized/" target="_blank" rel="noopener">深入分析synchronized原理和锁膨胀过程</a></p><h3><span id="直观的观察">直观的观察</span></h3><p>我们使用JOL 工具来查看一下一个对象的真是内存布局。有关<a href="https://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">JOL</a>的信息。</p><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LayOutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        objectLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========Object layout==========="</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        String s = ClassLayout.parseInstance(obj).toPrintable();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加入JVM参数<ul><li>-XX:-UseCompressedClassPointers</li><li>-XX:-UseCompressedOops</li></ul></li></ul><blockquote><p>这里是关闭类指针压缩和成员变量的指针压缩，关于指针压缩后面或详细分析，为了使得我们的实验不受到指针压缩的硬性，我们默认项关闭这两个指针压缩选项。</p></blockquote><ul><li>执行并得到输出如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">    <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">2</span>c ad <span class="number">0</span>d (<span class="number">00000000</span> <span class="number">00101100</span> <span class="number">10101101</span> <span class="number">00001101</span>) (<span class="number">229452800</span>)</span><br><span class="line">    <span class="number">12</span>    <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure><p>我们来分析一下</p><table><thead><tr><th>OFFSET</th><th>SIZE</th><th>TYPE DESCRIPTION</th><th>VALUE</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>(object header)</td><td>01 00 00 00 (<code>00000001</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (1)</td></tr><tr><td>4</td><td>4</td><td>(object header)</td><td>00 00 00 00 (<code>00000000</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (0)</td></tr><tr><td>8</td><td>4</td><td>(object header)</td><td>00 2c ad 0d (<code>00000000</code> <code>00101100</code> <code>10101101</code> <code>00001101</code>) (229452800)</td></tr><tr><td>12</td><td>4</td><td>(object header)</td><td>01 00 00 00 (<code>00000001</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (1)</td></tr></tbody></table><p>按照大小端重新排列一下得到：<br><strong>由于我们是64位的系统，所以，我们的前8个字节位mark （64bit）结构如下</strong></p><p><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</code></p><p>可以做如下划分：</p><table><thead><tr><th>0 - 55（56bit）</th><th>cms_free</th><th>分带年龄</th><th>偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>00000000 00000000 00000000 00000000 00000000 00000000 00000000</td><td>0</td><td>0000</td><td>0</td><td>01</td></tr></tbody></table><p>后面8个字节如下(Class Pointer)表示对象的类的指针。</p><p><code>00001101 10101101 00101100 00000000 00000001 00000000 00000000 00000000</code></p><ul><li>这里我们看到mark word 是无所状态，但是并没存贮hashcode。这是因为，如果我们要存入hashcode，必须要执行一次hascode代码，我们修改上述代码为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"=========Object layout==========="</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(<span class="string">"hash code:"</span> + hashCode + <span class="string">":"</span> + Integer.toBinaryString(hashCode));</span><br><span class="line">        String s = ClassLayout.parseInstance(obj).toPrintable();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash code:<span class="number">1581781576</span>:<span class="number">1011110010010000001001001001000</span></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">48</span> <span class="number">12</span> <span class="number">48</span> (<span class="number">00000001</span> <span class="number">01001000</span> <span class="number">00010010</span> <span class="number">01001000</span>) (<span class="number">1209157633</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01011110</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">94</span>)</span><br><span class="line">    <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">7</span>c <span class="number">1</span>c <span class="number">0</span>e (<span class="number">00000000</span> <span class="number">01111100</span> <span class="number">00011100</span> <span class="number">00001110</span>) (<span class="number">236747776</span>)</span><br><span class="line">    <span class="number">12</span>    <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure><p>我们依然按照上面的来划分得到：</p><table><thead><tr><th>0 - 23</th><th>24-55（56bit） hashcode</th><th>cms_free</th><th>分带年龄</th><th>偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>00000000 00000000 00000000</td><td>0<code>1011110 01001000 00010010 01001000</code></td><td>0</td><td>0000</td><td>0</td><td>01</td></tr></tbody></table><p>而：<code>hash code:1581781576:1011110010010000001001001001000</code><br>由此我们可以得到结论 在对象头的 24-55 位的bit 存放的是 hashcode值。</p><h2><span id="指针压缩">指针压缩</span></h2><p>从上文的分析中可以看到，64位JVM消耗的内存会比32位的要多大约1.5倍，这是因为对象指针在64位JVM下有更宽的寻址。对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用，这是开发者不愿意看到的。</p><p>从JDK 1.6 update14开始，64位的JVM正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。</p><p>我们刚才在启动的虚拟机上增加了两个选项：</p><ul><li>UseCompressedOops：普通对象指针压缩</li><li>UseCompressedClassPointers：类指针压缩</li></ul><h3><span id="什么是oop">什么是OOP？</span></h3><p>OOP的全称为：Ordinary Object Pointer，就是普通对象指针。启用CompressOops后，会压缩的对象：</p><ul><li>每个Class的属性指针（静态成员变量）；</li><li>每个对象的属性指针；</li><li>普通对象数组的每个元素指针。</li></ul><p>当然，压缩也不是所有的指针都会压缩，对一些特殊类型的指针，JVM是不会优化的，例如指向PermGen的Class对象指针、本地变量、堆栈元素、入参、返回值和NULL指针不会被压缩。</p><h3><span id="启用指针压缩"> 启用指针压缩</span></h3><p>在Java程序启动时增加JVM参数：<code>-XX:+UseCompressedOops</code>来启用。</p><p><em>注意：32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。</em></p><p>本文中使用的是JDK 1.8，默认该参数就是开启的。</p><h3><span id="usecompressedclasspointers-与-usecompressedoops">UseCompressedClassPointers 与 UseCompressedOops</span></h3><p>由于UseCompressedClassPointers的开启是依赖于UseCompressedOops的开启。因此，要使UseCompressedClassPointers起作用，得先开启UseCompressedOops，并且开启UseCompressedOops 也默认开启UseCompressedClassPointers，关闭UseCompressedOops 默认关闭UseCompressedClassPointers。</p><p>如果开启了  UseCompressedClassPointers 但是关闭额 UseCompressedOops</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCompressedClassPointers -XX:-UseCompressedOops</span><br><span class="line"><span class="comment">// java 虚拟机会报错</span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: UseCompressedClassPointers <span class="keyword">requires</span> UseCompressedOops</span></span><br></pre></td></tr></table></figure><h3><span id="观察开启指针压缩时的对象大小">观察开启指针压缩时的对象大小</span></h3><p>增加 <code>-XX:+UseCompressedClassPointers -XX:+UseCompressedOops</code><br>再次运行 objectLayout 方法<br>得到输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><p>我们看到了有这么一句话 loss due to the next object alignment<br>表示的是 从12 开始 有4个B 用于对齐。所有开启针织压缩后 对于类指针由8个字节压缩到了4个字节。</p><h3><span id="其他方式查看对象大小">其他方式查看对象大小</span></h3><blockquote><p>我们也可以使用<a href="http://www.javamex.com/" target="_blank" rel="noopener">http://www.javamex.com/</a>中提供的<a href="http://www.javamex.com/classmexer/classmexer-0_03.zip" target="_blank" rel="noopener">classmexer.jar</a>来计算对象的大小。 具体用法需加上-javaagent 参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行环境：JDK 1.8，Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line"></span><br><span class="line">[](#基本数据类型 &quot;基本数据类型&quot;)基本数据类型</span><br><span class="line">---</span><br><span class="line">对于基本数据类型来说，是比较简单的，因为我们已经知道每个基本数据类型的大小。代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line">  * VM options:</span><br><span class="line">  * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span><br><span class="line">  * -XX:+UseCompressedOops</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class TestObjectSize &#123;</span><br><span class="line">    int a;</span><br><span class="line">    long b;</span><br><span class="line">    static int c;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        TestObjectSize testObjectSize = new TestObjectSize();</span><br><span class="line">        // 打印对象的shallow size</span><br><span class="line">        System.out.println(&quot;Shallow Size: &quot; \+ MemoryUtil.memoryUsageOf(testObjectSize) + &quot; bytes&quot;);</span><br><span class="line">        // 打印对象的 retained size</span><br><span class="line">        System.out.println(&quot;Retained Size: &quot; \+ MemoryUtil.deepMemoryUsageOf(testObjectSize) + &quot; bytes&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：在运行前需要设置javaagent参数，在JVM启动参数中添加<code>-javaagent:/path_to_agent/classmexer.jar</code>来运行。</em></p><p>有关Shallow Size和Retained Size请参考<a href="http://blog.csdn.net/e5945/article/details/7708253" target="_blank" rel="noopener">http://blog.csdn.net/e5945/article/details/7708253</a>。</p><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>运行查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>根据上文的分析可以知道，64位开启指针压缩的情况下：</p><ul><li>对象头大小=Class Pointer的空间大小为4字节+<code>MarkWord</code>为8字节=12字节；</li><li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）<br>在MAT中分析的结果如下：<br><img src="/article/java-mem-objecat/%5B!%5Bdump1.png%5D(/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/dump1.png)%5D(/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/dump1.png)java-mem-objecat_.png" alt></li></ul><p>所以大小是24字节。其实这里并没有padding，因为正好是24字节。如果我们把<code>long b;</code>换成<code>int b;</code>之后，再来看一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>大小并没有变化，说明这里做了padding，并且padding的大小是4字节。<br>这里的Shallow Size和Retained Size是一样的，因为都是基本数据类型。</p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>如果要关闭指针压缩，在JVM参数中添加<code>-XX:-UseCompressedOops</code>来关闭，再运行上述代码查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>分析一下在64位未开启指针压缩的情况下：</p><ul><li>对象头大小=Class Pointer的空间大小为8字节+<code>MarkWord</code>为8字节=16字节；</li><li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）；</li></ul><p>这里计算后大小为16+12=28字节，这时候就需要padding来补齐了，所以padding为4字节，最后的大小就是32字节。</p><p>我们再把<code>long b;</code>换成<code>int b;</code>之后呢？通过上面的计算结果可以知道，实际数据大小就应该是int类型4字节+int类型4字节=8字节，对象头大小为16字节，那么不需要做padding，对象的大小为24字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><h3><span id="数组类型">数组类型</span></h3><p>64位系统中，数组对象的对象头占用24 bytes，启用压缩后占用16字节。比普通对象占用内存多是因为需要额外的空间存储数组的长度。基础数据类型数组占用的空间包括数组对象头以及基础数据类型数据占用的内存空间。由于对象数组中存放的是对象的引用，所以数组对象的Shallow Size=数组对象头+length _引用指针大小，Retained Size=Shallow Size+length_每个元素的Retained Size。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">16</span> bytes</span><br><span class="line">Retained Size: <span class="number">80</span> bytes</span><br></pre></td></tr></table></figure><p>Shallow Size比较简单，这里对象头大小为12字节， 实际数据大小为4字节，所以Shallow Size为16。</p><p>对于Retained Size来说，要计算数组占用的大小，对于数组来说，它的对象头部多了一个用来存储数组长度的空间，该空间大小为4字节，所以<em><em>数组对象的大小=引用对象头大小12字节+存储数组长度的空间大小4字节+数组的长度</em>数组中对象的Retained Size+padding大小</em>*</p><p>下面分析一下上述代码中的<code>long[] arr = new long[6];</code>，它是一个长度为6的long类型的数组，由于long类型的大小为8字节，所以数组中的实际数据是6*8=48字节，那么数组对象的大小=12+4+6*8+0=64，最终的Retained Size=Shallow Size + 数组对象大小=16+64=80。</p><p>通过MAT查看如下：<br><img src="/article/java-mem-objecat/1552621324467java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">96</span> bytes</span><br></pre></td></tr></table></figure><p>这个结果大家应该能自己分析出来了，因为这时引用对象头为16字节，那么数组的大小=<code>16+4+6*8+4=72</code>，（这里最后一个4是padding），所以Retained Size=Shallow Size + 数组对象大小=<code>24+72=96</code>。<br>通过MAT查看如下：</p><p><img src="/article/java-mem-objecat/1552621398448java-mem-objecat_.png" alt></p><h3><span id="包装类型">包装类型</span></h3><p>包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小等于对象头大小加上底层基础数据类型的大小。</p><p>包装类型的Retained Size占用情况如下：</p><table><thead><tr><th>Numberic Wrappers</th><th>+useCompressedOops</th><th>-useCompressedOops</th></tr></thead><tbody><tr><td>Byte, Boolean</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Short, Character</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Integer, Float</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Long, Double</td><td>24 bytes</td><td>24 bytes</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    Boolean a = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line">    Byte b = <span class="keyword">new</span> Byte(<span class="string">"1"</span>);</span><br><span class="line">    Short c = <span class="keyword">new</span> Short(<span class="string">"1"</span>);</span><br><span class="line">    Character d = <span class="keyword">new</span> Character(<span class="string">'a'</span>);</span><br><span class="line">    Integer e = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Float f = <span class="keyword">new</span> Float(<span class="number">2.5</span>);</span><br><span class="line">    Long g = <span class="keyword">new</span> Long(<span class="number">123L</span>);</span><br><span class="line">    Double h = <span class="keyword">new</span> Double(<span class="number">2.5</span>D);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">48</span> bytes</span><br><span class="line">Retained Size: <span class="number">192</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621628680java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">80</span> bytes</span><br><span class="line">Retained Size: <span class="number">272</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621649963java-mem-objecat_.png" alt></p><h3><span id="string类型">String类型</span></h3><p>在JDK1.7及以上版本中，<code>java.lang.String</code>中包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode, 部分源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    /\*\* Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在关闭指针压缩时，一个String对象的大小为：</p><ul><li><p><strong>Shallow Size=对象头大小16字节+int类型大小4字节+数组引用大小8字节+padding4字节=32字节</strong>；</p></li><li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p></li></ul><p>在开启指针压缩时，一个String对象的大小为：</p><ul><li><p><strong>Shallow Size=对象头大小12字节+int类型大小4字节+数组引用大小4字节+padding4字节=24字节</strong>；</p></li><li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"test"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shallow Size: <span class="number">16</span> bytes</span><br><span class="line">Retained Size: <span class="number">64</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621814345java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">88</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552622306091java-mem-objecat_.png" alt></p><h3><span id="其他引用类型的大小">其他引用类型的大小</span></h3><p>根据上面的分析，可以计算出一个对象在内存中的占用空间大小情况，其他的引用类型可以参考分析计算过程来计算内存的占用情况。</p><h2><span id="关于padding">关于padding</span></h2><p>思考这样一个问题，是不是padding都加到对象的后面呢，如果对象头占12个字节，对象中只有1个long类型的变量，那么该long类型的变量的偏移起始地址是在12吗？用下面一段代码测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用Unsafe类来查看变量的偏移地址，运行后结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>如果是换成int类型的变量呢？结果是12。</p><p>现在一般的CPU一次直接操作的数据可以到64位，也就是8个字节，那么字长就是64，而long类型本身就是占64位，如果这时偏移地址是12，那么需要分两次读取该数据，而如果偏移地址从16开始只需要通过一次读取即可。int类型的数据占用4个字节，所以可以从12开始。</p><p>把上面的代码修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line"></span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("b")));</span><br><span class="line"></span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("c")));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p>在本例中，如果变量的大小小于等于4个字节，那么在分配内存的时候会先优先分配，因为这样可以减少padding，比如这里的b和c变量；如果这时达到了16个字节，那么其他的变量按照类型所占内存的大小降序分配。</p><p>再次修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM options: -javaagent:D:\\source-files\\classmexer.jar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">long</span> g;</span><br><span class="line">    <span class="keyword">double</span> h;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println("field a --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field b --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("b")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field c --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("c")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field d --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field e --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("e")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field f --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("f")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field g --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("g")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field h --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("h")));</span><br><span class="line"></span><br><span class="line">        PaddingTest paddingTest = <span class="keyword">new</span> PaddingTest();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span>+ MemoryUtil.memoryUsageOf(paddingTest));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(paddingTest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">field a --&gt; <span class="number">40</span></span><br><span class="line">field b --&gt; <span class="number">41</span></span><br><span class="line">field c --&gt; <span class="number">36</span></span><br><span class="line">field d --&gt; <span class="number">38</span></span><br><span class="line">field e --&gt; <span class="number">12</span></span><br><span class="line">field f --&gt; <span class="number">32</span></span><br><span class="line">field g --&gt; <span class="number">16</span></span><br><span class="line">field h --&gt; <span class="number">24</span> </span><br><span class="line">Shallow Size: <span class="number">48</span></span><br><span class="line">Retained Size: <span class="number">48</span></span><br></pre></td></tr></table></figure><p>可以看到，先分配的是int类型的变量e，因为它正好是4个字节，其余的都是先从g和h变量开始分配的，因为这两个变量是long类型和double类型的，占64位，最后分配的是a和b，它们只占一个字节。</p><p>如果分配到最后，这时字节数不是8的倍数，则需要padding。这里实际的大小是42字节，所以padding6字节，最终占用48字节。</p><h2><span id="原文地址">原文地址</span></h2><p><img src="http://www.ideabuffer.cn/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" alt="http://www.ideabuffer.cn/2017/05/06/Java对象内存布局/"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
