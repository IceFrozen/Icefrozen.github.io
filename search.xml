<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事务详解（1）-- 隔离级别</title>
      <link href="/article/distributed-transaction-1/"/>
      <url>/article/distributed-transaction-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="概要">概要</span></h2><p>本文主要讨论的是事务隔离级别，从事务隔离级别的起源，标准和本质来深入分析事务并发控制下的隔离级别的原理和实现。阅读文本前，你需要具备事务的一些基本知识，本文的第一章节会回顾我们所熟知的有关隔离级别和事务的基础知识。如果你了解事务的一般基础知识，你可以跳过第一章节，直接阅读第二章节。</p><h2><span id="事务概述">事务概述</span></h2><h1><span id="什么是事务">什么是事务</span></h1><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p><h1><span id="事务的四大特性acid">事务的四大特性ACID</span></h1><h2><span id="原子性atomicity"><strong>原子性（Atomicity）</strong>:</span></h2><p>事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</p><h2><span id="一致性consistency"><strong>一致性（Consistency）</strong> :</span></h2><p>一致性是指事务必须使数据库从一个一致性状态变成另一个一致性状态，也就是事务执行前后必须处于一致性状态。</p><h2><span id="隔离性isolation"><strong>隔离性（Isolation）</strong>:</span></h2><p>一个事务所做的修改在最终提交以前，对其他事务是不可见，当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其它的事务操作所干扰，多个并发事务之间要相互隔离。</p><h2><span id="持久性durability"><strong>持久性（Durability)</strong>：</span></h2><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><h1><span id="事务的隔离级别">事务的隔离级别</span></h1><h2><span id="事务并发的问题">事务并发的问题</span></h2><h3><span id="1脏读读取未提交数据">【1】脏读（读取未提交数据）</span></h3><p>当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:left">3</td><td></td><td>查询余额1000</td></tr><tr><td style="text-align:left">4</td><td></td><td>取出 500 余额为 500</td></tr><tr><td style="text-align:left">5</td><td>查询账户余额 500</td><td></td></tr><tr><td style="text-align:left">6</td><td></td><td>出错，撤销事务 余额为1000</td></tr><tr><td style="text-align:left">7</td><td>汇入100 余额 600</td><td></td></tr><tr><td style="text-align:left">8</td><td>提交事务</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照逻辑，转账事务读取了B 撤销后的事务出现脏读</td><td></td></tr></tbody></table><h3><span id="2不可重复读前后多次读取数据内容不一致">【2】不可重复读（前后多次读取，数据内容不一致）</span></h3><p>在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>begin</td><td></td></tr><tr><td style="text-align:left">2</td><td>第一次查询余额 100</td><td></td></tr><tr><td style="text-align:left">3</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">4</td><td>其他操作</td><td></td></tr><tr><td style="text-align:left">5</td><td></td><td>消费30 余额 变为 70</td></tr><tr><td style="text-align:left">6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:left">7</td><td>第二次查询 余额为70</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照正确的逻辑，事务A前后两次读取的数据应该一致</td><td></td></tr></tbody></table><h3><span id="3幻读前后多次读取数据总量不一致">【3】幻读（前后多次读取，数据总量不一致）</span></h3><p>在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。</p><table><thead><tr><th style="text-align:left">时间顺序</th><th>统计金额事务</th><th>转账事务 B</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:left">2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:left">3</td><td>统计金额为（100个账户）10000</td><td></td></tr><tr><td style="text-align:left">4</td><td></td><td></td></tr><tr><td style="text-align:left">5</td><td></td><td>新增一个存款账户，余额为100</td></tr><tr><td style="text-align:left">6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:left">7</td><td>再次统计存款 为 10100 元</td><td></td></tr><tr><td style="text-align:left">备注</td><td>按照正确的逻辑，统计事务后出现了幻读（数据行发生了变化）</td><td></td></tr></tbody></table><h2><span id="数据库的隔离级别">数据库的隔离级别</span></h2><p>为了解决多个事务并发会引发的问题，进行并发控制。数据库系统提供了四种事务隔离级别供用户选择。</p><h3><span id="read-uncommitted-读未提交"><strong>Read Uncommitted 读未提交</strong>：</span></h3><p>即允许当前会话事务读取到其他会话中未提交事务修改的数据，可能导致脏读。</p><h3><span id="read-committed-读已提交"><strong>Read Committed 读已提交</strong>：</span></h3><p>只能读取到已成功提交事务的数据，因此可以避免发生脏读，但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。即事务前后两次读取的数据不一致。</p><h3><span id="repeatable-read-重复读"><strong>Repeatable Read 重复读</strong></span></h3><p>重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。但可能出现幻读。（这里为什么会出现幻读，参见后面的文章）</p><h3><span id="serializable-可串行化"><strong>Serializable 可串行化</strong>：</span></h3><p>所有的增删改查串行执行。(这里强调可串行化，而非真生意义上的串行化。读写操作是并发的，但是其效果等价于串行化执行，因此这里用可串行化来表述)</p><h2><span id="隔离级别的本质">隔离级别的本质</span></h2><p>上一个章节，对事务公共认知做了一个简单的介绍，这些认知是基于大众的普遍知识。你可能意识到，上一节的只是事实上来说并不完全，因为似乎少了某些异常情况。例如说，丢失更新等。<br>事实上，你的感觉并没有错，因为确实在异常中有很多不尽如人意的地方，这都取决于这套标准的制定。接下来，我将展开一些对着写公共认知更为细节的问题来讨论。</p><h2><span id="标准的提出">标准的提出</span></h2><p>我们知道，这些知识在任何一部MySql教程中都有不少的介绍。即便如此，这些隔离级别其实并不是由MySql定制的，而是由一个组织名叫ANSI的组织制定的。</p><blockquote><p>ANSI：美国国家标准学会（AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）成立于1918年。当时，美国的许多企业和专业技术团体，已开始了标准化工作，但因彼此间没有协调，存在不少矛盾和问题。为了进一步提高效率，数百个科技学会、协会组织和团体，均认为有必要成立一个专门的标准化机构，并制订统一的通用标准。</p></blockquote><p>要了解隔离级别的标准，我们必须要知道隔离级别的本质，也即是说我们为什么要设定隔离级别。</p><h2><span id="隔离级别的本质">隔离级别的本质</span></h2><p>在第一章节中，我们给出的事务四个特性ACID并不严谨，本文我们引用了数据库领域的大神Jim Gray对其的定义,Jim Gray是事务处理方面的大师，本文中很多内容都来自他的专著和论文。为避免翻译引入的歧义，这里我们直接引用原文。</p><ul><li><p>Atomicity: Either all the changes from the transaction occur (writes, and messages sent), or none occur.</p></li><li><p>Consistency: The transaction preserves the integrity of stored information.</p></li><li><p>Isolation: Concurrently executing transactions see the stored information as if they were running<br>erially (one after another).</p></li><li><p>Durability: Once a transaction commits, the changes it made (writes and messages sent) survive any system failures.</p></li></ul><p>在上述隔离性（Isolation）的定义中，我们可以发现其目标是使并发事务的执行效果与串行一致。并从一致性（Consistency）定义中知道，事务是需要将数据状态从一个变成另一个状态。假设我们有数据x = 1，经过若干事务之后，我们需要让x = x’。</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645758703747.png" alt></p><p>注意事务的顺序，当顺序确定之后，对于事务对数据的改变就是原子性的。也就是说事务2不可以在事务1前面更改数据状态，必须从事务A1结束后的状态开始执行。<br>但我们知道，事务中会包含对数据的Read操作和Wirte操作。Read操作不会影响数据的状态，但是Wirte则会影响数据的状态。<br>我们假设x的初始值是x = 1,事务A由（Read(x), Wirte(x, x =2), Read(x), Wirte(x, x =1) 的操作序列组成。那么对x的状态变化如下图：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645758868868.png" alt></p><p>假如，此时有个事务2，序列为(Read(x), Wirte(x,x + 1)),状态为下图：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645758966889.png" alt></p><p>假设我们事务执行的顺序为[事务A, 事务B],则会出现这样一个串行化的序列：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645759042722.png" alt></p><p>这里的某种调度就是 Read 和Wirte 的排序方式。<br>​但是事实是，现代操作系统中，多核cpu已经普及，为了提高事务执行的效率，不同的事务操作可能会分配到不同的核心。但是这样做，就有可能破坏事务的一致性。因为事务的执行顺序不能随心所欲，必须要串行化执行，那怎么样才能利用多核cpu让事务并发执行且满足事务的串行化效果呢？答案就是串行化理论。</p><p>串行化调度和可串行化理论：</p><blockquote><p>为了提高数据库的执行效率，显然我们需要并发的执行各个事务，如果存在调度S，对于数据库的任何状态，其执行结果完全等价于另一个串行调度S’，称这样的调度S为可串行化调度（serializable schedule）。</p></blockquote><blockquote><p>对比串行调度，等价的可串行化调度可就多了（比如：最终等价，视图等价冲突等价），并发度大幅提升，但我们又该如何实现并发控制才能校验出一个调度是可串行化的？总不能先按串行调度执行，再对比结果吧？我们需要一个更加易于验证的条件，并且保证满足这个条件的调度是一定是可串行化的，这就是可串行化理论。</p></blockquote><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645759263475.png" alt></p><p>​根据观察，我们只要让事务B的每个操作起始状态和串行化的起始状态保持一致，其他的时间阻塞等待就可以实现串行化的效果。例如：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645759339734.png" alt></p><p>因为事务B在串行执行的时候，第一个Read操作的起始状态为Ax=1，那么，我将这个操作提前到事务A相同的区间开始，事务B Wirte操作起始状态不满足的情况下阻塞等待。这样一来，我们就可以通过一个并行调度来降低事务A + 事务B的总执行时间。因此，我们称这个调度是可串行化调度。</p><p>串行化的理论很复杂，包括：两阶段锁协议（2PL）, 独占/共享锁（Lock）, 视图等价（view equivalence），冲突等价（conflict equivalence）,History 等等概念和复杂的数学公式，以及可串行化的条件和证明。很多数据库中的实现都会有这个理论的影子，由于太过复杂，这里我们不在展开。这里提出这个概念，是想告诉读者，事务的并发控制的解决方案，是经过一系列的科学的理论证明的，不是一拍脑门就决定的。本文系列文章尽量用可以理解的方式告诉读者这个理论的原理。</p><p>回到主题，事实上，大多时候我们无法控制事务B的开始时间（随机出现的）。​但是我们可以通过阻塞或者其他合理调度来提高效率。有时候，提高了效率却又会出现错误状态。​</p><p>事务B的起始时间可能在事务A区间的任何时候，如果不进行阻塞那么就会破坏事务的一致性要求。例如下图，x最后等于3：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645760135914.png" alt></p><p>我们称这种破坏一致性的现象成为异常现象（Phenomenon）<br>​<br>所以，可串行化但在具体技术实现上往往需要在并发能力和串行化效果之间进行平衡，很难两者兼顾。平衡的结果就是会出现违反串行效果的现象，即异常现象（Phenomenon）。</p><p>通常来说，隔离级别的提出就是性能和正确性的平衡，隔离级别越高，串行化效果越强，同时也伴随着并发能力的下降，两者负相关。</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1645760232142.png" alt></p><h2><span id="隔离级别起源">隔离级别起源</span></h2><p>在上一个章节中，我们讨论了隔离级别的本质，所谓隔离级别就是事务要保证串行化效果的前提下均衡性能和一致性要求的结果。隔离级别越高，串行化效果越强，同时也伴随着并发能力的下降并同时出现异常现象（Phenomenon）,两者负相关。接下来我们来讨论个理解的起源。</p><h1><span id="隔离级别标准的提出">隔离级别标准的提出</span></h1><p>首先，我们对比MysqlInnoDB引擎中的提供的四个隔离级别来入手。分别是：</p><ul><li>1）READ UNCOMMITTED (读未提交)；</li><li>2）READ COMMITTED （读已提交）；</li><li>3）REPEATABLE READ （可重复度）；</li><li>4）SERIALIZABLE （串行化执行）。</li></ul><p>这些知识在任何一部MySql教程中都有不少的介绍。这个标准是如何来的呢？ 事实上这些隔离级别其实并不是由MySql指定的，而是由一个组织名叫<strong>ANSI</strong>的组织制定的<strong>SQL-92</strong>标准。</p><p><strong>ANSI SQL-92</strong> 标准的第一版发布于 1986 年，之后又陆续发布了多个主版本和修订版本。不过，其影响最广泛的版本仍然是1992年发布的<strong>SQL-92</strong>，在这个版本中，<strong>ANSI</strong>组织总结了各种并发情况下可能出现的异常现象（<strong>Phenomenon</strong>），并给出了平衡的结果，并根据这些异常现象的容忍程度，这就是在上文提到的隔离级别。</p><p>这些隔离级别都是基于经典的序列化理论和是否允许三种异常现象（<strong>Phenomenon</strong>）（中文翻译就是我们熟知的脏读，不可重复度和幻读，注意这里是异常现象，并不是隔离级别）。这些现象有：</p><ul><li>(P1) Dirty Read （脏读）</li><li>(P2) Non-Repeatable Read （不可重复度）</li><li>(P3) Phantom （幻读）</li></ul><p>因此，根据对这些异常现象的容忍程度，给出了如下表格：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1642757861458.png" alt><br>(可以暂时认为P=A)</p><h1><span id="被质疑sql-92标准">被质疑SQL-92标准</span></h1><h2><span id="标准的缺陷">标准的缺陷</span></h2><p><strong>ANSI SQL-92</strong> 标准的出是想构建一个与实现无关，全面，理论话的标准，单是这个想法失败了。虽然针对于上述的三种异常现象<strong>ANSI SQL-92</strong> 给出了明确的定义。并且以这三种异常现象的有无来定义隔离级别。这显然是有些问题的。</p><ul><li>原因1：<strong>ANSI SQL-92</strong> 对这些异常现象给出的定义不够清晰和全面。</li></ul><p>作为标准，本应该由各大数据库厂商遵循并实现，但遗憾的是，在实际在实现过程中出现的异常现象远多于<strong>QL-92</strong>定义的现象，那么因此给出的隔离级别也会有所缺陷，甚至是错误。也正是因此，<strong>SQL-92</strong>的标准也开始被质疑。</p><ul><li><p>原因2：<strong>SQL-92</strong> 只考虑了数据是单个版本的情况下可能出现问题，并没有考数据可以有多个版本的情况。</p></li><li><p>原因3： <strong>ANSI SQL-92</strong> 是根据现象的容忍程度来定义标准，这显然是不符合理论的。</p></li></ul><p>上一篇文章我们从串行化理论入手来分析事务运行中的调度，来得出不同的调度会引起不同的异常现象。因此，想要定义完整的隔离级别，就必须从事务调度历史的依赖关系通过模型化的分析，才能得到科学全面的各级离别。<br>比如：<strong>ANSI SQL-92</strong>  规定避免P1、P2、P3异常现象就可以称之为可串行化了（what? 串行化理论够出一套教科书了，你告诉我避免P1-3就是串行化了？太儿戏了吧？）</p><p>即便如此，<strong>ANSI SQL-92</strong> 提出的观点至今为止仍然是应用最广的隔离级别定义, 但无论是当时还是后来都没有被各大数据库厂商严格遵循，部分原因可能是标准过于简化与实际应用有一定程度的脱离，这也是现在各大数据库厂商在隔离级别上的混乱的源头。</p><blockquote><p>如果想知道各大 RDBMS 厂商对事务隔离机制的实现的情况将参见:<a href="https://github.com/ept/hermitage" target="_blank" rel="noopener">https://github.com/ept/hermitage</a></p></blockquote><h2><span id="标准的批判">标准的批判</span></h2><p>由于这个标准的各种不足，随后一篇著名的论文：<strong>「A Critique of ANSI SQL Isolation Levels」</strong> （以下简称<strong>Critique</strong>）横空出世，这篇文章提出了上述的三种缺陷，并对其做出了补充。（现在好多书籍，都是以这个论文提出的概念来讲解事务的。）但是并没有从本质上解决隔离级别定义的​局限性。</p><p>随后，2000 **「Generalized Isolation Level Definitions」**这篇文章，指出了此前对隔离级别定义重度依赖数据库的实现，并且提出了与实现无关的隔离级别定义。这篇文章并没有从并发执行的事务产生的异常这个入手点分析，而是回归本质，通过事物之间的调度关系，从数学模型层面给出了科学的隔离级别的定义标准。这也是我们第一篇文章的理论依据。至此，隔离级别的争论才慢慢平息了下来。</p><p>但是，隔离级别的本质没有变化，还是性能和正确性之间的权衡。随着隔离级别多元化的理论发展下，各个数据库厂商的同名隔离级实现也大相径庭，没有做到标准规定那样。比如，MySQL 的 <strong>REPEATABLE READ</strong> 无法避免丢失更新（P4），(A5)读写偏序的问题（这两异常现象随后介绍），MVCC的实现也无法完全避免幻读（P3）异常等。也正因为如此，Mysql InnoDB的<strong>REPEATABLE READ</strong>被人狠狠的吐槽。</p><h2><span id="标准的修订之路">标准的修订之路</span></h2><p>接下来，我将用大量的篇幅介绍 <strong>「A Critique of ANSI SQL Isolation Levels」</strong>  这篇著名的论文，带你体会严谨的学术态度和数学建模的魅力所在。</p><p><strong>「Critique」</strong> 论文中，对<strong>SQL-92</strong>的隔离级别标准做了批判</p><p>第一，**异常现象（Phenomenon）**定义的模糊性：首先是自然语言方式界定的异常现象并不严格导致一些同质化的异常现象被遗漏；<br>第二、**异常现象（Phenomenon）**总结的不全面性。</p><p>ANSI当初制定标准时，依据的是<strong>single version（单版本）</strong> 和**Lock schedule（锁调度）**的思路，从最严格的 **Serializable（由2PL实现）**开始减少锁的数量、种类，放宽 <strong>release lock（释放锁）</strong> 的时机等，从而定义了4种隔离级别。但是事实上，在实现层面（Mysql）有类似多版本的实现方案（MVCC）。因此，仅仅从这两个方面定义的异常现象必定有所缺失。</p><p>因此，<strong>「Critique」</strong> 文中对<strong>SQL-92</strong>的三种异常现象由原来的（P1,P2,P3）重新将其编号为（A1/A2/A3）同时用公式来重新定义了A1,A2,A3并命名为新的（P1,P2,P3），又从中引申出了P0现象。并增加了两种锁实现中的可能异常（P4C和P4）和两种多版本并发控制实现中可能出现的异常（A5A和A5B），最后将所有这些异常组合在一起，并增加了两种隔离级别：<strong>Cursor Stability</strong>和 <strong>Snapshot</strong>。</p><p>接下来，我会深度分析 <strong>ANSI SQL-92</strong>，以及 <strong>「Critique」</strong> 中对其的补充修订。</p><h1><span id="对sql-92标准中的异常定义规范化">对SQL-92标准中的异常定义规范化</span></h1><h2><span id="ansi-sql-92-对phantom的重新定义">ANSI SQL-92 对Phantom的重新定义</span></h2><p>再次强调，ANSI当初制定标准时，依据的是<strong>single version</strong> 和<strong>Lock schedule</strong>的思路，不存在多版本的情况。先来看<strong>ANSI SQL-92</strong> 标准中的可能导致三种数据出现的问题：</p><blockquote><ol><li>P1 (“Dirty read”): SQL-transaction T1 modifies a row. SQL-<br>transaction T2 then reads that row before T1 performs a COMMIT.<br>If T1 then performs a ROLLBACK, T2 will have read a row that was<br>never committed and that may thus be considered to have never<br>existed.</li></ol></blockquote><blockquote><ol start="2"><li>P2 (“Non-repeatable read”): SQL-transaction T1 reads a row. SQL-<br>transaction T2 then modifies or deletes that row and performs<br>a COMMIT. If T1 then attempts to reread the row, it may receive<br>the modified value or discover that the row has been deleted.</li></ol></blockquote><blockquote><ol start="3"><li>P3 (“Phantom”): SQL-transaction T1 reads the set of rows N<br>that satisfy some . SQL-transaction T2 then<br>executes SQL-statements that generate one or more rows that<br>satisfy the used by SQL-transaction T1. If<br>SQL-transaction T1 then repeats the initial read with the same<br>, it obtains a different collection of rows.</li></ol></blockquote><p>这一冗长的打算不容易理解，我们用公式化来理解。</p><p>为了能更清晰的表述事务之间的操作关系，我们将操作简化为 w(write)， r(read) ，每个操作的数字w1,r2代表执行操作的事务，例如  r1代表事务1读， w2代表事务2写。紧跟着操作的中括号[]的内容代表当前操作所涉及的资源，例如 w1[x] 代表事务1写入了资源x， r2[P] 代表事务2读取了满足谓词P的资源。最后，使用  c(commit) 和 a (abort) 来表示提交与回滚。</p><p>因此我们就可以用一连串的操作来表示一段操作历史：</p><blockquote><p>w1[x] … r2[x]…(a1 and c2 in any order): 可以按照顺序表述：</p></blockquote><ul><li>事务1执行w1[x]操作，</li><li>事务2执行r2[x]操作：</li><li>最后事务1回滚或事务2提交，且操作顺序无要求。</li></ul><p>因此，上述的P1-P3的定义为：</p><ul><li>P1: Dirty Read：w1[x] … r2[x] … (a1 and c2 in any order)</li><li>P2: Fuzzy Read：r1[x] … w2[x] … c2 … r1[x] … c1</li><li>p3: Phantom Read：r1[P] … w2[y in P] … c2 … r1[P] … c1</li></ul><p>这就是上文所对应的脏读，可重复度和幻读三个概念了。针对这个定义，我们来看一下其中的概念。</p><ul><li>r1[P]表示事务1按照谓词P的条件读取若干条记录</li><li>w1[y in P]表示事务1写入记录y满足谓词P的条件</li></ul><blockquote><p>谓词（predicate）虽然之前我们没有提及谓词这个概念，但其实大家已经使用过了。例如，=、&lt;、&gt;、&lt;&gt; 等比较运算符，其正式的名称就是比较谓词。 我们可以简单理解为 SQL 语句Where 后面的表达式就好了。</p></blockquote><blockquote><p>通俗来讲谓词就是 各种各样的函数 中介绍的函数中的一种，是需要满足特定条件的函数，该条件就是返回值是真值。对通常的函数来说，返回值有可能是数字、字符串或者日期等，但是谓词的返回值全都是真值（TRUE/FALSE/UNKNOWN）。这也是谓词和函数的最大区别。</p></blockquote><p>根据定义，我们看到了P1的定义是T2读取提交后，T1恰好回滚之后，T2读取的值必定是T1回滚前的脏值。那么问题来了，异常的出现，我们一定要强调T1的回滚？其实不然，看一下的例子：</p><p>转账的例子：<strong>: x = 50; y = 50  Txn1 从x向y转账40</strong></p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>r1[x, 50]<br> w1[x = 10](x - 40)</td><td></td></tr><tr><td></td><td>r2[x = 10] <br> r2[y = 50]</td></tr><tr><td>r1[y = 50] <br>w1[y = 90](y = y + 40)</td><td></td></tr><tr><td>abort</td><td>…</td></tr><tr><td></td><td>commit</td></tr></tbody></table><p>可以看到，无论Txn1是否提交或者回滚，在某段时间范围内，不论Txn2是否提交或者回滚，读取到x + y ！= 100。因此，对于P1的定义过于严格。</p><h2><span id="重新定义p1-p2-p3">重新定义P1、P2、P3</span></h2><p>因为 <strong>ANSI SQL-92</strong> 定义P1,P2,P3只有语言上的描述，没有准确的定义这些异常，所以 <strong>「Critique」</strong> 对其做了两种解释，用 P表明可能发生异常的现象，用 A 表示已经发生的异常。我举个栗子就明白了。<strong>SQL-92</strong>定P1的时候过于严格，当出现定义中满足的条件的时候，错误已经发生。<br>因此，我们将P1的定义用A1来描述，A1（一定出问题的意思）。 那么我对A1进行扩大解释，新的定义来替换原来的P1(表示可能发生异常)。 根据A1出问题的原因，我们不强调脏读一定发生在（提交，回滚）之后， 因此 这个P1的定义就出来了，我们对比A1来看下：</p><ul><li>P1: w1[x]…r2[x]…((c1 or a1) and (c2 or a2) in any order)</li><li>A1: w1[x]…r2[x]…(a1 and c2 in any order)</li></ul><blockquote><p>解释一下： 无论你T1提交还是回滚 T2在回滚和提交前，我已经读到你的脏值了，那么问题就会产生。</p></blockquote><p>还是上面转账的例子：</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>r1[x, 50]<br> w1[x = 10](x - 40)</td><td></td></tr><tr><td></td><td>r2[x = 10] <br> r2[y = 50]</td></tr><tr><td>r1[y = 50] <br>w1[y = 90](y = y + 40)</td><td></td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>只要Txn2读到x = 10(x =10 是 Txn1中未提交的修改)就算脏读，不论是否有没有提交或者回滚。</p><p>根据这个规则，我们对原来的P2 和 P3 也类似的解释：</p><ul><li><p>P2: r1[x]…w2[x]…((c1 or a1) and (c2 or a2) in any order)</p></li><li><p>A2: r1[x]…w2[x]…c2…r1[x]…c1</p></li><li><p>P3: r1[P]…w2[y in P]…((c1 or a1) and (c2 or a2) any order)</p></li><li><p>A3: r1[P]…w2[y in P]…c2…r1[P]…c1</p></li></ul><p>有些文章将A系列(<strong>ANSI SQL-92</strong> 定义的异常现象)叫做狭义解释（严格解释），把P系列（ <strong>Critique</strong> 优化A系列定义的异常现象）叫做广义解释（宽泛解释）。</p><h2><span id="p3幻读的坑的补充">P3（幻读的坑）的补充</span></h2><p>A3名叫幻读，在幻读问题上，它和P2有着混淆的一个概念，首先我们先来看 <strong>ANSI SQL-92</strong> 定义的幻读:</p><blockquote><p>(“Phantom”): SQL-transaction T1 reads the set of rows N<br>that satisfy some . SQL-transaction T2 then<br>executes SQL-statements that generate one or more rows that<br>satisfy the used by SQL-transaction T1. If<br>SQL-transaction T1 then repeats the initial read with the same<br>, it obtains a different collection of rows.</p></blockquote><p>翻译一下：</p><ul><li>事务 T1 读取一组满足某些 &lt;搜索条件&gt; 的数据。</li><li>事务 T2 创建了满足 T1 的 &lt;搜索条件&gt; 的数据项并提交。</li><li>如果 T1 用相同的&lt;搜索条件&gt;再次读取，得到一组不同于第一次读取的数据。这就叫幻读。</li></ul><p>例子如下:</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,3,4]</td><td></td></tr><tr><td>…</td><td>begin</td></tr><tr><td>…</td><td>insert into t(a) values (2);</td></tr><tr><td></td><td>commit</td></tr><tr><td>select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,2,3,4]</td><td></td></tr></tbody></table><p>我们可以看到， Txn1最后获取到结果比原来的多一行。 也即是说，我们第一次读和第二次读取结果应该一样，都应该是2，3，4。这个定义怎么这么像 A2(<strong>SQL-92中的P2</strong>)（不可重复度）被？我们再来拿A2的定义看一下：</p><blockquote><p>P2(A2) (Non-repeatable or Fuzzy Read): Transaction T1 reads a data item. Another transaction T2 then modifies or deletes that data item and commits. If T1 then attempts to reread the data item, it receives a modified value or discovers that the data item has been deleted.</p></blockquote><p>注意和幻读定义的两个不同：</p><ul><li>幻读定义中有 &lt; search condition &gt;</li><li>幻读定义中 T2 是“创建数据”，不可重复读的定义中 T2 是修改或者删除数据</li></ul><p>在满足 **&lt; search condition &gt;**的范围内，修改和删除数据必定是对已经存在的数据行操作，而创建数据则意味着创建之前这个数据项是不存在的。“创建数据”不仅是 insert，还包括 update。update 把本来不满足谓词范围的数据项更新成满足谓词范围的数据项，比如：谓词范围是 a&gt;1 and a&lt;5，update a=2 where a=6 就是这样的情况。</p><p>显然，这样定义幻读是不合适的。对于A3和扩展P3的来说</p><ul><li>P3: r1[P]…w2[y in P]…((c1 or a1) and (c2 or a2) any order)</li><li>A3: r1[P]…w2[y in P]…c2…r1[P]…c1</li></ul><p>A3 的定义强调Txn2 提交后 r1 再去查询谓词，得到结果集不符合才算是幻读。这样是有问题的，下看面的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//tt是员工表</span><br><span class="line">mysql&gt; select * from tt;</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| name     | department |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| zhangsan | developer  |</span><br><span class="line">| lisi     | developer  |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">//tt_count是各部门人数统计表</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> tt_count;</span><br><span class="line">+<span class="comment">------------+--------+</span></span><br><span class="line">| department | number |</span><br><span class="line">+<span class="comment">------------+--------+</span></span><br><span class="line">| developer  |      2 |</span><br><span class="line">+<span class="comment">------------+--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>查询序列</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>select name from tt where department = ‘developer’ )[zhangsan,lisi ]</td><td></td></tr><tr><td>…</td><td>begin</td></tr><tr><td>…</td><td>insert tt(name, department) values(‘wangwu’,‘developer’);</td></tr><tr><td>…</td><td>update tt_count set number = number + 1 where department = ‘developer’</td></tr><tr><td></td><td>commit</td></tr><tr><td>select number from tt_count where department = ‘developer’ )[3 ]</td><td></td></tr><tr><td>commit</td><td></td></tr></tbody></table><p>上述的例子当中，Txn1 并没有去查询所谓的谓词，但是依然出现了tt_count表中的 <code>developer 的number = 3</code>, 因此，按照A3的定义来说是有问题的，如果我们用P3广义的来解释，只要 <code>insert tt(name, department) values('wangwu','developer')</code> 这条语句成功，那就算是幻读了。这样是可以解释通的。</p><p>这也是 P3 定义的由来，只要事务2对事务1的谓词范围进行了写入（写入成功），不管后面事务1做什么查询，都算是幻读。</p><p>幻读的另外一个例子：</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,3,4]</td><td></td></tr><tr><td>…</td><td>begin</td></tr><tr><td>…</td><td>update set a = 2 where a = 6);</td></tr><tr><td></td><td>commit</td></tr><tr><td>select a from t where a &gt; 1 and a &lt; 5&gt;)[result:2,2,3,4]</td><td></td></tr></tbody></table><p>再直观点讲（个人解读），不可重复读是说读的结果的行数不变或者减少，结果的内容发生变化；而幻读呢，就是读的结果的行数变多了。这就是<strong>SQL-92</strong> 定义的幻读。但是<strong>Critique</strong>认为这样定义幻读是不对的，论文认为幻读强调的是两次相同查询不同的数据，因此把删除一行，也就是数据变少，也应该属于幻读行列。</p><p>具体原文如下：</p><blockquote><p>One important note is that ANSI SQL P3 only prohibits inserts (and updates, according to some interpretations) to a predicate whereas the definition of P3 above prohibits any write satisfying the predicate once the predicate has been read — the write could be an insert, update, or delete.</p></blockquote><p>有了幻读较少数据的这个补充，我们来讨论另外一个case:</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>select a from t where a = 1)[result:2]</td><td></td></tr><tr><td>…</td><td>begin</td></tr><tr><td>…</td><td>delete from t where a = 1);</td></tr><tr><td></td><td>commit</td></tr><tr><td>select a from t where a = 1)[result:[]</td><td></td></tr></tbody></table><p>按照谓词查询一个数据，按照上面说的<strong>Critique</strong> 对P3的定义，这个case应该不仅满足P3也同时满足P2,那么问题又来了，这到底算是那个case?<br>在标准中有如下定义：</p><blockquote><p>p2 Another transaction T2 then modifies or <strong>deletes</strong> that data item</p></blockquote><blockquote><p>p3 the write could be an insert, update, or <strong>delete</strong></p></blockquote><p>由于标准中幻读和脏读的定义中核心点的区分就是，一个是 date item 的变化，一个是对Data Set的变化，上面的case可以有两种解读, 就是返回的结果是一个 data item 还是一个 data set？</p><p>根据前文知道，a = 1 在where之后，可以理解为谓词：Predicate， 严格来说，所有的查询条件都属于谓词；而相对的，在 KV 存储引擎中直接读取某个 key 的行为则称为 item。然而关系型数据库在 KV 之上还有 SQL 层，SQL 层即使是读取某个 key 也是通过一些查询条件（predicate）来进行描述的，当我们在 SQL 层面之上讨论是 predicate 还是 item 的时候，需要考虑它是否是一个点查询。</p><p>点查询是一种查找数据的方法，通过建立好的索引去定位数据的 key，一般能够用非常高的效率查找到所需的数据，其查询的过程和读取某个 key 相似，所以本文的观点认为：点查询是第一次查询返回为data item类型的查询。其他查询均是 predicate 类型的查询条件。明白这个之后，我们可以回答这个问题：上面的case是不P2。</p><p>当三个原始异常的坑填补上之后，我们再来看隔离级别：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1642757861458.png" alt></p><h4><span id="增加p0">增加P0</span></h4><p><strong>ANSI SQL-92</strong> 在定义异常的时候忽略了一个比较低级的异常现象， 先看定义：</p><ul><li>P0: w1[x]…w2[x]…((c1 or a1) and (c2 or a2) in any order)</li></ul><p>看一下例子：</p><table><thead><tr><th>Txn1</th><th>Txn2</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>w(x,2)</td><td></td></tr><tr><td>…</td><td>begin</td></tr><tr><td>…</td><td>w(x,3)</td></tr><tr><td></td><td>…</td></tr><tr><td>commit(abort)</td><td></td></tr></tbody></table><p>T1写入和提交之间，T2趁机写入别的的数据。能带来的后果为两个，导致T1的更新丢失了（没错，脏写有时候会被归为丢失更新。）</p><ul><li>1、不能保证数据的一致性。</li><li>2、回滚异常（设定x初始值为0， 当T1发生异常要回滚，是回滚到3还是回滚到0？）</li></ul><p>讲到这里你获取会奇怪，两个事务同时写X。同时写X加锁不就好了？管谁写，写成功就好了，为啥这也定义？是的，如果给x记上锁，那就意味着我想对这个序列串行化处理，串行化是我们后边隔离级别要讨论的事情，我们这里只谈问题，不谈解决办法，毕竟只有知道有问题在哪，我们才能解决不是。</p><h3><span id="重新定义隔离级别">重新定义隔离级别</span></h3><p>至此，四个新的定义出现了, 注意这里一个点，就是删掉了c2和a2,既然我们不强第二个调事务终止，所以就没有必要强调第二个事务提交或者回滚。但是我们必须要保留第一个事务的提交或者回滚，来却确保一个事务的操作会影响另一个事务操作。</p><ul><li>P0: w1[x]…w2[x]…(c1 or a1) (Dirty Write)</li><li>P1: w1[x]…r2[x]…(c1 or a1) (Dirty Read)</li><li>P2: r1[x]…w2[x]…(c1 or a1) (Fuzzy or Non-Repeatable Read)</li><li>P3: r1[P]…w2[y in P]…(c1 or a1) (Phantom)</li></ul><p>并且用广义的定义重新描述了ANSI隔离级别：</p><p><img src="/article/distributed-transaction-1/distributed-transaction-1-1642766870162.png" alt></p><p>然后根据P0-P3的容忍度补充了标准内的隔离级别。根据上面的新定义的图示，有了PO之后，感觉这个标准更加完善了，但是依旧有些异常现象不在这四种之内，比如<strong>P4,P4C</strong>之类的。我们下一篇文章在谈论。</p><p>下一篇文章，我会根据基于ANSI锁调度，分析上表中的隔离级别是如何实现的。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.modb.pro/db/88214" target="_blank" rel="noopener">关于 MySQL Repeatable Read Isolation 常见的三个误区</a></li><li><a href="https://www.cnblogs.com/ivan-uno/p/8274355.html" target="_blank" rel="noopener">再谈数据库事务隔离性</a></li><li><a href="https://juejin.cn/post/6844903854857781262" target="_blank" rel="noopener">Mysql RR级别依然可能丢失更新数据</a></li><li><a href="https://segmentfault.com/a/1190000023045329" target="_blank" rel="noopener">事务隔离级别，看这一篇就够了</a></li><li><a href="https://pingcap.com/zh/blog/take-you-through-the-isolation-level-of-tidb-1" target="_blank" rel="noopener">Transaction management：两阶段锁（two-phase locking</a></li><li><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.225.2581&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Correctness Criteria Beyond Serializability</a></li><li><a href="https://hw311.me/zh/study-notes/database/2019/02/24/transaction-consistency-serializability/#fn:1" target="_blank" rel="noopener">Transaction management：可串行性（serializability）</a></li><li><a href="https://lenshood.github.io/2020/11/30/isolation-level-with-mysql/" target="_blank" rel="noopener">MySQL(InnoDB) 独特的 Repeatable Read 隔离级别</a></li><li><a href="http://blog.kongfy.com/2019/03/serializable/" target="_blank" rel="noopener">可串行化（Serializable）：理想和现实</a></li><li><a href="https://segmentfault.com/a/1190000040548324" target="_blank" rel="noopener">技术分享 | 隔离级别：正确理解幻读</a></li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf" target="_blank" rel="noopener">A Critique of ANSI SQL Isolation Levels</a></li><li><a href="https://niceaz.com/2019/03/24/isolation-2pl-mvcc/" target="_blank" rel="noopener">数据库的隔离级别与2PL/MVCC算法原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/369953647" target="_blank" rel="noopener">《A Critique of ANSI SQL Isolation Levels》论文导读</a></li><li><a href="https://zz-jason.github.io/posts/ansi-sql-isolation-levels/" target="_blank" rel="noopener">论文阅读：《A Critique of ANSI SQL Isolation Levels》</a></li><li><a href="http://oserror.com/backend/transaction-isolation-second/" target="_blank" rel="noopener">事务隔离（二）：基于加锁方式的事务隔离原理</a></li><li><a href="https://blog.csdn.net/matrixyy/article/details/43115589" target="_blank" rel="noopener">数据库事务的ACID隔离级中P0（脏写）和P4（更新丢失）的区别</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MYSQL </tag>
            
            <tag> 事物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源重试组件Attempt</title>
      <link href="/article/attempt/"/>
      <url>/article/attempt/</url>
      
        <content type="html"><![CDATA[<h2><span id="开源">开源</span></h2><p>想做开源软件很久了，奈何一直没有启动起来。一来是没有契机，二来也没有想法。2020年由于一些变故，我从某团离职后来到了新公司。负责一个To B业务, 由于并发量和我以前负责的项目没法比，同时又是个to B的项目，因此<br>省去了火急火燎的去处理线上问题的时间。因此，更多的时间我拿来思考和总结。</p><p>同时也参加了软件架构师的培训中。虽然各大互联网企业对软考证书似乎并不care，但是我的目的不仅仅如此，是想通过宏观、系统的学习，重新将这个架构行业最精髓的理论知识重新拾起来（大学光顾着玩了）。</p><p>思考有时候让人着迷。将思考融入设计，然后付诸实现，这是意见多么让人兴奋的事情。每每看到有优秀的开源组件问世，我都会无比的激动。看着这些莫名又有点兴奋的代码，放佛同作者进行探讨，那一刻，我们不仅仅是程序员，还是一个设计师，一个先驱者。</p><p>技术真的能改变世界。怀着对技术崇敬和感恩之心，我步履蹒跚的追逐先驱们的身影，愿我辈豪杰辈出，生生不息。</p><h2><span id="想法">想法</span></h2><p>Attempt是一个很小的重试组件，与市面上的一些成熟的轮子相比也许不值得一体，但是由于是0-1的开阔，因此对本人的意义非凡。其他的就不扯淡了，作为第一个我的开源组件和本木西笔记的第一个技术推送，下面就Attempt的一些功能和设计做一个简要的说明。</p><p>本文就不对 <strong>Attempt</strong> 组件做详细的剖析，感兴趣的可以去clone下代码阅读，也欢迎 start 和 discuss。</p><h2><span id="attempt简介">Attempt简介</span></h2><p><strong>Attempt</strong> 是对标 <strong>SpringRetry</strong> 和 <strong>GuavaRetry</strong> 轮子的一个轻量的不能在轻量的组件。通过<strong>Attempt</strong> 你可以轻易将一个方法调用变成一个具有异常重试的调用。同时<strong>Attempt</strong> 支持带有重试的轮询策略，让你的轮询任务更加的稳定。</p><p><img src="/article/attempt/attempt-1645779632873.png" alt></p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="增加依赖">增加依赖</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.icefrozen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Attempt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="代理方式构建重试">代理方式构建重试</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUser</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queryUser error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">        AttemptBuilder.Retry&lt;UserService&gt; userRetry = <span class="keyword">new</span> AttemptBuilder.Retry&lt;UserService&gt;(userService);</span><br><span class="line">        UserService userServiceAttempt = userRetry.build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userServiceAttempt.queryUser(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());     <span class="comment">// queryUser 发生异常</span></span><br><span class="line">            <span class="comment">// 注意这里拿到是 userService原始对象</span></span><br><span class="line">            System.out.println(userService.count);      <span class="comment">//原始方法已经调用3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们执行 <strong>userServiceAttempt</strong> 代理类的时候，遇到异常会自动重试三次。 如果三次还是失败，则将异常抛出。 因此count为3。</p><p><strong>AttemptBuilder</strong> 可以使得对象中的成员方法有重试的行为，那么我们如何对静态方法赋予重试的功能呢？ 或者说，我重试某一类方法或者一个静态类如何做呢？</p><h3><span id="使用匿名函数构建静态方法重试">使用匿名函数构建静态方法重试</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">queryUserStatic</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        staticCount ++;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queryUser error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AttemptBuilder.retry(</span><br><span class="line">                () -&gt; UserService.queryUserStatic())</span><br><span class="line">                .exec();  <span class="comment">//  count = 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="comment">// ... staticCount &gt; 3 之后，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="轮询策略">轮询策略</span></h3><p>假设有这么一个场景，你上传了一个任务，服务方并不支持异步回调或者消息队列的方式通知你任务否执行完毕，那么你需要一个轮询策略，用于知道该任务的情况。为了稳定性，你需要满足一下几个特点：</p><ul><li><p>如果查询进度的过程中失败了，那么需要为了让任务进行下去，必须要进行一个重试，比如说遇到了超时。</p></li><li><p>如果超时3（重试最大次数暂定为3次）次，那么直接报错，返回失败。</p></li><li><p>如果超时没有超过3次（重试最大次数暂定为3次）在重试期间，网络恢复了，那么要要清除重试3次的历史，否则下次遇到超时的时候就会失败。</p></li></ul><p><img src="/article/attempt/attempt-1642672860843.png" alt></p><p>根据上面的场景<strong>Attempt</strong>可以很容易构建出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务服务</span></span><br><span class="line">TaskService taskService = <span class="keyword">new</span> TaskService()</span><br><span class="line"></span><br><span class="line">AttemptBuilder.Polling&lt;TaskService&gt; taskServicePollBuilder = <span class="keyword">new</span> AttemptBuilder.Polling&lt;&gt;(taskService);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定轮询停止条件</span></span><br><span class="line">TaskService taskServicePoll = taskServicePollBuilder.endPoint(context -&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取上一次结果</span></span><br><span class="line">    AttemptResult result = context.getLastResult();</span><br><span class="line">    <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">        Integer progress = result.getRetValue(Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> progress == <span class="number">100</span>;      <span class="comment">//  progress &lt; 100 poll continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置轮询最大次数 和异常类型</span></span><br><span class="line">.maxPollCount(<span class="number">100</span>)    </span><br><span class="line">.registerExceptionRetryTime(Exception<span class="class">.<span class="keyword">class</span>, 3)</span></span><br><span class="line"><span class="class">.<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行调用    </span></span><br><span class="line">Integer integer = taskServicePoll.queryProgress();</span><br></pre></td></tr></table></figure><h2><span id="attempt架构">Attempt架构</span></h2><p><strong>Attempt</strong> 设计初衷就是想摒弃大段大段的繁琐依赖，将重试性能压榨到极致，因此 <strong>Attempt</strong> 并没有引入过多的依赖，能手写的尽量不去依赖，设计能简单的就尽量不去复杂问题。简单的设计也必将会单来更为可靠的性能。</p><h3><span id="轻量级">轻量级</span></h3><p><strong>Attempt</strong> 实际依赖一共有以下三个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cglib.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想用 retry 功能，又不想引入 Spring 和Guava这个庞大的体系，Attempt是一个不错的选择。</p><h3><span id="可扩展">可扩展</span></h3><p>Attempt，但是层次清晰，预留了足够的扩展可能。Attempt总体架构如下图：</p><p><img src="/article/attempt/attempt-1642679803558.png" alt></p><ul><li>AttemptInvoker</li></ul><p><strong>AttemptInvoker</strong> 用于执行一些静态方法，其中包括一个 <strong>ThrowSafetyFunctionInvoke</strong> 用于不会让人恶心的异常，当我们使用lamda表达式去重试一些静态变量的时候，可以帮我们捕获异常。</p><p><strong>ThrowSafetyFunctionInvoke</strong> 就是一个扩展了 <figure class="highlight plain"><figcaption><span>注解的类。并且捕捉了**Exception**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ThrowSafetyFunctionInvokerSupplier&lt;T&gt; extends ThrowSafetyFunctionInvoker&lt;T&gt; &#123;</span><br><span class="line">    T get() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodThrowExceptionBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">throwException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"StaticMethodThrowExceptionBean's throwException"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可以这样写 </span></span><br><span class="line">AttemptBuilder.retry(StaticMethodThrowExceptionBean::throwException).exec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而不是恶心cat exception</span></span><br><span class="line">AttemptBuilder.retry(()-&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StaticMethodThrowExceptionBean.throwException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">&#125;).exec();</span><br></pre></td></tr></table></figure><ul><li>Attempt</li></ul><p><strong>AttemptInvoker</strong> 下封装了<strong>Attempt</strong>, 在代理方式构建方法中，<strong>Attempt</strong> 保存着我们的原始对象和构建对象。同时封装了 <strong>AttemptExecutor</strong> 执行器。</p><ul><li>AttemptExecutor</li></ul><p>执行器是执行 Attempt 主要方法，其本质是一个切面函数，将用户的调用方法进行动态拦截。策略如下图：</p><p><img src="/article/attempt/attempt-1642680270333.png" alt></p><ul><li>Executor首先调用start 方法，之后询问策略是否结束，策略会根据context山下文找到调用的历史和约束，例如次数，异常次数等。</li><li>如果此次调用满足继续，则进行真正方法调用。在调用真正方法的时候，无论是否异常，均会封装成一个 <strong>AttemptResult</strong> 对象并记录。</li><li>当策略判定此次调用结束之后，会进行状态的清理，和异常的抛出。如果我们置顶不抛出异常，则会返回一个默认的值</li></ul><p><strong>AttemptExecutor</strong> 是具体的执行策略，也是切面方法。<strong>AttemptExecutor</strong>中有三大组件。</p><ul><li><p>Stategy (Attempt策略)</p><p>stategy 是具体的重试策略，他是一个接口，用于实现各种Attempt策略，目前Attempt默认提供两种Attempt策略，分笔试 Retry 和 Polling 两种策略。 Polling 是基于Retry 策略的扩展，是带有重试的轮询策略。 Retry 就是我们的主要策略。 接口如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttemptStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、是否结束</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">(AttemptContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 一次调用声明周期结束后 true 进入循环，false 返回</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">back</span><span class="params">(AttemptResult record, AttemptContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 策略名称</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取属性集合</span></span><br><span class="line">    BaseAttemptPropertyViewer&lt;? extends BaseAttemptPropertyViewer&lt;?&gt;&gt; properties();</span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line">    <span class="function">AttemptStatus <span class="title">status</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="function">AttemptStatus <span class="title">status</span><span class="params">(AttemptStatus status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当调用结束之后，如果调用失败，将要进入回退中，所谓回退，就是调用之后休息多久再次调用，<strong>Attempt</strong> 提供了一下几种回退策略</p><ul><li>NoBackOffPolicy 空回退，不进行任何回退，立刻下次重试。</li><li>FixedSleepingBackOffPolicy 睡眠固定毫秒数的重试</li><li>RangeDescSleepingBackOffPolicy 睡眠时间按照范围递减的策略</li><li>SleepingBackOffPolicy 一般睡眠回退策略，提供了初始值，递减参数和最大值。</li></ul><p>具体是实现细节，这里不再展开。</p><ul><li>Context (Attempt上下文)</li></ul><p>Context 上下文记录这本次重试的历史，包括耗时，次数，异常次数等。他提供接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttemptContext</span> </span>&#123;</span><br><span class="line">    <span class="function">AttemptResult <span class="title">getLastResult</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">record</span><span class="params">(AttemptResult record)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">record</span><span class="params">(Class&lt;? extends Throwable&gt; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">AttemptResult <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getExecuteCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getExceptionCount</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getExceptionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getExceptionCount(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;AttemptResult&gt; <span class="title">getResults</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每次重试，<strong>Attempt</strong> 会拦截调用结果或者捕获异常，并封装成一个 <strong>AttemptResult</strong> 加入到一个容器中。</p><p>在 <strong>AttemptContext</strong> 的具体实现中 <strong>ResultContext</strong> 类中，增加了 AttemptResultContainer 容器，用于记录每次调用的 <strong>AttemptResult</strong> 结果。 当然，我们可以给<strong>AttemptResultContainer</strong> 一个很大的值，这就以为我们可以保存更多的 中间结果, 除非你知道你自己在做什么，否则这是不推荐的。</p><p>此外，<strong>AttemptContext</strong> 还要提供重试次数，调用次数，异常情况等诸多统计信息，供给 <strong>AttemptStrategy</strong> 使用，用于判断此次 <strong>AttemptExecutor</strong> 是否可以继续执行。</p><ul><li>Listener (监听器)</li></ul><p><strong>Listener</strong> 贯穿于整个 <strong>Attempt</strong> 的生命周期，包括 <strong>InvokeListener</strong> 和 <strong>ExecutorListener</strong> 两种类型，分别是环绕代理方法和Executor 的这个声明周期，提供一些扩展。比如Timeout 机制，就是在Listener里面扩展的。</p><blockquote><p>Timeout机制目前是不完善的，如果目标方法sleep了，那么将无法报出超时异常，这一点在后续的版本中会优化。</p></blockquote><h3><span id="性能高">性能高</span></h3><p>既然是对标 <strong>Attempt</strong> 是对标 <strong>SpringRetry</strong> 和 <strong>GuavaRetry</strong>， 难免需要进行对比。我采用的JMH的方法测试三者之间的性能。</p><p>在遇到异常重试300次的情况下，数据如下：</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score</th><th>Error</th><th>Units</th></tr></thead><tbody><tr><td>AttemptVsSpringRetry.testAttempt</td><td>avgt</td><td>10</td><td>165.921 ±</td><td>26.558</td><td>ns/op</td></tr><tr><td>AttemptVsSpringRetry.testGuavaRetry</td><td>avgt</td><td>10</td><td>909259.747 ±</td><td>323278.426</td><td>ns/op</td></tr><tr><td>AttemptVsSpringRetry.testSpringRetry</td><td>avgt</td><td>10</td><td>50681.819 ±</td><td>2848.606</td><td>ns/op</td></tr></tbody></table><p><img src="/article/attempt/attempt-1642680745774.png" alt></p><h2><span id="公众号">公众号</span></h2><p>我的公众号成立了，欢迎大家点赞关注。</p><p><img src="/article/attempt/attempt-1642680846066.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程之volatile关键字</title>
      <link href="/article/java-volatile/"/>
      <url>/article/java-volatile/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>volatile关键字是Java 并发编程当中不可或缺的一环，维序着Java共享变量的可见性和有序性。。当中由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来回顾一下volatile的应用场景。</p><p>Java是跨平台的，因此针对于不同平台的实现方式，但是必遵循一定的规范，来统一Java编程的基本原则，这个规范被成为Java虚拟机规范。Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果.具体内容请参考我的另一篇博文<a href="https://icefrozen.github.io/article/java-memory-model/" target="_blank" rel="noopener">Java内存模型(1)JMM是什么</a></p><p>我们先来看volatile是用来解决什么问题的。</p><h2><span id="volatile应用场景">volatile应用场景</span></h2><h2><span id="volatile-解决可见性">volatile 解决可见性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisibility</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* volatile */</span><span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                isStop=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 =  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!isStop)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> VolatileVisibility().test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码可能永远也不会结束，因为线程一对isStop的赋值，线程二可能对此并不可见。当然只是可能，所以为了放大可见性问题，我这里作了25次循环。只要有一组线程，“线程一对isStop的赋值,线程二对此不可见”的情况发生，就不会退出程序。<br>假如你给 isStop 添加一个 volatile 关键字，那么你会发现程序立马就会退出。</p><p>针对于可见性，还有一个经典的double check例子<a href="https://icefrozen.github.io/article/java-memory-model/#volatile-1" target="_blank" rel="noopener">DoubleCheckLock</a></p><h2><span id="volatile-有序性">volatile 有序性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderlyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            value = <span class="number">1</span>;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> DisplayThread();</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> CountThread();</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">            System.out.println(<span class="string">"-------------"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            value = <span class="number">1024</span>;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; value != <span class="number">1024</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i am error value flag=true and value != 1024"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; value != <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i am error value flag=false and value != 1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------46</span><br><span class="line">-------------47</span><br><span class="line">i am error value flag=true and value != 1024</span><br><span class="line">-------------48</span><br><span class="line">-------------49</span><br></pre></td></tr></table></figure><p>从上面代码中我们可以看到，flag、value 发生了重排序，也就是说，只要读取到flag=true;就能读取到value=1024；否则就是读取到flag=false;和value=1的还没被修改过的初始状态；</p><h2><span id="volatile是否可以解决原子性">volatile是否可以解决原子性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//每个线程对t进行1000次加1的操作</span></span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    t += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印t的值</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们运行了几次，得到的结果有可能不是10000，可得出结论，volatile无法解决原子性问题。</p><h2><span id="原理">原理</span></h2><h2><span id="有序性和可见性产生原因">有序性和可见性产生原因</span></h2><p>总的来说，volatile可以保证在多线程下共享变量的可见性和有序性。那么，之所以产生有序性和可见性的原因有两点，</p><ul><li>1、 指令重排序</li><li>2、 MESI协议的导致的缓存未刷新。</li></ul><p>而指令重排序，则又分为，编译器重排序和CPU重排序，这里重排序的原因不在赘述，详情请参见<a href="https://icefrozen.github.io/article/java-memory-model-complier-reordering/" target="_blank" rel="noopener">Java内存模型(2)编译器重排序</a>和<a href="https://icefrozen.github.io/article/java-memory-model/" target="_blank" rel="noopener">Java内存模型(1)JMM是什么</a>,这里面详细阐述了CPU指令重排序和编译器重排序的原理。</p><p>剩下的就是MESI协议导致的不可见原因，详情可以参考<a href="https://icefrozen.github.io/article/why-memory-barriers-1/" target="_blank" rel="noopener">CPU缓存一致性协议-深入理解内存屏障</a>, MESI协议是一个基础协议，在不同架构洗下的CPU会有不同形式的实现，例如X86下的CPU使用采用的是改进型的MESI协议。</p><p>因此，了解产生原因之后，我们就需要提出解决办法，思路就是很清楚了<strong>1、禁止指令重排序，2、强制令MESI协议中的中间状态刷入缓存当中</strong>。</p><p>如果你了解MESI协议，那么事实上，MESI协议其实也是一种指令重排，只不过是伪重排，这和CPU重排序是一个道理，CPU并没有将指令的顺序发生改变，而是各个指令的执行完的时间不是一样的，也就是说，顺序执行，乱序完成。了解这个事实，解决思路就非常明了，那就是内存屏障。</p><p>由于不同的平台CPU实现的机制不同，各个编译器对代码的优化方式不同，因此，JMM不得不考虑一种规则，适用于所有的平台，因此，JMM规定了四中屏障</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoadBarriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStoreBarriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStoreBarriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoadBarriers</td><td>Store1;StoreLoad;Load1</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><p>在每个volatile写操作的前面插入一个StoreStore屏障。<br>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>在每个volatile读操作的后面插入一个LoadLoad屏障。<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p><p><img src="/article/java-volatile/java-volatile-1627280986737.png" alt></p><p>上图的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了,因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存</p><p><img src="/article/java-volatile/java-volatile-1627281005319.png" alt></p><p><img src="/article/java-volatile/java-volatile-1627281024210.png" alt></p><p>总结来说，volatile 可见性包括两个方面：</p><ul><li><p>写入的 volatile 变量在写完之后能被别的 CPU 在下一次读取中读取到；</p></li><li><p>写入 volatile 变量之前的操作在别的 CPU 看到 volatile 的最新值后一定也能被看到；<br>对于第一个方面，主要通过：</p></li><li><p>读取 volatile 变量不能使用寄存器，每次读取都要去内存拿</p></li><li><p>禁止读 volatile 变量后续操作被重排到读 volatile 之前</p></li></ul><p>对于第二个方面，主要是通过写 volatile 变量时的 Barrier 保证写 volatile 之前的操作先于写 volatile 变量之前发生。最后还一个特殊的，如果能用到 StoreLoad Barrier，写 volatile 后一般会触发 Store Buffer 的刷写，所以写操作能「立即」被别的 CPU 看到。</p><h2><span id="x86下的内存屏障">X86下的内存屏障</span></h2><p>在<a href="(https://icefrozen.github.io/article/why-memory-barriers-2/)">CPU缓存一致性协议（2）- 缓存一致性性模型</a> 我们已经讨论了x86下TSO模型是只有 StoreLoad 是允许重排序的，也就是说 MESI协议的StoreBuffer的引入，会是的StoreLoad有乱序执行的可能，因此，我们需要在禁止 StoreLoad的排序。而其他的屏障，我们只需要保证，编译器不会在编译期间，进行优化就可以了。</p><h2><span id="hotspot原理">HotSpot原理</span></h2><p>接下来，我们将会以JDK1.8的源码来分析一下 volatile 的实现原理</p><h2><span id="字节码上的区别">字节码上的区别</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val++;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">add2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val2++;</span><br><span class="line">        <span class="keyword">return</span> val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编译，并且用javap 来查看字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">int</span> val;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_VOLATILE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> val2;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field val:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field val:I</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        11: getfield      #2                  // Field val:I</span><br><span class="line">        <span class="number">14</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #3                  // Field val2:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #3                  // Field val2:I</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        11: getfield      #3                  // Field val2:I</span><br><span class="line">        <span class="number">14</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从javap的输出来看，volatile和非volatile变量没有任何区别，从Java虚拟机规范可知，某个字段是否是volatile变量是通过用来描述字段属性的access_flags来决定的，通过特定的标识位来识别，如下图：</p><p><img src="/article/java-volatile/java-volatile-1627354231062.png" alt></p><p>从javap的输出分析可知，并没有专门针对volatile变量的特殊字节码指令，其处理逻辑还是在属性读写的字节码指令中，相关的指令有四个，<code>_getstatic/_putstatic，_getfield/_putfield</code>，</p><h2><span id="hotspot内的区别">Hotspot内的区别</span></h2><p>我们都知道，JVM执行字节码需要解释器(Interpreter)。 HotSpot虚拟机中支持两种解释器——CppInterpreter 和 TemplateInterpreter，对于一个编译好的JVM可执行程序来说，其使用的解释器是固定的，不可根据运行时条件改变，绝大多数JVM实例都使用TemplateInterpreter，下面也将分析基于TemplateInterpreter 的字节码执行。可以参考文档 [1] 了解这两种解释器的原理。</p><p>以x86平台为例，对于TemplateInterpreter，字节码对应的C/C++/汇编实现存放在/src/hotspot/cpu/x86/templateTable_x86.cpp文件中。</p><p>X86平台下，getfield和putfield的字节码模板指令如下<br><code>hotspot/src/cpu/x86/vm/templateTable_x86.cpp</code></p><h3><span id="读操作">读操作</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::getfield</span><span class="params">(<span class="keyword">int</span> byte_no)</span> </span>&#123;</span><br><span class="line">  getfield_or_static(byte_no, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_getstatic / _getfield</code>适用于所有类型的字段属性读取，因此在具体实现时需要根据flags中保存的属性类型适配对应的处理逻辑，为了避免每次都要判断属性类型，OpenJDK增加了几个自定义的带目标类型的属性读取的字节码指令，如<code>_fast_igetfield</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::getfield_or_static</span><span class="params">(<span class="keyword">int</span> byte_no, <span class="keyword">bool</span> is_static, RewriteControl rc)</span> </span>&#123;</span><br><span class="line">  transition(vtos, vtos);</span><br><span class="line">   <span class="keyword">const</span> Register cache = rcx;</span><br><span class="line">  <span class="keyword">const</span> Register index = rdx;</span><br><span class="line">  <span class="keyword">const</span> Register obj   = c_rarg3;</span><br><span class="line">  <span class="keyword">const</span> Register off   = rbx;</span><br><span class="line">  <span class="keyword">const</span> Register flags = rax;</span><br><span class="line">  <span class="keyword">const</span> Register bc = c_rarg3; <span class="comment">// uses same reg as obj, so don't mix them</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//给该字段创建一个ConstantPoolCacheEntry，该类表示常量池中某个方法或者字段的解析结果</span></span><br><span class="line">  resolve_cache_and_index(byte_no, cache, index, <span class="keyword">sizeof</span>(u2));</span><br><span class="line">  <span class="comment">//发布jvmti事件</span></span><br><span class="line">  jvmti_post_field_access(cache, index, is_static, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">//加载该字段的偏移量，flags，如果是静态字段还需要解析该类class实例对应的oop</span></span><br><span class="line">  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    <span class="comment">//将被读取属性的oop放入obj中</span></span><br><span class="line">    pop_and_check_object(obj);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">const</span> Address <span class="title">field</span><span class="params">(obj, off, Address::times_1)</span></span>;</span><br><span class="line"> </span><br><span class="line">  Label Done, notByte, notBool, notInt, notShort, notChar,</span><br><span class="line">              notLong, notFloat, notObj, notDouble;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">shrl</span><span class="params">(flags, ConstantPoolCacheEntry::tos_state_shift)</span></span>;</span><br><span class="line">  <span class="comment">// Make sure we don't need to mask edx after the above shift</span></span><br><span class="line">  assert(btos == <span class="number">0</span>, <span class="string">"change code, btos != 0"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">andl</span><span class="params">(flags, ConstantPoolCacheEntry::tos_state_mask)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否是byte类型</span></span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notZero, notByte)</span></span>;</span><br><span class="line">  <span class="comment">//读取该属性，并放入rax中</span></span><br><span class="line">  <span class="function">__ <span class="title">load_signed_byte</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(btos)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    <span class="comment">//将该指令改写成_fast_bgetfield，下一次执行时就是_fast_bgetfield</span></span><br><span class="line">    patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跳转到Done</span></span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notByte)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否boolean类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ztos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notBool)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ztos (same code as btos)</span></span><br><span class="line">  <span class="function">__ <span class="title">load_signed_byte</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(ztos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    <span class="comment">// use btos rewriting, no truncating to t/f bit is needed for getfield.</span></span><br><span class="line">    patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notBool)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否引用类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, atos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notObj)</span></span>;</span><br><span class="line">  <span class="comment">// atos</span></span><br><span class="line">  <span class="function">__ <span class="title">load_heap_oop</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(atos)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notObj)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否int类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, itos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notInt)</span></span>;</span><br><span class="line">  <span class="comment">// itos</span></span><br><span class="line">  <span class="function">__ <span class="title">movl</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(itos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notInt)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否char类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ctos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notChar)</span></span>;</span><br><span class="line">  <span class="comment">// ctos</span></span><br><span class="line">  <span class="function">__ <span class="title">load_unsigned_short</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(ctos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notChar)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否short类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, stos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notShort)</span></span>;</span><br><span class="line">  <span class="comment">// stos</span></span><br><span class="line">  <span class="function">__ <span class="title">load_signed_short</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(stos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_sgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notShort)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否long类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ltos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notLong)</span></span>;</span><br><span class="line">  <span class="comment">// ltos</span></span><br><span class="line">  <span class="function">__ <span class="title">movq</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(ltos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notLong)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否float类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ftos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notFloat)</span></span>;</span><br><span class="line">  <span class="comment">// ftos</span></span><br><span class="line">  <span class="function">__ <span class="title">movflt</span><span class="params">(xmm0, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(ftos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_fgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notFloat)</span></span>;</span><br><span class="line">  <span class="comment">// 只剩一种double类型</span></span><br><span class="line">  <span class="function">__ <span class="title">movdbl</span><span class="params">(xmm0, field)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">push</span><span class="params">(dtos)</span></span>;</span><br><span class="line">  <span class="comment">// Rewrite bytecode to be faster</span></span><br><span class="line">  <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">    patch_bytecode(Bytecodes::_fast_dgetfield, bc, rbx);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(Done)</span></span>;</span><br><span class="line">  <span class="comment">// [jk] not needed currently</span></span><br><span class="line">  <span class="comment">// volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |</span></span><br><span class="line">  <span class="comment">//                                              Assembler::LoadStore));</span></span><br></pre></td></tr></table></figure><p>这里有几个概念解释一下</p><ul><li><code>_fast_bgetfield</code> 由于JVM的模板解释器的原理很简单，将java字节码所要执行的操作以汇编代码方式（这里说汇编是针对于不同的cpu写出不同的汇编代码）然后在内存中申请一块区域，将代码（也就是二进制流）放到这块区域当中，搞一个函数指针指向这块区域，当然，在执行的时候会直接执行这块区域，那么这就需要操作系统允许应用程序开辟内存，且可以执行这块内存的代码。 所以，汇编指令在编写的时候，很关心需要操作的栈顶元素以及要操作的数据的长度，因此，有一系列的<code>_fast_bgetfield</code> 汇编代码模板。而<code>getstatic / _getfield</code>适用于所有类型的字段属性读取，因此在具体实现时需要根据flags中保存的属性类型适配对应的处理逻辑，为了避免每次都要判断属性类型。定义在<code>hotspot/src/share/vm/interpreter/templateTable.cpp</code>里。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                                    interpr. templates</span></span><br><span class="line"> <span class="comment">// Java spec bytecodes                ubcp|disp|clvm|iswd  in    out   generator             argument</span></span><br><span class="line"> def(Bytecodes::_nop                 , ____|____|____|____, vtos, vtos, nop                 ,  _           );</span><br><span class="line"> def(Bytecodes::_aconst_null         , ____|____|____|____, vtos, atos, aconst_null         ,  _           );</span><br><span class="line"> def(Bytecodes::_iconst_m1           , ____|____|____|____, vtos, itos, iconst              , <span class="number">-1</span>           );</span><br><span class="line">   <span class="comment">// JVM bytecodes</span></span><br><span class="line"> def(Bytecodes::_fast_agetfield      , ubcp|____|____|____, atos, atos, fast_accessfield    ,  atos        );</span><br><span class="line"> def(Bytecodes::_fast_bgetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );</span><br><span class="line"> def(Bytecodes::_fast_cgetfield      , ubcp|____|____|____, atos, itos, fast_accessfield    ,  itos        );</span><br><span class="line"> <span class="comment">//...略</span></span><br><span class="line"></span><br><span class="line"> def(Bytecodes::_fast_aputfield      , ubcp|____|____|____, atos, vtos, fast_storefield ,   atos        );</span><br><span class="line"> def(Bytecodes::_fast_bputfield      , ubcp|____|____|____, itos, vtos, fast_storefield ,   itos        );</span><br><span class="line"> def(Bytecodes::_fast_cputfield      , ubcp|____|____|____, itos, vtos, fast_storefield  ,  itos        );</span><br><span class="line"> <span class="comment">//...略</span></span><br><span class="line"></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><ul><li>__ __ 就是定义一个宏，泛指字节码解释器。<code>#define __ masm-&gt;</code> 而<code>masm</code> 指的就是<code>MacroAssembler</code> 这个类（当然，我是粗略的看了一下，并没有验证，这点存疑）<code>MacroAssembler</code> 就是具体将模板程和JVM的一个媒介。具体如何工作，这里就不在展开。 直接放实现fast_accessfield 的实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::fast_accessfield</span><span class="params">(TosState state)</span> </span>&#123;</span><br><span class="line">  transition(atos, state);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//发布JVMTI事件</span></span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::can_post_field_access()) &#123;</span><br><span class="line">    <span class="comment">// Check to see if a field access watch has been set before we</span></span><br><span class="line">    <span class="comment">// take the time to call into the VM.</span></span><br><span class="line">    Label L1;</span><br><span class="line">    <span class="function">__ <span class="title">mov32</span><span class="params">(rcx, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()))</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">testl</span><span class="params">(rcx, rcx)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::zero, L1)</span></span>;</span><br><span class="line">    <span class="comment">// access constant pool cache entry</span></span><br><span class="line">    <span class="function">__ <span class="title">get_cache_entry_pointer_at_bcp</span><span class="params">(c_rarg2, rcx, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">verify_oop</span><span class="params">(rax)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">push_ptr</span><span class="params">(rax)</span></span>;  <span class="comment">// save object pointer before call_VM() clobbers it</span></span><br><span class="line">    <span class="function">__ <span class="title">mov</span><span class="params">(c_rarg1, rax)</span></span>;</span><br><span class="line">    <span class="comment">// c_rarg1: object pointer copied above</span></span><br><span class="line">    <span class="comment">// c_rarg2: cache entry pointer</span></span><br><span class="line">    <span class="function">__ <span class="title">call_VM</span><span class="params">(noreg,</span></span></span><br><span class="line"><span class="function"><span class="params">               CAST_FROM_FN_PTR(address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                InterpreterRuntime::post_field_access),</span></span></span><br><span class="line"><span class="function"><span class="params">               c_rarg1, c_rarg2)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">pop_ptr</span><span class="params">(rax)</span></span>; <span class="comment">// restore object pointer</span></span><br><span class="line">    <span class="function">__ <span class="title">bind</span><span class="params">(L1)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//获取该字段对应的ConstantPoolCacheEntry</span></span><br><span class="line">  <span class="function">__ <span class="title">get_cache_and_index_at_bcp</span><span class="params">(rcx, rbx, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="comment">//获取字段偏移量</span></span><br><span class="line">  <span class="function">__ <span class="title">movptr</span><span class="params">(rbx, Address(rcx, rbx, Address::times_8,</span></span></span><br><span class="line"><span class="function"><span class="params">                         in_bytes(ConstantPoolCache::base_offset() +</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ConstantPoolCacheEntry::f2_offset())))</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//校验rax中实例对象oop，这里没有像getfield一样先把实例对象从栈顶pop到rax中，而是直接校验</span></span><br><span class="line">  <span class="comment">//这是因为fast_accessfield类指令的栈顶缓存类型是atos而不是vtos，即上一个指令执行完后会自动将待读取的实例放入rax中</span></span><br><span class="line">  <span class="function">__ <span class="title">verify_oop</span><span class="params">(rax)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">null_check</span><span class="params">(rax)</span></span>;</span><br><span class="line">  <span class="function">Address <span class="title">field</span><span class="params">(rax, rbx, Address::times_1)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// access field</span></span><br><span class="line">  <span class="keyword">switch</span> (bytecode()) &#123;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_agetfield:</span><br><span class="line">    <span class="comment">//将属性值拷贝到rax中</span></span><br><span class="line">    <span class="function">__ <span class="title">load_heap_oop</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">verify_oop</span><span class="params">(rax)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_lgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">movq</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_igetfield:</span><br><span class="line">    <span class="function">__ <span class="title">movl</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_bgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">movsbl</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_sgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">load_signed_short</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_cgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">load_unsigned_short</span><span class="params">(rax, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_fgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">movflt</span><span class="params">(xmm0, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_dgetfield:</span><br><span class="line">    <span class="function">__ <span class="title">movdbl</span><span class="params">(xmm0, field)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ShouldNotReachHere();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，其实在对于<code>volatile</code> 变量来说，在读取的时候，并没有做处理。我们在来看写操作。</p><h3><span id="写操作">写操作</span></h3><p><code>_putstatic / _putfield</code> 这两个字节码指令用于写入静态属性或者实例属性，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::putfield</span><span class="params">(<span class="keyword">int</span> byte_no)</span> </span>&#123;</span><br><span class="line">  putfield_or_static(byte_no, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::putstatic</span><span class="params">(<span class="keyword">int</span> byte_no)</span> </span>&#123;</span><br><span class="line">  putfield_or_static(byte_no, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::putfield_or_static</span><span class="params">(<span class="keyword">int</span> byte_no, <span class="keyword">bool</span> is_static)</span> </span>&#123;</span><br><span class="line">  transition(vtos, vtos);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> Register cache = rcx;</span><br><span class="line">  <span class="keyword">const</span> Register index = rdx;</span><br><span class="line">  <span class="keyword">const</span> Register obj   = rcx;</span><br><span class="line">  <span class="keyword">const</span> Register off   = rbx;</span><br><span class="line">  <span class="keyword">const</span> Register flags = rax;</span><br><span class="line">  <span class="keyword">const</span> Register bc    = c_rarg3;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//找到该属性对应的ConstantPoolCacheEntry</span></span><br><span class="line">  resolve_cache_and_index(byte_no, cache, index, <span class="keyword">sizeof</span>(u2));</span><br><span class="line">  <span class="comment">//发布事件</span></span><br><span class="line">  jvmti_post_field_mod(cache, index, is_static);</span><br><span class="line">  <span class="comment">//获取字段偏移量，flags，如果是静态属性获取对应类的class实例</span></span><br><span class="line">  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);</span><br><span class="line"> </span><br><span class="line">  Label notVolatile, Done;</span><br><span class="line">  <span class="function">__ <span class="title">movl</span><span class="params">(rdx, flags)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">shrl</span><span class="params">(rdx, ConstantPoolCacheEntry::is_volatile_shift)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">andl</span><span class="params">(rdx, <span class="number">0x1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//.......</span></span><br><span class="line">  <span class="comment">// btos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将栈顶的待写入值放入rax中</span></span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(btos)</span></span>;</span><br><span class="line">    <span class="comment">//待写入的值pop出去后，如果是实例属性则栈顶元素为准备写入的实例</span></span><br><span class="line">    <span class="comment">//校验该实例是否为空，将其拷贝到obj寄存器中</span></span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="comment">//将rax中的待写入值写入到filed地址处</span></span><br><span class="line">    <span class="function">__ <span class="title">movb</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      <span class="comment">//将该字节码改写成_fast_bputfield，下一次执行时直接执行_fast_bputfield，无需再次判断属性类型</span></span><br><span class="line">      patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notByte)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否boolean类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ztos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notBool)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ztos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(ztos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">andl</span><span class="params">(rax, <span class="number">0x1</span>)</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">movb</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notBool)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否引用类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, atos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notObj)</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notObj)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否int类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, itos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notInt)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// itos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(itos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movl</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notInt)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否char类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ctos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notChar)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ctos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(ctos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movw</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_cputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notChar)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否short类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, stos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notShort)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// stos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(stos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movw</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_sputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notShort)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否long类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ltos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notLong)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ltos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(ltos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movq</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_lputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notLong)</span></span>;</span><br><span class="line">  <span class="comment">//判断是否float类型</span></span><br><span class="line">  <span class="function">__ <span class="title">cmpl</span><span class="params">(flags, ftos)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::notEqual, notFloat)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ftos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(ftos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movflt</span><span class="params">(field, xmm0)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_fputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">jmp</span><span class="params">(Done)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notFloat)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// dtos</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//只剩一个,double类型</span></span><br><span class="line">    <span class="function">__ <span class="title">pop</span><span class="params">(dtos)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) pop_and_check_object(obj);</span><br><span class="line">    <span class="function">__ <span class="title">movdbl</span><span class="params">(field, xmm0)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_static) &#123;</span><br><span class="line">      patch_bytecode(Bytecodes::_fast_dputfield, bc, rbx, <span class="literal">true</span>, byte_no);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(Done)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//判断是否volatile变量，如果不是则跳转到notVolatile</span></span><br><span class="line">  <span class="function">__ <span class="title">testl</span><span class="params">(rdx, rdx)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::zero, notVolatile)</span></span>;</span><br><span class="line">  <span class="comment">//如果是</span></span><br><span class="line">  volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |</span><br><span class="line">                                               Assembler::StoreStore));</span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notVolatile)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们根据上面的template表，可以看到实际执行的代码段<code>fast_storefield</code> 如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::fast_storefield</span><span class="params">(TosState state)</span> </span>&#123;</span><br><span class="line">  transition(state, vtos);</span><br><span class="line"> </span><br><span class="line">  ByteSize base = ConstantPoolCache::base_offset();</span><br><span class="line">  <span class="comment">//发布jvmti时间</span></span><br><span class="line">  jvmti_post_fast_field_mod();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//获取该字段对应的ConstantPoolCacheEntry</span></span><br><span class="line">  <span class="function">__ <span class="title">get_cache_and_index_at_bcp</span><span class="params">(rcx, rbx, <span class="number">1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//获取该字段的flags</span></span><br><span class="line">  <span class="function">__ <span class="title">movl</span><span class="params">(rdx, Address(rcx, rbx, Address::times_8,</span></span></span><br><span class="line"><span class="function"><span class="params">                       in_bytes(base +</span></span></span><br><span class="line"><span class="function"><span class="params">                                ConstantPoolCacheEntry::flags_offset())))</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//获取该字段的偏移量</span></span><br><span class="line">  <span class="function">__ <span class="title">movptr</span><span class="params">(rbx, Address(rcx, rbx, Address::times_8,</span></span></span><br><span class="line"><span class="function"><span class="params">                         in_bytes(base + ConstantPoolCacheEntry::f2_offset())))</span></span>;</span><br><span class="line"> </span><br><span class="line">  Label notVolatile;</span><br><span class="line">  <span class="function">__ <span class="title">shrl</span><span class="params">(rdx, ConstantPoolCacheEntry::is_volatile_shift)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">andl</span><span class="params">(rdx, <span class="number">0x1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//将待写入的实例对象pop到rcx中，注意此处并没有像putfield一样把待写入的值先pop到rax中，</span></span><br><span class="line">  <span class="comment">//这是因为fast_storefield类的栈顶缓存类型不是vtos而是具体的写入值类型对应的类型，即上一个</span></span><br><span class="line"><span class="comment">//字节码指令执行完成后会自动将待写入的值放入rax中</span></span><br><span class="line">  pop_and_check_object(rcx);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// field address</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Address <span class="title">field</span><span class="params">(rcx, rbx, Address::times_1)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// access field</span></span><br><span class="line">  <span class="keyword">switch</span> (bytecode()) &#123;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_aputfield:</span><br><span class="line">    do_oop_store(_masm, field, rax, _bs-&gt;kind(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_lputfield:</span><br><span class="line">    <span class="comment">//将rax中的属性值写入到field地址</span></span><br><span class="line">    <span class="function">__ <span class="title">movq</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_iputfield:</span><br><span class="line">    <span class="function">__ <span class="title">movl</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_zputfield:</span><br><span class="line">    <span class="function">__ <span class="title">andl</span><span class="params">(rax, <span class="number">0x1</span>)</span></span>;  <span class="comment">// boolean is true if LSB is 1</span></span><br><span class="line">    <span class="comment">// fall through to bputfield</span></span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_bputfield:</span><br><span class="line">    <span class="function">__ <span class="title">movb</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_sputfield:</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_cputfield:</span><br><span class="line">    <span class="function">__ <span class="title">movw</span><span class="params">(field, rax)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_fputfield:</span><br><span class="line">    <span class="function">__ <span class="title">movflt</span><span class="params">(field, xmm0)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bytecodes::_fast_dputfield:</span><br><span class="line">    <span class="function">__ <span class="title">movdbl</span><span class="params">(field, xmm0)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ShouldNotReachHere();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//判断是否volatile变量</span></span><br><span class="line">  <span class="function">__ <span class="title">testl</span><span class="params">(rdx, rdx)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">jcc</span><span class="params">(Assembler::zero, notVolatile)</span></span>;</span><br><span class="line">  volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |</span><br><span class="line">                                               Assembler::StoreStore));</span><br><span class="line">  <span class="function">__ <span class="title">bind</span><span class="params">(notVolatile)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>fast_storefield</code> 还是 <code>putfield_or_static</code> 他们都判断了是否是<code>volatile</code> 变量，然后执行了 <code>volatile_barrier</code> 方法。<br>我们来看一下<code>volatile_barrier</code> 方法做了什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::volatile_barrier</span><span class="params">(Assembler::Membar_mask_bits</span></span></span><br><span class="line"><span class="function"><span class="params">                                order_constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (os::is_MP()) &#123; <span class="comment">//如果是多处理器系统</span></span><br><span class="line">        <span class="function">__ <span class="title">membar</span><span class="params">(order_constraint)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">membar</span><span class="params">(Membar_mask_bits order_constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">        <span class="comment">//只要包含StoreLoad</span></span><br><span class="line">        <span class="keyword">if</span> (order_constraint &amp; StoreLoad) &#123;</span><br><span class="line">            <span class="comment">//lock是一个指令前缀，实际执行的一条指令lock addl $0×0,(%rsp);</span></span><br><span class="line">            lock();</span><br><span class="line">            addl(Address(rsp, <span class="number">0</span>), <span class="number">0</span>);<span class="comment">// Assert the lock# signal here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是volatile变量，在属性修改完成后就会执行<code>lock addl $0×0,(%rsp);</code>。<br><strong>所以lock指令有两个含义，1、是形成流水行内存屏障，是的流水线执行顺序执行，2、是的MESI协议中的其他cpu缓存失效，并且将值写入内存，</strong>，这样volatile 其他cpu读取的时候就会直接从内存当中加载，而不是使用自己的缓存。</p><h3><span id="cppinterpreter-解释下的">CppInterpreter 解释下的</span></h3><p>hotspot解释器模块(hotspot\src\share\vm\interpreter)有两个实现：</p><ul><li>C++解释器 = bytecodeInterpreter* + cppInterpreter*</li><li>模板解释器 = templateTable* + templateInterpreter*</li></ul><p>模板解释器我们看完了，下面我们来看一下C++ 解释器的实现。代码位于<code>hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CASE(_getfield):</span><br><span class="line">CASE(_getstatic):</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//... 略</span></span><br><span class="line">        TosState tos_type = cache-&gt;flag_state();</span><br><span class="line">        <span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="comment">//... 略  并没有加屏障处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CASE(_putfield):</span><br><span class="line">CASE(_putstatic):</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        OrderAccess::storeload();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//略</span></span><br></pre></td></tr></table></figure><p>可以看到，在执行完操作之后，bytecodeInterpreter 增加了<code>OrderAccess::storeload()</code> 屏障，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (java 8) hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadload</span><span class="params">()</span>   </span>&#123; acquire(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storestore</span><span class="params">()</span> </span>&#123; release(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadstore</span><span class="params">()</span>  </span>&#123; acquire(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storeload</span><span class="params">()</span>  </span>&#123; fence(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> local_dummy;    <span class="comment">//c++ volatile 变量  // 避免命中同一个缓存行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"movq 0(%%rsp), %0"</span> : <span class="string">"=r"</span> (local_dummy) : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"movl 0(%%esp),%0"</span> : <span class="string">"=r"</span> (local_dummy) : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 避免命中同一个缓存行</span></span><br><span class="line">  <span class="keyword">volatile</span> jint local_dummy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 在java9以后的版本当中，除了之外，都换成了 fence 方法以外，都换成了编译器屏障，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (java 9) hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A compiler barrier, forcing the C++ compiler to invalidate all memory assumptions</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">compiler_barrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">""</span> : : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadload</span><span class="params">()</span>   </span>&#123; compiler_barrier(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storestore</span><span class="params">()</span> </span>&#123; compiler_barrier(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadstore</span><span class="params">()</span>  </span>&#123; compiler_barrier(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storeload</span><span class="params">()</span>  </span>&#123; fence();            &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::acquire</span><span class="params">()</span>    </span>&#123; compiler_barrier(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::release</span><span class="params">()</span>    </span>&#123; compiler_barrier(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  compiler_barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何 <code>__asm__ volatile (&quot;&quot; : : : &quot;memory&quot;);</code> 和<code>__asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;)</code> 完成的效果一样，都是禁止编译器进行优化，并且从内存取数据，而不要从寄存器取数据，如果想了解编译器优化，可以参考我的另一篇博文<a href="https://icefrozen.github.io/article/java-memory-model-complier-reordering/" target="_blank" rel="noopener">Java内存模型(2)编译器重排序</a></p><h2><span id="总结">总结</span></h2><p>总结一下，对于非volatile变量，虽然通过movl等指令修改了某个属性，但是这个修改只是对该CPU所属的高速缓存的修改，并没有实时写回到主内存中，在某个时机下如进程由用户态切换到内核态或者这里的执行lock指令会将对高速缓存行的修改回写到主内存中，同时通过缓存一致性协议通知其他CPU的高速缓存控制器将相关变量的高速缓存行置为无效，当其他CPU再次读取该缓存行时发现该缓存行是无效的，就会重新从主内存加载该变量到高速缓存行中，从而实现对其他CPU的可见性。</p><h2><span id="实验">实验</span></h2><p>你以为就完了，那就太容易，只有理论没有时间自然不能信服，下面我需要用到反汇编指令查看上述的问题。首先，我们用到的linux版本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/workplace/javalean/debug/javaclass$ uname -a</span><br><span class="line">Linux ubuntu 5.4.0-73-generic <span class="comment">#82~18.04.1-Ubuntu SMP Fri Apr 16 15:10:02 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><ul><li><a href="http://xn--hsdis-amd64-vd2rv030b.so" target="_blank" rel="noopener">使用hsdis-amd64.so</a>  首先你需要在网上找一个 <a href="http://hsdis-amd64.so" target="_blank" rel="noopener">hsdis-amd64.so</a> 库，然后放到jdk的目录下<code>/jre/lib/amd66</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/lib/jvm/java<span class="number">-8</span>-openjdk-amd64/jre/lib/amd64$ ls</span><br><span class="line">hsdis-amd64.so      libhprof.so          libjava.so        libnio.so</span><br><span class="line">jli                 libicedtea-sound.so  libjawt.so        libnpt.so</span><br><span class="line">jvm.cfg             libinstrument.so     libjdwp.so        libsaproc.so</span><br><span class="line">jvm.cfg-<span class="keyword">default</span>     libj2gss.so          libjsdt.so        libsctp.so</span><br><span class="line">libattach.so        libj2pcsc.so         libjsig.so        libsplashscreen.so</span><br><span class="line">libawt_headless.so  libj2pkcs11.so       libjsoundalsa.so  libsunec.so</span><br><span class="line">libawt.so           libjaas_unix.so      libjsound.so      libunpack.so</span><br><span class="line">libawt_xawt.so      libjava_crw_demo.so  libmanagement.so  libverify.so</span><br><span class="line">libdt_socket.so     libjavajpeg.so       libmlib_image.so  libzip.so</span><br><span class="line">libfontmanager.so   libjavalcms.so       libnet.so         server</span><br></pre></td></tr></table></figure><ul><li>编写我们的程序，使得程序可以执行 如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val++;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">add2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        val2++;</span><br><span class="line">        <span class="keyword">return</span> val2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileCode volatileCode = <span class="keyword">new</span> VolatileCode();</span><br><span class="line">        volatileCode.add();</span><br><span class="line">        volatileCode.add2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译，并加上打印参数如下<ul><li>-XX:+UnlockDiagnosticVMOptions</li><li>-XX:PrintAssembly 打印JIT编译后的汇编</li><li>-XX:CompileCommand=print,*MyClass.myMethod 过滤输出</li></ul></li></ul><p>过滤 add 和add2的方法，这里加上了 <code>-Xcomp</code> 确保是使用模板解释器来进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp -XX:CompileCommand=compileonly,*VolatileCode::add*  VolatileCode</span><br></pre></td></tr></table></figure><p>得到结果如下：<br>add 方法下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line"> Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x00007f3cd5ba83d0&#125; 'add' '()I' in 'VolatileCode'</span><br><span class="line">  #           [sp+<span class="number">0x20</span>]  (sp of caller)</span><br><span class="line">  <span class="comment">// ............ 略</span></span><br><span class="line">  <span class="number">0x00007f3cc110af47</span>: mov    %rbp,<span class="number">0x10</span>(%rsp)    ;*synchronization entry</span><br><span class="line">                                                ; - VolatileCode::add@<span class="number">-1</span> (line <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x00007f3cc110af4c</span>: mov    <span class="number">0xc</span>(%rsi),%r11d</span><br><span class="line">  <span class="number">0x00007f3cc110af50</span>: inc    %r11d</span><br><span class="line">  <span class="number">0x00007f3cc110af53</span>: mov    %r11d,<span class="number">0xc</span>(%rsi)</span><br><span class="line">  <span class="number">0x00007f3cc110af57</span>: lock addl $<span class="number">0x0</span>,(%rsp)     ;*putfield val</span><br><span class="line">                                                ; - VolatileCode::add@<span class="number">7</span> (line <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x00007f3cc110af5c</span>: mov    <span class="number">0xc</span>(%rsi),%eax     ;*getfield val</span><br><span class="line">                                                ; - VolatileCode::add@<span class="number">11</span> (line <span class="number">9</span>)</span><br><span class="line">    <span class="comment">// .......... 略</span></span><br><span class="line">  <span class="number">0x00007f3cc110af6a</span>: retq</span><br></pre></td></tr></table></figure><p>add2的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;0x00007f3cd5ba8470&#125; 'add2' '()I' in 'VolatileCode'</span><br><span class="line">  #           [sp+<span class="number">0x40</span>]  (sp of caller)</span><br><span class="line">    <span class="comment">//.......... 略</span></span><br><span class="line">  <span class="number">0x00007f3cc110f35c</span>: add    $<span class="number">0x8</span>,%edi</span><br><span class="line">  <span class="number">0x00007f3cc110f35f</span>: mov    %edi,<span class="number">0xdc</span>(%rax)</span><br><span class="line">  0x00007f3cc110f365: movabs $0x7f3cd5ba8470,%rax  ;   &#123;metadata(&#123;method&#125; &#123;0x00007f3cd5ba8470&#125; 'add2' '()I' in 'VolatileCode')&#125;</span><br><span class="line">  <span class="number">0x00007f3cc110f36f</span>: <span class="keyword">and</span>    $<span class="number">0x0</span>,%edi</span><br><span class="line">  <span class="number">0x00007f3cc110f372</span>: cmp    $<span class="number">0x0</span>,%edi</span><br><span class="line">  <span class="number">0x00007f3cc110f375</span>: je     <span class="number">0x00007f3cc110f38f</span>  ;*aload_0</span><br><span class="line">                                                ; - VolatileCode::add2@<span class="number">0</span> (line <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x00007f3cc110f37b</span>: mov    <span class="number">0x10</span>(%rsi),%eax    ;*getfield val2</span><br><span class="line">                                                ; - VolatileCode::add2@<span class="number">2</span> (line <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x00007f3cc110f37e</span>: inc    %eax</span><br><span class="line">  <span class="number">0x00007f3cc110f380</span>: mov    %eax,<span class="number">0x10</span>(%rsi)    ;*putfield val2</span><br><span class="line">                                                ; - VolatileCode::add2@<span class="number">7</span> (line <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......... 略</span></span><br><span class="line">  <span class="number">0x00007f3cc110f38e</span>: retq</span><br></pre></td></tr></table></figure><p>对于add 和add2 来说 add 比add多了一个 lock指令。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/qq_29328443/article/details/107570280" target="_blank" rel="noopener">深入理解Java volatile关键字</a></li><li><a href="https://blog.csdn.net/u013928208/article/details/109166440" target="_blank" rel="noopener">HotSpot volatile原理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(2)</title>
      <link href="/article/java-memory-model-complier-reordering/"/>
      <url>/article/java-memory-model-complier-reordering/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>在我的<a href="https://icefrozen.github.io/article/java-memory-model/" target="_blank" rel="noopener">Java内存模型(1)JMM是什么</a> 中我已经阐述了<code>JMM</code>是什么以及CPU缓存模型和流水线的技术，下面针对于指令重排序中的编译器重排序做深入的讨论。</p><h2><span id="内存模型在jvm的应用">内存模型在JVM的应用</span></h2><p>首先，我们再来重温一下，三种重排序。</p><h2><span id="重排序">重排序</span></h2><p>指令重排序:在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li><strong>编译器优化的重排序</strong></li></ul><p>编译器在不改变单线程程序语义的前提下（代码中不包含synchronized关键字），可以重新安排语句的执行顺序。（就是本文要介绍的）</p><ul><li><strong>指令级并行的重排序</strong></li></ul><p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。（具体细节可以参考<a href="https://icefrozen.github.io/article/java-memory-model/" target="_blank" rel="noopener">Java内存模型(1)JMM是什么</a>）</p><ul><li><strong>内存系统的重排序</strong></li></ul><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。（原因请参参考<a href="https://icefrozen.github.io/article/why-memory-barriers-1/" target="_blank" rel="noopener">CPU缓存一致性协议深入理解内存屏障</a>）<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序</p><p>这里主要分享一下一下编译器优化重排序.</p><h2><span id="编译器重排序">编译器重排序</span></h2><h3><span id="什么是编译器重排序">什么是编译器重排序</span></h3><p>编译器会对高级语言（本文里特指C/C++）的代码进行分析，当编译器认为你的代码可以优化的话，编译器会选择对代码进行优化然后生成汇编代码，当然编译器的优化满足特定的条件，这里要说一下大名鼎鼎的as-if规则：</p><blockquote><p>Allows any and all code transformations that do not change the observable behavior of the program.</p></blockquote><p>也就是说在不影响这段代码结果的前提下，编译器可以使用任意一种方式对代码进行编译，这也就给了编译器充分的空间对代码进行优化，从而提高代码的运行效率。</p><h3><span id="编译器重排序">编译器重排序</span></h3><p>举个例子,下面是一段简单的C语言代码：</p><p>环境如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux CentOS7 3.10.0-1127.19.1.el7.x86_64 <span class="comment">#1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">gcc 版本 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br></pre></td></tr></table></figure><p>我们编译的时候后使用 -O2 进行编译器优化。然后我们使用<code>objdump</code>进行反汇编代码的查看。<code>编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">a = b + <span class="number">11</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译  -g 表示输出调试信息</span></span><br><span class="line">gcc -O2 -g -o foo.o foo.c</span><br><span class="line"></span><br><span class="line"><span class="comment">//objdump 反汇编 并查看 foo函数上下14行数据</span></span><br><span class="line"><span class="meta"># objdump -C -d foo.o | grep -A14 foo</span></span><br><span class="line"></span><br><span class="line">foo.o：     文件格式 elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400510</span> &lt;foo&gt;:</span><br><span class="line">  <span class="number">400510</span>:<span class="number">8b</span> <span class="number">05</span> <span class="number">1</span>a <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    <span class="number">0x200b1a</span>(%rip),%eax        # <span class="number">601030</span> &lt;__TMC_END__&gt;</span><br><span class="line">  <span class="number">400516</span>:c7 <span class="number">05</span> <span class="number">10</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x0</span>,<span class="number">0x200b10</span>(%rip)        # <span class="number">601030</span> &lt;__TMC_END__&gt;</span><br><span class="line">  <span class="number">40051</span>d:<span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">400520</span>:<span class="number">83</span> c0 <span class="number">0b</span>             add    $<span class="number">0xb</span>,%eax</span><br><span class="line">  <span class="number">400523</span>:<span class="number">89</span> <span class="number">05</span> <span class="number">0b</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    %eax,<span class="number">0x200b0b</span>(%rip)        # <span class="number">601034</span> &lt;a&gt;</span><br><span class="line">  <span class="number">400529</span>:c3                   retq</span><br><span class="line">  <span class="number">40052</span>a:<span class="number">66</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>    nopw   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ... 略</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以使用线上的工具进行编译查看 <a href="https://godbolt.org/" target="_blank" rel="noopener">https://godbolt.org/</a></p><p><img src="/article/java-memory-model-complier-reordering/java-memory-model-complier-reordering-1626149586631.png" alt></p><p>我们来解释一下代码：</p><table><thead><tr><th>编译结果</th><th>网站结果</th><th>含义</th></tr></thead><tbody><tr><td>mov  0x200b1a(%rip),%eax</td><td>movl    b(%rip), %eax</td><td>将rip寄存器里的地址中的值， 赋值给 eax寄存器</td></tr><tr><td>movl $0x0,0x200b10(%rip)</td><td>movl  $0, b(%rip)</td><td>将 0 赋值到 rip寄存器里地址</td></tr><tr><td>add $0xb,%eax</td><td>add $11, %eax</td><td>将 11 + eax 寄存器里（上面说了是rip寄存器的值）</td></tr><tr><td>mov %eax,0x200b0b(%rip)</td><td>mov %eax, a(%rip)</td><td>将集群器eax 里的值赋值给 rip里地址的区域</td></tr></tbody></table><p>rip 寄存器涉及寻址，我们这里不做讨论，只要知道</p><ul><li>1、首先，rip 里存放的是b的地址，b的地址里放着b的初始值</li><li>2、将b的地址的值赋值给了eax, 然后 将0复制给了rip里地址地址，也就是b, 然后将11 加上 eax 寄存器的值（我们知道，eax是b的初始值），最后，将结果给了rip的地址（此时rip已经执向a的地址）</li></ul><p><strong>我们发现，编译得到的汇编代码和我们原本的C语言代码不顺序并不一致，而是相当于如下C语言代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line">  a = b + <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器的本意是提升程序在CPU上的运行性能，更好的使用寄存器以及现代处理器的流水线技术，减少汇编指令的数量，降低程序执行需要的CPU周期，减少CPU读写主存的时间，但是在多核多线程并行的情况下，这种重排序优化就有可能导致共享变量的可见性问题。</p><p>当然编译器的优化也不仅限于对于代码的重排序，编译器还会优化掉它认为不需要的一些变量，同时也会将一些本应去内存中取得数据存入寄存器中，然后下次取得时候就可以直接从寄存器中获取（这样也可能导致多线程中共享变量的可见性问题）。</p><p>当然，as-if规则在单核CPU时代是完全没有问题的，但是随着CPU的发展，出现了可以多核并行的CPU，这时编译器重排序就可能导致一些令人意想不到的问题，这点我们从感性认知上就可以理解，因为在多线程编程中经常会使用一些共享变量来实现不同线程的控制或者数据传输，但是如果编译器把我们精心设计的代码顺序进行了“优化“，就有可能出现我们不希望出现的运行结果</p><h3><span id="编译器优化">编译器优化</span></h3><p>前面我一直想用“优化&quot;这个词，而不是用”重排序”这个词，是因为编译器对于代码的优化不仅限于重排序，编译器同时会删除一些它认为无用的代码，更重要的是，会把一些变量放进寄存器中！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (run);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 的汇编变代码</span></span><br><span class="line"><span class="number">400500</span>:<span class="number">8b</span> <span class="number">05</span> <span class="number">26</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    <span class="number">0x200b26</span>(%rip),%eax        # <span class="number">60102</span>c &lt;run&gt;</span><br><span class="line"><span class="number">400506</span>:<span class="number">85</span> c0                test   %eax,%eax</span><br><span class="line"><span class="number">400508</span>:<span class="number">75</span> <span class="number">02</span>                jne    <span class="number">40050</span>c &lt;foo+<span class="number">0xc</span>&gt;</span><br><span class="line"><span class="number">40050</span>a:f3 c3                repz retq</span><br><span class="line"><span class="number">40050</span>c:eb fe                jmp    <span class="number">40050</span>c &lt;foo+<span class="number">0xc</span>&gt;</span><br><span class="line"><span class="number">40050</span>e:<span class="number">66</span> <span class="number">90</span>                xchg   %ax,%ax</span><br></pre></td></tr></table></figure><p>首先来看一下 几个指令的含义</p><blockquote><p><code>test a,b</code>是做 AND 运算（虽然通常是用来测试结果是否为零，但不限于此，比如一些位掩码操作，或者正负号判断等），但不把结果写回目的操作数，仅根据结果的值来置标志位。</p></blockquote><blockquote><p><code>jne</code> 当运算结果不为0时则跳转</p></blockquote><blockquote><p><code>jmp</code> 为无条件跳转</p></blockquote><ul><li>从rip地址中取的run的值放入 eax寄存器</li><li>判断寄存器eax当中的值是不是0</li><li>如果不是0 则跳转到 40050c 这个地址</li><li>40050c 地址的指令为 jmp 40050c 无条件循环</li></ul><p>那么问题来了，这里跳转以后并没有重新去取内存中run的值，而是进入了死循环，也就是说这段代码理论上会一直运行下去，即使别的线程会去更改内存中run的值，也不会跳出循环，其实这就导致了多线程中共享变量的可见性问题。</p><h2><span id="禁止重排序优化">禁止重排序/优化</span></h2><p>之前已经说了，多线程情况下编译器优化会导致一些问题的出现，那么有没有方法来阻止编译器的优化呢？答案是肯定的，而且方式还不止一种：</p><ul><li><strong>将变量声明为volatile变量（注意：Java中的volatile变量更强大）</strong></li><li><strong>代码中插入编译器屏障(Compiler Barrier)，阻止编译器对屏障前后的代码进行优化，因此编译器屏障也被叫做优化屏障(Optimization Barrier)</strong></li></ul><p>为了防止读者误解，在这里先做说明：<strong>C/C++中将变量声明为volatile相当于对这个变量的每一次操作前后插入一个编译器屏障</strong>。了解了这一点前提后，我们就能更好的解释后续的一些概念。</p><p>编译器屏障的作用是什么？阻止编译器对屏障前后的代码进行重排序优化，同时阻止编译器将变量置入寄存器中随后直接使用，而是需要取内存中（或者CPU缓存中）的变量值进行运算操作。简而言之，就是禁止编译屏障前后编译器对于变量操作的优化（重排序、从寄存器中取值使用）</p><h3><span id="禁止重排序">禁止重排序</span></h3><p>我们来看源码，注意编译还是用的 以上 -O2的编译优化等级。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span>: : :<span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = b + <span class="number">11</span>;</span><br><span class="line">  barrier(); <span class="comment">// 插入编译器屏障(优化屏障)</span></span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400510</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">400510</span>:<span class="number">8b</span> <span class="number">05</span> <span class="number">1</span>a <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    <span class="number">0x200b1a</span>(%rip),%eax        # <span class="number">601030</span> &lt;__TMC_END__&gt;</span><br><span class="line"><span class="number">400516</span>:<span class="number">83</span> c0 <span class="number">0b</span>             add    $<span class="number">0xb</span>,%eax</span><br><span class="line"><span class="number">400519</span>:<span class="number">89</span> <span class="number">05</span> <span class="number">15</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    %eax,<span class="number">0x200b15</span>(%rip)        # <span class="number">601034</span> &lt;a&gt;</span><br><span class="line"><span class="number">40051f</span>:c7 <span class="number">05</span> <span class="number">07</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x0</span>,<span class="number">0x200b07</span>(%rip)        # <span class="number">601030</span> &lt;__TMC_END__&gt;</span><br><span class="line"><span class="number">400526</span>:<span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">400529</span>:c3                   retq</span><br><span class="line"><span class="number">40052</span>a:<span class="number">66</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>    nopw   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/article/java-memory-model-complier-reordering/java-memory-model-complier-reordering-1626242899935.png" alt></p><p>再来根据上面的方法进行分析，我们得到了 b = 0 已经确实移动到了 a = b + 1 之后了。 原因在于我们加了一个屏障。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span>: : :<span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure><p>这是是一段内嵌汇编代码, <code>__asm__</code>代表C语言内嵌汇编代码，<code>__volatile__</code> 是告诉编译器不要把这行代码进行任何优化</p><p><code>(“”: : :”memory”)</code>这个比较复杂，但是在这里只需要知道，这段代码的意思是告诉编译器“内存发生了改变”，因此GCC编译时就会知道，不能使用寄存器中的值，而是要去内存中取值，且不能将屏障前后的代码重排序。</p><p>可以看到，使用了编译器屏障以后，代码并没有进行重排序，之前也提到编译器还会对代码进行优化，将本来应该从内存中取值的变量放在寄存器中，那么编译器屏障能解决这个现象吗？</p><h3><span id="内存取值">内存取值</span></h3><p>本文之前提到，编译器会将变量放入CPU寄存器中，减少访问内存（缓存）耗时，但是有些情况下放入寄存器会导致多线程环境下的变量不可见性。</p><p>那么编译器屏障能解决这个问题吗？我们看之前的代码插入编译器屏障以后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span>: : :<span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="keyword">int</span> run;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(run) &#123;</span><br><span class="line">      barrier();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400500</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">400500</span>:eb <span class="number">06</span>                jmp    <span class="number">400508</span> &lt;foo+<span class="number">0x8</span>&gt;</span><br><span class="line"><span class="number">400502</span>:<span class="number">66</span> <span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>    nopw   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line"><span class="number">400508</span>:<span class="number">8b</span> <span class="number">05</span> <span class="number">1</span>e <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    <span class="number">0x200b1e</span>(%rip),%eax        # <span class="number">60102</span>c &lt;run&gt;</span><br><span class="line"><span class="number">40050</span>e:<span class="number">85</span> c0                test   %eax,%eax</span><br><span class="line"><span class="number">400510</span>:<span class="number">75</span> f6                jne    <span class="number">400508</span> &lt;foo+<span class="number">0x8</span>&gt;</span><br><span class="line"><span class="number">400512</span>:f3 c3                repz retq</span><br><span class="line"><span class="number">400514</span>:<span class="number">66</span> <span class="number">2</span>e <span class="number">0f</span> <span class="number">1f</span> <span class="number">84</span> <span class="number">00</span> <span class="number">00</span> nopw   %cs:<span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line"><span class="number">40051b</span>:<span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">40051</span>e:<span class="number">66</span> <span class="number">90</span>                xchg   %ax,%ax</span><br></pre></td></tr></table></figure><p>编译后，我们可以看到 jne 直接跳到了 400508 而 400508段指令为：mov    0x200b1e(%rip),%eax，<br>表示 run 从地址中取值，而不是直接死循环了。相较于之前的跳转到本行的行为，相当于消除了编译器对于变量存入寄存器的优化。</p><h3><span id="volatilecc">volatile(C/C++)</span></h3><p>相应的，也可以通过把run变量声明为volatile变量，告诉编译器这个变量的不可优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">volatile</span> run;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400500</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">400500</span>:<span class="number">8b</span> <span class="number">05</span> <span class="number">26</span> <span class="number">0b</span> <span class="number">20</span> <span class="number">00</span>    mov    <span class="number">0x200b26</span>(%rip),%eax        # <span class="number">60102</span>c &lt;run&gt;</span><br><span class="line"><span class="number">400506</span>:<span class="number">85</span> c0                test   %eax,%eax</span><br><span class="line"><span class="number">400508</span>:<span class="number">75</span> f6                jne    <span class="number">400500</span> &lt;foo&gt;</span><br><span class="line"><span class="number">40050</span>a:f3 c3                repz retq</span><br><span class="line"><span class="number">40050</span>c:<span class="number">0f</span> <span class="number">1f</span> <span class="number">40</span> <span class="number">00</span>          nopl   <span class="number">0x0</span>(%rax)</span><br></pre></td></tr></table></figure><p>可以看到 jne 跳到了400500 行，而 400500 行正式从内存中取值run</p><p>C/C++中的volatile关键字作用和Java中是不同的，Java中volatile关键字相当于C/C++的加强版，至于怎么进行加强，以后我会着重说一说。</p><p>C/C++中的volatile关键字，我之说过，相当于对这个变量前后插入了内存屏障，其实这样说有些不够精确，其核心作用就是禁止编译器对于这个变量/代码块进行任何优化，禁止重排序、禁止使用寄存器而不取内存值、禁止编译器将其认为无用的代码优化掉。</p><p>但是Linux内核编程中是很抵制程序员使用volatile关键字的，因为Linux本身对于同步控制提供了各种API，都可以替代直接使用volatile关键字，其实Linux和JVM设计思路上有些一直，屏蔽了这些API的实现细节，就像JVM屏蔽了volatile、synchronized关键字的实现细节。但是有一点不得不说，无论是Linux还是JVM，底层都使用到了编译器屏障来防止一些问题的出现。</p><h2><span id="其他方式禁止实现编译器屏障">其他方式禁止实现编译器屏障</span></h2><p>试想一下，除了<code>__asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</code> 和 c++ 的volatile 关键字之外，还有什么方法可以实现编译器屏障的效果呢？我在openjdk1.8 的hotspot的时候见到过这样实现屏障的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将寄存器栈顶值复制给局部变量，保证了编译器不会重排序</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> local_dummy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"movq 0(%%rsp), %0"</span> : <span class="string">"=r"</span> (local_dummy) : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"movl 0(%%esp),%0"</span> : <span class="string">"=r"</span> (local_dummy) : : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span><br></pre></td></tr></table></figure><p>可以看到，这里是将 将寄存器栈顶值复制给局部变量。这个局部变量又是 <code>volatile</code> 的。不难看出，如果 <code>barrier</code> 换成了 <code>__asm__ volatile (&quot;movq 0(%%rsp), %0&quot; : &quot;=r&quot; (local_dummy) : : &quot;memory&quot;)</code> 之后， 其实和<code>__asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</code> 实现的效果差不多，只不过多了一步将寄存器栈顶值复制给局部变量， 后续就会释放这个局部局部变量，他的根本目的还是在于将barrier 前后的代码分割开来，破坏优化形成的条件。</p><p>但是jdk9以后统一使用了<code>__asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</code> 这种写法，看来这种写法冗余了，但是当初为什么这么写我没有找到资料，这里存个疑。但是有一种说法是为了让该变量独立落在一个缓存行当中，所以在这里定义了一个内部无用的变量。</p><p>下一篇，我会讨论Java volatile 和 synchronized 关键字的底层实现原理。</p><h2><span id="结束">结束</span></h2><p>之所以介绍编译器屏障，是因为在jvm当中曾经大量使用了屏障，编译解析阶段，都存在屏障的代码，后续的文章中，我会逐一介绍。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDk3NjM3Mg==&amp;mid=2247483755&amp;idx=1&amp;sn=50f80e73f46fab04d8a799e8731432c6&amp;chksm=fa48da70cd3f5366d9658277cccd9e36fca540276f580822d41aef7d8af4dda480fc85e3bde4&amp;token=1422563498&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从 Java 内存模型看内部细节</a></li><li><a href="https://blog.csdn.net/CringKong/article/details/99759216?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-1-99759216.pc_agg_rank_aggregation&amp;utm_term=%E7%BC%96%E8%AF%91%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F&amp;spm=1000.2123.3001.4430" target="_blank" rel="noopener">编译器重排序</a></li><li><a href="https://blog.csdn.net/CringKong/article/details/99759216" target="_blank" rel="noopener">synchronized 关键字实现细节</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU缓存一致性协议</title>
      <link href="/article/why-memory-barriers-1/"/>
      <url>/article/why-memory-barriers-1/</url>
      
        <content type="html"><![CDATA[<h1><span id="cpu-结构">CPU 结构</span></h1><p>现代多核处理器，一个CPU由多个核组成，每个核又可以有多个硬件线程，比如我们说4核8线程，就是指有4个核，每个核2个线程，这在OS看来就像8个并行处理器一样。<br>CPU缓存有多级缓存，比如L1, L2, L3等：<br>L1容量最小，速度最快，每个核都有L1缓存，L1又专门针对指令和数据分成L1d(数据缓存),L1i(指令缓存)。<br>L2容量比L1大，速度比L1慢，每个核都有L2缓存。<br>L3容量最大，速度最慢，多个核共享一个L3缓存。<br>有些CPU可能还有L4缓存，不过不常见；此外还有其他类型的缓存，比如TLB(translation lookaside buffer)，用于物理地址和虚拟地址转译，这不是我们关心的缓存。</p><p>这里盗个图</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624332073901.png" alt></p><h1><span id="cpu-缓存工作原理">CPU 缓存工作原理</span></h1><p>CPU cache和内存系统使用固定大小的数据块来进行交互，这个数据块被称为<code>Cache line</code>，<code>Cache line</code>的大小一般是2的整数次幂。根据设计的不同，从16B到256B不等。当CPU首次访问某个数据的时候，它没有在<code>Cpu cache</code>中，我们称之为<code>Cache miss</code>。在这种情况下，cpu需要花费几百个cycle去把该数据对应的<code>Cache line</code>从内存中中加载到cpu cache中，而在这个过程中，cpu只能是等待那个耗时内存操作完成。一旦完成了cpu cache数据的加载，随后的访问会由于数据在cache中而使得cpu全速运行。</p><p>运行一段时间之后，cpu cache的所有<code>Cache line</code>都会被填充有效的数据，这时候的，要加载新的数据到cache中必须将其他原来有效的cache数据“强制驱离”（一般选择最近最少使用的那些<code>Cache line</code>）。这种cache miss被称为capacity miss，因为CPU cache的容量有限，必须为新数据找到空闲的<code>Cache line</code>。有的时候，即便是cache中还有闲置的<code>Cache line</code>，旧的cache数据也会被“强制驱离”，以便为新的数据加载到<code>Cache line</code>中做准备。</p><p>当然，这是和cache的组织有关。比较大的cache往往实现成hash table（为了硬件性能），所有的cache line被分成了若干个固定大小的hash buckets（更专业的术语叫做set），这些hash buckets之间不是形成链表，而是类似阵列。</p><h2><span id="缓存结构">缓存结构</span></h2><p>一块CPU缓存可以看成是一个数组，数组元素是缓存项(cache entry)，一个缓存项的内容大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+   </span><br><span class="line">|  tag  |   data block(cache line) |  flag  |   </span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>data block就是从内存中拷贝过来的数据，也就是我们说的cache line，从上面信息可知大小是64字节。（linux 内存的最小单位是字节）</li><li>tag 保存了内存地址的一部分，是用来验证是否缓存命中的。</li><li>flag 是一些标志位，比如缓存是否失效，写dirty等等。</li></ul><p>我们可以通过以下命令来查看case line 的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]<span class="comment"># getconf -a | grep CACHE</span></span><br><span class="line">LEVEL1_ICACHE_SIZE                 32768  <span class="comment"># 32KB 指令缓存</span></span><br><span class="line">LEVEL1_ICACHE_ASSOC                8        <span class="comment"># ASSOC表示主存地址映射到缓存的策略，这里L18路组相联</span></span><br><span class="line">LEVEL1_ICACHE_LINESIZE             64       <span class="comment"># cache line 每行的大小为64Bytes</span></span><br><span class="line">LEVEL1_DCACHE_SIZE                 32768    <span class="comment">#</span></span><br><span class="line">LEVEL1_DCACHE_ASSOC                8    </span><br><span class="line">LEVEL1_DCACHE_LINESIZE             64</span><br><span class="line">LEVEL2_CACHE_SIZE                  262144</span><br><span class="line">LEVEL2_CACHE_ASSOC                 4         <span class="comment"># ASSOC表示主存地址映射到缓存的策略，这里L2 是4路组相联</span></span><br><span class="line">LEVEL2_CACHE_LINESIZE              64</span><br><span class="line">LEVEL3_CACHE_SIZE                  12582912 <span class="comment"># 12M</span></span><br><span class="line">LEVEL3_CACHE_ASSOC                 16       </span><br><span class="line">LEVEL3_CACHE_LINESIZE              64</span><br><span class="line">LEVEL4_CACHE_SIZE                  0           <span class="comment"># 没有l4 缓存</span></span><br><span class="line">LEVEL4_CACHE_ASSOC                 0           </span><br><span class="line">LEVEL4_CACHE_LINESIZE              0</span><br></pre></td></tr></table></figure><h2><span id="缓存映射">缓存映射</span></h2><p>缓存首先要解决的问题是：怎么映射内存地址和缓存地址？比如CPU要检查一个内存值是否已经缓存，那么它首先要能算出这个内存地址对应的缓存地址，然后才能检查。</p><p>为了解决这个问题，缓存将一个内存地址分成下面几个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+   </span><br><span class="line">|  tag                | index    | offset   |   </span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>tag和缓存项中的tag对应，用来验证是否缓存命中的。</li><li>index 缓存项数组中的索引。</li><li>offset 缓存块(cache line)中的偏移，因为缓存块是64字节，而内存值可能只有4个字节，一个缓存块可以保存多个连续的内存值。这个offset实际上就是指明内存值在cache line中的位置。</li></ul><h3><span id="直接映射direct-mapped">直接映射（Direct mapped）</span></h3><p>假如缓存的大小是32768B(32KB)，缓存块大小是64B，那么缓存项数组就有‭ 32768‬/64=512 个。</p><ul><li>CPU要访问一个内存地址0x1CAABBDD‬，它首先检查这个内存地址是否在缓存中，检查过程是这样的：</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624334918090.png" alt></p><ul><li><p>先计算内存在cache line中的偏移，因为缓存块是64字节，那么offset需要占6位(2^6=64)，即offset=011101=29。</p></li><li><p>接着要计算缓存项的索引，因为缓存项数组是512个，所以index需要占9位(2^9=512)，即index=011101111=239。</p></li><li><p>现在我们通过offset和index已经找到缓存块的具体位置了，但是因为内存要远比缓存大很多，所以多个内存块是可以映射到同一个位置的，怎么判断这个缓存块位置存的就是这个内存的值呢？答案就是tag：内存地址去掉index和offset的部分，剩下的就是tag=00011100101010101=0x3955。</p></li><li><p>通过index找到缓存项，比较缓存项中的tag是否与内存地址中的tag相同，如果相同表示命中，就直接取缓存块中的值；如果不同表示未命中，CPU需要将内存值拷贝到缓存(替换掉老的)。</p></li></ul><p>这种映射方式就称为直接映射(Direct mapped)，它的缺点就是多个内存地址会映射到同一个缓存地址，拿上面的内存地址来看，<strong>只要offset和index相同的内存地址</strong>，就一定会映射到同一个地方.</p><p>比如内存地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00011100101010100 011101111 011101</span><br><span class="line">00011100101010110 011101111 011101</span><br><span class="line">00011100101010111 011101111 011101</span><br></pre></td></tr></table></figure><h3><span id="组相联映射">组相联映射</span></h3><p>为了解决上面的问题，我试着把缓存项数组分成2个数组(2路)，比如分成2个256的数组，那么按照上述的匹配，会匹配出如下图所示：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624358096959.png" alt></p><ul><li>先通过index找到数组索引，只不过因为是2路，所以存在2个数组。</li><li>然后通过内存tag依次比较2个缓存顶的tag，如果其中一个tag相等，说明这个数组缓存命中；</li><li>如果两个都不相等，说明缓存不命中，CPU会拷贝内存值到缓存中，但是现在有2个位置，需要淘汰一个缓存，然后在进行写入。</li></ul><p>那这个和直接映射相比，好在哪里呢，因为一个内存值会随机拷贝到2路中的1个，所以缓存冲突(多个内存地址映射到同一个缓存地址)的概率会降低一半；如果把缓存项数组分成4个数组，这就是4路组相联。上面LEVEL1_ICACHE_ASSOC的值等于8，表明是8路组相联。分组越多，缓存冲突率越低，但是CPU要遍历的数组就越多，这是一个权衡的问题。通过观察也可以发现，其实直接映射就是1路组相联。如果直接分成512个数组，那每个数组只有1项，这种就是全相联，CPU直接遍历512个数组，判断内存地址在哪1个。</p><p>关于缓存映射，这里还有<a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/cache.htm" target="_blank" rel="noopener">动画演示</a></p><h2><span id="缓存分配策略和更新策略">缓存分配策略和更新策略</span></h2><h3><span id="读数据">读数据</span></h3><p>当CPU从内存读数据时，如果该数据没有在缓存中(read miss)，CPU会把数据拷贝到缓存。</p><h3><span id="写数据">写数据</span></h3><p>缓存写策略， 我们看到缓存当中有个一个flag，flag的存在是在表示该缓行的状态。</p><ul><li><p><strong>Write through</strong> 更新缓存的数据，同时更新内存的数据。</p><p>当cache写命中时，处理器对Cache写入的同时，将数据写入到内存中，内存的数据和Cache中的数据都是同步的，这种方式比较简单、可靠。但是处理每次对cache更新都需要对内存写操作，因此总线工作繁忙，内存的带宽被大大占用，因此运行速度会受到影响。</p><p>假设一段程序在频繁地修改一个局部变量，局部变量生存周期很短，而且其他进程/线程也用不到它，CPU依然会频繁地在Cache和内存之间交换数据，造成不必要的带宽损失。当cache写未命中时，只有直接向主存写入了，但此时是否将修改过的主存块取到cache，</p><p><strong>如果在写的时候数据没有在缓存中(write miss)，也有两种策略</strong></p><ul><li><p><strong>WTWA（Write–Through–with–Write–Allocate)</strong> 在写之前先把数据加载到缓存，然后再实施上面的写策略。</p></li><li><p><strong>WTNWA法（WriteThrough–with．NO-Write–Allocate)</strong> 加载缓存，直接把数据写到内存。数据只有在 read miss 时才会加载到缓存</p></li></ul></li></ul><ul><li><p><strong>Write back</strong></p><p>当CPU对cache写命中时，只修改cache的内容不立即写入主存，只当此行被换出时才写回主存。这种策略使cache在CPU－主存之间，不仅在读方而且在写方向上都起到高速缓存作用。对一cache行的多次写命中都在cache中快速完成修改，只是需被替换时才写回速度较慢的主存，减少了访问主的次数从而提高了效率。为支持这种策略，每个cache行必须配置一个修改位，以反映此行是否被CPU修改过。</p><p>当某行被换出时，根据此行修改位为是为0。对于cache写未命中，写回法的处理是为包含欲写字的主存块在cache分配一行，将此块整个拷贝到Cache后对其进行修改， 因为尔后对此块的多读/写访问的可能性很大。拷贝主存块时虽已读访问到主存，但此时并不对主存块修改。因为换出的cache很可能此期间要写回主存，为避免此过程耗时长，写未命中对将新块读入后，只在cache中进行写修改。统一地将主存写修改操作留待换出时进行</p></li><li><p><strong>Write-once</strong></p><p>写一次是一种基于写回又结合了写通的写策略，即写命中和写未命中的处理与写回法基本相同，只是第一次写命中时要同时写入主存。这策略主要用于某些处理器的片内cache，例如Pentium处理器的片内数据cache就采用的是写一次法。因为片内cache写命中时，写操作就在CPU内部高完成，若没有 内存地址及其它指示信号送出，就不便于系统中的其它cache监听（snoop）。采用写一次法，在第一次片内cache写命中时，CPU要在线上启动一个存储写周期。其它cache监听到此主存块地址及写信号后，即可把它们各自保存可能有的该块拷贝及时作废（无效处理）。尔后若有 对片cache此行的再次或多次写命中，则按回写法处理，无需再送出信号了。</p></li><li><p>其他</p><p>WC（write-combining）， UC（uncacheable）在这里不做详细展开，有兴趣可以自己深入了解。</p></li></ul><p>关于写策略，可以参看<a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/" target="_blank" rel="noopener">这个</a> 动画演示。</p><p>从上面描述我们知道，当我们向一个内存写数据时，内存中的数据可能不马上被更新，这个新数据可能还在cache line呆着。因为每个核都有自己的缓存，如果CPU不做处理，可以想象一定会出问题的：比如核1改了数据，核2去读同一个数据，此时数据还在核1的缓存中，核2读到的就是老的数据。CPU为了处理多核间的缓存同步,有一套复杂的一致性协议。</p><h1><span id="mesi-协议">MESI 协议</span></h1><h2><span id="mesi-协议状态">MESI 协议状态</span></h2><p>MESI是“modified”, “exclusive”, “shared”, 和 “invalid”首字母的大写，当使用MESI 协议的时候，cacheline可以处于这四个状态中的一个，因此除了物理地址和具体的数据之外，还需要为每一个cacheline设计一个2-bit的tag来标识该cacheline的状态。</p><h3><span id="modified-状态">modified 状态</span></h3><p>处于modified状态的cacheline说明近期有过来自对应cpu的写操作，同时也说明该该数据不会存在其他cpu对应的cache中。因此，处于modified状态的cacheline也可以说是被该CPU独占。而又因为只有该CPU的cache保存了最新的数据（最终的memory中都没有更新），所以，该cache需要对该数据负责到底。例如根据请求，该cache将数据及其控制权传递到其他cache中，或者cache需要负责将数据写回到memory中，而这些操作都需要在reuse该cache line之前完成。</p><h3><span id="exclusive">exclusive</span></h3><p>exclusive状态和modified状态非常类似，唯一的区别是对应CPU还没有修改cacheline中的数据，也正因为还没有修改数据，因此memory中对应的data也是最新的。在exclusive状态下，cpu也可以不通知其他CPU cache而直接对cacheline进行操作，因此，<strong>exclusive状态也可以被认为是被该CPU独占</strong>。由于memory中的数据和cacheline中的数据都是最新的，因此，cpu不需对exclusive状态的cacheline执行写回的操作或者将数据以及归属权转交其他cpu cache，而直接reuse该cacheline（将cacheine中的数据丢弃，用作他用）。</p><h3><span id="share">share</span></h3><p>处于share状态的cacheline，其数据可能在一个或者多个CPU cache中，因此，处于这种状态的cache line，CPU不能直接修改cacheline的数据，而是需要首先和其他CPU cache进行沟通。和exclusive状态类似，处于share状态的cacheline对应的memory中的数据也是最新的，因此，cpu也可以直接丢弃cacheline中的数据而不必将其转交给其他CPU cache或者写回到memory中。</p><h3><span id="invalid">invalid</span></h3><p>处于invalid状态的cacheline是空的，没有数据。当新的数据要进入cache的时候，优选状态是invalid的cacheline，之所以如此是因为如果选中其他状态的cacheline，则说明需要替换cacheline数据，而未来如果再次访问这个被替换掉的cacheline数据的时候将遇到开销非常大的cache miss。</p><p>CPU中每个缓存行（Caceh line)使用4种状态进行标记，使用2bit来表示:</p><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th><th>状态转换</th></tr></thead><tbody><tr><td>M 修改 (Modified)</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td><td>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。</td></tr><tr><td>E 独享、互斥 (Exclusive)</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td><td>当CPU修改该缓存行中内容时，该状态可以变成Modified状态</td></tr><tr><td>S 共享 (Shared)</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td><td>当有一个CPU修改该缓存行时，其它CPU中该缓存行可以被作废（变成无效状态 Invalid）。</td><td></td></tr><tr><td>I 无效 (Invalid)</td><td>该Cache line无效。</td><td>无</td><td>无</td></tr></tbody></table><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624520651865.png" alt></p><h2><span id="mesi-协议消息">MESI 协议消息</span></h2><p>当cpu对内存数据进行修改的或者读取的时候，自然缓存状态需要改变，因此，多核CPU就要通过总线来告知其他cpu自己对某个缓存的状态修改。因此CPU之间也会通过传递消息来传递这种消息的改变</p><table><thead><tr><th>消息</th><th>说明</th><th>收到回复消息</th></tr></thead><tbody><tr><td>Read</td><td>read message用来获取指定物理地址上的cacheline数据</td><td>Read Response</td></tr><tr><td>Read Response</td><td>该消息携带了read message请求的数据。read response可能来自memory，也可能来自其他的cache。例如：如果一个cache有read message请求的数据并且该cacheline的状态是modified，那么该cache必须以read response回应这个read message，因为该cache中保存了最新的数据。</td><td></td></tr><tr><td>Read Invalidate</td><td>该命令用来将其他cpu cache中的数据设定为无效。该命令携带物理地址的参数，其他CPU cache在收到该命令后，必须进行匹配，发现自己的cacheline中有该物理地址的数据，那么就将其移除并用Invalidate Acknowledge回应。</td><td>Invalidate Acknowledge</td></tr><tr><td>Invalidate Acknowledge</td><td>收到invalidate message的cpu cache，在移除了其cache line中的特定数据之后，必须发送invalidate acknowledge消息</td><td></td></tr><tr><td>Read Invalidate</td><td>该message中也包括了物理地址这个参数，以便说明其想要读取哪一个cacheline数据。此外，该message还同时有invalidate message的功效，即其他的cache在收到该命令后，移除自己cacheline中的数据。因此，Read Invalidate message实际上就是read ＋ invalidate。发送Read Invalidate之后，cache期望收到一个read response以及多个invalidate acknowledge。</td><td>read response、invalidate acknowledge</td></tr><tr><td>Writeback</td><td>该message包括两个参数，一个是地址，另外一个是写回的数据。该消息用在modified状态的cacheline被驱逐出境（给其他数据腾出地方）的时候发出，该命名用来将最新的数据写回到memory（或者其他的CPU cache中）。</td><td></td></tr></tbody></table><h2><span id="mesi-协议状态变换">MESI 协议状态变换</span></h2><p>下图是MESI 协议通过MESI 消息进行的变换</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624521537740.png" alt></p><p>对上图中的状态迁移解释如下：</p><ul><li>Transition (a)：</li></ul><p>cache可以通过writeback 消息 将一个cacheline的数据写回到memory中（或者下一级cache中），这时候，该cacheline的状态从Modified迁移到Exclusive状态。对于cpu而言，cacheline中的数据仍然是最新的，而且是该cpu独占的，因此可以不通知其他cpu cache而直接修改之。</p><ul><li>Transition (b)：</li></ul><p>在Exclusive状态下，cpu可以直接将数据写入cacheline，不需要其他操作。相应的，该cacheline状态从Exclusive状态迁移到Modified状态。这个状态迁移过程不涉及bus上的Transaction（即无需MESI Protocol Messages的交互）。</p><ul><li>Transition ©：</li></ul><p>CPU 在总线上收到一个read invalidate的请求，同时，该请求是针对一个处于modified状态的cacheline，在这种情况下，CPU必须该cacheline状态设置为无效，并且用read response”和“invalidate acknowledge来回应收到的read invalidate的请求，完成整个bus transaction。一旦完成这个transaction，数据被送往其他cpu cache中，本地的copy已经不存在了。</p><ul><li>Transition (d)：</li></ul><p>CPU需要执行一个原子的readmodify-write操作，并且其cache中没有缓存数据，这时候，CPU就会在总线上发送一个read invalidate用来请求数据，同时想独自霸占对该数据的所有权。该CPU的cache可以通过read response获取数据并加载cacheline，同时，为了确保其独占的权利，必须收集所有其他cpu发来的invalidate acknowledge之后（其他cpu没有local copy），完成整个bus transaction。</p><ul><li>Transition (e)：</li></ul><p>CPU需要执行一个原子的readmodify-write操作，并且其local cache中有read only的缓存数据（cacheline处于shared状态），这时候，CPU就会在总线上发送一个invalidate请求其他cpu清空自己的local copy，以便完成其独自霸占对该数据的所有权的梦想。同样的，该cpu必须收集所有其他cpu发来的invalidate acknowledge之后，才算完成整个bus transaction。</p><ul><li>Transition (f):</li></ul><p>在本cpu独自享受独占数据的时候，其他的cpu发起read请求，希望获取数据，这时候，本cpu必须以其local cacheline的数据回应，并以read response回应之前总线上的read请求。这时候，本cpu失去了独占权，该cacheline状态从Modified状态变成shared状态（有可能也会进行写回的动作）。</p><ul><li>Transition (g)：</li></ul><p>这个迁移和f类似，只不过开始cacheline的状态是exclusive，cacheline和memory的数据都是最新的，不存在写回的问题。总线上的操作也是在收到read请求之后，以read response回应。</p><ul><li>Transition (h)：</li></ul><p>如果cpu认为自己很快就会启动对处于shared状态的cacheline进行write操作，因此想提前先霸占上该数据。因此，该cpu会发送invalidate敦促其他cpu清空自己的local copy，当收到全部其他cpu的invalidate acknowledge之后，transaction完成，本cpu上对应的cacheline从shared状态切换exclusive状态。还有另外一种方法也可以完成这个状态切换：当所有其他的cpu对其local copy的cacheline进行写回操作，同时将cacheline中的数据设为无效（主要是为了为新的数据腾些地方），这时候，本cpu坐享其成，直接获得了对该数据的独占权。</p><ul><li>Transition (i)：</li></ul><p>其他的CPU进行一个原子的read-modify-write操作，但是，数据在本cpu的cacheline中，因此，其他的那个CPU会发送read invalidate，请求对该数据以及独占权。本cpu回送read response”和“invalidate acknowledge”，一方面把数据转移到其他cpu的cache中，另外一方面，清空自己的cacheline。</p><ul><li>Transition (j)：</li></ul><p>cpu想要进行write的操作但是数据不在local cache中，因此，该cpu首先发送了read invalidate启动了一次总线transaction。在收到read response回应拿到数据，并且收集所有其他cpu发来的invalidate acknowledge之后（确保其他cpu没有local copy），完成整个bus transaction。当write操作完成之后，该cacheline的状态会从Exclusive状态迁移到Modified状态。</p><ul><li>Transition (k):</li></ul><p>本CPU执行读操作，发现local cache没有数据，因此通过read发起一次bus transaction，来自其他的cpu local cache或者memory会通过read response回应，从而将该cacheline从Invalid状态迁移到shared状态。</p><ul><li>Transition (l)：</li></ul><p>当cacheline处于shared状态的时候，说明在多个cpu的local cache中存在副本，因此，这些cacheline中的数据都是read only的，一旦其中一个cpu想要执行数据写入的动作，必须先通过invalidate获取该数据的独占权，而其他的CPU会以invalidate acknowledge回应，清空数据并将其cacheline从shared状态修改成invalid状态。</p><h2><span id="mesi-协议例子">MESI 协议例子</span></h2><p>OK，在理解了各种cacheline状态、各种MESI协议消息以及状态迁移的描述之后，我们从cache line数据的角度来看看MESI协议是如何运作的。开始，数据保存在memory的0地址中，随后，该数据会穿行在四个CPU的local cache中。</p><p>为了方便起见，我们让CPU local cache使用最简单的Direct-mapped的组织形式。具体的过程可以参考下面的图片：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624522274781.png" alt></p><table><thead><tr><th>列明</th><th>说明</th><th>值说明</th></tr></thead><tbody><tr><td>Sequence</td><td>第一列是操作序列号，也就是时间执行顺序</td><td>0 , 1, 2</td></tr><tr><td>CPU</td><td>执行操作的CPU</td><td>0， 1，2，3 四个CPU</td></tr><tr><td>Operation</td><td>第三列是具体执行哪一种操作</td><td></td></tr><tr><td>CPU cached</td><td>描述了各个cpu local cache中的cacheline的状态</td><td>（用meory address/状态表示）</td></tr><tr><td>Memory</td><td>描述了内存在0地址和8地址的数据内容的状态</td><td>V表示是最新的，和cache一致，I表示不是最新的内容，最新的内容保存在cache中。</td></tr></tbody></table><hr><br><ul><li><p>最开始的时候（sequence 0），各个cpu cache中的cacheline都是Invalid状态，而Memory中的数据都保存了最新的数据。</p></li><li><p>随后（sequence 1），CPU 0执行了load操作，将address 0的数据加载到寄存器，这个操作使得保存0地址数据的那个cacheline从invalid状态迁移到shared状态。</p></li><li><p>随后（sequence 2），CPU3也对0地址执行了load操作，导致其local cache上对应的cacheline也切换到shared状态</p></li><li><p>sequence 3中，CPU 0执行了对地址8的load操作，由于地址0和地址8都是选择同一个cache set，而且，我们之前已经说过，该cache是direct-mapped的（即每个set只有一个cacheline），因此需要首先清空该cacheline中的数据（该操作被称为Invalidation），由于cacheline的状态是shared，因此，不需要通知其他CPU。 invalidation local cache上的cacheline之后，cpu 0的load操作将该cacheline状态修改成Shared状态（保存地址8的数据）</p></li><li><p>sequence 4 CPU 2也开始执行load操作了虽然是load操作，但是CPU知道程序随后会修改该值（不是原子操作的read-modify-write，否就是迁移到Modified状态了，也不是单纯的load操作，否则会迁移到shared状态），因此向总线发送了read invalidate命令，一方面获取该数据（自己的local cache中没有地址0的数据），另外，CPU 2想独占该数据（因为随后要write）。这个操作导致CPU 3的cacheline迁移到invalid状态。当然，这时候，memory仍然是最新的有效数据。</p></li><li><p>Sequence5 CPU 2的store操作很快到来，由于准备工作做的比较充分（Exclusive状态，独占该数据），cpu直接修改cacheline中的数据（对应地址0），从而将其状态迁移到modified状态，同时要注意的是：memory中的数据已经失效，不是最新的数据了，任何其他CPU发起对地址0的load操作都不能从memory中读取，而是通过嗅探（snoop）的方式从CPU 2的local cache中获取。</p></li><li><p>sequence 6中，CPU 1对地址0的数据执行原子的加1操作，这时候CPU 1会发出read invalidate命令，将地址0的数据从CPU 2的cacheline中嗅探得到，同时通过invalidate其他CPU local cache的内容而获得独占性的数据访问权。这时候，CPU 2中的cacheline状态变成invalid状态，而CPU 1将从invalid状态迁移到modified状态</p></li><li><p>sequence 7，CPU 1对地址8进行load操作，由于cacheline被地址0占据，因此需要首先将其驱逐出cache，于是执行write back操作将地址0的数据写回到memory，同时发送read命名，从CPU 0的cache中获得数据加载其cacheline，最后，CPU1的cache变成shared状态（保存地址8的数据）。由于执行了write back操作，memory中地址0的数据又变成最新的有效数据了。</p></li></ul><p><strong>这里有个动画，来说明CPU MESI协议的工作原理 这里做个传送门<a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm" target="_blank" rel="noopener">MESI协议动画演示</a></strong></p><h2><span id="store-buffers">Store Buffers</span></h2><p>在上面的现代计算机cache结构图，我们可以看出，针对某些特定地址的数据（在一个cacheline中）重复的进行读写，这种结构可以获得很好的性能，不过，对于第一次写，其性能非常差。下面的这个图可以展示为何写性能差：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624589488820.png" alt></p><p>cpu 0发起一次对某个地址的写操作，但是local cache没有数据，该数据在CPU 1的local cache中，因此，为了完成写操作，CPU 0发出invalidate的命令，invalidate其他CPU的cache数据。只有完成了这些总线上的transaction之后，CPU 0才能正在发起写的操作，这是一个漫长的等待过程，<br>但是，其实没必要等待这么长的时间，毕竟，物理CPU 1中的cacheline保存有什么样子的数据，其实都没有意义，这个值都会被CPU 0新写入的值覆盖的。</p><p>有一种可以阻止cpu进入无聊等待状态的方法就是在CPU和cache之间增加store buffer。</p><p><strong>注意下图，写入store buffer是单向的</strong></p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624589532895.png" alt></p><p>一旦增加了store buffer，那么cpu0无需等待其他CPU的相应，只需要将要修改的内容放入store buffer，然后继续执行就OK了。当cacheline完成了bus transaction，并更新了cacheline的状态后，要修改的数据将从store buffer进入cacheline。</p><p>这些store buffer对于cpu而言是私有的的，多核CPU的情况下，每一个cpu拥有自己私有的stroe buffer，一个cpu只能访问自己私有的那个store buffer。</p><p>在上图中，cpu 0不能访问cpu1的store buffer，store buffer增加了CPU连续写的性能，同时把各个CPU之间的通信的任务交给维护cache一致性的协议。当然这种设计会引入了一些复杂性问题。</p><h2><span id="store-forwarding">Store Forwarding</span></h2><p>上文提到store buffer引入了复杂性，我们先看第一个例子：本地数据不一致的问题。我们先看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>;</span><br><span class="line">System.out.println(b == <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624610580058.png" alt></p><ul><li>a和b都是初始化为0，并且变量a在CPU 1的cacheline中，变量b在CPU 0的cacheline中。</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624610580057.png" alt></p><ul><li>（1） CPU 0执行a=1的赋值操作，但是load a的时候遇到了cache miss</li><li>（2）CPU 0发送read invalidate消息想从CPU 1那里获得数据，并invalid其他cpu保存a数据的local cacheline。但是不能等回复消息，就紧接着将要写入的数据“1”放入store buffer 里</li><li>（3）CPU 1收到read invalidate后回应，把本地cacheline的数据发送给CPU 0并清空本地cache中a的数据</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624610962888.png" alt></p><ul><li>（4）CPU 0要开始执行 b = a + 1，再次之前需要load a值，此时CPU 0 收到来自CPU 1的数据，该数据是“0”，这样啊= 0 就被缓存到了cache里</li><li>（5）CPU 0从cacheline中加载a，获得0值</li><li>（6）此时，storebuffer里的数据写会到了cache中。 所以a值是“1”</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624673019516.png" alt></p><ul><li>（7） CPU 0执行a＋1，得到1并将该值写入b</li><li>（8）CPU 0 executes assert(b == 2)你期望b等于2，但是实际上b等于了1</li></ul><p>导致这个问题的根本原因是我们有两个a值，一个在cacheline中，一个在store buffer中。</p><p>上面这个出错的例子之所以发生是因为它违背了一个基本的原则，即每个CPU按照其视角来观察自己的行为的时候必须是符合program order的。一旦违背这个原则，会导致一些非常不直观的软件行为，对软件工程师而言就是灾难。还好，有”好心“的硬件工程师帮助我们，修改了CPU的设计如下：</p><p><strong>注意storebuffer 是可以进行cpu 和 cache的干预的</strong></p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624611186311.png" alt></p><p>这种设计叫做store forwarding，<strong>当CPU执行load操作的时候，不但要看cache，还有看store buffer是否有内容，如果store buffer有该数据，那么就采用store buffer中的值</strong>。因此，即便是store操作还没有写入cacheline，store forwarding的效果看起来就好象cpu的store操作被向前传递了一样（后面的load的指令可以感知到这个store操作）。</p><p>有了store forwarding的设计，上面的步骤（5）和 （6）中就可以在store buffer获取正确的a值是”1“而不是”0“，因此计算得到的b的结果就是2，和我们预期的一致了。</p><p>如下图：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624611544452.png" alt></p><h2><span id="memory-barriers">Memory Barriers</span></h2><p>关于store buffer引入的复杂性，我们再来看看第二个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，a和b都是初始化成0.我们假设CPU 0执行foo函数，CPU 1执行bar函数。我们再进一步假设a变量在CPU 1的cache中，b在CPU 0 cache中</p><p>执行的操作序列如下：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624617623917.png" alt></p><ul><li>（1）CPU 0将a值放到store buffer中之后，发送了read invalidate命令到总线上去。</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624617764687.png" alt></p><ul><li><p>（2）CPU 1执行 while (b == 0) 循环，由于b不在CPU 1的cache中，因此 CPU1发送一个read message到总线上，看看是否可以从其他cpu的local cache中或者memory中获取数据</p></li><li><p>（3）CPU 0继续执行b=1的赋值语句，由于b就在自己的local cache中（cacheline处于modified状态或者exclusive状态），因此CPU0可以直接操作将新的值1写入cache line。</p></li><li><p>（4）CPU 0收到了read message，将最新的b值”1“回送给CPU 1，同时将b cacheline的状态设定为shared</p></li><li><p>（5）CPU 1收到了来自CPU 0的read response消息，将b变量的最新值”1“值写入自己的cacheline，状态修改为shared。</p></li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624617938017.png" alt></p><ul><li>（6） CPU 1 判断b值等于1了，因此CPU 1跳出while (b == 0)的循环，继续前行。</li><li>（7） CPU 1执行assert(a == 1)，这时候CPU 1的local cache中还是旧的a值，因此assert(a == 1)失败。</li><li>（8）CPU 1收到了来自CPU 0的read invalidate消息，以a变量的值进行回应，同时清空自己的cacheline，但是这已经太晚了。</li></ul><p>遇到这样的问题，CPU设计者也不能直接帮什么忙，毕竟CPU并不知道哪些变量有相关性，这些变量是如何相关的。不过CPU设计者可以间接提供一些工具让软件工程师来控制这些相关性。这些工具就是memory-barrier指令。要想程序正常运行，必须增加一些memory barrier的操作.</p><h2><span id="memory-barrier">memory-barrier</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  smp_mb();</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>smp_mb() 这个内存屏障的操作会在执行后续的store操作之前，首先flush store buffer（也就是将之前的值写入到cacheline中）smp_mb() 操作主要是为了让数据在local cache中的操作顺序是符合program order的顺序的，为了达到这个目标有两种方法：</p><ul><li><p>CPU stall，直到完成了清空了store buffer（也就是把store buffer中的数据写入cacheline了）</p></li><li><p>CPU可以继续运行，不过需要在store buffer中做些文章，也就是要记录store buffer中数据的顺序，在将store buffer的数据更新到cacheline的操作中，严格按照顺序执行，即便是后来的store buffer数据对应的cacheline已经ready，也不能执行操作，要等前面的store buffer值写到cacheline之后才操作。</p></li></ul><p>接下来，我们再来看一下整个的运行过程：</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624673274521.png" alt></p><ul><li><p>(1） CPU 0执行a=1的赋值操作，由于a不在local cache中，因此，CPU 0将a值放到store buffer中之后，发送了read invalidate命令到总线上去。</p></li><li><p>（2） CPU 1执行 while (b == 0) 循环，由于b不在CPU 1的cache中，因此，CPU发送一个read message到总线上，看看是否可以从其他cpu的local cache中或者memory中获取数据</p></li><li><p>（3） CPU 0执行smp_mb()函数，给目前store buffer中的所有项做一个标记（后面我们称之marked entries）。当然，针对我们这个例子，store buffer中只有一个marked entry就是“a=1”。</p></li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624673505186.png" alt></p><ul><li><p>（4）CPU 0继续执行b=1的赋值语句，虽然b就在自己的local cache中（cacheline处于modified状态或者exclusive状态），不过在store buffer中有marked entry，因此CPU0并没有直接操作将新的值1写入cache line，取而代之是b的新值”1“被写入store buffer，当然是unmarked状态。</p></li><li><p>（5）CPU 0收到了read message，将b值”0“（新值”1“还在store buffer中）回送给CPU 1，同时将b cacheline的状态设定为shared。</p></li><li><p>（6） CPU 1收到了来自CPU 0的read response消息，将b变量的值（”0“）写入自己的cacheline，状态修改为shared。</p></li><li><p>（7） 完成了bus transaction之后，CPU 1可以load b到寄存器中了（local cacheline中已经有b值了），当然，这时候b仍然等于0，因此循环不断的loop。虽然b值在CPU 0上已经赋值等于1，但是那个新值被安全的隐藏在CPU 0的store buffer中。</p></li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624673637069.png" alt></p><ul><li>（8）CPU 1收到了来自CPU 0的read invalidate消息，以a变量的值进行回应，同时清空自己的cacheline。<br>（9）CPU 0将store buffer中的a值写入cacheline，并且将cacheline状态修改为modified状态。</li><li>（10） 因此，完成step 9之后，store buffer的b也可以进入cacheline了。不过需要注意的是，当前b对应的cacheline的状态是shared。因此还不能进入到cacheline里</li><li>（11）CPU 0发送invalidate消息，请求b数据的独占权</li><li>（12） CPU 1收到invalidate消息，清空自己的b cacheline，并回送acknowledgement给CPU 0。</li><li>（13） CPU 1继续执行while (b == 0)，由于b不在自己的local cache中，因此 CPU 1发送read消息，请求获取b的数据。</li><li>（14）CPU 0收到acknowledgement消息，将b对应的cacheline修改成exclusive状态，这时候，CPU 0终于可以将b的新值1写入cacheline。</li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624673954822.png" alt></p><ul><li>（15） CPU 1 再次执行循环，读取b的值，发现已经失效，一次你给CPU 0发了read消息， CPU 0收到read消息，将b的新值1回送给CPU 1，同时将其local cache中b对应的cacheline状态修改为shared。</li><li>（16） CPU 1获取来自CPU 0的b的新值，将其放入cacheline中，由于b值等于1了，因此CPU 1跳出while (b == 0)的循环，继续前行。</li><li>（17） CPU 1执行assert(a == 1)，不过这时候a值没有在自己的cacheline中，因此需要通过cache一致性协议从CPU 0那里获得，这时候获取的是a的最新值，也就是1值，因此assert成功。</li></ul><p>通过上面的描述，我们可以看到，一个直观上很简单的给a变量赋值的操作，都需要那么长的执行过程，而且每一步都需要芯片参与，最终完成整个复杂的赋值操作过程。</p><h2><span id="store-sequences-result-in-unnecessary-stalls">Store Sequences Result in Unnecessary Stalls</span></h2><h3><span id="invalidate-queues">Invalidate Queues</span></h3><p>不幸的是：每个cpu的store buffer不能实现的太大，其entry的数目不会太多。当cpu以中等的频率执行store操作的时候（假设所有的store操作导致了cache miss），store buffer会很快的被填满。在这种状况下，CPU只能又进入等待状态，直到cache line完成invalidation和ack的交互之后，可以将store buffer的entry写入cacheline，从而为新的store让出空间之后，CPU才可以继续执行。这种状况也可能发生在调用了memory barrier指令之后，因为一旦store buffer中的某个entry被标记了，那么随后的store都必须等待invalidation完成，因此不管是否cache miss，这些store都必须进入store buffer。</p><p>引入invalidate queues可以缓解这个状况。store buffer之所以很容易被填充满，主要是其他CPU回应invalidate acknowledge比较慢，如果能够加快这个过程，让store buffer尽快进入cacheline，那么也就不会那么容易填满了。</p><p>invalidate acknowledge不能尽快回复的主要原因是invalidate cacheline的操作没有那么快完成，特别是cache比较繁忙的时候，这时，CPU往往进行密集的loading和storing的操作，而来自其他CPU的，对本CPU local cacheline的操作需要和本CPU的密集的cache操作进行竞争，只要完成了invalidate操作之后，本CPU才会发生invalidate acknowledge。此外，如果短时间内收到大量的invalidate消息，CPU有可能跟不上处理，从而导致其他CPU不断的等待。</p><p>然而，CPU其实不需要完成invalidate操作就可以回送acknowledgement消息，这样，就不会阻止发生invalidate请求的那个CPU进入无聊的等待状态。CPU可以buffer这些invalidate message（放入Invalidate Queues），然后直接回应acknowledgement，表示自己已经收到请求，随后会慢慢处理。当然，再慢也要有一个度，例如对a变量cacheline的invalidate处理必须在该CPU发送任何关于a变量对应cacheline的操作到bus之前完成。</p><h2><span id="invalidate-queues-and-invalidate-acknowledge">Invalidate Queues and Invalidate Acknowledge</span></h2><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624851575788.png" alt></p><p>有了Invalidate Queue的CPU，在收到invalidate消息的时候首先把它放入Invalidate Queue，同时立刻回送acknowledge 消息，无需等到该cacheline被真正invalidate之后再回应。当然，如果本CPU想要针对某个cacheline向总线发送invalidate消息的时候，那么CPU必须首先去Invalidate Queue中看看是否有相关的cacheline，如果有，那么不能立刻发送，需要等到Invalidate Queue中的cacheline被处理完之后再发送。</p><p>一旦将一个invalidate（例如针对变量a的cacheline）消息放入CPU的Invalidate Queue，实际上该CPU就等于作出这样的承诺：在处理完该invalidate消息之前，不会发送任何相关（即针对变量a的cacheline）的MESI协议消息。只要是对该cacheline的竞争不是那么剧烈，CPU还是对这样的承诺很有信心的。</p><p>然而，缓存了invalidate消息也会引入一些其他的memory order的问题，我们在下一节讨论。</p><h3><span id="invalidate-queues-and-memory-barriers">Invalidate Queues and Memory Barriers</span></h3><p>我们假设CPU缓存invalidation消息，在操作cacheline之前直接回应该invalidation消息。这样的机制对于发送invalidation的CPU侧是非常好的事，该CPU的store性能会非常高，但是会使内存屏障指令失效，我们来看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，我们假设a和b初值是0，并且a在CPU 0和CPU 1都有缓存的副本，即a变量对应的CPU0和CPU 1的cacheline都是shared状态。b处于exclusive或者modified状态，被CPU 0独占。我们假设CPU 0执行foo函数，CPU 1执行bar函数。</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624856118442.png" alt></p><ul><li><p>（1） CPU 0执行a=1的赋值操作，由于a在CPU 0 local cache中的cacheline处于shared状态，因此，CPU 0将a的新值“1”放入store buffer，并且发送了invalidate消息去清空CPU 1对应的cacheline。</p></li><li><p>（2）CPU 1执行while (b == 0)的循环操作，但是b没有在local cache，因此发送read消息试图获取该值。</p></li><li><p>（3）CPU 1收到了CPU 0的invalidate消息，放入Invalidate Queue，并立刻回送Ack。</p></li><li><p>（4） CPU 0收到了CPU 1的invalidate ACK之后，即可以越过程序设定内存屏障（第四行代码的smp_mb() ），这样a的新值从store buffer进入cacheline，状态变成Modified。</p></li></ul><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624856146651.png" alt></p><ul><li>（5） CPU 0 越过memory barrier后继续执行b=1的赋值操作，由于b值在CPU 0的local cache中，因此store操作完成并进入cache line。</li><li>（6） CPU 0收到了read消息后将b的最新值“1”回送给CPU 1，并修正该cacheline为shared状态。</li><li>（7）  CPU 1收到read response，将b的最新值“1”加载到local cacheline。对于CPU 1而言，b已经等于1了，因此跳出while (b == 0)的循环，继续执行后续代码</li><li>（9） CPU 1执行assert(a == 1)，但是由于这时候CPU 1 cache的a值仍然是旧值0，因此assertion 失败</li><li>（10） 该来总会来，Invalidate Queue中针对a cacheline的invalidate消息最终会被CPU 1执行，将a设定为无效，但素，大错已经酿成。</li></ul><p>很明显，在上文中的场景中，加速Invalidation response导致foo函数中的memory barrier失效了，因此，这时候对Invalidation response已经没有意义了，毕竟程序逻辑都错了。怎么办？其实我们可以让memory barrier指令和Invalidate Queue进行交互来保证确定的memory order。具体做法是这样的：当CPU执行memory barrier指令的时候，对当前Invalidate Queue中的所有的entry进行标注，这些被标注的项次被称为marked entries，而随后CPU执行的任何的load操作都需要等到Invalidate Queue中所有marked entries完成对cacheline的操作之后才能进行。因此，要想保证程序逻辑正确，我们需要给bar函数增加内存屏障的操作，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"> smp_mb();</span><br><span class="line"> <span class="keyword">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的过程跟上述例子一样，只不过在CPU 1 执行 asserrt a == 1 的时候会有些许不同。 我们这里只列出来不同的部分，上述问题过程8 之后执行如下过程</p><p><img src="/article/why-memory-barriers-1/why-memory-barriers-1624856501048.png" alt></p><ul><li>（9） 对于CPU 1而言，b已经等于1了，因此跳出while (b == 0)的循环，继续执行memory barrier的代码。</li><li>（10） CPU 1现在不能继续执行代码，只能等待，直到Invalidate Queue中的message被处理完成， CPU 1处理队列中缓存的Invalidate消息，将a对应的cacheline设置为无效。</li><li>（11） 由于a变量在local cache中无效，因此CPU 1在执行assert(a == 1)的时候需要发送一个read消息去获取a值。CPU 0用a的新值1回应来自CPU 1的请求。</li><li>（12） CPU 1获得了a的新值，并放入cacheline，这时候assert(a == 1)不会失败了。</li></ul><h3><span id="read-and-write-memory-barriers">Read and Write Memory Barriers</span></h3><p>在我们上面的例子中，memory barrier指令对store buffer和invalidate queue都进行了标注，不过，在实际的代码片段中，foo函数不需要mark invalidate queue，bar函数不需要mark store buffer</p><p>因此，许多CPU architecture提供了弱一点的memory barrier指令只mark其中之一。如果只mark invalidate queue，那么这种memory barrier被称为read memory barrier。相应的，write memory barrier只mark store buffer。一个全功能的memory barrier会同时mark store buffer和invalidate queue。</p><p>我们一起来看看读写内存屏障的执行效果：对于read memory barrier指令，它只是约束执行CPU上的load操作的顺序，具体的效果就是CPU一定是完成read memory barrier之前的load操作之后，才开始执行read memory barrier之后的load操作。read memory barrier指令象一道栅栏，严格区分了之前和之后的load操作。同样的，write memory barrier指令，它只是约束执行CPU上的store操作的顺序，具体的效果就是CPU一定是完成write memory barrier之前的store操作之后，才开始执行write memory barrier之后的store操作。全功能的memory barrier会同时约束load和store操作，当然只是对执行memory barrier的CPU有效。</p><p>现在，我们可以改一个用读写内存屏障的版本了，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_wmb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"> smp_rmb()</span><br><span class="line"> <span class="keyword">assert</span>(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>简单总结一下：smp_mb 包含的语义有些“重”，既包含了 Store Buffer 的 flush，又包含了 Invalidate Queue 的等待环节，但现实场景下，我们可能只需要与其中一个数据结构打交道即可。于是，CPU 的设计者把 smp_mb 屏障进一步拆分，一分为二， smp_rmb 称之为读内存屏障，smp_wmb 称之为写内存屏障。他们分别的语义也相应做了简化：</p><ul><li><p>smp_wmb(StoreStore)：执行后需等待 Store Buffer 中的写入变更 flush 完全到缓存后，后续的写操作才能继续执行，保证执行前后的写操作对其他 CPU 而言是顺序执行的；</p></li><li><p>smp_rmb(LoadLoad)：执行后需等待 Invalidate Queue 完全应用到缓存后，后续的读操作才能继续执行，保证执行前后的读操作对其他 CPU 而言是顺序执行的；</p></li></ul><p>如果没有 smp_wmb，那么 foo 方法对于别的 CPU 而言，a 与 b 赋值语句的执行顺序是不确定的，可能会导致 assert failed；如果没有 smp_rmb，那么 bar 方法对于其他 CPU 而言，b 与 a 的 读取指令的执行顺序也是不确定的，也可能会导致 assert failed。（这里做个说明，如果 当b 读取成功后，那么意味着 a 在其他的cpu已经值已经完成，那么load b 之后 在去load a 就是没问题的就会让其他CPU 告诉 a = 1 这样是没问题的，如果没有这个屏障，相当于a还是等于0，那么意味着这个cpu 是先load a的值，然后用a的值惊醒操作，在load b 之后，a = 1 已经写入内存完成，那么就产生了乱序。）</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/80672073" target="_blank" rel="noopener">程序优化：CPU缓存基础知识</a></li><li><a href="https://blinkfox.github.io/2018/11/18/ruan-jian-gong-ju/cpu-duo-ji-huan-cun/" target="_blank" rel="noopener">CPU多级缓存</a></li><li><a href="http://lihaizhou.top/2020/06/20/Memory-Barrier%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://zhuanlan.zhihu.com/p/66085562" target="_blank" rel="noopener">内存屏障Memory Barrier: a Hardware View</a></li><li><a href="https://www.cnblogs.com/lqlqlq/p/13693876.html" target="_blank" rel="noopener">x86-TSO : 适用于x86体系架构并发编程的内存模型</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDk3NjM3Mg==&amp;mid=2247483755&amp;idx=1&amp;sn=50f80e73f46fab04d8a799e8731432c6&amp;chksm=fa48da70cd3f5366d9658277cccd9e36fca540276f580822d41aef7d8af4dda480fc85e3bde4&amp;token=1422563498&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从 Java 内存模型看内部细节</a></li><li><a href="https://zhuanlan.zhihu.com/p/81555436" target="_blank" rel="noopener">为什么在 x86 架构下只有 StoreLoad 屏障是有效指令？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> 缓存一致性 </tag>
            
            <tag> 并发系统 </tag>
            
            <tag> 内存屏障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KeepAlived 详解</title>
      <link href="/article/keepalived-1/"/>
      <url>/article/keepalived-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><h2><span id="keepalived-作用">Keepalived 作用</span></h2><p>keepalived顾名思义是保持存活，常用来搭建设备的高可用，防止业务核心设备出现单点故障。keepalived基于VRRP协议来实现高可用，主要用作realserver的健康检查以及负载均衡主机和backup主机之间的故障漂移。他很大程度上是为ipvs服务的，也不需要共享存储。Keepalived主要的任务就是去调用ipvsadm命令，来生成规则，并自动实现将用户需要访问的地址转移到可用LVS节点实现。所以keepalive的高可用是属于具有很强针对性的高可用。</p><p>Keepalived的主要目的就是它自身启动为一个服务，它工作在多个LVS主机节点上，当前活动的节点叫做Master备用节点叫做Backup，Master会不停的向Backup节点通告自己的心跳，这种通告是基于VRRP协议的。Backup节点一旦接收不到Master的通告信息，它就会把LVS的VIP拿过来，并且把ipvs的规则也拿过来，在自己身上生效，从而替代Master节点。</p><p>Keepalived除了可以监控和转移LVS资源之外，它还可以直接配置LVS而不需要直接使用ipvsadm命令，因为它可以调用，也就是说在LVS+KEEPALIVED模型中，你所有的工作在Keepalived中配置就可以了，而且它还有对后端应用服务器健康检查的功能。</p><p>如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，实现自动剔除与恢复，不需要人工干涉，需要人工做的只是修复故障的服务器。</p><p>Keepalived 健康检查可以在三层 - 五层之间：</p><ul><li>三层机理是发送ICMP数据包即PING给某台服务器，如果不通，则认为其故障，并从服务器群中剔除；</li><li>四层机理是检测TCP端口号状态来判断某台服务器是否故障，如果检测端口存在异常，则从服务器群中剔除；</li><li>五层机理是根据用户的设定检查某个服务器应用程序是否正常运行，如果不正常，则从服务器群中剔除，比如说某个网页，可以通过http 状态码来判定是否正常。</li></ul><h2><span id="详解">详解</span></h2><h2><span id="虚拟路由冗余协议vrrp协议">虚拟路由冗余协议（VRRP)协议</span></h2><h3><span id="vrrp解决什么问题">VRRP解决什么问题</span></h3><p>VRRP 是 Virtual Router Redundancy Protocol 的简称，即 虚拟路由冗余协议 。</p><p>如图所示，通常，同一网段内的所有主机都设置一条相同的、以网关为下一跳的缺省路由。主机 发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。</p><p>当网关发生故障时，本网段内所有以网关为缺省路由的主机将无法与外部网络通信。</p><p>所以，网关设备提出了很高的稳定性要求。增加出口网关是提高系统可靠性的常见方法，此时如何在多个出口之间进行选路就成为需要解决的问题。<br>通俗的讲，就是在设置不同的网关，在一个网关机器宕机或者有问题的时候，可以进行自动的切换。</p><p><img src="/article/keepalived-1/keepalived-1-1620441794310.png" alt></p><p>VRRP，就是解决这个问题而存在的，它将可以承担网关功能的一组 路由器加入到备份组中，形成一台虚拟路由器，由 VRRP 的选举机制决定哪台路由器承担转发任务， 局域网内的主机只需将虚拟路由器配置为缺省网关。通俗的来讲就是将网关做成主备方案，用于容错。</p><p><strong>VRRP 协议的实现有 VRRPv2 和 VRRPv3 两个版本。其中，VRRPv2 基于 IPv4，VRRPv3 基于 IPv6。 VRRPv2 和 VRRPv3 在功能实现上并没有区别，只是应用的网络环境不同。</strong></p><h3><span id="vrrp-备份组">VRRP 备份组</span></h3><p>VRRP 将局域网内的一组路由器划分在一起，称为一个备份组。备份组由一个 Master 路由器和多个 Backup 路由器组成，功能上相当于一台虚拟路由器。 VRRP 备份组具有以下特点:</p><ul><li><p>虚拟路由器具有IP地址，称为虚拟IP地址。局域网内的主机仅需要知道这个虚拟路由器的IP地址，并将其设置为缺省路由的下一跳地址。</p></li><li><p>网络内的主机通过这个虚拟路由器与外部网络进行通信。</p></li><li><p>备份组内的路由器根据优先级，选举出 Master 路由器，承担网关功能。其他路由器作为 Backup 路由器，当 Master 路由器发生故障时，取代 Master 继续履行网关职责，从而保证网络内的 主机不间断地与外部网络进行通信。</p></li></ul><p><img src="/article/keepalived-1/keepalived-1-1620442091415.png" alt></p><blockquote><p>如 图 2所示，Router A、Router B和Router C组成一个虚拟路由器。此虚拟路由器有自己的IP地址。 局域网内的主机将虚拟路由器设置为缺省网关。Router A、Router B和Router C中优先级最高的路 由器作为Master路由器，承担网关的功能。其余两台路由器作为Backup路由器。</p></blockquote><h3><span id="备份组相关概念">备份组相关概念</span></h3><ul><li>虚拟IP</li></ul><p>虚拟IP技术。虚拟IP，就是一个未分配给真实主机的IP，也就是说对外提供数据库服务器的主机除了有一个真实IP外还有一个虚IP，使用这两个IP中的任意一个都可以连接到这台主机</p><p>其实现原理主要是靠 TCP/IP 的 ARP 协议。因为IP地址只是一个逻辑地址，在以太网中 MAC 地址才是真正用来进行数据传输的物理地址，每台主机中都有一个 ARP 高速缓存，存储同一个网络内的 IP 地址与 MAC 地址的对应关系，以太网中的主机发送数据时会先从这个缓存中查询目标 IP 对应的 MAC 地址，会向这个 MAC 地址发送数据。操作系统会自动维护这个缓存。</p><ul><li>虚拟MAC地址：</li></ul><p>一个虚拟路由器拥有一个虚拟MAC地址。虚拟MAC地址的格式为00-00-5E-00-01-{VRID}。通常情况下，虚拟路由器回应ARP请求使用的是虚拟MAC地址，只有虚拟路由器做特殊配置的时候，才回应接口的真实MAC地址。</p><ul><li><p>角色</p><ul><li>Master: 对外提供服务的主服务器，只能有一个</li><li>Backup： 备选防范，当Master 出现问题之后会取代master提供服务，可以有多个。</li></ul></li><li><p>优先级</p></li></ul><p>VRRP 根据优先级来确定备份组中每台路由器的角色(Master 路由器或 Backup 路由器)。优先级越高，则越有可能成为 Master 路由器。</p><p>VRRP 优先级的取值范围为 0 到 255(数值越大表明优先级越高)，可配置的范围是 1 到 254，优 先级 0 为系统保留给特殊用途来使用，255 则是系统保留给 IP 地址拥有者。当路由器为 IP 地址拥 有者时，其优先级始终为 255。因此，当备份组内存在 IP 地址拥有者时，只要其工作正常，则为 Master 路由器。</p><ul><li><p>工作方式</p><ul><li><p>非抢占方式:如果备份组中的路由器工作在非抢占方式下，则只要 Master 路由器没有出现故 障，Backup 路由器即使随后被配置了更高的优先级也不会成为 Master 路由器。</p></li><li><p>抢占方式:如果备份组中的路由器工作在抢占方式下，它一旦发现自己的优先级比当前的 Master 路由器的优先级高，就会对外发送 VRRP 通告报文。导致备份组内路由器重新选举 Master 路由器，并最终取代原有的 Master 路由器。相应地，原来的 Master 路由器将会变成 Backup 路由器。</p></li></ul></li><li><p>认证方式</p><ul><li><p>simple:简单字符认证。发送 VRRP 报文的路由器将认证字填入到 VRRP 报文中，而收到 VRRP 报文的路由器会将收到的 VRRP 报文中的认证字和本地配置的认证字进行比较。如果 认证字相同，则认为接收到的报文是真实、合法的 VRRP 报文;否则认为接收到的报文是一 个非法报文。</p></li><li><p>md5:MD5 认证。发送 VRRP 报文的路由器利用认证字和 MD5 算法对 VRRP 报文进行摘要 运算，运算结果保存在Authentication Header(认证头)中。收到VRRP报文的路由器会利 用认证字和 MD5 算法进行同样的运算，并将运算结果与认证头的内容进行比较。如果相同， 则认为接收到的报文是真实、合法的 VRRP 报文;否则认为接收到的报文是一个非法报文。</p></li></ul></li><li><p>定时器</p><ul><li>VRRP 通告报文间隔时间定时器和</li></ul><p>VRRP 备份组中的 Master 路由器会定时发送 VRRP 通告报文，通知备份组内的路由器自己工作正常。用户可以通过设置 VRRP 定时器来调整 Master 路由器发送 VRRP 通告报文的时间间隔。如果 Backup 路由器在等待了 3 个间隔时间后，依然没有收到 VRRP 通告报文，则认为自己是 Master 路由器，并对外发送 VRRP 通告报文，重新进行 Master 路由器的选举。</p><ul><li>VRRP 抢占延迟时间定时器。</li></ul><p>为了避免备份组内的成员频繁进行主备状态转换，让 Backup 路由器有足够的时间搜集必要的信息 (如路由信息)，Backup 路由器接收到优先级低于本地优先级的通告报文后，不会立即抢占成为 Master，而是等待一定时间——抢占延迟时间后，才会对外发送 VRRP 通告报文取代原来的 Master 路由器。</p></li></ul><h3><span id="vrrp-工作方式">VRRP 工作方式</span></h3><ul><li><p>选举MASTER:路由器使能 VRRP 功能后，会根据优先级确定自己在备份组中的角色。优先级高的路由器成 为 Master 路由器，优先级低的成为 Backup 路由器。Master 路由器定期发送 VRRP 通告报文， 通知备份组内的其他路由器自己工作正常;Backup 路由器则启动定时器等待通告报文的到来。</p></li><li><p>MASTER 通过ARP 协议对外通告该备份组的虚拟ip以及MAC地址</p></li><li><p>在抢占方式下，当 Backup 路由器收到 VRRP 通告报文后，会将自己的优先级与通告报文中 的优先级进行比较。如果大于通告报文中的优先级，则成为 Master 路由器;否则将保持 Backup 状态。</p></li><li><p>如果 Backup 路由器的定时器超时后仍未收到 Master 路由器发送来的 VRRP 通告报文，则认 为 Master 路由器已经无法正常工作，此时 Backup 路由器会认为自己是 Master 路由器，并对 外发送 VRRP 通告报文。备份组内的路由器根据优先级选举出 Master 路由器，承担报文的转 发功能。</p></li><li><p>Backup 通过ARP 协议对外通告该备份组的虚拟ip以及MAC地址</p></li><li><p>MASER 恢复之后，根据是否是抢占模式，逐步恢复对路由转发的功能。</p></li></ul><h2><span id="keepalived-配置详解">Keepalived 配置详解</span></h2><h3><span id="安装keepalived">安装keepalived</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure><h3><span id="配置文件详解">配置文件详解</span></h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/usr/sbin/keepalived</td><td>二进制程序</td></tr><tr><td>/etc/keepalived/keepalived.conf</td><td>配置文件</td></tr><tr><td>/usr/lib/systemd/system/keepalived.service</td><td>服务文件</td></tr></tbody></table><p>里面主要包括以下几个配置区域，分别是:</p><ul><li>global_defs: 主要是配置故障发生时的通知对象以及机器标识。</li><li>static_ipaddress</li><li>static_routes</li><li>vrrp_script</li><li>vrrp_instance</li><li>virtual_server</li></ul><ol><li>global_defs区域</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   <span class="comment"># 邮件通知信息</span></span><br><span class="line">   notification_email &#123;</span><br><span class="line">     <span class="comment"># 定义收件人</span></span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment"># 定义发件人</span></span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1   <span class="comment"># SMTP服务器地址</span></span><br><span class="line">   smtp_connect_timeout 30 <span class="comment"># smtp_connect_timeout 连接smtp服务器的超时时间</span></span><br><span class="line">   <span class="comment"># 路由器标识，一般不用改，也可以写成每个主机自己的主机名 router_id 标识本节点的字条串，通常为hostname，但不一定非得是hostname。故障发生时，邮件通知会用到</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   <span class="comment"># VRRP的ipv4和ipv6的广播地址，配置了VIP的网卡向这个地址广播来宣告自己的配置信息，下面是默认值</span></span><br><span class="line">   <span class="comment"># vrrp_mcast_group4表示的ipv4协议下的组播地址，举个例子，因为集群中的心跳通信用单播每个服务器都要单独发送，用广播会给局域网内所有的服务器都发送信息，因此此处使用组播，向拥有同一组播地址的服务器发送心跳信息比较合适。</span></span><br><span class="line">   vrrp_mcast_group4 224.0.0.18</span><br><span class="line">   vrrp_mcast_group6 ff02::12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>static_ipaddress和static_routes区域[可忽略]</li></ol><p>static_ipaddress和static_routes区域配置的是是本节点的IP和路由信息。如果你的机器上已经配置了IP和路由，那么这两个区域可以不用配置。其实，一般情况下你的机器都会有IP地址和路由信息的，因此没必要再在这两个区域配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static_ipaddress &#123;</span><br><span class="line">    10.210.214.163/24 brd 10.210.214.255 dev eth0</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">static_routes &#123;</span><br><span class="line">    10.0.0.0/8 via 10.210.214.1 dev eth0</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>vrrp_script区域</li></ol><p>用来做健康检查的，当时检查失败时会将vrrp_instance的priority减少相应的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;   </span><br><span class="line">    script <span class="string">"&lt;/dev/tcp/127.0.0.1/80"</span>       <span class="comment">#一句指令或者一个脚本文件，需返回0(成功)或非0(失败)，keepalived以此为依据判断其监控的服务状态。</span></span><br><span class="line">    interval 1    <span class="comment">#健康检查周期</span></span><br><span class="line">    weight -10   <span class="comment"># 优先级变化幅度，如果script中的指令执行失败，那么相应的vrrp_instance的优先级会减少10个点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>vrrp_instance和vrrp_sync_group区域</li></ol><p>vrrp_instance用来定义对外提供服务的VIP区域及其相关属性。<br>vrrp_rsync_group用来定义vrrp_intance组，使得这个组内成员动作一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vrrp_sync_group VG_1 &#123;  <span class="comment">#监控多个网段的实例</span></span><br><span class="line">    group &#123;</span><br><span class="line">        inside_network   <span class="comment"># name of vrrp_instance (below)</span></span><br><span class="line">        outside_network  <span class="comment"># One for each moveable IP.</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master /path/to_master.sh      <span class="comment"># notify_master表示切换为主机执行的脚本</span></span><br><span class="line">    notify_backup /path/to_backup.sh      <span class="comment"># notify_backup表示切换为备机师的脚本</span></span><br><span class="line">    notify_fault <span class="string">"/path/fault.sh VG_1"</span>    <span class="comment"># notify_fault表示出错时执行的脚本</span></span><br><span class="line">    notify /path/notify.sh  <span class="comment"># notify表示任何一状态切换时都会调用该脚本，且在以上三个脚本执行完成之后进行调用</span></span><br><span class="line">    smtp_alert  <span class="comment"># smtp_alert 表示是否开启邮件通知（用全局区域的邮件设置来发通知）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个vrrp_instance就是定义一个虚拟路由器的，实例名称为VI_1</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER <span class="comment"># state MASTER或BACKUP，当其他节点keepalived启动时会将priority比较大的节点选举为MASTER，因此该项其实没有实质用途。</span></span><br><span class="line">    interface eth0  <span class="comment"># interface 节点固有IP（非VIP）的网卡，用来发VRRP包</span></span><br><span class="line">    use_vmac    dont_track_primary <span class="comment"># use_vmac 是否使用VRRP的虚拟MAC地址，dont_track_primary 忽略VRRP网卡错误（默认未设置）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># track_interface 监控以下网卡，如果任何一个不通就会切换到FALT状态。（可选项）</span></span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">        eth1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#mcast_src_ip 修改vrrp组播包的源地址，默认源地址为master的IP</span></span><br><span class="line">    mcast_src_ip    lvs_sync_daemon_interface eth1 <span class="comment">#lvs_sync_daemon_interface 绑定lvs syncd的网卡</span></span><br><span class="line"></span><br><span class="line">    garp_master_delay 10  <span class="comment"># garp_master_delay 当切为主状态后多久更新ARP缓存，默认5秒</span></span><br><span class="line">    </span><br><span class="line">    virtual_router_id 1   <span class="comment"># virtual_router_id 取值在0-255之间，用来区分多个instance的VRRP组播， 同一网段中virtual_router_id的值不能重复，否则会出错</span></span><br><span class="line">    </span><br><span class="line">    priority 100 <span class="comment">#priority用来选举master的，根据服务是否可用，以weight的幅度来调整节点的priority，从而选取priority高的为master，该项取值范围是1-255（在此范围之外会被识别成默认值100）</span></span><br><span class="line">    </span><br><span class="line">    advert_int 1 <span class="comment"># advert_int 发VRRP包的时间间隔，即多久进行一次master选举（可以认为是健康查检时间间隔）</span></span><br><span class="line">    </span><br><span class="line">    authentication &#123; <span class="comment"># authentication 认证区域，认证类型有PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位）</span></span><br><span class="line">        auth_type PASS  <span class="comment">#认证方式</span></span><br><span class="line">        auth_pass 12345678  <span class="comment">#认证密码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123; <span class="comment"># 设置vip</span></span><br><span class="line">        <span class="comment"># IP/掩码 dev 配置在哪个网卡</span></span><br><span class="line">        192.168.200.16/24 dev eth1</span><br><span class="line">        <span class="comment"># IP/掩码 dev 配置在哪个网卡的哪个别名上</span></span><br><span class="line">        192.168.200.17/24 dev label eth1:1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 虚拟路由，在需要的情况下可以设置lvs主机 数据包在哪个网卡进来从哪个网卡出去 即当IP漂过来之后需要添加的路由信息</span></span><br><span class="line">    virtual_routes &#123; </span><br><span class="line">        172.16.0.0/12 via 10.210.214.1</span><br><span class="line">        192.168.1.0/24 via 192.168.1.1 dev eth1</span><br><span class="line">        default via 202.102.152.1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 追踪脚本，通常用于去执行上面的vrrp_script定义的脚本内容</span></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_http_port</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nopreempt <span class="comment"># nopreempt 允许一个priority比较低的节点作为master，即使有priority更高的节点启动</span></span><br><span class="line">    preempt_delay 300 <span class="comment"># preempt_delay master启动多久之后进行接管资源（VIP/Route信息等），并提是没有nopreempt选项</span></span><br><span class="line">    debug</span><br><span class="line">    notify_master|    notify_backup|    notify_fault|    notify|    smtp_alert</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三个指令，如果主机状态变成Master|Backup|Fault之后会去执行的通知脚本，脚本要自己写</span></span><br><span class="line">    notify_master <span class="string">""</span></span><br><span class="line">    notify_backup <span class="string">""</span></span><br><span class="line">    notify_fault <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>virtual_server_group和virtual_server区域<br>定义LVS集群服务，可以是IP+PORT；也可以是fwmark 数字，也就是防火墙规则,所以通过这里就可以看出来keepalive天生就是为ipvs而设计的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">virtual_server IP Port &#123;</span><br><span class="line">    delay_loop    <span class="comment"># delay_loop 延迟轮询时间（单位秒）</span></span><br><span class="line">    lb_algo rr|wrr|lc|wlc|lblc|sh|dh  <span class="comment"># lb_algo 后端调试算法（load balancing algorithm）</span></span><br><span class="line">    lb_kind NAT|DR|TUN  <span class="comment"># lb_kind LVS调度类型NAT/DR/TUN</span></span><br><span class="line">    persistence_timeout    <span class="comment">#会话保持时间</span></span><br><span class="line">    persistence_granularity  <span class="comment">#lvs会话保持粒度 </span></span><br><span class="line">    protocol TCP  <span class="comment">#使用的协议</span></span><br><span class="line">    ha_suspend</span><br><span class="line">    virtualhost    <span class="comment"># virtualhost 用来给HTTP_GET和SSL_GET配置请求header的</span></span><br><span class="line">    alpha </span><br><span class="line">    omega</span><br><span class="line">    quorum   </span><br><span class="line">    hysteresis   </span><br><span class="line">    quorum_up|   </span><br><span class="line">    quorum_down|  </span><br><span class="line">     </span><br><span class="line">    sorry_server  <span class="comment">#备用机，所有realserver失效后启用   如果后端应用服务器都不可用，就会定向到那个服务器上</span></span><br><span class="line">     <span class="comment"># 后端应用服务器 IP PORT</span></span><br><span class="line">    real_server 192.168.200.2 1358 &#123;</span><br><span class="line">        <span class="comment"># 权重</span></span><br><span class="line">        weight 1</span><br><span class="line">        <span class="comment"># MSIC_CHECK|SMTP_CHEKC|TCP_CHECK|SSL_GET|HTTP_GET这些都是</span></span><br><span class="line">        <span class="comment"># 针对应用服务器做健康检查的方法</span></span><br><span class="line">        MISC_CHECK &#123;&#125;</span><br><span class="line">        <span class="comment"># 用于检查SMTP服务器的</span></span><br><span class="line">        SMTP_CHEKC &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果应用服务器不是WEB服务器，就用TCP_CHECK检查</span></span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          <span class="comment"># 向哪一个端口检查，如果不指定默认使用上面定义的端口</span></span><br><span class="line">          connect_port &lt;PORT&gt;</span><br><span class="line">          <span class="comment"># 向哪一个IP检测，如果不指定默认使用上面定义的IP地址</span></span><br><span class="line">          bindto &lt;IP&gt;</span><br><span class="line">          <span class="comment"># 连接超时时间</span></span><br><span class="line">          connect_timeout 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果对方是HTTPS服务器就用SSL_GET方法去检查，里面配置的内容和HTTP_GET一样</span></span><br><span class="line">        SSL_GET &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用服务器UP或者DOWN，就执行那个脚本</span></span><br><span class="line">        notify_up <span class="string">"这里写的是路径，如果脚本后有参数，整体路径+参数引起来"</span></span><br><span class="line">        notify_down <span class="string">"/PATH/SCRIPTS.sh 参数"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用HTTP_GET方法去检查</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            <span class="comment"># 检测URL</span></span><br><span class="line">            url &#123; </span><br><span class="line">              <span class="comment"># 具体检测哪一个URL</span></span><br><span class="line">              path /testurl/test.jsp</span><br><span class="line">              <span class="comment"># 检测内容的哈希值</span></span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">              <span class="comment"># 除了检测哈希值还可以检测状态码，比如HTTP的200 表示正常，两种方法二选一即可</span></span><br><span class="line">              status_code 200</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123; </span><br><span class="line">              path /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># 向哪一个端口检查，如果不指定默认使用上面定义的端口</span></span><br><span class="line">            connect_port &lt;PORT&gt;</span><br><span class="line">            <span class="comment"># 向哪一个IP检测，如果不指定默认使用上面定义的IP地址</span></span><br><span class="line">            bindto &lt;IP&gt;</span><br><span class="line">            <span class="comment"># 连接超时时间</span></span><br><span class="line">            connect_timeout 3</span><br><span class="line">            <span class="comment"># 尝试次数</span></span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            <span class="comment"># 每次尝试之间间隔几秒</span></span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="实战">实战</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 ~]<span class="comment"># man 5 keepalived.conf</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># cd /etc/keepalived/</span></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># ls</span></span><br><span class="line">keepalived.conf</span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># cp keepalived.conf keepalived.conf.bak</span></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2><span id="配置vip漂移配置">配置VIP漂移配置</span></h2><p>本次来配置 vip 漂移配置 网络拓扑如下：</p><p><img src="/article/keepalived-1/keepalived-1-1620791493940.png" alt></p><ul><li>keepalived.conf 配置如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvs-node-0 配置如下</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">       root@localhost</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from roor@localhost</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.16.100.104/24 dev ens33 label ens33:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># lvs-node-0-backup 配置如下</span></span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">       root@localhost</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from roor@localhost</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       172.16.100.104/24 dev ens33 label ens33:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动keepalived</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># systemctl restart  keepalived</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># systemctl status  keepalived</span></span><br><span class="line">● keepalived.service - LVS and VRRP High Availability Monitor</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/keepalived.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2021-05-12 11:38:41 CST; 16min ago</span><br><span class="line">  Process: 6306 ExecStart=/usr/sbin/keepalived <span class="variable">$KEEPALIVED_OPTIONS</span> (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 6307 (keepalived)</span><br><span class="line">   CGroup: /system.slice/keepalived.service</span><br><span class="line">           ├─6307 /usr/sbin/keepalived -D</span><br><span class="line">           ├─6308 /usr/sbin/keepalived -D</span><br><span class="line">           └─6309 /usr/sbin/keepalived -D</span><br></pre></td></tr></table></figure><ul><li>keepalived 进程</li></ul><p>我们可以通过日志看到 keepalived 一共启动了三个进程，分别是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├─6307 /usr/sbin/keepalived -D</span><br><span class="line">├─6308 /usr/sbin/keepalived -D</span><br><span class="line">└─6309 /usr/sbin/keepalived -D</span><br></pre></td></tr></table></figure><p>keepalived正常启动的时候，共启动3个进程：</p><ul><li><p>一个是父进程，负责监控其子进程；一个是VRRP子进程，另外一个是checkers子进程；</p></li><li><p>两个子进程都被系统watchlog（为keepalived程序当中的模块）看管，两个子进程各自负责复杂自己的事。</p></li><li><p>Healthcheck（为keepalived程序当中的模块）子进程检查各自服务器的健康状况，，例如http,lvs。如果healthchecks进程检查到master上服务不可用了，就会通知本机上的VRRP子进程，让他删除通告，并且去掉虚拟IP，转换为BACKUP状态。</p></li><li><p>查看配置<br>我们来卡一下 lvs-node-0 的机器是否配置成功</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvs-node-0 的机器</span></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.100  netmask 255.255.255.0  broadcast 172.16.100.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe15:e448  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:15:e4:48  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 16648  bytes 11694770 (11.1 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 10336  bytes 1105559 (1.0 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.104  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class="line">        ether 00:0c:29:15:e4:48  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 56  bytes 5592 (5.4 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 56  bytes 5592 (5.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># lvs-node-0-backup 的机器</span></span><br><span class="line">[root@lvs-node-0-backup keepalived]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.103  netmask 255.255.255.0  broadcast 172.16.100.255</span><br><span class="line">        inet6 fe80::fe47:7422:c78:9b51  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:53:4c:39  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 11694  bytes 11187317 (10.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5520  bytes 538341 (525.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>下面我们做一下验证，将lvs-node-0 ens33网卡down 掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># ifconfig ens33 down</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据现实 lvs-node-0-backup 已经有172.16.100.104 虚拟地址了</span></span><br><span class="line">[root@lvs-node-0-backup keepalived]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.103  netmask 255.255.255.0  broadcast 172.16.100.255</span><br><span class="line">        inet6 fe80::fe47:7422:c78:9b51  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:53:4c:39  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 48331  bytes 13390569 (12.7 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5572  bytes 544595 (531.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.104  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class="line">        ether 00:0c:29:53:4c:39  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3><span id="keepalived-手动宕机脚本">Keepalived 手动宕机脚本</span></h3><p>keepalived 支持 vrrp_script 配置，用于可以手动关闭 keepalived，用户手动切换vrrp 具体配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment"># ... 其他配置</span></span><br><span class="line"></span><br><span class="line">vrrp_script chk_mt &#123;</span><br><span class="line">    script <span class="string">"/etc/keepalived/down.sh"</span></span><br><span class="line">    interval 1</span><br><span class="line">    weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment"># ... 其他配置</span></span><br><span class="line">    track_script &#123;</span><br><span class="line">chk_mt</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment"># ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>/etc/keepalived/down.sh 内容如下(注意增加chmod +x <a href="http://down.sh" target="_blank" rel="noopener">down.sh</a>) 权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/keepalived/down ];<span class="keyword">then</span></span><br><span class="line">weight -2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面的配置为，当我们 /etc/keepalived/down 文件存在的时候，会将改keepalived 监控的vip 转移到 backup 机器上，笔者已经试验过，没有问题。</p><h3><span id="配置虚拟vip-变更之后的通知">配置虚拟vip 变更之后的通知</span></h3><p>本次主要配置当vip切换之后，需要给我们发邮件通知<br>先来看通知脚本(/etc/keepalived/notify.sh)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">通知脚本：</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 这里是我们的vip 地址</span></span><br><span class="line">vip=172.16.100.104</span><br><span class="line">contact=<span class="string">'root@localhost'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    mailsubject=<span class="string">"`hostname` to be <span class="variable">$1</span>: <span class="variable">$vip</span> floating"</span></span><br><span class="line">    mailbody=<span class="string">"`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$mailbody</span> | mail -s <span class="string">"<span class="variable">$mailsubject</span>"</span> <span class="variable">$contact</span>  <span class="comment"># 发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    master)</span><br><span class="line">        notify master</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    backup)</span><br><span class="line">        notify backup</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    fault)</span><br><span class="line">        notify fault</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Usage: `basename $0` &#123;master|backup|fault&#125;'</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>再来看一下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment"># ... 其他配置</span></span><br><span class="line"></span><br><span class="line">vrrp_script chk_mt &#123;</span><br><span class="line">    script <span class="string">"/etc/keepalived/down.sh"</span></span><br><span class="line">    interval 1</span><br><span class="line">    weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment"># ... 其他配置</span></span><br><span class="line">    track_script &#123;</span><br><span class="line">chk_mt</span><br><span class="line">&#125;</span><br><span class="line">     <span class="comment"># ... 其他配置</span></span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/notify.sh master"</span></span><br><span class="line">notify_backup <span class="string">"/etc/keepalived/notify.sh backup"</span></span><br><span class="line">notify_fault <span class="string">"/etc/keepalived/notify.sh fault"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="keepalived-配置-lvs-dr-模型">keepalived 配置 LVS DR 模型</span></h3><p>关于LVS的细节，这里不再详细赘述，有兴趣的读者可以看<a href="https://icefrozen.github.io/article/lvs-3" target="_blank" rel="noopener">负载均衡（3）LVS服务的搭建机及其高级应用</a></p><ul><li>拓扑结构：</li></ul><p><img src="/article/keepalived-1/keepalived-1-1620889198590.png" alt></p><ul><li>搭建过程：</li></ul><p>在准备两台服务器,lvs-node-1(172.16.100.101), lvs-node-2(172.16.100.101)<br>在两台服务器上分别执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2"</span>&gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line"></span><br><span class="line">ifconfig lo:0 172.16.100.104/32 broadcast 172.16.100.104 up</span><br><span class="line">route add -host 172.16.100.104 dev lo:0</span><br></pre></td></tr></table></figure><p>在 lvs-node-0 和lvs-node-0-backup 编辑keepalived配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment"># ... 其他配置</span></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment"># ... 其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 172.16.100.104 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    nat_mask 255.255.244.0</span><br><span class="line">    protocol TCP</span><br><span class="line">    <span class="comment"># sorry_server 127.0.0.1 80  这了不配置sorry 服务器，有需要的读者自己配置</span></span><br><span class="line"></span><br><span class="line">    real_server 172.16.100.101 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">            path /</span><br><span class="line">            status_code 200 </span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 172.16.100.102 80 &#123;</span><br><span class="line">        weight 2</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">            path /</span><br><span class="line">            status_code 200 </span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lvs-ndoe-0 上执行安装lvs 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A -t 172.16.100.104:80 -s rr</span><br><span class="line">ipvsadm -a -t 172.16.100.104:80 -r 172.16.100.101:80 -g</span><br><span class="line">ipvsadm -a -t 172.16.100.104:80 -r 172.16.100.102:80 -g</span><br></pre></td></tr></table></figure><p>在一台机器上执行是否生效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http://172.16.100.104</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx in lvs-node-2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">➜  ~ curl http://172.16.100.104</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx in lvs-node-1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看心跳信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-2 ~]<span class="comment"># tailf /var/log/nginx/access.log</span></span><br><span class="line">172.16.100.100 - - [13/May/2021:15:04:02 +0800] <span class="string">"GET / HTTP/1.0"</span> 200 101 <span class="string">"-"</span> <span class="string">"KeepAliveClient"</span> <span class="string">"-"</span></span><br><span class="line">172.16.100.103 - - [13/May/2021:15:04:05 +0800] <span class="string">"GET / HTTP/1.0"</span> 200 101 <span class="string">"-"</span></span><br></pre></td></tr></table></figure><p>停掉一台lvs-node-2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@lvs-node-2 ~]<span class="comment"># systemctl stop nginx.service</span></span><br><span class="line">[root@lvs-node-2 ~]<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 lvs-node-0 的lvs 配置 看到已经将102排除在外</span></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.104:80 wrr</span><br><span class="line">  -&gt; 172.16.100.101:80            Route   1      0          0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复 lvs-ndoe-2 的ngixn</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-2 ~]<span class="comment"># systemctl start nginx.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 lvs-node-0 的lvs 配置 看到已经将102 已经加回来了</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.104:80 wrr</span><br><span class="line">  -&gt; 172.16.100.101:80            Route   1      0          0</span><br><span class="line">  -&gt; 172.16.100.102:80            Route   2      0          0</span><br><span class="line">[root@lvs-node-0 keepalived]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2><span id="keepalived-双主模型搭建">keepalived 双主模型搭建</span></h2><p>以上的环境是基于主备模型，当master 节点工作正常的状态下，BACKUP是不对外提供服务的，这就意味着我们使用有一个节点处于备份状态，无法对外提供服务。这就会导致一部分的性能浪费，为了解决这个问题，提出了双主模型，也就是说 我们提供两个VIP 并且使用 DNS轮询的方式，使得两个keepalived 都在工作，互为准备，当一台机器失败之后，其中的vip 会转移到另外一个节点上去，该节点拥有两个vip 地址。</p><p>上面我们已经演示过如果搭建 LVS， 本次演示keepalived Track的功能，也就是监视功能。</p><ul><li>VRRP 监视功能</li></ul><p>keepalived 通过track 脚本实现对服务的监控， 根据服务的状态，改变路由器的优先级。当服务出现故障，被监视 Track 项的状态为 Negative，并将路由器的优先级降低指 定的数额。从而，使得备份组内其它路由器的优先级高于这个路由器的优先级，成为 Master 路由器，保证局域网内主机与外部网络的通信不会中断。</p><ul><li>在 Backup 路由器上监视 Master 路由器的状态。当 Master 路由器出现故障时，工作在切换模 式的 Backup 路由器能够迅速成为 Master 路由器，以保证通信不会中断。</li></ul><p><img src="/article/keepalived-1/keepalived-1-1620965195327.png" alt></p><ul><li>lvs-node-0 keepalived 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##配置nginx检查脚本</span></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">  script <span class="string">"/etc/keepalived/chk_nginx.sh"</span></span><br><span class="line">  interval 1</span><br><span class="line">  weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       172.16.100.104/24 dev ens33 label ens33:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       172.16.100.105/24 dev ens33 label ens33:2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lvs-node-0-backup keepalived 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##配置nginx检查脚本</span></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">  script <span class="string">"/etc/keepalived/chk_nginx.sh"</span></span><br><span class="line">  interval 1</span><br><span class="line">  weight -20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       172.16.100.104/24 dev ens33 label ens33:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">       172.16.100.105/24 dev ens33 label ens33:2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>/etc/keepalived/chk_nginx.sh 脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">run=`ps -C nginx --no-header | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$run</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"stop nginx ....."</span></span><br><span class="line">        systemctl stop nginx</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"start nginx ..."</span></span><br><span class="line">systemctl start nginx</span><br><span class="line">        ps -C nginx --no-header</span><br><span class="line">        sleep 3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>在lvs-node-0 和lvs-node-0-backup 上安装 nginx 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="comment"># 负载到 lvs-node-1 和 lvs-node-2 的机器上</span></span><br><span class="line">upstream monitor_server &#123;</span><br><span class="line">    server 172.16.100.102:80;</span><br><span class="line">    server 172.16.100.101:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/host.access.log  main;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_pass http://monitor_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework 源码分析（1）</title>
      <link href="/article/spring-framework-0/"/>
      <url>/article/spring-framework-0/</url>
      
        <content type="html"><![CDATA[<h1><span id="概诉">概诉</span></h1><p>Spring在java 语言层面的核心地位不用多说，Spring 三个核心思想：<strong>控制反转，依赖注入和面向切面编程</strong>，分别是</p><h2><span id="一-spring-ioc-控制反转">一 、Spring IOC (控制反转)</span></h2><ul><li><p>IOC (即  Inversion of Control)为控制反转.Spring开发的基本思想 : 采用面向接口的编程模式.框架做的越多,就越有体会接口在起中起的作用,而Spring将这一想法,开始贯彻到业务的开发中.Bean的Set方法使用接口作为参数,保证其扩展性,实现依赖关系的解耦合.所谓的控制反转,也可以理解为依赖注入,IOC容器就是具有依赖注入功能的容器,IOC容器负责实例化、定位、配置应用程序中的对象及监理这些对象间的依赖.程序将无需直接在代码中new相关对象,程序将由IOC容器进行组装.</p></li><li><p>简单点说,就是将创建对象的控制权,被反转到了Spring框架上. 通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工交给了Spring容器。</p></li><li><p>IOC主要实现方式有两种 :  依赖查找 、 依赖注入 . 依赖注入是一种更可取的方式.</p></li><li><p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p></li><li><p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p></li></ul><h2><span id="二-di-依赖注入">二 、DI (依赖注入)</span></h2><p>由IOC容器动态将某个对象所需要的外部资源 (包括对象 、资源 、 常量 、)注入到组件(Controller 、 Service 等) 之中 . 简单说,就是IOC容器会把当前对象所需要的外部资源动态的注入给我们 .</p><p>Spring依赖注入的方式主要有四种,基于注解注入方式、set注入方式 、 构造器注入方式 、 静态工厂注入方式 . 推荐使用注解注入方式,配置扫,比较方便.</p><h2><span id="三-spring-aop-面向切面编程">三、 Spring AOP (面向切面编程)</span></h2><ul><li><p>AOP (即 Aspect Oriented Programing) 称为：面向切面编程，它是一种编程思想。在程序运行的时候，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。 简单来说就是“纵向重复，横向抽取”这很抽象， Filter 的思想，过滤器在解决乱码的时候不需要我们在每一个类中都写处理乱码的代码。而是直接由 Fliter 来统一处理。还有拦截器的思想，我们在 Action 中需要对参数进行校验、封装，而拦截器又是统一对参数进行校验、封装。 不管是 Fliter 还是拦截器，都是面向切面编程思想的具体应用。</p></li><li><p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p></li><li><p>Spring AOP 的具体实现 : 动态代理 和 cglib 代理。Spring 中通过代理来体现 AOP 的思想，而代理的实现又分为动态代理和 cglib 代理。动态代理要求代理类和被代理类实现同一个接口。而 cglib 是继承代理，代理对象只需继承被代理对象即可实现。在 Spring 中优先使用动态代理。</p></li></ul><h1><span id="源码分析环境搭建">源码分析环境搭建</span></h1><p>此章节不不在赘述，在网上一搜就能出现大把的sprign源码分析环境。Spring 源码仓库地址是：<a href="https://github.com/spring-projects/spring-framework%E3%80%82" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework。</a></p><h1><span id="核心思想分析">核心思想分析</span></h1><h2><span id="构建示例程序">构建示例程序</span></h2><p>目录结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── build.gradle</span><br><span class="line">└── src</span><br><span class="line">    ├── main.java.org.springframework</span><br><span class="line">    │   │               ├── bean</span><br><span class="line">    │   │               │   └── TestBean.java</span><br><span class="line">    │   │               └── debug</span><br><span class="line">    │   │                   └── SpringDebugMain.java</span><br><span class="line">    │   resources</span><br><span class="line">           └── beans.xml</span><br></pre></td></tr></table></figure><ul><li>SpringDebugMain</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDebugMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:beans.xml"</span>);</span><br><span class="line">TestBean testbean = ctx.getBean(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(<span class="string">"testbean = "</span> + testbean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>beanx.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.bean.TestBean"</span> <span class="attr">id</span>=<span class="string">"testBean"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"testbean1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"testaddress"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>bean.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// get set to String 方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'org.springframework'</span></span><br><span class="line">version <span class="string">'5.2.14.BUILD-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(project(<span class="string">":spring-context"</span>))</span><br><span class="line">    testCompile group: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="前置核心概念">前置核心概念</span></h2><p><strong>注意下面的所有概念均为抽象层</strong></p><h3><span id="resource">Resource</span></h3><p>Java一个标准类 java.net.URL，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator），但是我们知道它的实现基本只限于网络形式发布的资源的查找和定位。然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等。而且它可以存在于任何场所，比如网络、文件系统、应用程序中。所以 java.net.URL 的局限性迫使 Spring 必须实现自己的资源加载策略，该资源加载策略需要满足如下要求：</p><ul><li>职能划分清楚。资源的定义和资源的加载应该要有一个清晰的界限；</li><li>统一的抽象。统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来界定。</li></ul><h3><span id="resourceloader">ResourceLoader</span></h3><p>资源加载器，用于将文件，二进制流解析成  Resource 文件下层使用。</p><h3><span id="environment">Environment</span></h3><p>资源，主要是spring运行所以依赖的环境，这些环境主要是存放一下属性值或者配置。</p><h3><span id="beandefinitionreader">BeanDefinitionReader</span></h3><p>BeanDefinitionReader ，该接口的作用就是加载 Bean。在 Spring 中，Bean 一般来说都在配置文件中定义。而在配置的路径由在 web.xml 中定义。所以加载 Bean 的步骤大致就是：加载资源，通过配置文件的路径（Location）加载配置文件（Resource）解析资源，通过解析配置文件的内容得到 Bean。这个是一个扩展层，可以有多个扩展来实现，这个只是定义了抽象层接口。</p><h3><span id="beandefinition">BeanDefinition</span></h3><p>Bean的定义主要由BeanDefinition来描述的。作为Spring中用于包装Bean的数据结构,里面装配了产生这个bean的所有信息，我们第IOC容器也就是 beanFactory 工厂会根据这个配置信息来生产bean。</p><h3><span id="beanfactory">BeanFactory</span></h3><p>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)， 它负责生产和管理bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h3><span id="applicationcontext">ApplicationContext</span></h3><p>ApplicationContext建立在BeanFactory的基础上，提供了更多面向应用的功能， 它提供了国际化支持和框架事件体系。当然本身他也将整个上述所有的关系连接起来，形成处理流，处理完成之后就会开启我们的spring容器。</p><p>我们一般称BeanFactory为IoC容器，而称ApplicationContext为应用上下文，但有时候为了行文方便，我们也将ApplicationContext称为Spring容器。<br>对于BeanFactory 和 ApplicationContext的用途：BeanFactory是Spring框架的基础设施，面向Spring本身<br>ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用Application而非底层的BeanFactory.</p><h3><span id="bean产生的过程">bean产生的过程</span></h3><p><img src="/article/spring-framework-0/spring-framework-0-1616749900995.png" alt></p><h2><span id="bean声明周期">Bean声明周期</span></h2><p>本节我们来解决的是 bean的声明周期。 也就是上图的产出的过程。试想一下，我们如果想创建自己的java 对象，应该怎么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TestBean bean = <span class="keyword">new</span> TestBean();<span class="comment">// 创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">bean.setName(<span class="string">"bean Name"</span>);</span><br><span class="line">bean.setAddress(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他操作 记录对象到某个地方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="comment">// jvm gc 进程负责回收</span></span><br></pre></td></tr></table></figure><p>这个过程包括了几个步骤</p><ol><li>创建对象</li><li>给对象赋值</li><li>使用对象</li><li>销毁对象</li></ol><p>这几个步骤就包括了springIOC容器对bean的管理基本步骤，当然还有一些其他额外操作比如说一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitPostProcessor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 这里面做一下属性赋值之后的一些工作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这是发现接口，当我们实现Aware 接口之后，我们可以将 bean 初始化一些属性注入进来</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述：我们的ioc对bean有一下几个阶段</p><ol><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ol><p>过程如下：实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><ul><li><p>实现了这些接口的Bean会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。例如：BeanPostProcessor, InstantiationAwareBeanPostProcessor吗，InstantiationAwareBeanPostProcessor作用于实例化阶段的前后，BeanPostProcessor作用于初始化阶段的前后。</p></li><li><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如BeanNameAware可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！</p></li></ul><p><img src="/article/spring-framework-0/spring-framework-0-1616752151393.png" alt></p><h2><span id="声明周期详解">声明周期详解</span></h2><p>作者：大闲人柴毛毛<br>链接：<a href="https://www.zhihu.com/question/38597960/answer/247019950" target="_blank" rel="noopener">https://www.zhihu.com/question/38597960/answer/247019950</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3><span id="实例化对象">实例化对象</span></h3><ol><li>实例化Bean对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</li></ol><h3><span id="依赖注入属性">依赖注入属性</span></h3><ol start="2"><li>设置对象属性（依赖注入）实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring根据BeanDefinition中的信息进行依赖注入。 并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</li></ol><h3><span id="aware接口">Aware接口</span></h3><ol start="3"><li>注入Aware接口紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。</li></ol><h3><span id="自定义处理器">自定义处理器</span></h3><ol start="4"><li>BeanPostProcessor当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：postProcessBeforeInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。postProcessAfterInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li></ol><h3><span id="initializingbean-初始化">InitializingBean 初始化</span></h3><ol start="5"><li>InitializingBean与init-method当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：afterPropertiesSet()这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</li></ol><h3><span id="对象的销毁">对象的销毁</span></h3><ol start="6"><li>DisposableBean和destroy-method和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</li></ol><p><img src="/article/spring-framework-0/spring-framework-0-1616752329562.png" alt></p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">请别再问Spring Bean的生命周期了！</a></li><li><a href="https://www.zhihu.com/question/38597960/answer/247019950" target="_blank" rel="noopener">Spring中Bean的生命周期是怎样的？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡（3）</title>
      <link href="/article/lvs-3/"/>
      <url>/article/lvs-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>根据<a href="https://icefrozen.github.io/article/lvs-2/" target="_blank" rel="noopener">LVS四层负载均衡器</a>所述，本节来详细搭建一下LVS环境, 这里我们只做NAT模型和DR模型。</p><h2><span id="lvs服务的搭建">LVS服务的搭建</span></h2><h1><span id="ipvsadm">ipvsadm</span></h1><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum  ipvsadm  -y</span><br></pre></td></tr></table></figure><ul><li>ipvsadm 是LVS 管理集群服务的命令行工具，用法如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [-b <span class="built_in">sched</span>-flags]</span><br><span class="line">ipvsadm -D -t|u|f service-address</span><br><span class="line">ipvsadm -C</span><br><span class="line">ipvsadm -R</span><br><span class="line">ipvsadm -S [-n]</span><br><span class="line">ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight] [-x upper] [-y lower]</span><br><span class="line">ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line">ipvsadm -L|l [options]</span><br><span class="line">ipvsadm -Z [-t|u|f service-address]</span><br><span class="line">ipvsadm --<span class="built_in">set</span> tcp tcpfin udp</span><br><span class="line">ipvsadm -h</span><br></pre></td></tr></table></figure><ul><li>管理集群服务：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm  -A|E  -t|u|f  service-address  [-s scheduler]</span><br><span class="line">ipvsadm  -D  -t|u|f service-address</span><br><span class="line">-A：添加</span><br><span class="line">-E：修改</span><br><span class="line">-D：删除</span><br><span class="line">service-address：</span><br><span class="line">-t, tcp, vip:port </span><br><span class="line">-u, udp, vip:port</span><br><span class="line">-f, fwm, MARK</span><br><span class="line">    -s scheduler：默认为wlc；</span><br></pre></td></tr></table></figure><ul><li>管理集群服务上的RS:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -a|e  -t|u|f service-address -r server-address [-g|i|-r] [-w weight]</span><br><span class="line">ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line"></span><br><span class="line">-a：添加一个RS</span><br><span class="line">-e：修改一个RS</span><br><span class="line">-d：删除一个RS</span><br><span class="line"></span><br><span class="line">server-address： rip[:port]</span><br><span class="line">    -g：GATEWAY （默认）</span><br><span class="line">    -i: IPIP</span><br><span class="line">    -m: MASQUERADE</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -L|l [options]</span><br><span class="line">    -n：numeric，数字格式显示地址和端口；</span><br><span class="line">    -c：connection，显示ipvs连接；</span><br><span class="line">    --stats：统计数据；</span><br><span class="line">    --rate：速率</span><br><span class="line">    --exact：精确值</span><br></pre></td></tr></table></figure><ul><li>清空和保存：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -C</span><br></pre></td></tr></table></figure><ul><li>保存和重载：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">保存：</span><br><span class="line">    ipvsadm -S  &gt; /PATH/TO/SOME_RULE_FILE</span><br><span class="line">    ipvsadm-save  &gt; /PATH/TO/SOME_RULE_FILE</span><br><span class="line">重载：</span><br><span class="line">    ipvsadm  -R &lt; /PATH/FROM/SOME_RULE_FILE</span><br><span class="line">    ipvsadm-restore &lt; /PATH/FROM/SOME_RULE_FILE</span><br><span class="line">    </span><br><span class="line">计数器清零：</span><br><span class="line">ipvsadm  -Z  [-t|u|f service-address]</span><br></pre></td></tr></table></figure><h1><span id="环境准备">环境准备</span></h1><h2><span id="环境概述">环境概述</span></h2><ul><li><p>lvs-node-1: RS(CentOS7)  sshd  nginx</p></li><li><p>lvs-node-2: RS(CentOS7) sshd nginx</p></li><li><p>lvs-node-0: LVS(CentOS7) bind(name server) sshd ipvsadm</p></li><li><p>vmware funsion vmnet4 host-only 虚拟网路</p></li><li><p>nginx web server</p></li><li><p>DNS server</p></li><li><p>网络拓扑如下：</p></li></ul><p><img src="/article/lvs-3/lvs-3-1611499387628.png" alt></p><h2><span id="搭建vmnet4-虚拟网络">搭建vmnet4 虚拟网络</span></h2><p>打开偏好设置</p><p><img src="/article/lvs-3/lvs-3-1611499472947.png" alt></p><p>新建 vmnet4虚拟交换机</p><p><img src="/article/lvs-3/lvs-3-1611499522637.png" alt></p><p>新建 vmnet4 子网为 172.16.100.0</p><p><img src="/article/lvs-3/lvs-3-1611499180529.png" alt></p><h2><span id="lvs设置hostname-和-网卡信息">LVS设置hostname 和 网卡信息</span></h2><ul><li>设置lvs-node-0 双网卡<br>虚拟机添加网卡，使得该网卡链接在虚拟vmnet4 设备之上<br>网卡信息如下：</li></ul><p><img src="/article/lvs-3/lvs-3-1611500354576.png" alt></p><blockquote><p>vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>编辑如下： <strong>注意172.16.100.10 不要配置网关</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=172.16.100.10</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=119.29.29.29</span><br><span class="line">DNS2=182.254.116.116</span><br></pre></td></tr></table></figure><blockquote><p>vim /etc/sysconfig/network-scripts/ifcfg-ens37<br>编辑如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens37</span><br><span class="line">DEVICE=ens37</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.100.6</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=119.29.29.29</span><br><span class="line">GATEWAY=192.168.100.2</span><br><span class="line">DNS2=182.254.116.116</span><br></pre></td></tr></table></figure><ul><li>设置hostname</li></ul><blockquote><p>hostnamectl set-hostname lvs-node-0</p></blockquote><ul><li>关闭防火墙</li></ul><blockquote><p>systemctl stop firewalld<br>systemctl disable firwalld</p></blockquote><ul><li>安装dns服务(这里不做介绍，也可以做可以不做)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并设置 lvs-node-1.exmaple.com 为 172.16.100.11</span><br><span class="line">并设置 lvs-node-2.exmaple.com 为 172.16.100.12</span><br></pre></td></tr></table></figure><ul><li>设置完成重启网卡后网卡信息如下：</li></ul><blockquote><p>systemctl restart network</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@lvs-node-0 ~]# ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.10  netmask 255.255.255.0  broadcast 172.16.100.255</span><br><span class="line">        inet6 fe80::fe47:7422:c78:9b51  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:15:e4:48  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 4946  bytes 985195 (962.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7786  bytes 860433 (840.2 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens37: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.100.6  netmask 255.255.255.0  broadcast 192.168.100.255</span><br><span class="line">        inet6 fe80::4909:a397:124:1798  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:15:e4:52  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 30945  bytes 15583220 (14.8 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 13008  bytes 2620954 (2.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 140  bytes 15978 (15.6 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 140  bytes 15978 (15.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h2><span id="rs设置hostname-和-网卡信息">RS设置hostname 和 网卡信息</span></h2><ul><li>设置lvs-node-1 和 lvs-node-2 hostname</li></ul><blockquote><p>hostnamectl set-hostname {hostname}</p></blockquote><ul><li>设置lvs-node-1 和 lvs-node-2 网卡信息</li></ul><blockquote><p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p></blockquote><p>编辑如下：<strong>DNS1设置刚才配置的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">IPADDR=172.16.100.11</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=172.16.100.10      </span><br><span class="line">GATEWAY=172.16.100.10</span><br><span class="line">DNS2=182.254.116.116</span><br></pre></td></tr></table></figure><h2><span id="安装nginx">安装nginx:</span></h2><p>在 lvs-node-1 和lvs-node-2 上安装nginx</p><ol><li><p>添加源:默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：</p><blockquote><p>sudo rpm -Uvh <a href="http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p></blockquote></li><li><p>安装Nginx</p><blockquote><p>sudo yum install -y nginx</p></blockquote></li><li><p><strong><em>设置keepd-alive 为0（这一点很重要，关掉之后，我们才可以在浏览器看到负载的效果)</em></strong></p><blockquote><p>vim /etc/nginx/nginx.conf</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    keepalive_timeout  <span class="number">0</span>;  <span class="comment">// 修改 keepalive_timeout 为0 关闭keepalive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动Nginx并设置开机自动运行</p><blockquote><p>sudo systemctl start nginx.service<br>sudo systemctl enable nginx.service</p></blockquote></li><li><p>关闭防火墙</p><blockquote><p>sudo systemctl stop firewalld<br>sudo systemctl disable firewalld</p></blockquote></li><li><p>设置nginx index 页面(在lvs-node-1 lvs-node-2上分别设置一下index.html)</p><blockquote><p>vim  /usr/share/nginx/html/index.html<br>替换hostname 和本地ip 到下面的{}设置<br>如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx in &#123;hostname&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote></li><li><p>在lvs-node-0上验证服务</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 ~]# curl http://172.16.100.11</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx in lvs-node-1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">[root@lvs-node-0 ~]# curl http://172.16.100.12</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx in lvs-node-2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">[root@lvs-node-0 ~]#</span><br></pre></td></tr></table></figure><ol start="8"><li>lvs-node-0  ip_forward 设置为转发</li></ol><p>出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。</p><p>配置Linux系统的ip转发功能，首先保证硬件连通，然后打开系统的转发功能<br>/proc/sys/net/ipv4/ip_forward，该文件内容为0，表示禁止数据包转发，1表示允许，将其修改为1。可使用</p><p><strong>注意 proc 下的文件是内核运行后映射的内存参数， 不可使用vim 进行修改，要使用重定向才能修改生效</strong></p><blockquote><p>sudo echo “1” &gt; /proc/sys/net/ipv4/ip_forward</p></blockquote><p>修改内核参数文件</p><blockquote><p>sudo echo “net.ipv4.ip_forward = 1”  &gt;&gt; /etc/sysctl.conf</p></blockquote><p>配置生效</p><blockquote><p>sudo sysctl -p</p></blockquote></li></ol><h1><span id="lvs-四种模式的搭建">LVS 四种模式的搭建</span></h1><h1><span id="nat模式">NAT模式</span></h1><ul><li>NAT的特点<a href="https://icefrozen.github.io/article/lvs-2/#lvs-nat" target="_blank" rel="noopener">LVS NAT模式</a></li></ul><p>注意，当我们配置的NAT模式的时候，我们的网关要经过lvs服务器，所以上述的网关要执行lvs节点。</p><ul><li>添加lvs-node-0 上执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -A -t 192.168.100.6:80 -s rr</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -t 192.168.100.6:80 -r 172.16.100.12 -m</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -t 192.168.100.6:80 -r 172.16.100.11 -m</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.100.6:80 rr</span><br><span class="line">  -&gt; 172.16.100.11:80             Masq    1      0          0</span><br><span class="line">  -&gt; 172.16.100.12:80             Masq    1      0          0</span><br></pre></td></tr></table></figure><ul><li>使用curl 实验负载均衡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http://192.168.100.6:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx in lvs-node-2&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">➜  ~ curl http://192.168.100.6:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx in lvs-node-1&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>总结：我们宿主机的数据包通过请求vip 到达了 lvs-node-0节点，阶段的lvs自动生效，通过将目的地址的ip转换，在通过ens33 接口转发转发出去，到达我们read server，当数据包回来的时候，real server 通过网关LVS机器在转发给我们的客户端。</p><h1><span id="dr模式">DR模式</span></h1><ul><li>DR的特点<a href="https://icefrozen.github.io/article/lvs-2/#lvs-dr" target="_blank" rel="noopener">LVS DR模式</a></li></ul><h2><span id="环境准备">环境准备</span></h2><p>环境准备参考如上配置，首先我们应该清空我们的规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 ~]# ipvsadm -C</span><br><span class="line">[root@lvs-node-0 ~]# ipvsadm -L -n</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br></pre></td></tr></table></figure><p>本次要解决的网络拓扑为不同子网之间的沟通问题，通过我们对DR模式的了解，我们知道，DR模式是通过修改mac地址达到负载的，这就要求我们需要将lvs的各个节点链接到同一个交换机上。</p><p>此时，我们的可选方案有：</p><p>1、 所有机器桥接链接Vmnet8 桥接在我们的物理网卡上，如下图：</p><p><img src="/article/lvs-3/lvs-3-1611976888687.png" alt></p><ul><li><p>一般网卡显示vmnet0，桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。</p></li><li><p>虚拟网桥会转发主机网卡接收到的广播和组播信息，以及目标为虚拟交换机，网段的单播。所以，与虚拟交换机机连接，的虚拟网卡(如: eth0、 eth1等)接收到<br>了路由器发出的DHCP信息及路由更新。</p></li><li><p>桥接模式是通过虚拟网桥将主机上的网卡与虚拟交换机Vmnet0连接在一起， 虚拟机上的<br>虚拟网卡(并不是VMware Network Adapter VMnet1和VMware Network Adapter VMnet8)都连接在虚拟交换机Vmnet0上，所以桥接模式的虚拟机IP必须与主机在同一网段且子网掩码、网关与DNS也要与主机网卡-致。</p></li></ul><p>我们这次以下面这种为搭建对象。</p><p>2、 所有机器链接Vmnet4， Vment4通过NAT连接外网。如下图：</p><p><img src="/article/lvs-3/lvs-3-1611977861193.png" alt></p><ul><li><p>当我们选用vmet4 可以连通外网的时候，vmnet虚拟交换机会虚拟出一个网关，这个网关链接在我们对外的网卡上，一般情况下，ip地址为vmnetip +1</p></li><li><p>可以将原来的删除vmnet8的桥接网络。<br>例如 vment4的子网为 172.16.100.0则 vment4虚拟适配器地址为 172.16.100.1</p></li></ul><p><img src="/article/lvs-3/lvs-3-1611845694265.png" alt></p><ul><li>则会在一下地址出现 nat.conf 文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Library/Preferences/VMware Fusion/vmnet4</span><br><span class="line">➜  vmnet4 ls</span><br><span class="line">nat.conf nat.mac</span><br><span class="line">➜  vmnet4</span><br></pre></td></tr></table></figure><p>里面有个配置为：gateway</p><p><img src="/article/lvs-3/lvs-3-1611846170403.png" alt></p><ul><li>并配置lvs-node-1 和 lvs-node-2 的网关为 172.16.100.2 然后重启我们的网卡。</li></ul><blockquote><p>重启虚拟网络设备</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --stop</span><br><span class="line">sudo  /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --start</span><br><span class="line">sudo  /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --status</span><br></pre></td></tr></table></figure><h2><span id="配置-lvs-node-0-1-2-的网关-并配置相应的ip地址和dns服务器">配置 lvs-node-0 1 2 的网关 并配置相应的ip地址和DNS服务器</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  /etc/sysconfig/network-scripts/ifcfg-ens33</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=172.16.100.100 （注意根据 lvs-node-0,1,2来配置）</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=172.16.100.2</span><br><span class="line">DNS1=119.29.29.29</span><br><span class="line">DNS2=182.254.116.116</span><br></pre></td></tr></table></figure><p>#重启网络服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart network</span><br></pre></td></tr></table></figure><h2><span id="配置lvs-node-1-和-lvs-node-2-内核参数">配置lvs-node-1 和 lvs-node-2 内核参数</span></h2><p>注意此服务要优先于 vip 的配置</p><h3><span id="arp_ignore和arp_announce介绍">arp_ignore和arp_announce介绍</span></h3><p>arp_ignore和arp_announce参数都和ARP协议相关，主要用于控制系统返回arp响应和发送arp请求时的动作。</p><ul><li><p>arp_ignore 参数的作用是控制系统在收到外部的arp请求时，是否要返回arp响应。</p><ul><li>0：响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。</li><li>1：只响应目的IP地址为接收网卡上的本地地址的arp请求。</li><li>2：只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。</li><li>3：如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。</li><li>4~7：保留未使用</li><li>8：不回应所有的arp请求<br>　　sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效。</li></ul></li><li><p>（1）当arp_ignore参数配置为0时，eth1网卡上收到目的IP为环回网卡IP的arp请求，但是eth1也会返回arp响应，把自己的mac地址告诉对端。 如下图</p></li></ul><p><img src="/article/lvs-3/lvs-3-1611843674941.png" alt></p><ul><li>（2）当arp_ignore参数配置为1时，eth1网卡上收到目的IP为环回网卡IP的arp请求，发现请求的IP不是自己网卡上的IP，不会回arp响应。</li></ul><p><img src="/article/lvs-3/lvs-3-1611843707788.png" alt></p><ul><li>arp_announce</li></ul><p>作用是控制系统在对外发送arp请求时，如何选择arp请求数据包的源IP地址。</p><p>（比如系统准备通过网卡发送一个数据包a，这时数据包a的源IP和目的IP一般都是知道的，而根据目的IP查询路由表，发送网卡也是确定的，故源MAC地址也是知道的，这时就差确定目的MAC地址了。而想要获取目的IP对应的目的MAC地址，就需要发送arp请求。arp请求的目的IP自然就是想要获取其MAC地址的IP，而arp请求的源IP是什么呢？ 可能第一反应会以为肯定是数据包a的源IP地址，但是这个也不是一定的，arp请求的源IP是可以选择的，控制这个地址如何选择就是arp_announce的作用）<br>　　arp_announce参数常用的取值有0，1，2。</p><ul><li>0：允许使用任意网卡上的IP地址作为arp请求的源IP，通常就是使用数据包a的源IP。</li><li>1：尽量避免使用不属于该发送网卡子网的本地地址作为发送arp请求的源IP地址。</li><li>2：忽略IP数据包的源IP地址，选择该发送网卡上最合适的本地地址作为arp请求的源IP地址。</li></ul><p>sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效。</p><ul><li>(1) 当arp_announce参数配置为0时，系统要发送的IP包源地址为eth1的地址，IP包目的地址根据路由表查询判断需要从eth2网卡发出，这时会先从eth2网卡发起一个arp请求，用于获取目的IP地址的MAC地址。该arp请求的源MAC自然是eth2网卡的MAC地址，但是源IP地址会选择eth1网卡的地址。</li></ul><p><img src="/article/lvs-3/lvs-3-1611843735708.png" alt></p><ul><li>（2）当arp_announce参数配置为2时，eth2网卡发起arp请求时，源IP地址会选择eth2网卡自身的IP地址。</li></ul><p><img src="/article/lvs-3/lvs-3-1611843785536.png" alt></p><h3><span id="配置方法有以下三种">配置方法有以下三种</span></h3><ol><li>修改/etc/sysctl.conf文件，然后sysctl -p刷新到内存。</li></ol> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.arp_ignore=1</span><br><span class="line">net.ipv4.conf.lo.arp_ignore=1</span><br><span class="line">net.ipv4.conf.all.arp_announce=2</span><br><span class="line">net.ipv4.conf.lo.arp_announce=2</span><br></pre></td></tr></table></figure><ol start="2"><li>使用sysctl -w直接写入内存：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.conf.all.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.all.arp_announce=2</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_announce=2</span><br></pre></td></tr></table></figure><ol start="3"><li>修改/proc文件系统：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1&quot;&gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo &quot;1&quot;&gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo &quot;2&quot;&gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">echo &quot;2&quot;&gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br></pre></td></tr></table></figure><h2><span id="配置-lvs-node-0-1-2-的-vip">配置 lvs-node-0 1 2 的 vip</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@lvs-node-0 ~]# ifconfig lo:0 172.16.100.200/32 broadcast 172.16.100.200 up</span><br><span class="line">[root@lvs-node-0 ~]# ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.100.100  netmask 255.255.255.0  broadcast 172.16.100.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe15:e448  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:15:e4:48  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1493  bytes 157841 (154.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 753  bytes 86686 (84.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 8  bytes 488 (488.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 488 (488.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo:0: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 172.16.100.200  netmask 0.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br></pre></td></tr></table></figure><ul><li>增加路由条目，让host 为 192.168.100.6 的数据通过 lo:0 网卡出去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -host 172.16.100.200 dev lo:0</span><br></pre></td></tr></table></figure><ul><li>查看arp 条目是否符合预期</li></ul><p><img src="/article/lvs-3/lvs-3-1611980191531.png" alt></p><ul><li>添加LVS 配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A -t 172.16.100.200:80 -s rr</span><br><span class="line">ipvsadm -a -t 172.16.100.200:80 -r 172.16.100.101:80 -g</span><br><span class="line">ipvsadm -a -t 172.16.100.200:80 -r 172.16.100.102:80 -g</span><br></pre></td></tr></table></figure><ul><li>实验效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http://172.16.100.200</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx in lvs-node-1&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">➜  ~ curl http://172.16.100.200</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx in lvs-node-2&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">➜  ~ curl http://172.16.100.200</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx in lvs-node-1&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1><span id="fwm应用">FWM应用</span></h1><h2><span id="fwm的应用场景-session-保持的问题">FWM的应用场景 Session 保持的问题。</span></h2><p>在电商行业，我们有一些东西是，需要保存到Seesion 当中的，当我们进行LVS调度的时候，需要进行Session的同步。业内对于Session 有很多已经很成熟的做法，<br>比如</p><ul><li>Session 复制</li><li>Seesion 服务器</li><li>其中还有一种是连接定向。</li></ul><h2><span id="链接定向">链接定向</span></h2><p><strong>所谓的链接定向</strong>就是以某个特定的算法将一个请求定向到同一个RealServer上。这就是我们在负载均衡算法那个章节说的<a href="https://icefrozen.github.io/article/lvs-2/#-2" target="_blank" rel="noopener">SH算法</a>。</p><p>但是试想一下这样的情景, http是明文的，https是在http基础上增加了ssl的过程，但是https毕竟在性能损耗上多了个一个，因此，有些服务会存在http和https共存的现象，有些是可以通过http访问的，比如说一些静态资源，有一些服务必须要通过https进行，比如说登录注册。</p><p>比如，我们在浏览网站商品的时候使用http，但是登录的时候就会跳转成为https，这种意味着网站必须同时提供了80和443两种服务</p><p><img src="/article/lvs-3/lvs-3-1612019649648.png" alt></p><ul><li><p>链接定向的负载问题：</p><p>A客户端访问HTTP集群时，LVS会通过SH算法给A客户端分配一个real_server_1，以后A客户端再次访问V80端口时就一直是real_server_1给客户端A服务；</p><p>而B客户端访问的是443端口，通过SH算法依然可能将B客户端分配给real_server_1，因为SH算法是静态算法并不考虑服务器的负载，仅仅通过算法本身进行转发，这就可能导致在real_server_1的负载过重，而real_server_2可能会一直闲着，如何进行平衡一下呢？</p></li><li><p>Session 问题</p><p>除了平衡问题之外，还有一个问题，A客户端浏览商品和向购物车当中加商品时通过80端口集群被分发到real_server_1上。</p><p>但当A用户想登付款时，这时用户会通过HTTPS访问，结果由于是两个集群各自通过算法分发，把A用户又给分发到real_server_2上去了，real_server_1上并没有A用户的缓存记录，结果用户登录上之后发现购物车里面的商品全都不见了！！</p><p>可能你会说，不是通过SH算法吗？源地址哈希怎么还能把同一个用户不同请求调度到不同的real server上呢？</p><p>当A客户端访问的是80端口时保持连接没有问题，但是当A客户端用443端口访问时，这对于LVS的443端口集群来说这是一个新的用户请求，A用户之前通过80端口访问的连接记录在80集群的缓存上保存着呢？443端口集群没有呀！所以就会出现上述情况。</p></li></ul><p>解决办法其实也好简单，我们只要把两个集群合并成为一个集群，然后统一进行调度不就行了吗？可是一个集群是80，另一个集群是443，如何合并呢？这个时候我们就要用到iptables当中mangle功能了。</p><h2><span id="fwm">FWM</span></h2><p><strong>FWM:FireWall Mark MARK target</strong> 可用于给特定的报文打标记 --set-mark value 其中：value 可为0xffff格式，表示十六进制数字 借助于防火墙标记来分类报文，而后基于标记定义集群服务；可将多个不同的应用使用同一个集群服务 进行调度,</p><ul><li>FWM 工作原理</li></ul><p>lvs的ipvs函数位于net-filter架构当中的input函数上，我们在input函数的前面，也就是prerouting上将访问VIP的80端口和443端口的都打上一样的标记，就类似于交换机上的tag；</p><p>然后我们再通知ipvs函数，不让它根据报文当中的IP+端口的方式强行改道了，而是根据标记强行改道，只要报文上有这个标记的，统统改道到postrouting上，这样同一个用户无论访问的是80端口和还是443端口，都会统一通过一个SH算法调度到同一台R-SERVER上，并提高了缓存命中率，有效的解决了用户在将商品加入完购物车之后付款时商品丢失问题，而且因为是一个集群，所以也不会出现两个集群通过不同算法调度导致R-SERVER负载不平衡的问题。</p><ul><li>FWM命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A PREROUTING -d $&#123;vip&#125; -p $&#123;protocol&#125; --dport $&#123;port&#125; -j MARK --set-mark 10</span><br></pre></td></tr></table></figure><h2><span id="ipvs-持久链接">IPVS 持久链接</span></h2><h3><span id="什么是持久链接">什么是持久链接</span></h3><p>在LVS中，持久连接是为了用来保证当来自同一个client的请求时，director能够将这些请求调度定位到第一次选定的Real Server。</p><h3><span id="持久链接类型">持久链接类型</span></h3><ul><li>PPC（persistent port connections）</li></ul><p>持久的端口连接，将来自于同一个客户端对同一个服务(端口)的请求，始终定向至此前选定的RS。</p><blockquote><p>例如：来自同一个IP的用户第一次访问集群的80端口分配到Real Server1，433号端口分配到Real Server2。当之后这个用户继续访问80端口仍然分配到Real Server1，433号端口仍然分配到Real Server2。</p></blockquote><blockquote><p>PCC（persistent client connections）</p></blockquote><p>将来自于同一个客户端的所有请求统统定向至此前选定的RS；也就是只要IP相同，分配的服务器始终相同。</p><blockquote><p>例如，来自同一个IP的用户访问集群的80端口分配到Real Server1，然后用户访问433号端口仍然分配到Real Server1。但如需要SSH：22连接管理Director时，也被分配到Real Server就不好了，下面的PNMPP可以解决这个问题。</p></blockquote><ul><li>PNMPP（Persistent Netfilter Marked Packet Persistence）</li></ul><p>基于防火墙标记的持久性连接，这种防火墙标记仅在数据包在分发器上时有影响，数据包一旦离开Director，就不再被标记。</p><p>需要用到iptables的mangle表为数据包设置Mark标记，mangle表主要用于修改数据包的TOS（Type Of Service，服务类型）、TTL（Time To Live，生存周期）指以及为数据包设置Mark标记。</p><p>它可以将两个毫不相干的端口定义为一个集群服务，例如：合并http的80端口和https的443端口定义为同一个集群服务，而不会出现上面PCC据说的问题。</p><h2><span id="搭建持久链接及其防火墙表示">搭建持久链接及其防火墙表示</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置防火墙标记</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># iptables -t mangle -A PREROUTING -d 172.16.100.200 -p tcp --dport 80 -j MARK --set-mark 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空规则</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义mark 为 99的服务，定义持久化链接（-p 选项 后面可以跟持久链接的时长，默认360s）</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -A -f 10 -s rr -p</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -f 10 -r 172.16.100.101 -g</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -f 10 -r 172.16.100.102 -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line"></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">FWM  10 rr persistent 360</span><br><span class="line">  -&gt; 172.16.100.101:0             Route   1      0          0</span><br><span class="line">  -&gt; 172.16.100.102:0             Route   1      0          0</span><br></pre></td></tr></table></figure><ul><li>PPC 和PCC 持久连接方法</li></ul><p>#0表示所有端口，无论什么端口都会进行分发操作，我们只要请求的是这个地址，都会统统转发至realserver中 如果加上端口号 则表示PCC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 清空规则</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -C</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># pvsadm -A -t 172.16.100.200:0 -s rr -p</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -t 172.16.100.200:0 -r 172.16.100.101 -g</span></span><br><span class="line">[root@lvs-node-0 ~]<span class="comment"># ipvsadm -a -t 172.16.100.200:0 -r 172.16.100.102 -g</span></span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/u010948569/article/details/80766597" target="_blank" rel="noopener">https://blog.csdn.net/u010948569/article/details/80766597</a></li><li><a href="https://blog.csdn.net/eraining/article/details/109148957" target="_blank" rel="noopener">mac版VMWare的vmnet8默认网关和ip配置</a></li><li><a href="https://www.cnblogs.com/yizhangheka/p/12367765.html" target="_blank" rel="noopener">FireWall Mark + LVS</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS服务(2)</title>
      <link href="/article/Net-wrok-DNS-2/"/>
      <url>/article/Net-wrok-DNS-2/</url>
      
        <content type="html"><![CDATA[<h1><span id="dns-服务简介">DNS 服务简介</span></h1><ul><li>接上篇 <a href="https://icefrozen.github.io/article/Net-wrok-DNS-1/" target="_blank" rel="noopener">DNS服务(1)</a> 简述了DNS的诞生和结构，本节来实际操作一遍，搭建一个DNS服务器。</li></ul><h1><span id="dns-服务单台服务器">DNS 服务单台服务器</span></h1><h2><span id="dns-服务器准备">DNS 服务器准备</span></h2><ul><li>CentOS7 ip 为 192.168.100.10</li><li>user 用户为root 用户。</li></ul><h2><span id="安装bind">安装Bind</span></h2><ul><li>查看本机内bind 软件情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]<span class="comment"># rpm -qa | grep ^bind</span></span><br><span class="line"><span class="built_in">bind</span>-libs-9.11.4-26.P2.el7_9.3.x86_64</span><br><span class="line"><span class="built_in">bind</span>-export-libs-9.11.4-16.P2.el7_8.6.x86_64</span><br><span class="line"><span class="built_in">bind</span>-license-9.11.4-26.P2.el7_9.3.noarch</span><br><span class="line"><span class="built_in">bind</span>-libs-lite-9.11.4-26.P2.el7_9.3.x86_64</span><br><span class="line"><span class="built_in">bind</span>-utils-9.11.4-26.P2.el7_9.3.x86_64</span><br><span class="line"><span class="built_in">bind</span>-9.11.4-26.P2.el7_9.3.x86_64</span><br><span class="line">[root@CentOS7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>报名</th><th>作用</th></tr></thead><tbody><tr><td>bind</td><td>BIND主程序</td></tr><tr><td>bind-utils</td><td>客户端搜索主机名的相关命令</td></tr><tr><td>bind-libs</td><td>BIND相关的库文件</td></tr><tr><td>bind-chroot</td><td>将BIND设定文件和程序限制在虚拟根目录下</td></tr></tbody></table><ul><li>安装bind</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bind-utils bind bind-devel bind-libs</span><br></pre></td></tr></table></figure><h2><span id="配置文件">配置文件</span></h2><table><thead><tr><th>文件目录</th><th>说明</th><th>详解</th></tr></thead><tbody><tr><td>/etc/hosts</td><td>主机的一个文件列表</td><td>添加记录如:111.13.100.92</td></tr><tr><td>/etc/resolv.conf</td><td>转换程序配置文件</td><td>一般存放的是域名服务器的ip地址 记录如 nameserver <a href="http://xxx.xxx.xxx.xxx" target="_blank" rel="noopener">xxx.xxx.xxx.xxx</a> 一般不要指定超过3个服务器</td></tr><tr><td>/etc/named.conf</td><td>BIND主文件</td><td>设置一般的name参数，指向该服务器使用的域数据库的信息源</td></tr><tr><td>/var/named/named.ca</td><td>根域名配置服务器指向文件</td><td>指向根域名配置服务器，用于告诉缓存服务器初始化</td></tr><tr><td>/var/named/localhost.zone</td><td>localhost区正向域名解析文件</td><td>用于将本地IP地址（127.0.0.1）转换为本地回送IP地址（127.0.0.1）</td></tr><tr><td>/var/named/name.local</td><td>localhost区反向域名解析文件</td><td>用于将localhost名字转换为本地回送IP地址（127.0.0.1）</td></tr></tbody></table><h2><span id="配置主配置文件etcnameconf">配置主配置文件/etc/name.conf</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">options &#123;</span><br><span class="line">    listen-on port 53 &#123; any; &#125;; <span class="comment"># 绑定在所有ipv4的网卡上</span></span><br><span class="line">    listen-on-v6 port 53 &#123; ::1; &#125;;  <span class="comment"># 绑定在所有ipv6的网卡上</span></span><br><span class="line">    directory     <span class="string">"/var/named"</span>;  <span class="comment"># bind 主目录</span></span><br><span class="line">    dump-file     <span class="string">"/var/named/data/cache_dump.db"</span>;</span><br><span class="line">    statistics-file <span class="string">"/var/named/data/named_stats.txt"</span>; <span class="comment"># statistics-file 统计文件</span></span><br><span class="line">    memstatistics-file <span class="string">"/var/named/data/named_mem_stats.txt"</span>;</span><br><span class="line">    recursing-file  <span class="string">"/var/named/data/named.recursing"</span>;</span><br><span class="line">    secroots-file   <span class="string">"/var/named/data/named.secroots"</span>;</span><br><span class="line">    allow-query     &#123; any; &#125;;           <span class="comment"># 允许所有机器查询</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#   是否允许迭代查询 </span></span><br><span class="line">    recursion yes;</span><br><span class="line">    dnssec-enable yes;</span><br><span class="line">    dnssec-validation yes;</span><br><span class="line">    bindkeys-file <span class="string">"/etc/named.iscdlv.key"</span>;</span><br><span class="line">    managed-keys-directory <span class="string">"/var/named/dynamic"</span>;</span><br><span class="line">    pid-file <span class="string">"/run/named/named.pid"</span>;</span><br><span class="line">    session-keyfile <span class="string">"/run/named/session.key"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logging &#123;</span><br><span class="line">        channel default_debug &#123;</span><br><span class="line">                file <span class="string">"data/named.run"</span>;</span><br><span class="line">                severity dynamic;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">"."</span> IN &#123;</span><br><span class="line">    <span class="built_in">type</span> hint;</span><br><span class="line">    file <span class="string">"named.ca"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">include <span class="string">"/etc/named.rfc1912.zones"</span>;</span><br><span class="line">include <span class="string">"/etc/named.root.key"</span>;</span><br></pre></td></tr></table></figure><p>这面我们来挑选几个详细解释一下配置文件。</p><ul><li><p>recursion 是否允许迭代查询 如果你配置的是一个权威服务器，则不能进行迭代查询，如果你配置的是个缓存DNS服务，那么你需要将迭代查询开启。</p></li><li><p>dnssec 相关配置<br>DNSSEC通过为通过为DNS中的数据添加数字签名信息，使得客户端在得到应答消息后可以通过检查此签名信，使得客户端在得到应答消息后可以通过检查此签名信息来判断应答数据是否权威和真实，从而为 从而为DNS数据提供数据来源验证和数据完整性检验，可以防止针对 可以防止针对DNS的相关攻击，这里不做相关的介绍</p></li><li><p>include 这里是我们的配置区域文件 named.root.key 根DNS解析服务器</p></li></ul><h2><span id="增加-配置区域文件">增加 配置区域文件</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/named.rfc1912.zones</span><br><span class="line"></span><br><span class="line">zone <span class="string">"icefornze.com"</span> IN &#123;            <span class="comment"># 测试域名为 icefornze.com</span></span><br><span class="line">        <span class="built_in">type</span> master;                <span class="comment"># DNS 服务器类型 master</span></span><br><span class="line">        file <span class="string">"icefornze.com.zone"</span>;  <span class="comment"># 区域文件解析 该文件目录为 /var/named/</span></span><br><span class="line">        allow-update &#123;none;&#125;;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 /var/named/ 新建 icefornze.com.zone 文件增加记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 1D                                                             ;TTL 修改配置生效时间，默认为一天</span><br><span class="line">@       IN      SOA     ns.icefornze.com.  root.icefornze.com. (</span><br><span class="line">                                                                20201221     ; serial，配置编号，每次改完配置 +1，这样从服务器就知道更新配置</span><br><span class="line">                                                                1D           ; refresh，从服务器刷新时间，默认一天刷新一次</span><br><span class="line">                                                                1h           ; retry，如果刷新失败，默认1小时重试一次</span><br><span class="line">                                                                1W           ; expire，缓存过期时间，一周</span><br><span class="line">                                                                3H          ; minimum</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加记录文件 NS 记录 以及A 记录 和www 记录</span></span><br><span class="line">        IN NS      ns.icefornze.com.</span><br><span class="line">ns      IN A    192.168.100.10</span><br><span class="line">        IN A    192.168.100.10</span><br><span class="line">www     IN A    192.168.100.10</span><br></pre></td></tr></table></figure><h2><span id="设置nameserver服务器">设置nameserver服务器</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;nameserver 192.168.100.10&quot; &gt;&gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><h2><span id="检查配置文件">检查配置文件</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检查主配置</span><br><span class="line">named-checkconf /etc/named.conf</span><br><span class="line"></span><br><span class="line"># 检查 zone 配置</span><br><span class="line">named-checkzone icefornze.com /var/named/icefornze.com.zone</span><br></pre></td></tr></table></figure><h2><span id="启动服务">启动服务</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl start named</span><br><span class="line">systemctl enable named</span><br><span class="line"></span><br><span class="line">查看是否启动</span><br><span class="line"></span><br><span class="line">[root@CentOS7 ~]# netstat -tlunp | grep 53</span><br><span class="line">tcp        0      0 192.168.100.10:53       0.0.0.0:*               LISTEN      1927/named</span><br><span class="line">tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      1927/named</span><br><span class="line">tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      1927/named</span><br><span class="line">tcp6       0      0 ::1:953                 :::*                    LISTEN      1927/named</span><br><span class="line">udp        0      0 192.168.100.10:53       0.0.0.0:*                           1927/named</span><br><span class="line">udp        0      0 127.0.0.1:53            0.0.0.0:*                           1927/named</span><br></pre></td></tr></table></figure><h2><span id="实验成功与否">实验成功与否</span></h2><p>我们使用nslookup 验证一下，发现验证不过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># nslookup</span></span><br><span class="line">&gt; icefornze.com</span><br><span class="line">;; Got SERVFAIL reply from 192.168.100.10, trying next server</span><br><span class="line">;; Got SERVFAIL reply from 192.168.100.10, trying next server</span><br><span class="line">Server:119.29.29.29</span><br><span class="line">Address:119.29.29.29<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">** server can<span class="string">'t find icefornze.com: NXDOMAIN</span></span><br></pre></td></tr></table></figure><p>这是时候，我们要检查一下named解析文件的权限，我们发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># ls -alt</span></span><br><span class="line">总用量 20</span><br><span class="line">drwxrwx--T.  5 root  named  153 1月  31 20:25 .</span><br><span class="line"><span class="comment">## 这里是问题， 我们的权限组设置是root。这个时候，我们需要将权限组整理成 named</span></span><br><span class="line">-rw-r-----.  1 root  root   224 1月  31 20:25 icefornze.com.zone  </span><br><span class="line">-rw-r-----.  1 root  named  152 12月 15 2009 named.empty</span><br><span class="line">-rw-r-----.  1 root  named  168 12月 15 2009 named.loopback</span><br><span class="line">-rw-r-----.  1 root  named  152 6月  21 2007 named.localhost</span><br><span class="line"></span><br><span class="line">[root@CentOS7 named]<span class="comment"># chown -R root:named icefornze.com.zone</span></span><br><span class="line">[root@CentOS7 named]<span class="comment"># ls -alt</span></span><br><span class="line">drwxrwx--T.  5 root  named  153 1月  31 20:25 .</span><br><span class="line">-rw-r-----.  1 root  named  224 1月  31 20:25 icefornze.com.zone</span><br><span class="line">drwxrwx---.  2 named named   60 1月  31 20:24 dynamic</span><br><span class="line">drwxrwx---.  2 named named  127 1月  24 16:00 data</span><br><span class="line">drwxr-xr-x. 20 root  root   280 12月 20 20:58 ..</span><br><span class="line">drwxrwx---.  2 named named    6 12月 16 00:32 slaves</span><br><span class="line">-rw-r-----.  1 root  named 2253 4月   5 2018 named.ca</span><br><span class="line">-rw-r-----.  1 root  named  152 12月 15 2009 named.empty</span><br><span class="line">-rw-r-----.  1 root  named  168 12月 15 2009 named.loopback</span><br><span class="line">-rw-r-----.  1 root  named  152 6月  21 2007 named.localhost</span><br></pre></td></tr></table></figure><h2><span id="验证一下">验证一下</span></h2><p>Ping 一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]# ping www.icefornze.com</span><br><span class="line">PING www.icefornze.com (192.168.100.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from CentOS7 (192.168.100.10): icmp_seq=1 ttl=64 time=0.010 ms</span><br></pre></td></tr></table></figure><h1><span id="dns-主从服务器的搭建">DNS 主从服务器的搭建</span></h1><ol><li>主从 DNS 的搭建开始的时候其实是和单机搭建一样的，我们修改主服务器的配置文件：/etc/named.rfc1912.zones<br>将我们之前的配置进行修改：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">"icefornze.com"</span> IN &#123;           <span class="comment"># 测试用的域是 icefornze.com</span></span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">"icefornze.com.zone"</span>;  <span class="comment"># 配置文件为 icefornze.com.zone，该文件目录为 /var/named/ 下</span></span><br><span class="line">        allow-update &#123; 192.168.100.113; &#125;;</span><br><span class="line">        allow-transfer &#123; 192.168.100.113; &#125;;    <span class="comment"># 允许同步DNS的辅助服务器IP</span></span><br><span class="line">        also-notify &#123; 192.168.100.113; &#125;;</span><br><span class="line">        notify yes;                             <span class="comment"># 启用变更通告，当主文件变更，通知从进行比较同步</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>从服务器也安装 bind 并将 /etc/named.conf 配置拷贝过来。接着也是配置：/etc/named.rfc1912.zones，此时就能体现主从的不同：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">"icefornze.com"</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> slave;</span><br><span class="line">        file <span class="string">"slaves/icefornze.com.zone"</span>;</span><br><span class="line">        masters &#123; 192.168.100.10; &#125;;   <span class="comment"># 指定主服务器的 IP</span></span><br><span class="line">        masterfile-format text;         <span class="comment"># 指定区域文件的格式为text，不指定有可能会为乱码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们不需要再去配置 icefornze.com.zone 文件，因为我们需要去主同步。所有直接启动从的 dns 服务。重启成功后我们会发现，在从服务器的 /var/named/slaves 目录下，icefornze.com.zone 已经同步成功。我们修改主服务器的 icefornze.com.zone，新加解析的同时，修改配置编号，让从能够探测到变化。<br>此时我们重启主服务器，会发现从服务器就能够同步成功。顺便值得一提的是，我这里使用 reload named 服务并没有使配置生效。</p><h1><span id="子域授权">子域授权</span></h1><h3><span id="什么是子域授权">什么是子域授权</span></h3><p>举例(1)，假设我们是域名为com下所管理的域，如果需要让我们xxx.icefornze.com解析交给我们的ns.icefornze.com来解析，就需要授权，<a href="http://xn--ns-kw2ckd3vx67bgvftpbo4k9uolykph9b6v2cjpr.icefornze.com" target="_blank" rel="noopener">并且将这个子域的解析授予ns.icefornze.com</a> 这个服务器。</p><p><a href="http://xn--xxx-x98dx8lky5a9nha0876aqu8c.icefornze.com" target="_blank" rel="noopener">那么所有的有关xxx.icefornze.com</a> <a href="http://xn--ns-2f3cvgy1uryam91ekusi9u9edp07ddciia9z120ehusla.icefornze.com" target="_blank" rel="noopener">的询问请求都会被我们告知去询问ns.icefornze.com</a> 服务器，并将 <a href="http://ns2.icefornze.com" target="_blank" rel="noopener">ns2.icefornze.com</a> 的ip地址告诉请求客户端。</p><p><img src="/article/Net-wrok-DNS-2/Net-wrok-DNS-2-1612101783761.png" alt></p><h2><span id="定义转发服务器">定义转发服务器</span></h2><h3><span id="其他域名访问我们的域名流程">其他域名访问我们的域名流程</span></h3><p>当用户查询DNS服务器，当DNS数据库有相应的记录时则会回应用户，如果没有，则DNS会直接区询问根域,然后根域会一级一级的询问相应的子域,直到帮用户查询到相应记录.</p><p><img src="/article/Net-wrok-DNS-2/Net-wrok-DNS-2-1612102348591.png" alt></p><p>试想一下，如果我们的 ohter域名服务器 当请求 <a href="http://www.icefornzen.com" target="_blank" rel="noopener">www.icefornzen.com</a> 的时候知道直接去 <a href="http://icefornze.com" target="_blank" rel="noopener">icefornze.com</a> 服务器下去询问呢，是不是就省去了1， 2，3，4 的步骤呢？</p><p>这就是DNS转发功能的实现，也就是说DNS没有对应记录时我们也可以让他把询问请求转发到我们指定的服务器上去查询。DNS转发功能的实现主要是方便优先共享DNS数据库资源，节省查询时间，而不必每次一级一级的递归去询问根，这样节省带宽流量的时间。如下图：</p><p><img src="/article/Net-wrok-DNS-2/Net-wrok-DNS-2-1612102752449.png" alt></p><p>当转发功能开启之后，则必须满足：</p><ul><li>1）保证该非递归服务器不出现在客户机的 /etc/resolv.conf 的</li><li>2）证该非递归服务器不被其他 name server 当成转发器 （forwarder）</li></ul><h3><span id="定义转发服务器">定义转发服务器</span></h3><p>如上图所示，我们开启一个 <a href="http://staging.iceforzen.com" target="_blank" rel="noopener">staging.iceforzen.com</a> 的授权子域名，将www.staging.iceforzen.com的解析放到 192.168.100.12 这台机器上去。</p><ul><li>添加授权子域</li></ul><p>在192.168.100.10 编辑入下记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim /var/named/icefornze.com.zone</span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@       IN      SOA     icefornze.com.  root.icefornze.com. (</span><br><span class="line">                                                                20201221;</span><br><span class="line">                                                                1D      ;</span><br><span class="line">                                                                1h      ;</span><br><span class="line">                                                                1W      ;</span><br><span class="line">                                                                3H      ;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IN  NS  ns</span><br><span class="line">ns      IN A    192.168.100.10</span><br><span class="line">www     IN A    192.168.100.10</span><br><span class="line">*       IN A    192.168.100.10</span><br><span class="line"><span class="comment"># 子域记录</span></span><br><span class="line">staging IN NS   ns.staging</span><br><span class="line">ns.staging      IN A    192.168.100.11</span><br></pre></td></tr></table></figure><p>重新reload 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rndc reload</span><br></pre></td></tr></table></figure><ul><li>启动192.168.100.11 服务</li></ul><p>启动过程入上述,编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim /etc/named.rfc1912.zones</span><br><span class="line"></span><br><span class="line">zone <span class="string">"staging.icefornze.com"</span> IN &#123;            <span class="comment"># 测试域名为 icefornze.com</span></span><br><span class="line">        <span class="built_in">type</span> master;                <span class="comment"># DNS 服务器类型 master</span></span><br><span class="line">        file <span class="string">"staging.icefornze.com.zone"</span>;  <span class="comment"># 区域文件解析 该文件目录为 /var/named/</span></span><br><span class="line">        allow-update &#123;none;&#125;;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 /var/named/ 新建 staging.icefornze.com.zone 文件增加记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@       IN      SOA     staging.icefornze.com.  root.staging.icefornze.com. (</span><br><span class="line">                                                                20201221;</span><br><span class="line">                                                                1D      ;</span><br><span class="line">                                                                1h      ;</span><br><span class="line">                                                                1W      ;</span><br><span class="line">                                                                3H      ;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IN NS   ns</span><br><span class="line">ns      IN A    192.168.100.11</span><br><span class="line">www     IN A    192.168.100.11</span><br><span class="line">*       IN A    192.168.100.11</span><br></pre></td></tr></table></figure><p>重启服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart named</span><br></pre></td></tr></table></figure><ul><li>实验效果<br>在192.168.100.10 上dig <a href="http://www.staging.icefornze.com" target="_blank" rel="noopener">www.staging.icefornze.com</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># dig -t -A www.staging.icefornze.com @192.168.100.10</span></span><br><span class="line">;; Warning, ignoring invalid <span class="built_in">type</span> -A</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; -t -A www.staging.icefornze.com @192.168.100.10</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 35377</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.staging.icefornze.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.staging.icefornze.com. 86400 INA192.168.100.11</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">staging.icefornze.com.86400INNSns.staging.icefornze.com.</span><br><span class="line"></span><br><span class="line">;; Query time: 293 msec</span><br><span class="line">;; SERVER: 192.168.100.10<span class="comment">#53(192.168.100.10)</span></span><br><span class="line">;; WHEN: 日 1月 31 23:09:02 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 87</span><br><span class="line"></span><br><span class="line">[root@CentOS7 named]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>在 192.168.100.11 上查询自己的解析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># dig -t A www.staging.icefornze.com @192.168.100.11</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; -t A www.staging.icefornze.com @192.168.100.11</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 24828</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.staging.icefornze.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.staging.icefornze.com. 86400 INA192.168.100.11</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">staging.icefornze.com.86400INNSns.staging.icefornze.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns.staging.icefornze.com. 86400INA192.168.100.11</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 192.168.100.11<span class="comment">#53(192.168.100.11)</span></span><br><span class="line">;; WHEN: 日 1月 31 23:09:59 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 103</span><br></pre></td></tr></table></figure><ul><li>子域上查询父域的域名<br>如果我们在192.168.100.11 上去查询 <a href="http://www.icefornze.com" target="_blank" rel="noopener">www.icefornze.com</a> 域名，则192.168.100.11 则会走递归查询到根服务器，由于我们的服务器没有得到com的授权，因此没有办法查询到。我们来实验一下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># dig -t A www.icefornze.com @192.168.100.11</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; -t A www.icefornze.com @192.168.100.11</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 37028</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.icefornze.com.INA</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">com.247INSOAa.gtld-servers.net. nstld.verisign-grs.com. 1612105249 1800 900 604800 86400</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 192.168.100.11<span class="comment">#53(192.168.100.11)</span></span><br><span class="line">;; WHEN: 日 1月 31 23:12:13 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 119</span><br><span class="line"></span><br><span class="line">[root@CentOS7 named]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>通过上述，我们看到要去查询com. 这个。 现在我们要通过配置让此命令可以查询到父域负责的解析的域名。</p><ul><li>全局配置</li></ul><p>编辑192.1638.100.11上的 /etc/named.conf 加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">   forward first; </span><br><span class="line">   forwarders &#123;192.168.100.10;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>①foward only  子DNS服务器指父DNS服务器请求DNS解析。</li><li>②foward first 子DNS服务器优先指向父DNS服务器，</li></ul><p>我们在来测试是否可以在11上dig <a href="http://xn--www-nb4j.icefornze.com" target="_blank" rel="noopener">通www.icefornze.com</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]<span class="comment"># rndc reload</span></span><br><span class="line">server reload successful</span><br><span class="line">[root@CentOS7 named]<span class="comment"># dig -t A www.icefornze.com @192.168.100.11</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; -t A www.icefornze.com @192.168.100.11</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 25350</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.icefornze.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.icefornze.com.86400INA192.168.100.10</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">icefornze.com.86400INNSns.icefornze.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns.icefornze.com.86400INA192.168.100.10</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 192.168.100.11<span class="comment">#53(192.168.100.11)</span></span><br><span class="line">;; WHEN: 日 1月 31 23:18:51 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 95</span><br></pre></td></tr></table></figure><ul><li>定向配置</li></ul><p>当然我们还可以不用全局配置，可以特定的zone当中去配置,编辑 192.168.100.11 上的  /etc/named.rfc1912.zones</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zone <span class="string">"icefornze.com."</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> forward;</span><br><span class="line">        forwarders &#123; 192.168.100.10;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">systemcl restart named</span><br></pre></td></tr></table></figure><p>将我们的nameserver 指向自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/resolve.conf</span><br><span class="line"></span><br><span class="line">nameserver 192.168.100.11</span><br></pre></td></tr></table></figure><p>ping <a href="http://xn--www-p18d1b.icefornze.com" target="_blank" rel="noopener">一下www.icefornze.com</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 named]# ping www.icefornze.com</span><br><span class="line">PING www.icefornze.com (192.168.100.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.10 (192.168.100.10): icmp_seq=1 ttl=64 time=0.353 ms</span><br><span class="line">64 bytes from 192.168.100.10 (192.168.100.10): icmp_seq=2 ttl=64 time=0.681 ms</span><br></pre></td></tr></table></figure><p>可以成功</p><h1><span id="智能dns">智能DNS</span></h1><h2><span id="bind-关键配置">Bind 关键配置</span></h2><p>在names.conf 中有许多配置，这里列出个表格供大家参考</p><table><thead><tr><th>配置名称</th><th>功    能</th></tr></thead><tbody><tr><td>acl</td><td>定义一个访问控制列表，用于以后对列表中的IP进行访问控制</td></tr><tr><td>controls</td><td>定义有关本地域名服务器操作的控制通道，这些通道被rndc用来发送控制命令</td></tr><tr><td>include</td><td>把另一个文件中的内容包含进来做为主配置文件的内容</td></tr><tr><td>key</td><td>定义一个密匙信息，用于通过TSIG进行授权和认证的配置中</td></tr><tr><td>logging</td><td>设置日志服务器，以及日志信息的发送位置</td></tr><tr><td>options</td><td>设置DNS服务器的全局配置选项</td></tr><tr><td>server</td><td>定义了与远程服务器交互的规则</td></tr><tr><td>trusted-keys</td><td>定义信任的 DNSSED密匙</td></tr><tr><td>view</td><td>定义一个视图</td></tr><tr><td>zone</td><td>定义一个区域</td></tr></tbody></table><h2><span id="options">options</span></h2><p>options语句设定可以被整个BIND使用的全局选项。这个语句在每个配置文件中只有一处，如果出现多个options语句，则第一个options的配置有效，并且会产生一个警告信息。如果没有options语句，每个子语句使用默认值</p><h2><span id="acl">ACL</span></h2><p>acl主配置语句用于定义一个命名的访问列表，里面包含了一些用IP表示的主机，这个访问列表可以在其他语句使用，表示其所定义的主机。其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl acl-name &#123;   </span><br><span class="line">    address_match_list   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>address_match_list表示IP地址或IP地址集。其中，none、any、localhost和localnets这4个内定的关键字有特别含义，分别表示没有主机、任何主机、本地网络接口IP和本地子网IP。一个具体的例子如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">acl &quot;someips&quot; &#123;                 //定义一个名为someips的ACL  </span><br><span class="line">  10.0.0.1; 192.168.23.1; 192.168.23.15;      //包含3个单个IP  </span><br><span class="line"> &#125;;  </span><br><span class="line"></span><br><span class="line">acl &quot;complex&quot; &#123;             //定义一个名为complex的ACL  </span><br><span class="line">  &quot;someips&quot;;                //可以包含其他ACL  </span><br><span class="line">  10.0.15.0/24;                 //包含10.0.15.0子网中的所有IP  </span><br><span class="line">  !10.0.16.1/24;                //非10.0.16.1子网的IP  </span><br><span class="line">  &#123;10.0.17.1;10.0.18.2;&#125;;   //包含了一个IP组  </span><br><span class="line">  localhost；                //本地网络接口IP（含实际接口IP和127.0.0.1）  </span><br><span class="line"> &#125;;  </span><br><span class="line"></span><br><span class="line">zone &quot;example.com&quot; &#123;  </span><br><span class="line">  type slave;  </span><br><span class="line">  file &quot;slave.example.com&quot;;  </span><br><span class="line">  allow-notify &#123;&quot;complex&quot;;&#125;;    //在此处使用了前面定义的complex访问列表  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="zone">Zone</span></h2><p>下面是Zone 配合选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">zone zone_name [class] [</span><br><span class="line">&#123;</span><br><span class="line">        type ( master | slave | hint | stub | forward ) ;</span><br><span class="line">        [ allow-notify &#123; address_match_list &#125; ; ]</span><br><span class="line">        [ allow-query &#123; address_match_list &#125; ; ]</span><br><span class="line">        [ allow-transfer &#123; address_match_list &#125; ; ]</span><br><span class="line">        [ allow-update &#123; address_match_list &#125; ; ]</span><br><span class="line">        [ update-policy &#123; update_policy_rule [...] &#125; ; ]</span><br><span class="line">        [ allow-update-forwarding &#123; address_match_list &#125; ; ]</span><br><span class="line">        [ alsonotify</span><br><span class="line">        &#123; ip_addr [port ip_port] ; [ ip_addr [port ip_port] ; ... ] &#125;; ]</span><br><span class="line">        [ check-names (warn|fail|ignore) ; ]</span><br><span class="line">        [ dialup dialup_option ; ]</span><br><span class="line">        [ file string ; ]</span><br><span class="line">        [ forward (only|first) ; ]</span><br><span class="line">        [ forwarders</span><br><span class="line">        &#123; ip_addr [port ip_port] ; [ ip_addr [port ip_port] ; ... ] &#125;; ]</span><br><span class="line">        [ ixfr-base string ; ]</span><br><span class="line">        [ ixfr-tmp-file string ; ]</span><br><span class="line">        [ maintain-ixfr-base yes_or_no ; ]</span><br><span class="line">        [ masters [port ip_port] &#123; ip_addr [port ip_port] [key key]; [...] &#125; ; ]</span><br><span class="line">        [ max-ixfr-log-size number ; ]</span><br><span class="line">        [ max-transfer-idle-in number ; ]</span><br><span class="line">        [ max-transfer-idle-out number ; ]</span><br><span class="line">        [ max-transfer-time-in number ; ]</span><br><span class="line">        [ max-transfer-time-out number ; ]</span><br><span class="line">        [ notify yes_or_no | explicit ; ]</span><br><span class="line">        [ pubkey number number number string ; ]</span><br><span class="line">        [ transfer-source (ip4_addr | *) [port ip_port] ; ]</span><br><span class="line">        [ transfer-source-v6 (ip6_addr | *) [port ip_port] ; ]</span><br><span class="line">        [ notify-source (ip4_addr | *) [port ip_port] ; ]</span><br><span class="line">        [ notify-source-v6 (ip6_addr | *) [port ip_port] ; ]</span><br><span class="line">        [ zone-statistics yes_or_no ; ]</span><br><span class="line">        [ sig-validity-interval number ; ]</span><br><span class="line">        [ database string ; ]</span><br><span class="line">        [ min-refresh-time number ; ]</span><br><span class="line">        [ max-refresh-time number ; ]</span><br><span class="line">        [ min-retry-time number ; ]</span><br><span class="line">        [ max-retry-time number ; ]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>zone语句定义了DNS服务器所管理的区，也就是哪一些域的域名是授权给该DNS服务器回答的。一共有5种类型的区，由其type子语句指定，具体名称和功能如下所示。</p><ul><li>Master（主域）：主域用来保存某个区域（<a href="http://xn--www-eo8e.wzvtc.cn" target="_blank" rel="noopener">如www.wzvtc.cn</a>）的数据信息。</li><li>Slave（辅域）：也叫次级域，数据来自主域，起备份作用。</li><li>Stub：Stub区与辅域相似，但它只复制主域的NS记录，而不是整个区数据。它不是标准DNS的功能，只是BIND提供的功能。</li><li>Forward（转发）：转发域中一般配置了 forward和forwarders子句，用于把对该域的查询请求转由其他DNS服务器处理。</li><li>Hint：Hint域定义了一套最新的根DNS服务器地址，如果没有定义，DNS服务器会使用内建的根DNS服务器地址。<br>配置实例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;.&quot; IN &#123;           //定义一个名为&quot;.&quot;的区，查询类为IN  </span><br><span class="line">type hint;              //类型为hint  </span><br><span class="line">file &quot;named.root&quot;;      //区文件是named.root  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">zone  &quot;1.10.10.in-addr.arpa&quot; IN &#123;     //定义一个名为1.10.10.in-addr.arpa的区，查询类为IN  </span><br><span class="line">        type master;                    //类型为master  </span><br><span class="line">        file &quot;named.1.10.10&quot;;       //区文件是named.1.10.10  </span><br><span class="line">        allow-update  &#123; none; &#125;;    //不允许任何客户端对数据进行更新  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="bind-view">Bind View</span></h2><p>我们需要知道什么是DNS VIEW??</p><p>DNS view简单的理解就是实现不同网段发出不同的请求却得出不同的DNS解析结果，有效的分流网络流量，减少服务器的压力，提高访问控制能力。在我国大家都知道，电信和网通之间访问速度是很慢的，但是像百度、sina这种大网站，不管我们怎么访问速度都是很快的，那么他们是采用什么样的技术呢？？</p><p>采用CDN（内容分发网络）技术实现的。在这次我们只讨论CND底层采用的DNS view技术。</p><p>view语句定义了视图功能。视图是BIND 9提供的强大的新功能，允许DNS服务器根据客户端的不同有区别地回答DNS查询，每个视图定义了一个被特定客户端子集见到的DNS名称空间。这个功能在一台主机上运行多个形式上独立的DNS服务器时特别有用。</p><p>视图（view）语句的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">view view_name [class] &#123;</span><br><span class="line">        match-clients &#123; address_match_list &#125; ;</span><br><span class="line">        match-destinations &#123; address_match_list &#125; ;</span><br><span class="line">        match-recursive-only &#123; yes_or_no &#125; ;</span><br><span class="line">        [ view_option; ...]</span><br><span class="line">        zone-statistics yes_or_no ; ]</span><br><span class="line">        [ zone_statement; ...]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>视图是BIND9强大的新功能，允许名称服务器根据询问者的不同有区别的回答DNS查询。特别是当运行拆分DNS设置而不需要运行多个服务器时特别有用。每个视图定义了一个将会在用户的子集中见到的DNS名称空间。</p><p>配置实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">view &quot;internal&quot; &#123;</span><br><span class="line">match-clients &#123; 10.0.0.0/8; &#125;;</span><br><span class="line">// 应该与内部网络匹配.</span><br><span class="line">// 只对内部用户提供递归服务.</span><br><span class="line">// 提供example.com zone 的完全视图</span><br><span class="line">//包括内部主机地址.</span><br><span class="line">recursion yes;</span><br><span class="line">zone &quot;example.com&quot; &#123;</span><br><span class="line">type master;</span><br><span class="line">file &quot;example-internal.db&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">view &quot;external&quot; &#123;</span><br><span class="line">match-clients &#123; any; &#125;;</span><br><span class="line">// 拒绝对外部用户提供递归服务</span><br><span class="line">// 提供一个example.com zone 的受限视图</span><br><span class="line">// 只包括公共可接入主机</span><br><span class="line">recursion no;</span><br><span class="line">zone &quot;example.com&quot; &#123;</span><br><span class="line">type master;</span><br><span class="line">file &quot;example-external.db&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="智能dns">智能DNS</span></h2><p>对于ACL、VIEW、ZONE的应用，DNS服务器有一个高级的功能，能够实现不同的用户访问同一个域名，把域名解析成不同的IP地址，使用户能够访问离他最近的服务器上的数据，这就是DNS服务器的视图功能。</p><p>使用DNS服务器的视图功能可以增加网站的响应速度。例如，当我们网站的数据同步在两台web服务器上时，一台是电信服务器，一台是网通服务器，那么我们肯定希望全国访问我们网站的用户在打开网站的时候，能够自动实现，电信用户访问电信服务器，网通用户访问网通服务器。</p><p>配置这种情况的前提是，web服务器必须要有一个电信的IP地址和一个网通的IP地址。DNS服务器的这种解析功能通常也被称之为智能解析。</p><p>DNS服务器的视图通常在配置文件中是使用view实现的。把要使用某些IP地址作单独访问的zone区域，统一放在一个命名的view段落中，并且在view中定义请求的IP地址或IP地址段，把IP地址写入match-clients选项中。如果像上面说的，区分电信和网通路线的话，那么可以使用两个acl访问控制列表写上电信或网通IP地址，定义电信网通路线，把acl名字写入view段落match-clients选项中。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">acl telecomip&#123; tele_IP; ... &#125;;</span><br><span class="line">acl netcomip&#123; net_IP; ... &#125;;</span><br><span class="line">view telecom &#123;</span><br><span class="line">    match-clients &#123; telecomip; &#125;;</span><br><span class="line">    zone &quot;ZONE_NAME&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;ZONE_NAME.telecom&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">view netcom &#123;</span><br><span class="line">    match-clients &#123; netcomip; &#125;;</span><br><span class="line">    zone &quot;ZONE_NAME&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;ZONE_NAME.netcom&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">view default &#123;</span><br><span class="line">    match-clients &#123; any; &#125;;</span><br><span class="line">    zone &quot;ZONE_NAME&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;ZONE_NAME.netcom&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>(1)、如果使用了视图的功能，那么配置文件中的所有zone区域都要必须写在视图里面，如，配置文件里默认要配置的三个区域，根、127.0.0.1、1.0.0.127.in-addr.arpa都要写入视图。</li><li>(2)、在acl中定义IP地址，IP地址的写法可以是单个IP地址也可以是一个IP地址段加掩码，如：192.168.0.0/24。</li><li>(3)、视图是根据配置文件从上往下匹配的，所以希望优先访问的资源记录文件，区域应该尽量写前面。</li><li>(4)、如果定义的若干个视图的IP地址不全的话，那么可以在最后定义一个默认视图，match-clients选项中的IP地址写上any，代表如果此次访问的IP地址上面没有一个能匹配到，则在此处归类。</li></ul><h2><span id="参考">参考</span></h2><ul><li><p><a href="https://blog.itcloudblog.cn/Linux/BIND-View.html" target="_blank" rel="noopener">智能DNS（BIND+VIEW）的功能如何实现呢？？</a></p></li><li><p><a href="https://blog.csdn.net/zhu_tianwei/article/details/45104125" target="_blank" rel="noopener">DNS BIND之ACL、View、ZONE介绍</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡（2）</title>
      <link href="/article/lvs-2/"/>
      <url>/article/lvs-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上节，讨论了负载均衡的常规策略和一般算法<a href="https://icefrozen.github.io/article/lvs-1/" target="_blank" rel="noopener">负载均衡（1）</a>，今天来主要学习一下LVS负载器。</p><h2><span id="lvs">LVS</span></h2><h3><span id="什么是lvs">什么是LVS</span></h3><ul><li><p>什么是LVS</p><p>LVS是<strong>Linux Virtual Server</strong>的简称，也就是<strong>Linux虚拟服务器</strong>，是一个由章文嵩博士发起的自由软件项目，官方站点是：<a href="http://www.linuxvirtualserver.org" target="_blank" rel="noopener">http://www.linuxvirtualserver.org</a>。现在LVS已经是Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须重新编译内核以支持LVS功能模块，但是从Linux2.4内核心之后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。</p><p><strong>使用LVS技术要达到的目标是</strong>：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能，高可用的服务器群集，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p><p><strong>LVS是四层负载技术</strong> 关于四层负载均衡我已经在上一篇博客当中<a href="https://icefrozen.github.io/article/lvs-1/" target="_blank" rel="noopener">负载均衡（1）</a>做了详细说明，这里就不在赘述。</p></li><li><p>其他的负载均衡软件</p><p>除了LVS 之外，还有一些其他的常见的负载均衡软件， 成熟的架构有<strong>LVS+Keepalived、Nginx+Keepalived、HAProxy+keepalived</strong>。</p><ul><li>HAproxy： 是法国人Willy Tarreau开发的一个开源软件，是一款应对客户端10000以上的同时连接的高性能的TCP和HTTP负载均衡器（LB）。其功能是用来提供基于cookie的持久性，基于内容的交换，过载保护的高级流量管制，自动故障切换，以正则表达式为基础的标题控制运行事件，基于Web的报表，高级日志记录以帮助排除故障的应用或网络及其他功能</li><li>nginx/httpd/Tengine/openresty： 常见的http服务器。</li><li>ats （Apache Traffic Server）：</li><li>perlbal： Perlbal 是一个用 Perl 编写的单线程的事件驱动服务器，可充当 Web 服务器 和 HTTP 负载均衡。</li><li>varnishi： varnish 是非常轻量级,也很强大的一款提供缓存服务的应用.高性能且开源的反向代理服务器和HTTP加速器；</li></ul></li><li><p>Nginx和LVS对比的总结：</p><ul><li><p>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。</p></li><li><p>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</p></li><li><p>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。</p></li><li><p>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。</p></li><li><p>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。</p></li><li><p>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。</p></li></ul></li></ul><p>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。</p><p>在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。</p><p>Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p><p>现在对网络负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术：</p><ul><li><p>第一阶段：利用Nginx或HAProxy进行单点的负载均衡，这一阶段服务器规模刚脱离开单服务器、单数据库的模式，需要一定的负载均衡，但是仍然规模较小没有专业的维护团队来进行维护，也没有需要进行大规模的网站部署。这样利用Nginx或HAproxy就是第一选择，此时这些东西上手快， 配置容易，在七层之上利用HTTP协议就可以。这时是第一选择。</p></li><li><p>第二阶段：随着网络服务进一步扩大，这时单点的Nginx已经不能满足，这时使用LVS或者商用Array就是首要选择，Nginx此时就作为LVS或者Array的节点来使用，具体LVS或Array的是选择是根据公司规模和预算来选择，Array的应用交付功能非常强大，本人在某项目中使用过，性价比也远高于F5，商用首选，但是一般来说这阶段相关人才跟不上业务的提升，所以购买商业负载均衡已经成为了必经之路。</p></li><li><p>第三阶段：这时网络服务已经成为主流产品，此时随着公司知名度也进一步扩展，相关人才的能力以及数量也随之提升，这时无论从开发适合自身产品的定制，以及降低成本来讲开源的LVS，已经成为首选，这时LVS会成为主流。</p></li></ul><p>最终形成比较理想的基本架构为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         </span><br><span class="line">    Array/LVS - ( keepalived) - Array/LVS   （四层负载层）</span><br><span class="line">---------------------------------------------        </span><br><span class="line">    Nginx/Haproxy  Nginx/Haproxy ...        （七层代理层）</span><br><span class="line">---------------------------------------------</span><br><span class="line">    Squid/Varnish  Squid/Varnish ...        （缓存CDN层）</span><br><span class="line">----------------------------------------------</span><br><span class="line">    AppServer        AppServer   ...         （应用层侧）</span><br></pre></td></tr></table></figure><h2><span id="lvs详解">LVS详解</span></h2><h3><span id="lvs-优点">LVS 优点</span></h3><ul><li>高并发连接：LVS基于内核网络层面工作，有超强的承载能力和并发处理能力。单台LVS负载均衡器，可支持上万并发连接。</li><li>稳定性强：是工作在网络4层之上仅作分发之用，这个特点也决定了它在负载均衡软件里的性能最强，稳定性最好，对内存和cpu资源消耗极低。</li><li>成本低廉：硬件负载均衡器少则十几万，多则几十万上百万，LVS只需一台服务器和就能免费部署使用，性价比极高。</li><li>配置简单：LVS配置非常简单，仅需几行命令即可完成配置，也可写成脚本进行管理。</li><li>支持多种算法：支持多种论调算法，可根据业务场景灵活调配进行使用</li></ul><h3><span id="lvs概念">LVS概念</span></h3><ul><li><p>（1）核心组件：</p><ul><li><strong>ipvsadm</strong>：用户空间的命令行工具，也就是LVS的管理工具，用于管理集群服务及集群服务上的RS等；</li><li><strong>ipvs</strong>：工作于内核上的<strong>netfilter INPUT</strong>钩子之上的程序，可根据用户定义的集群实现请求转发, ipvs可以将管理工具的命令转化为系统调用，通过写入规则来到达到调度的问题。</li></ul></li><li><p>（2）专业术语</p><ul><li>VS：Virtual Server   #虚拟服务器</li><li>Director, Balancer    #负载均衡器、分发器</li><li>RS：Real Server   #后端请求处理服务器</li><li>CIP: Client IP    #用户端IP</li><li>VIP：Director Virtual IP   #负载均衡器虚拟IP</li><li>DIP：Director IP   #负载均衡器IP</li><li>RIP：Real Server IP #后端请求处理服务器IP</li></ul></li></ul><h2><span id="lvs原理之网络">LVS原理之网络</span></h2><h3><span id="netfilter"><strong>NETFILTER</strong></span></h3><p>netfilter是Linux系统中真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到&quot;防火&quot;的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了<strong>input</strong>关卡和 <strong>output</strong> 关卡</p><p>当数据包流向本机的时候，如果ip地址不是本机，则要进行转发，当本机的内核支持 <strong>IP_FORWARD</strong>时，我们可以将报文转发给其他服务器，转发特性有三个概念， PREROUTING、FORWARD、POSTROUTING， 分别是<strong>路由前、转发、路由后</strong>。</p><p>即内核中的如下五个关卡：</p><ul><li>PREROUTING:数据包进入路由表之前</li><li>INPUT:通过路由表后目的地为本机</li><li>FORWARDING:通过路由表后，目的地不为本机</li><li>OUTPUT:由本机产生，向外转发</li><li>POSTROUTIONG:发送到网卡接口之前。如下图：</li></ul><p><img src="/article/lvs-2/lvs-2-1610803269124.png" alt></p><p>如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。</p><h3><span id="nat"><strong>NAT</strong></span></h3><ul><li><p>什么是NAT<br>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。因此我们可以认为，NAT在一定程度上，能够有效的解决公网地址不足的问题。</p></li><li><p>NAT分类<br>NAT有三种类型：<strong>静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port-Level NAT）</strong>。</p></li></ul><p>其中，网络地址端口转换NAPT（Network Address Port Translation）则是把内部地址映射到外部网络的一个IP地址的不同端口上。它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与 动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。</p><p>NAPT是使用最普遍的一种转换方式，它又包含两种转换方式：SNAT和DNAT。</p><ul><li>(1)源NAT（Source NAT，SNAT）：修改数据包的源地址。源NAT改变第一个数据包的来源地址，它永远会在数据包发送到网络之前完成，数据包伪装就是一具SNAT的例子。</li><li>(2)目的NAT（Destination NAT，DNAT）：修改数据包的目的地址。Destination NAT刚好与SNAT相反，它是改变第一个数据懈的目的地地址，如平衡负载、端口转发和透明代理就是属于DNAT。</li></ul><ul><li>NAT 工作原理</li></ul><p>1、 <strong>地址转换</strong></p><p>NAT的基本工作原理是，当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。<br>我们来举个例子：</p><p><img src="/article/lvs-2/lvs-2-1610803713892.png" alt></p><p>如图所示，NAT网关有2个网络端口，其中公共网络端口的IP地址是统一分配的公共 IP，为202.20.65.5；</p><p>私有网络端口的IP地址是保留地址，为192.168.1.1。私有网中的主机192.168.1.2向公共网中的主机202.20.65.4发送了1个IP包(Dst=202.20.65.4,Src=192.168.1.2)。</p><p>过程如下：</p><ul><li><p>当IP包经过NAT网关时，<strong>NAT Gateway</strong>会将IP包的源IP转换为NAT Gateway的公共IP并转发到公共网，此时IP包（Dst=202.20.65.4，Src=202.20.65.5）中已经不含任何私有网IP的信息。</p></li><li><p>由于IP包的源IP已经被转换成NAT Gateway的公共IP，Web Server发出的响应IP包（Dst= 202.20.65.5,Src=202.20.65.4）将被发送到NAT Gateway。</p></li><li><p>NAT Gateway会将IP包的目的IP转换成私有网中主机的IP，然后将IP包（Des=192.168.1.2，Src=202.20.65.4）转发到私有网。对于通信双方而言，这种地址的转换过程是完全透明的。转换示意图如下。</p></li></ul><p><img src="/article/lvs-2/lvs-2-1610804025618.png" alt></p><p><strong>如果内网主机发出的请求包未经过NAT，那么当Web Server收到请求包，回复的响应包中的目的地址就是私网IP地址，在Internet上无法正确送达，导致连接失败。</strong></p><p>当NAT Gateway 收到 （Dst=202.20.65.4，Src=202.20.65.5） 这个数据包的返回的时候，我们如何知道到底应应该将 （202.20.65.4 转化为 192.168.1.1 呢 还是 192.168.1.2呢？）这就需要我们在发送这个包的时候做记录，这既是<strong>链路追踪</strong>。</p><p>2、 <strong>连接追踪</strong></p><p>NAT Gateway在收到响应包后，就需要判断将数据包转发给谁。此时如果子网内仅有少量客户机，可以用静态NAT手工指定；但如果内网有多台客户机，并且各自访问不同网站，这时候就需要连接跟踪（connection track）。如下图所示</p><p><img src="/article/lvs-2/lvs-2-1610804515877.png" alt></p><p>在NAT Gateway收到客户机发来的请求包后，做源地址转换，并且将该连接记录保存下来，当NAT Gateway收到服务器来的响应包后，查找Track Table，确定转发目标，做目的地址转换，转发给客户机。</p><p>3、 <strong>端口转换</strong><br>当仅有一台客户机访问服务器时，NAT Gateway只须更改数据包的源IP或目的IP即可正常通讯。但是如果Client A和Client B同时访问Web Server，那么当NAT Gateway收到响应包的时候，就无法判断将数据包转发给哪台客户机，如下图所示</p><p><img src="/article/lvs-2/lvs-2-1610804667338.png" alt></p><p>此时，NAT Gateway会在Connection Track中加入端口信息加以区分。如果两客户机访问同一服务器的源端口不同,我们知道TCP链接中，当两台主机要进行通信时候，客户机会在本机的1-65535上随机挑选一个端口作为client端的通信端口。所以，当数据包到大NAT Gateway的时候，是带着本机的端口的。</p><p>那么在Track Table里加入端口信息即可区分，如果源端口正好相同，那么在时行SNAT和DNAT的同时对源端口也要做相应的转换，如下图所示。</p><p><img src="/article/lvs-2/lvs-2-1610805000231.png" alt></p><p>4、 <strong>路由规则</strong></p><p>当一个数据包要发往外网的时候，需要将包发向自己的网关，再由网关进行NAT的地址转换。但是如果是要想内网发送数据包，在有三层交换机的前提下，是不需要走网关的。一般的网路拓扑结构为网关（网关是个更为抽象的概念，可以由路由器担任，也可以由主机担任。），网关链接运营商，运营商分配公网地址，网关向内提供私有地址。</p><p>子网内，主机链接不同的交换机，交换机链接我们的PC主机，主机需要设定网关的地址才能进行上网（网关的设定有动态和静态两种，静态的需要手动设置自己IP，子网掩码和网关，动态DHCP则靠分配获取。）</p><p>网络拓扑如下：</p><p><img src="/article/lvs-2/lvs-2-1610847078489.png" alt></p><p>当一个网络主机要跟本网通信时候，需要用到一个叫路由表的，路由表用于目标地址的转换。</p><p>我们在192.168.3.1的主机上执行 route 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Destination      Gateway     Genmask         Flags    Metric Ref    Use Iface</span><br><span class="line">192.168.3.0     0.0.0.0         255.255.255.0          U     100     0        0 eth0</span><br><span class="line">default          gateway        0.0.0.0                UG     100    0        0 eth0</span><br></pre></td></tr></table></figure><p>关于路由相关的可以参考这篇文章<a href="https://segmentfault.com/a/1190000019363010" target="_blank" rel="noopener">通俗理解IP路由</a>。</p><ul><li>发送内网数据包</li></ul><p><img src="/article/lvs-2/lvs-2-1610814352947.png" alt></p><ul><li>发送封装的数据包</li><li>将源地址和本地路由表条目进行对比，也就是与运算，得到目标子网。</li><li>匹配上之后，将数据包封装通过路由表当中匹配条目也就是 etch0这网卡发出去。</li></ul><p>eth0 则和物理设备交换机互相连接，交换机有一张映射表，映射了IP地址和MAC地址以及这些插在那些交换机的插口上，则数据包可以经过将换机发送数据包，如下图：</p><p><img src="/article/lvs-2/lvs-2-1610814255717.png" alt></p><ul><li>发送外网数据包</li></ul><p>当我们要发送外网数据包的时候，我们就需要用到网关了。网关链接交换机的时候，网关是会将自己的MAC地址和IP地址注册到交换机，只有注册到了交换机，数据包才能通过交换机到达网关。</p><p><img src="/article/lvs-2/lvs-2-1610846424911.png" alt></p><p>外网数据包在和本地路由匹配的时候，会发现没有匹配的路由条目，则要将数据发送到默认网关，由网关进行转发。流程如下图：</p><p><img src="/article/lvs-2/lvs-2-1610814548968.png" alt></p><p><img src="/article/lvs-2/lvs-2-1610814615551.png" alt></p><ul><li>如何知道对方的MAC地址。</li></ul><p>我们知道TCP的分层协议，链路层封装目标的MAC地址，上述的流程只解决了IP的问题，那么如何知道对方的MAC地址以及交换机中的IP和MAC映射关系是如何形成的呢？接下来我们来看ARP广播协议。</p><p>5、 <strong>ARP广播和MAC地址</strong></p><ul><li>MAC地址</li></ul><p>MAC地址就是在媒体接入层上使用的地址，也叫物理地址、硬件地址或链路地址，由网络设备制造商生产时写在硬件内部。MAC地址与网络无关，也即无论将带有这个地址的硬件（如网卡、集线器、路由器等）接入到网络的何处，都有相同的MAC地址，它由厂商写在网卡的BIOS里。MAC地址可采用6字节（48比特）或2字节（16比特）这两种中的任意一种。但随着局域网规模越来越大，一般都采用6字节的MAC地址。这个48比特都有其规定的意义，前24位是由生产网卡的厂商向IEEE申请的厂商地址，目前的价格是 1000美元买一个地址块，后24位由厂商自行分配，这样的分配使得世界上任意一个拥有48位MAC地址的网卡都有唯一的标识。</p><p>MAC地址解决的是网络数据表下一次的转发地址。</p><ul><li>ARP广播</li></ul><p>知道要通bai讯的IP地址后，PC1 为了获取PC2 的MAC地址，需要发送请求，但是不能一个一个请求，效率太慢，所以发送广播，帧目的地址FFFFFFFFFFFF 在同一个广播域的所有设备都能收到这个 请求，如果自己的IP 是对方请求的IP地址就把自己的MACdu复出去。流程如下：</p><p>例如：192.168.3.1 要向 192.168.3.2 发送一个数据包，但是需要192.168.6.2 的MAC地址，那么他要想交换机询问</p><ul><li><p>发出ARP广播包</p><p><img src="/article/lvs-2/lvs-2-1610814066477.png" alt></p></li><li><p>交换机发出广播，上报IPMAC地址并记录在案</p><p><img src="/article/lvs-2/lvs-2-1610814086495.png" alt></p><p><img src="/article/lvs-2/lvs-2-1610814161452.png" alt></p></li><li><p>构建自己的记录表之后，再给192.168.3.1 发送MAC地址</p><p><img src="/article/lvs-2/lvs-2-1610814195580.png" alt></p></li></ul><h2><span id="lvs-工作模式">LVS 工作模式</span></h2><h3><span id="lvs-nat模式">LVS NAT模式</span></h3><p><img src="/article/lvs-2/lvs-2-1610848992199.png" alt></p><p>LVS NAT原理：</p><p>用户请求LVS到达director，director将请求的报文的目的IP改为RIP，同时将报文的目标端口也改为realserver的相应端口，最后将报文发送到realserver上，realserver将数据返回给director，director再把数据发送给用户</p><p>特点：</p><ul><li>(1) RIP和DIP应该使用私网地址，RS的网关应该指向DIP，（因为VIP到DIP要做NAT,所以要记录，以便于RIP的返回包可以通过原路返回，所以，这里的网关必须指向DIP）</li><li>(2) 请求和响应报文都要经由director转发；极高负载的场景中，Director可能会成为系统瓶颈；</li><li>(3) 支持端口映射；</li><li>(4) VS必须为Linux，RS可以是任意的OS；</li><li>(5) RS的RIP与Director的DIP必须在同一IP网络, 相同的网关已经约束了RS 和 VS 必须在相同固定网络。</li></ul><h3><span id="lvs-dr模式">LVS DR模式</span></h3><p><img src="/article/lvs-2/lvs-2-1610849667170.png" alt></p><ul><li>LVS DR原理：</li></ul><p>用户请求LVS到达director，director将请求的报文的目的MAC地址改为后端的realserver的MAC地址，目的IP为VIP(不变)，源IP为client IP地址(不变)，然后director将报文发送到realserver，realserver检测到目的地址为自己本地的VIP，如果在同一网段，将请求直接返回给用户，如果用户跟realserver不在同一个网段，则需要通过网关返回给用户。</p><p>这里问题：</p><ul><li>1、 要让RS 接到的数据包源地址 VIP, 想要相应的RS相应该包，那么RS上也必须有VIP,否则RS会丢弃该报文。</li><li>2、 如果RS上也有VIP 那么如何保证，当目标地址是VIP的包只会发送给 VS 而不会发送给RS 呢?</li></ul><p>问题解决：</p><p>RS 的网卡可以配置多个IP地址，但是MAC地址只有一个，当数据包通过交换设备要进行转发的时候是要封装MAC包，那么我们只需要让转发设备只知道 VS 的MAC 地址，而不知道RS 的MAC地址不叫好了？也就是说，转发设备在询问 VIP 的MAC地址的时候，只有VS响应，其他人不响应，就可以解决问题。</p><p>基于这个思想，我们得到了一下特性：</p><ul><li><p>(1) 确保前端路由器将目标IP为VIP的请求报文一定会发送给Director；</p><p>解决方案：</p><ul><li>RS静态绑定VIP；</li><li>禁止RS响应VIP的ARP请求（修改各RS的内核参数或者iptabls规则过滤相应，并把VIP配置在特定的接口上实现禁止其响应）；</li></ul></li><li><p>(2) RS的RIP可以使用私有地址，也可以使用公网地址；</p></li><li><p>(3) RS跟Director必须在同一物理网络中（VS的下一条是修改MAC的，所以必须在同一个物理网络中）；</p></li><li><p>(4) 请求报文必须由Director调度，但响应报文必须不能经由Director；</p></li><li><p>(5) 不支持端口映射；（由于是修改MAC,因此不支持端口映射）</p></li><li><p>(6) 各RS可以使用大多数的OS；</p></li></ul><h3><span id="lvs-fullnat">LVS FULLNAT</span></h3><p><img src="/article/lvs-2/lvs-2-1610850532583.png" alt></p><ul><li>FULLNAT模式也不需要DIP和RIP在同一网段</li><li>FULLNAT和NAT相比的话：会保证RS的回包一定可到达LVS</li><li>FULLNAT需要更新源IP，所以性能正常比NAT要低一点</li><li>FULLNAT同样VS 会成为瓶颈</li></ul><h3><span id="lvs-tun原理">LVS TUN原理</span></h3><p><img src="/article/lvs-2/lvs-2-1610850637506.png" alt></p><ul><li>LVS TUN原理：</li></ul><ul><li>①、当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。此时报文的源IP为CIP，目标IP为VIP。</li><li>②、PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链</li><li>③、IPVS比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层IP报文，封装源IP为为DIP，目标IP为RIP。然后发至POSTROUTING链。此时源IP为DIP，目标IP为RIP</li><li>④、POSTROUTING链根据最新封装的IP报文，将数据包发至RS（因为在外层封装多了一层IP首部，所以可以理解为此时通过隧道传输）。此时源IP为DIP，目标IP为RIP</li><li>⑤、RS接收到报文后发现是自己的IP地址，就将报文接收下来，拆除掉最外层的IP后，会发现里面还有一层IP首部，而且目标是自己的lo接口VIP，那么此时RS开始处理此请求，处理完成之后，通过lo接口送给eth0网卡，然后向外传递。此时的源IP地址为VIP，目标IP为CIP</li><li>⑥、响应报文最终送达至客户端</li></ul><ul><li>(1) RIP，DIP，VIP全得是公网地址；</li><li>(2) RS的网关不能也不可能指向DIP；</li><li>(3) 请求报文经由Director调度，但响应报文将直接发给CIP；</li><li>(4) 不支持端口映射；</li><li>(5) RS的OS必须支持IP隧道功能；</li></ul><h3><span id="三种类型的对比">三种类型的对比</span></h3><table><thead><tr><th>lvs-nat/fullnat</th><th>lvs-dr</th><th>lvs-tun</th></tr></thead><tbody><tr><td>建议小规模使用</td><td>建议大规模使用，也是现在较多使用场景的方法</td><td>lvs-tun模型比较少用，因为他不能实现全局负载均衡，不能根据用户区域的距离来挑选最近的机房。这个最多为了实现异地容灾来实现的。比方说日本的机房地震了，而此时美国的机房仍然可使用，那么只要将指向到美国机房即可。而一般只有这种场景下才会用到隧道机制</td></tr></tbody></table><h2><span id="lvs-负载算法">LVS 负载算法</span></h2><p>LVS算法分为静态方法和动态方法</p><h3><span id="静态方法">静态方法</span></h3><p>仅根据调度算法本身，不考虑背后服务器的负载</p><ul><li><strong>rr(round robin) 轮询算法</strong></li></ul><p>调度器通过“轮询”的调度算法，按照顺序将请求分配到后端的真实服务器上，无论后端服务器的负载状态如何，都会平均“轮询”调度。</p><ul><li><strong>WRR(weightd round robin)带权重的轮询</strong></li></ul><p>指的是能者多劳，服务器性能强的，就会分配的比较多。所以根据后端真实服务器的性能来进行调度，根据后端真实服务器负载情况，修改权重值来实现动态的调度</p><ul><li><strong>sh(source hashing)源地址hash</strong></li></ul><p>将来自于同一个源IP的请求将始终被定向至同一个RS,这个目的是为了session持久功能，仅实现session的绑定.</p><ul><li><strong>dh(destination hashing)目标地址hash</strong></li></ul><p>主要用于实现当你的内部主机上有多个防火墙出口时有用或者正向web代理，负载均衡内网用户对互联网的请求。</p><h3><span id="动态方法">动态方法</span></h3><p>根据算法及各RS当前的负载状况进行调度 态通常由活动链接（active），非活动链接（inactive）和权重来计算。</p><ul><li><strong>lc(least connection)最少连接</strong></li></ul><p>通过监控后端RS的连接数，根据TCP协议中的某些计数器来判断。将请求调度到已建立的连接数最少后端的真实服务器上。<br>计算方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Overhead=Active*256+Inactive</span><br><span class="line">Overhead：负载状态</span><br><span class="line">Overhead越小，表示负载越低</span><br></pre></td></tr></table></figure><ul><li><strong>wlc(weight lc)加权的lc</strong></li></ul><p>在集群系统中的服务器，如果性能差异较大的情况下，调度器可以根据采用“加权的最少连接”调度算法来提高负载均衡性能，如果权重值较高的RS，将会承接更大比例的连接负载，所以调度器可以根据“加权的最少连接”来判断服务器的负载情况，并动态调整期权重值。<br>计算方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Overhead=(Active*256+Inactive)/weight</span><br></pre></td></tr></table></figure><ul><li>sed(shortest expertion delay)最短期望延迟</li></ul><p>基于WLC算法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Overhead = （ACTIVE+1）*256/加权（让权重大的优先接收请求）</span><br></pre></td></tr></table></figure><p>不再考虑非活动状态，把当前处于活动状态的数目+1来实现，数目最小的，接受下次请求，+1的目的是为了考虑加权的时候，非活动连<br>接过多缺陷：当权限过大的时候，会倒置空闲服务器一直处于无连接状态。</p><ul><li><strong>nq(Never Queue)永不排队</strong></li></ul><p>可以理解第一个请求上来先轮一圈，就是每个都先响应一次，然后在接着使用上面那种方法计算让谁响应。如果有台Real Server的连接数＝0就直接分配过去，不需要在进行sed运算。</p><ul><li><strong>lblc(Locality-Based Least connection) 基于本地的最小连接</strong></li></ul><p>基于局部性的最少连接算法是针对请求报文的目标IP地址的负载均衡调度。主要用于Cache集群系统，因为Cache中客户请求报文的目标IP会不断发生改变。所以该算法根据请求的目标IP地址找出该目标IP地址最近使用的Real Server，若该服务器是可用的且没有超载，就会使用“最少链接”来挑选一台可用的服务器，将请求发送到该服务器｡</p><ul><li><strong>lblcr(Replicated lblc)带复制功能的lblc，是dh算法的一种改进</strong></li></ul><p>带复制功能的lblc也是针对目标IP地址做负载均衡。主要是根据请求的目标IP找到目标IP对应的服务器组，根据“最小连接”原则，从服务器组中挑选一台服务器。若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器｡同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.zhihu.com/column/helloim" target="_blank" rel="noopener">即时通讯技术分享</a></li><li><a href="https://www.cnblogs.com/zhaiyf/p/9051694.html" target="_blank" rel="noopener">四层、七层负载均衡的区别</a></li><li><a href="https://blog.csdn.net/hzhsan/article/details/45038265" target="_blank" rel="noopener">网络地址转换NAT原理（易于理解）</a></li><li><a href="https://cloud.tencent.com/developer/article/1115747" target="_blank" rel="noopener">你真的掌握lvs工作原理吗？</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡（1）</title>
      <link href="/article/lvs-1/"/>
      <url>/article/lvs-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：以下大部分内容来自：<a href="https://zhuanlan.zhihu.com/p/64207926" target="_blank" rel="noopener">一篇读懂分布式架构下的负载均衡技术：分类、原理、算法、常见方案等</a></p></blockquote><h1><span id="负载均衡的概念">负载均衡的概念</span></h1><p>关于“负载均衡”的解释，百度词条里：负载均衡，英文叫Load Balance，意思就是将请求或者数据分摊到多个操作单元上进行执行，共同完成工作任务。</p><p><strong>负载均衡（Load Balance</strong>）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>负载均衡有两方面的含义：</p><ul><li><p>1）首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；</p></li><li><p>2）其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p></li></ul><h1><span id="负载均衡方案">负载均衡方案</span></h1><h2><span id="osi模型">OSI模型</span></h2><p><img src="/article/lvs-1/lvs-1-12345678.png" alt></p><ul><li>物理层</li></ul><p><img src="/article/lvs-1/lvs-1-1609818465797.png" alt></p><ul><li>数据链路层</li></ul><p><img src="/article/lvs-1/lvs-1-1609818483091.png" alt></p><ul><li>网络层</li></ul><p><img src="/article/lvs-1/lvs-1-1609818546007.png" alt></p><ul><li>传输层</li></ul><p><img src="/article/lvs-1/lvs-1-1609818559823.png" alt></p><ul><li>应用层</li></ul><p><img src="/article/lvs-1/lvs-1-1609818575020.png" alt></p><h2><span id="osi模型的负载方案">OSI模型的负载方案</span></h2><ul><li>1）二层负载均衡（一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应）；</li><li>2）三层负载均衡（一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应）；</li><li>3）四层负载均衡（在三次负载均衡的基础上，用 ip+port 接收请求，再转发到对应的机器）；</li><li>4）七层负载均衡（根据虚拟的url或是IP，主机名接收请求，再转向相应的处理服务器）。</li></ul><h3><span id="二层负载方案">二层负载方案</span></h3><p><strong>二层负债均衡是基于数据链路层的负债均衡</strong>，即让负债均衡服务器和业务服务器绑定同一个虚拟IP（即VIP），客户端直接通过这个VIP进行请求。</p><p>那么如何区分相同IP下的不同机器呢？通过MAC物理地址，每台机器的MAC物理地址都不一样，当负载均衡服务器接收到请求之后，通过改写HTTP报文中以太网首部的MAC地址，按照某种算法将请求转发到目标机器上，实现负载均衡。</p><p>这种方式负载方式虽然控制粒度比较粗，但是优点是负载均衡服务器的压力会比较小，负载均衡服务器只负责请求的进入，不负责请求的响应（响应是有后端业务服务器直接响应给客户端），吞吐量会比较高。</p><p><img src="/article/lvs-1/lvs-1-1609815358102.png" alt></p><h3><span id="三层负载">三层负载</span></h3><p>三层负载均衡是基于网络层的负载均衡，通俗的说就是按照不同机器不同IP地址进行转发请求到不同的机器上。</p><p>这种方式虽然比二层负载多了一层，但从控制的颗粒度上看，并没有比二层负载均衡更有优势，并且，由于请求的进出都要经过负载均衡服务器，会对其造成比较大的压力，性能也比二层负载均衡要差。</p><p><img src="/article/lvs-1/lvs-1-1609815579978.png" alt></p><h3><span id="四层负载均衡">四层负载均衡</span></h3><p>四层的负载均衡就是基于IP+端口的负载均衡：在三层负载均衡的基础上，通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>对应的负载均衡器称为四层交换机（L4 switch），主要分析IP层及TCP/UDP层，实现四层负载均衡。<br>此种负载均衡器不理解应用协议（如HTTP/FTP/MySQL等等），常见例子有：<strong>LVS，F5。</strong></p><h3><span id="七层负载均衡">七层负载均衡</span></h3><p>七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡：在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。</p><p>对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议，常见例子有：<strong>haproxy，MySQL Proxy</strong>。</p><h3><span id="七层和四层的区别">七层和四层的区别</span></h3><ul><li><strong>所谓四层负载均衡</strong>，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</li></ul><p>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p><ul><li><strong>所谓七层负载均衡</strong>，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</li></ul><p>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p><h3><span id="七层和四层的应用场景">七层和四层的应用场景</span></h3><p>七层应用负载的好处，是使得整个网络更&quot;智能化&quot;。</p><p>例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p><p>当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p><p>另外一个常常被提到功能就是安全性。网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(DoS)的目的。</p><p>从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。</p><p>现在的7层负载均衡，主要还是着重于应用HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如IM即时通讯、实时消息推送等socket长连接系统。</p><h2><span id="七层和四层的对比">七层和四层的对比</span></h2><p>四层负载均衡和七层负载均衡技术的总体对比：</p><ul><li><p><strong>1）智能性</strong>：七层负载均衡由于具备OIS七层的所有功能，所以在处理用户需求上能更加灵活，从理论上讲，七层模型能对用户的所有跟服务端的请求进行修改。例如对文件header添加信息，根据不同的文件类型进行分类转发。四层模型仅支持基于网络层的需求转发，不能修改用户请求的内容。</p></li><li><p><strong>2）安全性</strong>: 七层负载均衡由于具有OSI模型的全部功能，能更容易抵御来自网络的攻击；四层模型从原理上讲，会直接将用户的请求转发给后端节点，无法直接抵御网络攻击。</p></li><li><p><strong>3）复杂度</strong>:四层模型一般比较简单的架构，容易管理，容易定位问题；七层模型架构比较复杂，通常也需要考虑结合四层模型的混用情况，出现问题定位比较复杂。</p></li><li><p><strong>4）效率比</strong>:四层模型基于更底层的设置，通常效率更高，但应用范围有限；七层模型需要更多的资源损耗，在理论上讲比四层模型有更强的功能，现在的实现更多是基于http应用。</p></li></ul><h1><span id="复杂均衡算法">复杂均衡算法</span></h1><p>常用的负载均衡算法分为两类：</p><ul><li><strong>1）一种是静态负载均衡</strong></li><li><strong>2）一种是动态负载均衡</strong></li></ul><h2><span id="静态均衡算法">静态均衡算法</span></h2><h3><span id="轮询法">轮询法</span></h3><p>将请求按顺序轮流地分配到每个节点上，不关心每个节点实际的连接数和当前的系统负载<br>有点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡<br>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</p><h3><span id="随机法">随机法</span></h3><p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p><h3><span id="哈希法">哈希法</span></h3><p>源地址哈希的思想是根据客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会落到到同一台服务器进行访问。</p><p>优点：相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布；</p><p>缺点：如果某个节点出现故障，会导致这个节点上的客户端无法使用，无法保证高可用。当某一用户成为热点用户，那么会有巨大的流量涌向这个节点，导致冷热分布不均衡，无法有效利用起集群的性能。所以当热点事件出现时，一般会将源地址哈希法切换成轮询法。</p><h3><span id="加权轮询法">加权轮询法</span></h3><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><p>加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</p><p>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</p><p>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</p><h3><span id="加权随机法">加权随机法</span></h3><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><h3><span id="键值范围法">键值范围法</span></h3><p>根据键的范围进行负债，比如0到10万的用户请求走第一个节点服务器，10万到20万的用户请求走第二个节点服务器……以此类推。</p><p>优点：容易水平扩展，随着用户量增加，可以增加节点而不影响旧数据；</p><p>缺点：容易负债不均衡，比如新注册的用户活跃度高，旧用户活跃度低，那么压力就全在新增的服务节点上，旧服务节点性能浪费。而且也容易单点故障，无法满足高可用。</p><h2><span id="动态均衡算法">动态均衡算法</span></h2><h3><span id="最小连接数法">最小连接数法</span></h3><p>根据每个节点当前的连接情况，动态地选取其中当前积压连接数最少的一个节点处理当前请求，尽可能地提高后端服务的利用效率，将请求合理地分流到每一台服务器。俗称闲的人不能闲着，大家一起动起来。</p><p>优点：动态，根据节点状况实时变化；</p><p>缺点：提高了复杂度，每次连接断开需要进行计数；</p><p>实现：将连接数的倒数当权重值。</p><h3><span id="最快响应速度法">最快响应速度法</span></h3><p>根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。</p><p>优点：动态，实时变化，控制的粒度更细，跟灵敏；</p><p>缺点：复杂度更高，每次需要计算请求的响应速度；</p><p>实现：可以根据响应时间进行打分，计算权重。</p><h3><span id="观察模式法">观察模式法</span></h3><p>观察者模式是综合了最小连接数和最快响应度，同时考量这两个指标数，进行一个权重的分配。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之集群搭建</title>
      <link href="/article/distributed-redis-advanced/"/>
      <url>/article/distributed-redis-advanced/</url>
      
        <content type="html"><![CDATA[<h2><span id="redis集群模式">Redis集群模式</span></h2><h2><span id="redis-主从集群">Redis 主从集群</span></h2><ul><li>(1) 读写分离<br>在redis主从架构中，Master节点负责处理写请求，Slave节点只处理读请求。对于写请求少，读请求多的场景，例如电商详情页，通过这种读写分离的操作可以大幅提高并发量，通过增加redis从节点的数量可以使得redis的QPS达到10W+。</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052712952.png" alt></p><ul><li>(2) 主从同步<br>Master节点接收到写请求并处理后，需要告知Slave节点数据发生了改变，保持主从节点数据一致的行为称为主从同步，所有的Slave都和Master通信去同步数据也会加大Master节点的负担，实际上，除了主从同步，redis也可以从从同步，我们在这里统一描述为主从同步。</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052723735.png" alt></p><h3><span id="redis-主从集群原理">Redis 主从集群原理</span></h3><ol><li>主从同步原理</li></ol><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607052862511.png" alt></p><ol start="2"><li>命令传播</li></ol><p>主从服务器为了保持一致，当主服务接受写操作的时候，将会同步给从服务器，保证两个服务器回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</p><ol start="3"><li>复制功能缺陷（SYNC)缺陷<br>在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</li></ol><ul><li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li><li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li></ul><p>每次执行SYNC命令，主从服务器需要执行以下动作：<br>1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。<br>2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。<br>3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。<br>因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。</p><p>要理解这一情况，请看表15-2展示的断线后重复制例子。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053237800.png" alt></p><p>上面给出的例子可能有一点理想化，因为在主从服务器断线期间，主服务器执行的写命令可能会有成百上千个之多，而不仅仅是两三个写命令。但总的来说，主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的。</p><ol start="4"><li>复制功能缺陷（PSYNC)缺陷</li></ol><p>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：</p><ul><li><p>·其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</p></li><li><p>·而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p></li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053765461.png" alt></p><p>在了解了PSYNC命令的由来，以及部分重同步的工作方式之后，是时候来介绍一下部分重同步的实现细节了。</p><p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053957940.png" alt></p><p>考虑以下这个例子：主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从服务器A断线了，那么主服务器传播的数据将只有从服务器B和从服务器C能收到</p><p>在这之后，主服务器、从服务器B和从服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607053987185.png" alt></p><p>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器将复制加压缓冲区的数据协会到从服务器当中。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607054010960.png" alt></p><blockquote><p>Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。<br>复制积压缓冲区的最小大小可以根据公式second<em>write_size_per_second来估算：<br>·其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。<br>·而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。<br>例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。<br>为了安全起见，可以将复制积压缓冲区的大小设为2</em>second*write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理。<br>至于复制积压缓冲区大小的修改方法，可以参考配置文件中关于repl-backlog-size选项的说明。</p></blockquote><ul><li>PSYNC命令的执行流程</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607054028716.png" alt></p><h3><span id="redis-主从集群搭建">Redis 主从集群搭建</span></h3><ul><li><ol><li>目录结构</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]<span class="comment"># </span></span><br><span class="line"><span class="comment">#root 目录下</span></span><br><span class="line">redis</span><br><span class="line">├── confs</span><br><span class="line">│   ├── 6379</span><br><span class="line">│   │   ├── dump.rdb</span><br><span class="line">│   │   ├── redis_6379.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   ├── 6380</span><br><span class="line">│   │   ├── redis_6380.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   ├── 6381</span><br><span class="line">│   │   ├── dump.rdb</span><br><span class="line">│   │   ├── redis_6381.pid</span><br><span class="line">│   │   ├── redis.conf</span><br><span class="line">│   │   └── redislog.log</span><br><span class="line">│   └── redis.conf</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>修改配置文件</li></ol></li></ul><p>在配置之后，我们可以关闭防火墙。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0                                <span class="comment"># 监听外网端口</span></span><br><span class="line">port 6379                                   <span class="comment"># 端口</span></span><br><span class="line">pidfile /root/redis/confs/6379/redis_6379.pid   <span class="comment">#pid 文件</span></span><br><span class="line">logfile <span class="string">"/root/redis/confs/6379/redislog.log"</span>   <span class="comment">#日志文件</span></span><br><span class="line">daemonize yes  <span class="comment">#后台启动</span></span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>启动服务器</li></ol></li></ul><p>在三个目录下分别执行下，然后启动服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 6380]<span class="comment"># pwd</span></span><br><span class="line">/root/redis/confs/6380</span><br><span class="line">[root@CentOS7 6380]<span class="comment"># redis-server ./redis.conf</span></span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>执行主从命令</li></ol></li></ul><p>在6380 和 6381 执行一下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 6380]<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 192.168.100.10 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6379 日志如下</span></span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Slave 192.168.100.10:6380 asks <span class="keyword">for</span> synchronization</span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Partial resynchronization not accepted: Replication ID mismatch (Slave asked <span class="keyword">for</span> <span class="string">'33469ac4d687096890a7b2b238f2d54104618166'</span>, my replication IDs are <span class="string">'f9730ab8455c298502f5d876da0b47ae8c016cb2'</span> and <span class="string">'0000000000000000000000000000000000000000'</span>)</span><br><span class="line">18217:M 04 Dec 11:19:23.211 * Starting BGSAVE <span class="keyword">for</span> SYNC with target: disk</span><br><span class="line">18217:M 04 Dec 11:19:23.212 * Background saving started by pid 18331</span><br><span class="line">18331:C 04 Dec 11:19:23.216 * DB saved on disk</span><br><span class="line">18331:C 04 Dec 11:19:23.217 * RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">18217:M 04 Dec 11:19:23.308 * Background saving terminated with success</span><br><span class="line">18217:M 04 Dec 11:19:23.309 * Synchronization with slave 192.168.100.10:6380 succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment">## 6380 or 8381 日志如下：</span></span><br><span class="line"></span><br><span class="line">18247:S 04 Dec 11:19:23.208 * Connecting to MASTER 192.168.100.10:6379</span><br><span class="line">18247:S 04 Dec 11:19:23.209 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">18247:S 04 Dec 11:19:23.210 * Non blocking connect <span class="keyword">for</span> SYNC fired the event.</span><br><span class="line">18247:S 04 Dec 11:19:23.210 * Master replied to PING, replication can <span class="built_in">continue</span>...</span><br><span class="line">18247:S 04 Dec 11:19:23.211 * Trying a partial resynchronization (request 33469ac4d687096890a7b2b238f2d54104618166:1).</span><br><span class="line">18247:S 04 Dec 11:19:23.213 * Full resync from master: e2b2649c877aa6ff55ead56cf96e398975ee71aa:0</span><br><span class="line">18247:S 04 Dec 11:19:23.213 * Discarding previously cached master state.</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: receiving 4573 bytes from master</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Loading DB <span class="keyword">in</span> memory</span><br><span class="line">18247:S 04 Dec 11:19:23.309 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure><p>主从结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    6379  master </span><br><span class="line">    /   \</span><br><span class="line">6380     6381  slaver</span><br></pre></td></tr></table></figure><p>当集群完成主从之后，从服务器只允许读数据，不允许写数据。</p><ol start="5"><li>wait 命令（扩展，redis-3.0新增）</li></ol><p>wait 提供两个参数，第一个参数是从节点的数量 m，第二个参数是时间 t，以毫秒<br>为单位。它表示等待 wait 指令之前的所有写操作同步到 n 个子节点 (也就是确保<br>m 个子节点的同步没有滞后)，最多等待时间 t。如果时间 t=0，表示无限等待直到<br>N 个从库同步完成达成一致。<br>假设此时某个子节点与主节点网络断开，wait 指令第二个参数时间 t = 0，主从同步无法继续<br>进行，wait 指令会永远阻塞，redis 服务器将丧失可用性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name jason</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">wait</span> 2 5000</span><br><span class="line">(<span class="built_in">integer</span>) 2  <span class="comment"># 同步2个实例</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2><span id="redis-哨兵集群">redis 哨兵集群</span></h2><h3><span id="sentinel-的作用">Sentinel 的作用</span></h3><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p><p><strong>Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。</strong></p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309468097.png" alt></p><h3><span id="sentinel-的故障迁移">Sentinel 的故障迁移</span></h3><ul><li>用双环图案表示的是当前的主服务器server1。</li><li>用单环图案表示的是主服务器的三个从服务器server2、server3以及server4。</li><li>server2、server3、server4三个从服务器正在复制主服务器server1，而Sentinel系统则在监视所有四个服务器。</li></ul><p>假设这时，主服务器server1进入下线状态，那么从服务器server2、server3、server4对主服务器的复制操作将被中止，并且Sentinel系统会察觉到server1已下线，如图所示（下线的服务器用虚线表示）。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309666481.png" alt></p><p>当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：</p><ul><li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li><li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p>举个例子，图16-3展示了Sentinel系统将server2升级为新的主服务器，并让服务器server3和server4成为server2的从服务器的过程。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309710885.png" alt></p><p>之后，如果server1重新上线的话，它将被Sentinel系统降级为server2的从服务器，如图所示。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607309728173.png" alt></p><h3><span id="sentinel-实现原理">Sentinel 实现原理</span></h3><ol><li>创建网络连接</li></ol><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：</p><ul><li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li><li>另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道。</li></ul><blockquote><p>在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失__sentinel__:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息。<br>另一方面，除了订阅频道之外，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。因为Sentinel需要与多个实例创建多个网络连接，所以Sentinel使用的是异步连接。</p></blockquote><ol start="2"><li>Sentinel 可以监控多个master</li></ol><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310052529.png" alt></p><ol start="3"><li>获取主服务器信息</li></ol><p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310084959.png" alt></p><p>通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面的信息：</p><ul><li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色；</li><li>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个&quot;slave&quot;字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li><li>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。</li></ul><ol start="4"><li>获取从服务器连接</li></ol><p>在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令，并获得类似于以下内容的回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">...</span><br><span class="line">run_id:32be0699dd27b410f7c90dada3a6fab17f97899f</span><br><span class="line">...</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">slave_repl_offset:11887</span><br><span class="line">slave_priority:100</span><br><span class="line"># Other sections</span><br></pre></td></tr></table></figure><p>根据INFO命令的回复，Sentinel会提取出以下信息：</p><ul><li>从服务器的运行ID run_id。</li><li>从服务器的角色role。</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port。</li><li>主从服务器的连接状态master_link_status。</li><li>从服务器的优先级slave_priority。</li><li>从服务器的复制偏移量slave_repl_offset。</li></ul><ol start="5"><li>向主服务器和从服务器发送信息<br>在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure><p>这条命令向服务器的__sentinel__:hello频道发送了一条信息，信息的内容由多个参数组成：</p><ul><li>其中以s_开头的参数记录的是Sentinel本身的信息，各个参数的意义如表16-2所示。</li><li>而m_开头的参数记录的则是主服务器的信息，各个参数的意义如表所示。如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310307757.png" alt></p><ol start="6"><li>接收来自主服务器和从服务器的频道信息</li></ol><p>Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息</p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p><p>举个例子，假设现在有sentinel1、sentinel2、sentinel3三个Sentinel在监视同一个服务器，那么当sentinel1向服务器的__sentinel__:hello频道发送一条信息时，所有订阅了__sentinel__:hello频道的Sentinel（包括sentinel1自己在内）都会收到这条信息，如图1所示。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310519310.png" alt></p><p>当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</p><p>·如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理。</p><p>·相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</p><ol start="7"><li>创建连向其他Sentinel的命令连接</li></ol><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络：Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310619469.png" alt></p><blockquote><p><strong>Sentinel之间不会创建订阅连接</strong> Sentinel在连接主服务器或者从服务器时，会同时创建命令连接和订阅连接，但是在连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。</p></blockquote><blockquote><p>这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</p></blockquote><h3><span id="sentinel-故障迁移和选主流程">Sentinel 故障迁移和选主流程</span></h3><ol><li>发送监控命令</li></ol><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607310765757.png" alt></p><ol start="2"><li>命令回复</li></ol><p>实例对PING命令的回复可以分为以下两种情况：</p><ul><li>有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种。</li><li>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</li></ul><ol start="3"><li><p>检查客观下线状态<br>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p></li><li><p>确定下线状态</p></li></ol><p>Sentinel使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure><p>命令询问其他Sentinel是否同意主服务器已下线</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311285144.png" alt></p><p>当一个Sentinel（目标Sentinel）接收到另一个Sentinel（源Sentinel）发来的SENTINEL is-master-down-by命令时，目标Sentinel会分析并取出命令请求中包含的各个参数，并根据其中的主服务器IP和端口号，检查主服务器是否已下线，然后向源Sentinel返回一条包含三个参数的Multi Bulk回复作为SENTINEL is-master-down-by命令的回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &lt;down_state&gt;</span><br><span class="line">2) &lt;leader_runid&gt;</span><br><span class="line">3) &lt;leader_epoch&gt;</span><br></pre></td></tr></table></figure><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311309721.png" alt></p><ol start="5"><li>其他Sentinel 确认下线状态</li></ol><p>根据其他Sentinel发回的SENTINEL is-master-down-by-addr命令回复，Sentinel将统计其他Sentinel同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量时， 那么该Sentinel就会认为主服务器已经进入客观下线状态。</p><ol start="6"><li>选主流程（Raft算法）</li></ol><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。</p><ul><li>所有Sentinel 选举地位平等</li><li>头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次</li><li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改</li><li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel</li><li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝</li><li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607311786666.png" alt></p><ol start="7"><li>故障迁移</li></ol><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：</p><ul><li>1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</li><li>2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。</li><li>3）将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ul><ol start="8"><li>选出新的主服务器</li></ol><p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。<br>领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：</p><ul><li>1）删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。</li><li>2）删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。</li><li>3）删除所有与已下线主服务器连接断开超过down-after-milliseconds<em>10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds</em>10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。</li><li>之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。</li><li>如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并选出其中偏移量最大的从服务器（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。</li><li>最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。</li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312133265.png" alt></p><p>在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了。</p><p>例如，在图16-22展示的例子中，领头Sentinel会一直向server2发送INFO命令，当server2返回的命令回复从：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">...</span><br><span class="line"># Other sections</span><br><span class="line">...</span><br><span class="line">变为：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">...</span><br><span class="line"># Other sections</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>的时候，领头Sentinel就知道server2已经成功升级为主服务器了。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312162448.png" alt></p><ol start="9"><li>修改从服务器的复制目标</li></ol><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送SLAVEOF命令来实现。</p><p>下图展示了在故障转移操作中，领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让它们复制新的主服务器server2的例子。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312437938.png" alt></p><p>server3和server4成为server2的从服务器之后，各个服务器以及领头Sentinel的样子</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312469029.png" alt></p><ol start="10"><li>将旧的主服务器变为从服务器</li></ol><p>当server1重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312499922.png" alt></p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607312505178.png" alt></p><h3><span id="sentinel-的搭建过程">Sentinel 的搭建过程</span></h3><ol><li>Sentinel 配置说明<br>redis-sentinel.conf配置项说明如下：</li></ol><table><thead><tr><th>配置项目</th><th>配置说明</th><th>示例</th></tr></thead><tbody><tr><td>port</td><td>sentinel监听端口，默认是26379，可以修改。</td><td></td></tr><tr><td>sentinel monitor <master-name> <ip> <redis-port> <quorum></quorum></redis-port></ip></master-name></td><td>告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效。master-name只能包含英文字母，数字，和“.-_”这三个字符需要注意的是master-ip 要写真实的ip地址而不要用回环地址（127.0.0.1）。</td><td>sentinel monitor mymaster 192.168.0.5 6379 2</td></tr><tr><td>sentinel auth-pass <master-name> <password></password></master-name></td><td>设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</td><td>sentinel auth-pass mymaster 0123passw0rd</td></tr><tr><td>sentinel down-after-milliseconds <master-name> <milliseconds></milliseconds></master-name></td><td>这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒</td><td>sentinel down-after-milliseconds mymaster 30000</td></tr><tr><td>sentinel parallel-syncs <master-name> <numslaves></numslaves></master-name></td><td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</td><td>sentinel parallel-syncs mymaster 1</td></tr><tr><td>sentinel failover-timeout <master-name> <milliseconds></milliseconds></master-name></td><td><div>failover-timeout 可以用在以下这些方面： <br>1. 同一个sentinel对同一个master两次failover之间的间隔时间。<br>2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。<br>3. 当想要取消一个正在进行的failover所需要的时间。  <br>4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。 </div></td><td>sentinel failover-timeout mymaster1 20000</td></tr><tr><td>sentinel notification-script <master-name> <script-path></script-path></master-name></td><td>sentinel的notification-script和reconfig-script是用来配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：<br>若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10<br>若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。<br>如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。<br>一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。<br>通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</td><td>sentinel notification-script mymaster /var/redis/notify.sh</td></tr><tr><td>sentinel client-reconfig-script <master-name> <script-path></script-path></master-name></td><td>当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下参数将会在调用脚本时传给脚本:<master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>目前<state>总是“failover”, <role>是“leader”或者“observer”中的一个。 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的。这个脚本应该是通用的，能被多次调用，不是针对性的。</role></state></to-port></to-ip></from-port></from-ip></state></role></master-name></td><td>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 搭建集群</span><br><span class="line"></span><br><span class="line">文件位置</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">.</span><br><span class="line">├── 16379</span><br><span class="line">│   ├── redis_sentinel_16379.pid</span><br><span class="line">│   ├── redis_sentinel_log.log</span><br><span class="line">│   └── sentinel.conf</span><br><span class="line">├── 16380</span><br><span class="line">│   ├── redis_sentinel_16380.pid</span><br><span class="line">│   ├── redis_sentinel_log.log</span><br><span class="line">│   └── sentinel.conf</span><br><span class="line">└── 16381</span><br><span class="line">    ├── redis_sentinel_16381.pid</span><br><span class="line">    ├── redis_sentinel_log.log</span><br><span class="line">    └── sentinel.conf</span><br></pre></td></tr></table></figure><p>配置文件模板 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 16379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /root/redis/confs/sentinel/16379/redis_sentinel_16379.pid</span><br><span class="line">logfile &quot;/root/redis/confs/sentinel/16379/redis_sentinel_log.log&quot;</span><br><span class="line">dir ./</span><br><span class="line">sentinel monitor mymaster 192.168.100.10 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>分别启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ./sentinel.conf <span class="comment">#16379/sentinel.conf</span></span><br></pre></td></tr></table></figure><p>=</p><ol start="3"><li>查看<br>故障转移后 client 怎么知道新的master地址？sentinel 就像是一个服务注册中心，可以请求 sentinel 获取当前的 master 信息。</li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# redis-cli -p 16379 sentinel get-master-addr-by-name mymaster</span><br><span class="line">1) &quot;192.168.100.10&quot;</span><br><span class="line">2) &quot;6379&quot;</span><br></pre></td></tr></table></figure><p>client 使用的 Redis 客户端需要支持 sentinel，那么就可以自动拿到 master 的地址了。</p><h2><span id="redis-集群模式">redis 集群模式</span></h2><p>哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。<br>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><h3><span id="槽位">槽位</span></h3><p>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。<br>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607667695339.png" alt></p><ul><li>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点当其它主节点，.</li><li>ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</li><li>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</li></ul><h3><span id="在集群中执行命令">在集群中执行命令</span></h3><p>在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p><ul><li>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</li><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。</li></ul><p>图展示了这两种情况的判断流程。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607667862191.png" alt></p><h3><span id="重新分片">重新分片</span></h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。<br>重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。</p><p>redis-trib对集群的单个槽slot进行重新分片的步骤如下(如果重新分片涉及多个槽，那么redis-trib将对每个给定的槽分别执行上面给出的步骤)：</p><ul><li>1）redis-trib对目标节点发送CLUSTER SETSLOT<slot>IMPORTING&lt;source_id&gt;命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</slot></li><li>2）redis-trib对源节点发送CLUSTER SETSLOT<slot>MIGRATING&lt;target_id&gt;命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</slot></li><li>3）redis-trib向源节点发送CLUSTER GETKEYSINSLOT<slot><count>命令，获得最多count个属于槽slot的键值对的键名（key name）。</count></slot></li><li>4）对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE&lt;target_ip&gt;&lt;target_port&gt;&lt;key_name&gt;0<timeout>命令，将被选中的键原子地从源节点迁移至目标节点。</timeout></li><li>5）重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。每次迁移键的过程如图所示。</li><li>6）redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT<slot>NODE&lt;target_id&gt;命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点</slot></li></ul><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668216367.png" alt></p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668240201.png" alt></p><h3><span id="复制与故障转移">复制与故障转移</span></h3><p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><p>举个例子，对于包含7000、7001、7002、7003四个主节点的集群来说，我们可以将7004、7005两个节点添加到集群里面，并将这两个节点设定为节点7000的从节点</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668429906.png" alt></p><p>表记录了集群各个节点的当前状态，以及它们正在做的工作。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668451733.png" alt></p><p>如果这时，节点7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点——节点7004和节点7005中选出一个节点作为新的主节点，这个新的主节点将接管原来节点7000负责处理的槽，并继续处理客户端发送的命令请求。</p><p>例如，如果节点7004被选中为新的主节点，那么节点7004将接管原来由节点7000负责处理的槽0至槽5000，节点7005也会从原来的复制节点7000，改为复制节点7004，如图17-33所示（图中用虚线包围的节点为已下线节点）。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668567214.png" alt></p><p>如果在故障转移完成之后，下线的节点7000重新上线，那么它将成为节点7004的从节点，如图所示。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668597356.png" alt></p><h3><span id="故障转移">故障转移</span></h3><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果节点7001向节点7000发送了一条PING消息，但是节点7000没有在规定的时间内，向节点7001返回一条PONG消息，么节点7001就会让节点7000进入了疑似下线状态，状态有三种<br><strong>在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。</strong></p><p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</p><p>举个例子，对于图17-38所示的下线报告来说，主节点7002和主节点7003都认为主节点7000进入了下线状态，并且主节点7001也认为主节点7000进入了疑似下线状态（代表主节点7000的结构打开了REDIS_NODE_PFAIL标识），综合起来，在集群四个负责处理槽的主节点里面，有三个都将主节点7000标记为下线，数量已经超过了半数，所以主节点7001会将主节点7000标记为已下线，并向集群广播一条关于主节点7000的FAIL消息，如图17-39所示。</p><p><img src="/article/distributed-redis-advanced/distributed-redis-advanced-1607668873309.png" alt></p><h3><span id="总结">总结</span></h3><p>故障转移，当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p><ul><li>1）复制下线主节点的所有从节点里面，会有一个从节点被选中。</li><li>2）被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>3）新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li><li>4）新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>5）新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ul><p>选举新的主节点新的主节点是通过选举产生的。以下是集群选举新的主节点的方法：</p><ul><li>1）集群的配置纪元是一个自增计数器，它的初始值为0。</li><li>2）当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li><li>3）对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>4）当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li><li>5）如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li><li>6）每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li><li>7）如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li><li>8）因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>9）如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li></ul><h3><span id="集群搭建">集群搭建</span></h3><ol><li>目录结构</li></ol><table><thead><tr><th>端口</th><th>主从</th><th>复制节点</th></tr></thead><tbody><tr><td>7000</td><td>主</td><td>7003</td></tr><tr><td>7001</td><td>主</td><td>7004</td></tr><tr><td>7002</td><td>主</td><td>7005</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 7000</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7001</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7002</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7003</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7004</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7005</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── redis_7000.pid</span><br><span class="line">├── redis_7001.pid</span><br><span class="line">├── redis_7002.pid</span><br><span class="line">├── redis_7003.pid</span><br><span class="line">├── redis_7004.pid</span><br><span class="line">├── redis_7005.pid</span><br><span class="line">├── redislog_7000.log</span><br><span class="line">├── redislog_7001.log</span><br><span class="line">├── redislog_7002.log</span><br><span class="line">├── redislog_7003.log</span><br><span class="line">├── redislog_7004.log</span><br><span class="line">└── redislog_7005.log</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 端口号 其他配置参见其他章节这里只保留集群模式</span><br><span class="line"># 开启集群模式</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置，配置文件首次启动自动生成</span><br><span class="line"># 这里只需指定文件名即可，集群启动成功后会自动在data目录下创建</span><br><span class="line">cluster-config-file &quot;nodes-6379.conf&quot;</span><br><span class="line"># 请求超时，设置10秒</span><br><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]# redis-server ./700&#123;0,1,2,3,4,5&#125;/redis.conf</span><br></pre></td></tr></table></figure><p>登录7000 查看集群信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; CLIENT info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:1</span><br><span class="line">cluster_size:0</span><br><span class="line">cluster_current_epoch:0</span><br><span class="line">cluster_my_epoch:0</span><br><span class="line">cluster_stats_messages_sent:0</span><br><span class="line">cluster_stats_messages_received:0</span><br></pre></td></tr></table></figure><ol start="3"><li>组成集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@CentOS7 cluster]<span class="comment"># redis-cli -p 7001</span></span><br><span class="line">127.0.0.1:7001&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; CLUSTER MEET 127.0.0.1 700</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7002</span></span><br><span class="line">127.0.0.1:7002&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7003</span></span><br><span class="line">127.0.0.1:7003&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7003&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7004</span></span><br><span class="line">127.0.0.1:7004&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7004&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7005</span></span><br><span class="line">127.0.0.1:7005&gt; CLUSTER MEET 127.0.0.1 7000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7005&gt;</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:0</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:45</span><br><span class="line">cluster_stats_messages_pong_sent:50</span><br><span class="line">cluster_stats_messages_meet_sent:1</span><br><span class="line">cluster_stats_messages_sent:96</span><br><span class="line">cluster_stats_messages_ping_received:44</span><br><span class="line">cluster_stats_messages_pong_received:46</span><br><span class="line">cluster_stats_messages_meet_received:6</span><br><span class="line">cluster_stats_messages_received:96</span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) CLUSTERDOWN Hash slot not served</span><br><span class="line">127.0.0.1:7000&gt;</span><br></pre></td></tr></table></figure><p>查看节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; CLUSTER nodes</span><br><span class="line">14bd4c6a0d82425637d10ac11238426bbf7d5e9f 127.0.0.1:7000@17000 myself,master - 0 1607679088000 1 connected</span><br><span class="line">8e1da11c7da154ed2515c6a9b683ebb58d23618d 127.0.0.1:7002@17002 master - 0 1607679093630 2 connected</span><br><span class="line">f52ae1c178ef712d7c5eac2f4112fba924013dc6 127.0.0.1:7003@17003 master - 0 1607679094631 3 connected</span><br><span class="line">7c33f7bb44fb9d93a74cc3264604d67ff6866df6 127.0.0.1:7004@17004 master - 0 1607679093000 4 connected</span><br><span class="line">2e25473d824a0598cd56b4ce846f099593bfd867 127.0.0.1:7005@17005 master - 0 1607679094000 5 connected</span><br><span class="line">fca142b994747c432858c131c97d6e36f597d0af 127.0.0.1:7001@17001 master - 0 1607679092000 0 connected</span><br></pre></td></tr></table></figure><ol start="4"><li>设立主从</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER REPLICATE &lt;node_id&gt; 分别在 7003 7004 7005 执行</span><br><span class="line">得到如下配置</span><br><span class="line"></span><br><span class="line">8e1da11c7da154ed2515c6a9b683ebb58d23618d 127.0.0.1:7002@17002 master - 0 1607680045949 2 connected</span><br><span class="line">14bd4c6a0d82425637d10ac11238426bbf7d5e9f 127.0.0.1:7000@17000 master - 0 1607680045000 1 connected</span><br><span class="line">fca142b994747c432858c131c97d6e36f597d0af 127.0.0.1:7001@17001 master - 0 1607680048957 0 connected</span><br><span class="line">2e25473d824a0598cd56b4ce846f099593bfd867 127.0.0.1:7005@17005 slave 8e1da11c7da154ed2515c6a9b683ebb58d23618d 0 1607680047000 5 connected</span><br><span class="line">f52ae1c178ef712d7c5eac2f4112fba924013dc6 127.0.0.1:7003@17003 slave 14bd4c6a0d82425637d10ac11238426bbf7d5e9f 0 1607680048000 3 connected</span><br><span class="line">7c33f7bb44fb9d93a74cc3264604d67ff6866df6 127.0.0.1:7004@17004 myself,slave fca142b994747c432858c131c97d6e36f597d0af 0 1607680043000 4 connected</span><br></pre></td></tr></table></figure><ol start="5"><li>配置槽位</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7000 cluster addslots &#123;0..5460&#125;</span></span><br><span class="line">OK</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7001 cluster addslots &#123;5461..10000&#125;</span></span><br><span class="line">OK</span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -p 7002 cluster addslots &#123;10001..16383&#125;</span></span><br><span class="line"><span class="comment"># 查看槽位</span></span><br><span class="line">127.0.0.1:7000&gt; CLUSTER info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:1481</span><br><span class="line">cluster_stats_messages_pong_sent:1455</span><br><span class="line">cluster_stats_messages_meet_sent:1</span><br><span class="line">cluster_stats_messages_sent:2937</span><br><span class="line">cluster_stats_messages_ping_received:1449</span><br><span class="line">cluster_stats_messages_pong_received:1482</span><br><span class="line">cluster_stats_messages_meet_received:6</span><br><span class="line">cluster_stats_messages_received:2937</span><br></pre></td></tr></table></figure><ol start="6"><li>查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单击模式 登录</span></span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli  -p 7000 </span></span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001  <span class="comment"># 返回错误</span></span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> 1</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> 1 1 </span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001 </span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">(error) MOVED 9842 127.0.0.1:7001</span><br><span class="line">127.0.0.1:7000&gt;</span><br><span class="line"><span class="comment"># 集群模式登录</span></span><br><span class="line">[root@CentOS7 cluster]<span class="comment"># redis-cli -c -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt; get 1</span><br><span class="line">-&gt; Redirected to slot [9842] located at 127.0.0.1:7001</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/f0e042b95249" target="_blank" rel="noopener">010.Redis 主从架构搭建及原理详解</a></li><li><a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS服务</title>
      <link href="/article/Net-wrok-DNS-1/"/>
      <url>/article/Net-wrok-DNS-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><h2><span id="什么是dns">什么是DNS</span></h2><p>Domain Name System （缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。他的的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。<br>举例来说，<a href="http://xn--math-uo6ft1wu7gzrdk29bg34eoff3s9a.stackexchange.com" target="_blank" rel="noopener">如果你要访问域名math.stackexchange.com</a>，首先要通过DNS查出它的IP地址是151.101.129.69， DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符</p><h3><span id="dns-的运行过程">DNS 的运行过程</span></h3><p>当一台主机想要通过域名访问某个服务的内容时，需要先通过当前域名获取对应的 IP 地址。这时就需要通过一个 DNS 解析器负责域名的解析，下面的图片展示了 DNS 查询的执行过程：</p><p><img src="/article/Net-wrok-DNS-1/Net-wrok-DNS-1-1607870989235.png" alt></p><ul><li>本地的 DNS 客户端向 DNS 解析器发出解析 <a href="http://draveness.me" target="_blank" rel="noopener">draveness.me</a> 域名的请求；</li><li>DNS 解析器首先会向就近的根 DNS 服务器 . 请求顶级域名 DNS 服务的地址；</li><li>拿到顶级域名 DNS 服务 me. 的地址之后会向顶级域名服务请求负责 <a href="http://dravenss.me" target="_blank" rel="noopener">dravenss.me</a>. 域名解析的命名服务；</li><li>得到授权的 DNS 命名服务时，就可以根据请求的具体的主机记录直接向该服务请求域名对应的 IP 地址；</li></ul><p>这里涉及到几个名词，一个是DNS服务器，一个是顶级域名，一个是根DNS服务器。<br>想要了解这几个概念，先要了解一下什么事ICANN.</p><h3><span id="icann">ICANN</span></h3><p>全世界域名的最高管理机构，是一个叫做 **ICANN （Internet Corporation for Assigned Names and Numbers）**的组织。它的总部在美国加州。</p><p>它原来是美国商务部下面的一个非盈利机构，所以有人说，美国政府控制了全世界的域名，这种说法是有根据的。2016年，美国政府宣布，<strong>ICANN</strong> 不再隶属于商务部，成为一个自我管理的独立机构。但是可想而知，美国政府依然对它有绝对影响。</p><p>ICANN 负责管理全世界域名系统的运作。它的一项主要工作，就是规定顶级域名（t<strong>op level domain，简写为 TLD</strong>）。</p><h3><span id="dns-的命名语法">DNS 的命名语法</span></h3><p><img src="/article/Net-wrok-DNS-1/DNS%E5%91%BD%E5%90%8D%E8%AF%AD%E6%B3%95.png" alt></p><h3><span id="域名系统">域名系统</span></h3><p>域名空间用于指定组织名称的域的层次结构，不同域间以英文句点隔开，如<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 中的 com、baidu、<a href="http://baidu.com" target="_blank" rel="noopener">baidu.com</a> 都是域。</p><p><img src="/article/Net-wrok-DNS-1/Net-wrok-DNS-1-1607871331360.png" alt></p><h4><span id="根域名">根域名</span></h4><p>由于 <strong>ICANN</strong> 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名**（root domain）**。在有些场合，<a href="http://www.example.xn--comwww-kw2jx10ikv6e.example.com" target="_blank" rel="noopener">www.example.com被写成www.example.com</a>.，即最后还会多出一个点。这个点就是根域名。</p><p>理论上，所有域名查询都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p><p>比如，<a href="http://xn--www-st5fu45oo2cory.example.com" target="_blank" rel="noopener">我要访问www.example.com</a>，就必须先询问 ICANN 的根域名列表，它会告诉我.com域名由 <strong>Verisign</strong> 托管，我必须去找 <strong>Verisign</strong>，它会告诉我example.com服务器在哪里。</p><p>再比如，我要访问abc.xyz，也必须先去询问根域名列表，它会告诉我.xyz域名由 CentralNic 公司托管。根域名列表还记载，.google由谷歌公司托管，.apple由苹果公司托管等等。</p><p>由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p><h4><span id="顶级域名tld">顶级域名（TLD）</span></h4><p>所谓顶级域名（TLD），就是最高层级的域名。简单说，就是网址的最后一个部分。比如，<a href="http://xn--www-cs6eq54p.example.xn--com-t33er8owvhvrttz4awkpy14d.com" target="_blank" rel="noopener">网址www.example.com的顶级域名就是.com</a>。</p><p>ICANN 就负责规定，哪些字符串可以当作顶级域名。截至2015年7月，顶级域名共有1058个。</p><p>它们可以分成两类。一类是一般性顶级域名（gTLD），<a href="http://xn--bvs393b.com" target="_blank" rel="noopener">比如.com</a>、.net、.edu、.org、.xxx等等，共有700多个。另一类是国别顶级域名（ccTLD），代表不同的国家和地区，<a href="http://xn--bvs393b.cn" target="_blank" rel="noopener">比如.cn</a>（中国）、.io（英属印度洋领地）、.cc（ 科科斯群岛）、.tv（图瓦卢）等，共有300多个。</p><p>ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。</p><p>ICANN 的政策是，每个顶级域名都找一个托管商，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，.cn域名的托管商就是中国互联网络信息中心（CNNIC），它决定了.cn域名的各种政策。</p><p>目前，世界最大的顶级域名托管商是美国的 Verisign 公司。</p><h2><span id="dns-的查找过程">DNS 的查找过程</span></h2><p>DNS解析流程分为递归查询和迭代查询，递归查询是以本地名称服务器为中心查询， 递归查询是默认方式，迭代查询是以DNS客户端，也就是客户机器为中心查询。<strong>其实DNS客户端和本地名称服务器是递归，而本地名称服务器和其他名称服务器之间是迭代</strong></p><h3><span id="迭代查询的区别">迭代查询的区别</span></h3><p><img src="/article/Net-wrok-DNS-1/Net-wrok-DNS-1-1607924406934.png" alt></p><h3><span id="递归查询">递归查询</span></h3><p><img src="/article/Net-wrok-DNS-1/Net-wrok-DNS-1-1607924398443.png" alt></p><p>在这个查询过程中，一直是以本地名称服务器（Local DNS）为中心的，DNS客户端只是发出原始的域名查询请求报文，然后就一直处于等待状态的，直到本地名称服务器发来了最终的查询结果。此时的本地名称服务器就相当于<strong>中介代理</strong>的作用。如果考虑了本地名称服务器的缓存技术（也就是在DNS服务器上对一定数量的以前查询记录保存一定时间，这样后面查询同样的域名信息时就可直接从缓存中调出来，以加速查询效率）的话，则递归解析的基本流程如下：</p><ul><li><p>（1）客户端向本机配置的本地名称服务器（在此仅以首选DNS服务器为例进行介绍，所配置其它备用DNS服务器的解析流程完全一样）发出DNS域名查询请求。</p></li><li><p>（2）本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器就直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则本地名称服务器再以DNS客户端的角色发送与前面一样的DNS域名查询请求发给根名称服务器。</p></li><li><p>（3）根名称服务器收到DNS请求后，把所查询得到的所请求的DNS域名中顶级域名所对应的顶级名称服务器地址返回给本地名称服务器。</p></li><li><p>（4）本地名称服务器根据根名称服务器所返回的顶级名称服务器地址，向对应的顶级名称服务器发送与前面一样的DNS域名查询请求。</p></li><li><p>（5）对应的顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有所请求的DNS域名的记录项，则相接把对应的记录项返回给本地名称服务器，然后再由本地名称服务器返回给DNS客户端，否则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的二级名称服务器地址。</p></li></ul><p><strong>然后本地名称服务器继续按照前面介绍的方法一次次地向三级、四级名称服务器查询</strong>，直到最终的对应域名所在区域的权威名称服务器返回到最终的记录给本地名称服务器。然后再由本地名称服务器返回给DNS客户，同时本地名称服务器会缓存本次查询得到的记录项。</p><h3><span id="dns-主从服务器">DNS 主从服务器</span></h3><p>据服务器与所提供域名解析记录的关系，将DNS服务器分为不同的角色：</p><ul><li><p>1）缓存域名服务器，也称为 唯高速缓存服务器，通过向其他域名服务器查询获得域名-&gt;IP地址记录，将域名查询结果缓存到本地，提高重复查询时的速度</p></li><li><p>2）主域名服务器，特定DNS区域的官方服务器，具有唯一性，负责维护该区域内所有域名-&gt;IP地址的映射记录</p></li><li><p>3）从域名服务器（通俗一点就是用于备份DNS服务器的）也称为 辅助域名服务器，其维护的 域名-&gt;IP地址记录 来源于主域名服务器</p></li></ul><h3><span id="dns-权威解释和非权威解释">DNS 权威解释和非权威解释</span></h3><p>DNS服务器在自己的区域文件里找到了客户端需要查询的记录，就会返回一个权威性应答。</p><blockquote><p>例如客户端要查找srv1.contoso.com主机的IP地址。在contoso.com的DC（也就是DNS服务器）上查找该主机的“A记录”，我们找到了。就把记录内容通过DNS应答的方式发还给客户端，这就是一个权威性应答。――当然实际的查询方式比较复杂远没有我说的这么简单。</p></blockquote><ul><li>如果DNS服务器最近被查找过该主机（可能其他客户端也查找过）记录，就会在缓存里找到记录应答客户端――当然上一种方法快。</li><li>如果该DC服务器找不到srv1.contoso.com主机的A记录，就会返回（RecordNotFound）应答――同样也是权威性应答</li><li>如果接到DNS查询请求的服务器不是contoso.com的DC（Dns服务器），那么有3种方法处理该请求：</li><li>首先，查询其他DNS服务器直到找到，然后此服务器将找到的内容返回给客户端――非权威性应答</li><li>其次，推荐客户端到上一级DNS服务器找。―――非权威性应答。</li><li>最后，如果原来被别人访问过，本地有该缓存，那么用缓存里的数据回答―――非权威性应答。</li></ul><h3><span id="dns的记录类型">DNS的记录类型</span></h3><p>DNS server 内的每一个域名都有自己的域文件(zone file)，zone file 是由多个记录组成的，每一个记录就被称为资源记录(Resource Record，简称RR)。</p><p>当在设定 DNS 域名解析、反向解析及其他的管理目的时，往往需要使用不同类型的RR，也就是我们常说的记录类型。</p><p>RR 记录类型格式</p><table><thead><tr><th>owner</th><th>TTL</th><th>CLASS</th><th>TYPE</th><th>RDATA</th></tr></thead><tbody></tbody></table><ul><li><p>owner<br>指示拥有资源记录的DNS域名</p></li><li><p>TTL<br>对大多数资源记录，该字段为可选项。指明其它DNS服务器在期满放弃该记录信息之前对其缓存多长时间。TTL值为零的资源记录不会被缓存</p></li><li><p>CLASS</p><ul><li>IN（Internet类）</li><li>CS（CSNET类）、CH（CHAOS类）、HS（Hesiod）很少使用</li></ul></li><li><p>TYPE（这里只列出以下常见）：</p><ul><li>A：主机地址</li><li>AAAA：IPv6主机地址</li><li>NS：权威名称服务器</li><li>CNAME：别名的正则名称</li><li>SOA：标记权威区域的开始</li><li>MX：邮件交换</li></ul></li><li><p>RDATA<br>用于描述资源的信息且长度可变的必要字段，随CLASS和TYPE的变化而变化</p></li></ul><h3><span id="记录类型举例">记录类型举例</span></h3><ul><li>SOA 记录</li></ul><p><strong>SOA记录表明了DNS服务器之间的关系</strong>。SOA记录表明了谁是这个区域的所有者。就是谁对这个区域有修改权利。常见的DNS服务器只能创建一个标准区域，然后可以创建很多个辅助区域。标准区域是可以读写修改的。</p><p>而辅助区域只能通过标准区域复制来完成，不能在辅助区域中进行修改。而创建标准区域的DNS就会有SOA记录，或者准确说SOA记录中的主机地址一定是这个标准区域的服务器IP地址。</p><p><strong>NS记录NS记录和SOA记录是任何一个DNS区域都不可或缺的两条记录，NS记录也叫名称服务器记录，用于说明这个区域有哪些DNS服务器负责解析，SOA记录说明负责解析的DNS服务器中哪一个是主服务器。因此，任何一个DNS区域都不可能缺少这两条记录。NS记录，说明了在这个区域里，有多少个服务器来承担解析的任务</strong></p><p><strong>OA记录 NS记录说明了有多台服务器在进行解析，但哪一个才是主服务器呢，NS并没有说明，这个就要看SOA记录了，SOA名叫起始授权机构记录，SOA记录说明了在众多NS记录里那一台才是主要的服务器！</strong></p><p>SOA 格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">domain.com.  IN SOA ns1.domain.com. admin.domain.com. (</span><br><span class="line">                                            12083   ; serial number</span><br><span class="line">                                            3h      ; refresh interval</span><br><span class="line">                                            30m     ; retry interval</span><br><span class="line">                                            3w      ; expiry period</span><br><span class="line">                                            1h      ; negative TTL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p><strong><a href="http://domain.com" target="_blank" rel="noopener">domain.com</a>.</strong>：这是区域的根。这表明该区域文件用于 <a href="http://domain.com" target="_blank" rel="noopener">http://domain.com</a> 域名。通常，你会看到这个用 @ 代替，它只是一个占位符，</p></li><li><p><strong>IN SOA</strong>：”IN” 部分表示互联网（它会出现在许多记录中）。 SOA 是表示这是开始权限记录。</p></li><li><p><strong><a href="http://ns1.domain.com" target="_blank" rel="noopener">ns1.domain.com</a>.</strong>：这定义了该域的主名称服务器。名称服务器可以是主服务器或从服务器，如果配置了动态 DNS，就像这里，则一个服务器需要是 “主服务器”。如果你未配置动态 DNS，那么这只是你其中一个主名称服务器。</p></li><li><p><strong><a href="http://admin.domain.com" target="_blank" rel="noopener">admin.domain.com</a>.</strong>：这是这个区域文件管理员的邮箱地址。邮箱地址的 @ 这里用一个 . 代替。如果你的名字中也有 . 它会用 \ 代替。（比如 <a href="mailto:your.name@domain.com" target="_blank" rel="noopener">your.name@domain.com</a> 变成 your\<a href="http://name.domain.com" target="_blank" rel="noopener">http://name.domain.com</a>）</p></li><li><p>附加说明</p><ul><li>12083：这是区域文件的序列号。每次编辑区域文件时，必须增加此序列号以使区域文件能够正确传播。从服务器将检查主服务器的区域序列号是否大于它们在系统上的序列号。如果是，它请求新的区域文件，如果不是，它继续服务原始文件。</li><li>3h：这是区域的刷新间隔。这是从服务器向主服务器轮询检查区域文件是否变更之间等待的时间量。</li><li>30m：这是此区域的重试间隔。如果从机在刷新周期结束时无法连接到主机，则它将等待此时间并重试轮询主机。</li><li>3w：这是到期时间。如果从服务器在此时间内无法与主服务器联系，则它不再作为此区域的权威来源的返回响应。</li><li>1h：这是名称服务器在此文件中找不到所请求的名称时缓存找不到结果的时间量。</li></ul></li></ul><ul><li>NS 记录<br>NS记录实际上也是在DNS服务器之间，表明谁对某个区域有解释权，即权威DNS。<br>语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner  TTL  CLASS  NS name_server_domain_name</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">www.baidu.com.  IN  NS  baidu.com.</span><br></pre></td></tr></table></figure><ul><li>CNAME记录：<br>CNAME 记录为您的服务器（由A或AAAA记录定义的名称）定义规范名称的别名。比较多的是用在CDN加速上</li></ul><p>举个CDN的栗子 ：假如你是DD公司老板，你公司中的一台IP为1.1.1.1的服务器，注册了域名为http://www.dd.com，要对外提供客户访问。随着公司越做越大，访问量也越来越多，服务器顶不住了，你去找CDN提供商购买CDN加速服务，这个时候他们要求你的域名做个CNAME指向,他们给你的一个域名叫http://www.xdd.com，当用户访问http://www.dd.com的时候，本地DNS会获得CDN提供的CNAME域名：<a href="http://www.xdd.com" target="_blank" rel="noopener">http://www.xdd.com</a>，然后再次向DNS调度系统发出请求，通过DNS调度系统的智能分析，把这个http://www.xdd.com指向一个（离用户地理位置最近的）CDN提供商的服务器IP，让用户就近取到想要的资源（如访问网站），大大降低了延迟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">owner  TTL  CLASS  NS name_server_domain_name</span><br><span class="line">例如：</span><br><span class="line">www.baidu.com.413INCNAMEwww.a.shifen.com.</span><br></pre></td></tr></table></figure><ul><li>A记录：<br>通俗来说A记录就是服务器的IP，域名绑定A记录就是告诉DNS，当输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner  TTL  CLASS  NS name_server_domain_name</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">www.a.shifen.com.98INA220.181.38.149</span><br></pre></td></tr></table></figure><ul><li>其他的略</li></ul><h3><span id="dns-相关命令">DNS 相关命令</span></h3><ul><li>dig 命令<br>虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。<br>工具软件dig可以显示整个查询过程。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig www.baidu.com</span><br><span class="line"><span class="comment">// dig 相关信息</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.10</span><span class="number">.6</span> &lt;&lt;&gt;&gt; www.baidu.com  <span class="comment">//dig程序的版本号，和要查询的域名</span></span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, <span class="attr">status</span>: NOERROR, <span class="attr">id</span>: <span class="number">10663</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, <span class="attr">ANSWER</span>: <span class="number">3</span>, <span class="attr">AUTHORITY</span>: <span class="number">0</span>, <span class="attr">ADDITIONAL</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * opcode 操作码，QUERY，代表是查询操作</span></span><br><span class="line"><span class="comment">* status 状态，NOERROR，代表没有错误</span></span><br><span class="line"><span class="comment">* id 编号，54864，16bit数字，在dns协议中，通过编号匹配返回和查询。</span></span><br><span class="line"><span class="comment">* flags 标志，如果出现就表示有标志，如果不出现就未设置标志：</span></span><br><span class="line"><span class="comment">  qr query，查询标志，代表是查询操作</span></span><br><span class="line"><span class="comment">  rd recursion desired， 代表希望进行递归(recursive)查询操作</span></span><br><span class="line"><span class="comment">  ra recursive available 在返回中设置，代表查询的服务器支持递归(recursive)查询操作。</span></span><br><span class="line"><span class="comment">  aa Authoritative Answer 权威回复，如果查询结果由管理域名的域名服务器而不是缓存服务器提供的，则称为权威回复。</span></span><br><span class="line"><span class="comment">* QUERY 查询数，1代表1个查询，对应下面的QUESTION SECTION中的记录数</span></span><br><span class="line"><span class="comment">* ANSWER 结果数，4代表有4项结果，对应下面ANSWER SECTION中的记录数</span></span><br><span class="line"><span class="comment">* AUTHORITY 权威域名服务器记录数，0代表该域名有0个权威域名服务器，可供域名解析用。</span></span><br><span class="line"><span class="comment">* ADDITIONAL 格外记录数，0代表有0项格外记录。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, <span class="attr">flags</span>:; udp: <span class="number">512</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.INA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是返回的记录列表</span></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line"><span class="comment">// 域名             ttl     记录类型    类型值</span></span><br><span class="line">www.baidu.com.<span class="number">362</span>INCNAMEwww.a.shifen.com.</span><br><span class="line">www.a.shifen.com.<span class="number">43</span>INA<span class="number">220.181</span><span class="number">.38</span><span class="number">.150</span></span><br><span class="line">www.a.shifen.com.<span class="number">43</span>INA<span class="number">220.181</span><span class="number">.38</span><span class="number">.149</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一下是DNS 服务器返回的结果</span></span><br><span class="line">;; Query time: <span class="number">34</span> msec</span><br><span class="line">;; SERVER: 114.114.114.114#53(114.114.114.114)</span><br><span class="line">;; WHEN: Thu Dec <span class="number">17</span> <span class="number">19</span>:<span class="number">47</span>:<span class="number">02</span> CST <span class="number">2020</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">101</span></span><br></pre></td></tr></table></figure><ul><li>nslookup</li></ul><p>用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题<br>nslookup domain [dns-server]<br>//如果没有指定dns服务器，就采用系统默认的dns服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt = type domain [dns-server]</span><br><span class="line">type:</span><br><span class="line">    A --&gt;地址记录</span><br><span class="line">    AAAA   --&gt;地址记录</span><br><span class="line">    AFSDB Andrew    --&gt;文件系统数据库服务器记录</span><br><span class="line">    ATMA --&gt;ATM地址记录</span><br><span class="line">    CNAME   --&gt;别名记录</span><br><span class="line">    HINHO  --&gt;硬件配置记录，包括CPU、操作系统信息 </span><br><span class="line">    ISDN   --&gt;域名对应的ISDN号码</span><br><span class="line">    MB   --&gt;存放指定邮箱的服务器</span><br><span class="line">    MG    --&gt;邮件组记录</span><br><span class="line">    MINFO   --&gt;邮件组和邮箱的信息记录</span><br><span class="line">    MR   --&gt;改名的邮箱记录</span><br><span class="line">    MX   --&gt;邮件服务器记录</span><br><span class="line">    NS  --&gt; 名字服务器记录</span><br><span class="line">    PTR    -&gt;反向记录</span><br><span class="line">    RP    --&gt;负责人记录</span><br><span class="line">    RT  --&gt;路由穿透记录</span><br><span class="line">    SRV    --&gt;TCP服务器信息记录</span><br><span class="line">    TXT   --&gt;域名对应的文本信息</span><br><span class="line">    X25  --&gt;域名对应的X<span class="number">.25</span>地址记录</span><br></pre></td></tr></table></figure><p>看一下返回结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Server:<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">Address:114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:       <span class="comment">//是否是权威回答</span></span><br><span class="line">Name:baidu.com               <span class="comment">// 域名</span></span><br><span class="line">Address: <span class="number">220.181</span><span class="number">.38</span><span class="number">.148</span>         <span class="comment">//域名ip地址</span></span><br><span class="line">Name:baidu.com               </span><br><span class="line">Address: <span class="number">39.156</span><span class="number">.69</span><span class="number">.79</span></span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://draveness.me/dns-coredns/" target="_blank" rel="noopener">详解 DNS 与 CoreDNS 的实现原理</a></li><li><a href="https://www.jianshu.com/p/6b502d0f2ede" target="_blank" rel="noopener">DNS解析原理:递归 VS 迭代</a></li><li><a href="https://blog.csdn.net/mooncarp/article/details/51556059" target="_blank" rel="noopener">使用nslookup定位权威域名服务器得到权威应答</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作系统原理-文件系统(2)</title>
      <link href="/article/openerating-learning-vfs-2/"/>
      <url>/article/openerating-learning-vfs-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>接上篇 <a href="https://icefrozen.github.io/article/openerating-learning-vfs-1/" target="_blank" rel="noopener">Linux 操作系统原理-文件系统(1)</a> 本节来讨论一下，文件类型。</p><h2><span id="文件类型">文件类型</span></h2><h1><span id="普通文件类型">普通文件类型</span></h1><p>理解了文件系统的结构之后，我们来看一下文件的类型。</p><p>Linux以文件的形式对计算机中的数据和硬件资源进行管理，也就是彻底的一切皆文件，反映在Linux的文件类型上就是：**普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）**等等。而这些种类繁多的文件被Linux使用目录树进行管理， 所谓的目录树就是以根目录（/）为主，向下呈现分支状的一种文件结构。</p><h2><span id="普通文件">普通文件</span></h2><p>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。我们知道，文件的属性，权限，大小，占用那些数据块是存在inode当中。所以，这里注意一旦，inode 当中并没有存放文件名，至于为什么，我们接下来看目录文件。</p><h2><span id="目录文件">目录文件</span></h2><p>本质上来书，目录页是文件，目录文件inode除了存放一些目录的权限，等属性之外，目录文件的内容则是该目录文件下文件名和其inode编号的一个映射关系。最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p><p>文件目录块：</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601454295870.png" alt></p><p>通常，第一项是「.」，表示当前目录，第二项是「…」，表示上一级目录，接下来就是一项一项的文件名和 inode。<br>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p><p>于是，保存目录的格式改成哈希表，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p><p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p><p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p><p>文件inode</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601454987763.png" alt></p><h2><span id="文件操作">文件操作</span></h2><h3><span id="文件链接">文件链接</span></h3><ul><li>硬链接</li></ul><p>一般情况下，文件名和inode号码是&quot;一一对应&quot;关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。<br>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为&quot;硬链接&quot;（hard link）。</p><p>其实原理很简单，我们会在某个目录下创建一个文件名，这个文件名和硬链接的文件inode 相同，并且会在这个inode的记录中增加链接数量。<br>我们看到的就是两个链接到同一个inode 的文件其实是一个文件和inode的映射。</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601459333721.png" alt></p><p>ln命令可以创建硬链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@CentOS7 lnDemo]<span class="comment"># ln source source_ln</span></span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># ls -ali</span></span><br><span class="line">总用量 8</span><br><span class="line">33575032 drwxr-xr-x. 2 root root  37 9月  30 17:35 .</span><br><span class="line">33574977 dr-xr-x---. 4 root root 161 9月  30 17:34 ..</span><br><span class="line">33575033 -rw-r--r--. 2 root root   7 9月  30 17:31 <span class="built_in">source</span></span><br><span class="line">33575033 -rw-r--r--. 2 root root   7 9月  30 17:31 source_ln</span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># stat source</span></span><br><span class="line">  文件：<span class="string">"source"</span></span><br><span class="line">  大小：7         块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768dInode：33575033    硬链接：2</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">环境：unconfined_u:object_r:admin_home_t:s0</span><br><span class="line">最近访问：2020-09-30 17:34:54.975711266 +0800</span><br><span class="line">最近更改：2020-09-30 17:31:49.124074625 +0800</span><br><span class="line">最近改动：2020-09-30 17:35:05.665345071 +0800</span><br><span class="line">创建时间：-</span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># stat source_ln</span></span><br><span class="line">  文件：<span class="string">"source_ln"</span></span><br><span class="line">  大小：7         块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768dInode：33575033    硬链接：2</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">环境：unconfined_u:object_r:admin_home_t:s0</span><br><span class="line">最近访问：2020-09-30 17:34:54.975711266 +0800</span><br><span class="line">最近更改：2020-09-30 17:31:49.124074625 +0800</span><br><span class="line">最近改动：2020-09-30 17:35:05.665345071 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure><p>根据我们上面的研究，我们发现，硬链接有一下几个问题：</p><ul><li>目录不允许硬链接<br>如果目录允许硬链接，那么我们完全可以将两个目录链接起来，那么操作系统则在找文件的时候，就会在两个目录跳来跳去，形成死循环。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@CentOS7 ~]<span class="comment"># ln lnDemo/ ./lnDemo2</span></span><br><span class="line">ln: <span class="string">"lnDemo/"</span>: 不允许将硬链接指向目录</span><br><span class="line">[root@CentOS7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>不同分区不允许硬链接<br>由于硬链接是在本分区指向相同的inode，那么就意味着inode的命名空间需要一直，但是不同的分区，inode的编号将会重置，所有不能通过inode映射同一个文件。</li></ul><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601459956238.png" alt></p><ul><li>软连接</li></ul><p>而软连接则不同，当创建软连接的时候，linux确实已经创建了一个inode 和起对应来的data block，只不过，在data block存放的是字符串，字符串的内容则是 链接文件的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 lnDemo]<span class="comment"># ln -s source source_sln</span></span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">source</span>  source_sln</span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># ls -alt</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root root  38 9月  30 18:08 .</span><br><span class="line">lrwxrwxrwx. 1 root root   6 9月  30 18:08 source_sln -&gt; <span class="built_in">source</span></span><br><span class="line">dr-xr-x---. 5 root root 172 9月  30 17:55 ..</span><br><span class="line">-rw-r--r--. 1 root root   7 9月  30 17:31 <span class="built_in">source</span></span><br><span class="line">[root@CentOS7 lnDemo]<span class="comment"># ls -ailt</span></span><br><span class="line">总用量 4</span><br><span class="line">33575032 drwxr-xr-x. 2 root root  38 9月  30 18:08 .</span><br><span class="line">33575034 lrwxrwxrwx. 1 root root   6 9月  30 18:08 source_sln -&gt; <span class="built_in">source</span></span><br><span class="line">33574977 dr-xr-x---. 5 root root 172 9月  30 17:55 ..</span><br><span class="line">33575033 -rw-r--r--. 1 root root   7 9月  30 17:31 <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>我们发现 source_sln 的文件类型为 l ，且inode和source 不同。大小很小，原因就是我们存放的是地址字符。</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601460660320.png" alt></p><h3><span id="文件新建复制">文件新建(复制)</span></h3><ul><li>(1).读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号；</li><li>(2).在inode table中完善该inode号所在行的记录；</li><li>(3).在目录的data block中添加一条该文件的相关记录；</li><li>(4).将数据填充到data block中。</li></ul><blockquote><p>注意，填充到data block中的时候会调用block分配器：一次分配4KB大小的block数量，当填充完4KB的data block后会继续调用block分配器分配4KB的block，然后循环直到填充完所有数据。也就是说，如果存储一个100M的文件需要调用block分配器100*1024/4=25600次。<br>另一方面，在block分配器分配block时，block分配器并不知道真正有多少block要分配，只是每次需要分配时就分配，在每存储一个data block前，就去bmap中标记一次该block已使用，它无法实现一次标记多个bmap位。这一点在ext4中进行了优化。</p></blockquote><ul><li>(5)填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针。</li></ul><h3><span id="文件删除">文件删除</span></h3><p>删除文件分为普通文件和目录文件，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。</p><p>对于删除普通文件：</p><ul><li>(1)找到文件的inode和data block(根据前一个小节中的方法寻找)；</li><li>(1.5) 如果inode的硬链接是数量不是1 ，则将硬链接的数量-1， 否则执行真正的删除。</li><li>(2)将inode table中该inode记录中的data block指针删除；</li><li>(3)在imap中将该文件的inode号标记为未使用；</li><li>(4)在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针（实际上不是真的删除，直接删除的话会在目录data block的数据结构中产生空洞，所以实际的操作是将待删除文件的inode号设置为特殊的值0，这样下次新建文件时就可以重用该行记录）；</li><li>(5)将bmap中data block对应的block号标记为未使用。</li></ul><p>对于删除目录文件：</p><ul><li>找到目录和目录下所有文件、子目录、子文件的inode和data block；</li><li>在imap中将这些inode号标记为未使用；将bmap中将这些文件占用的 block号标记为未使用；</li><li>在该目录的父目录的data block中将该目录名所在的记录行删除。需要注意的是，删除父目录data block中的记录是最后一步，如果该步骤提前，将报目录非空的错误，因为在该目录中还有文件占用。</li></ul><h3><span id="文件搜索">文件搜索</span></h3><p>当执行&quot;cat /var/log/messages&quot;命令在系统内部进行了什么样的步骤呢？</p><ul><li>找到根文件系统的块组描述符表所在的blocks，读取GDT(已在内存中)找到inode table的block号。</li></ul><blockquote><p>根文件系统是不需被引用的，因为在操作系统加载到内存当中的时候，跟文件系统已经存在，其中第inode编号也已经注册到了操作系统内核当中。根文件系统的GDT早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的GDT放进内存中。</p></blockquote><ul><li>在inode table的block中定位到根&quot;/“的inode，找出”/&quot;指向的data block。</li><li>在&quot;/&quot;的datablock中记录了var目录名和var的inode号，找到该inode记录，inode记录中存储了指向var的block指针，所以也就找到了var目录文件的data block。</li><li>通过var目录的inode号，可以寻找到var目录的inode记录，但是在寻找的过程中，还需要知道该inode记录所在的块组以及所在的inode table，所以需要读取GDT，同样，GDT已经缓存到了内存中。</li><li>在var的data block中记录了log目录名和其inode号，通过该inode号定位到该inode所在的块组及所在的inode table，并根据该inode记录找到log的data block。</li><li>在log目录文件的data block中记录了messages文件名和对应的inode号，通过该inode号定位到该inode所在的块组及所在的inode table，并根据该inode记录找到messages的data block。</li><li>最后读取messages对应的datablock。</li><li>当然，在每次定位到inode记录后，都会先将inode记录加载到内存中，然后查看权限，如果权限允许，将根据block指针找到对应的data block。</li></ul><h3><span id="文件移动">文件移动</span></h3><p>同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针，如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除</p><p>所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p><p>对于不同文件系统内的移动，相当于先复制再删除的动作。</p><h3><span id="文件挂载">文件挂载</span></h3><p>linux 系统下，文件是虚拟文件系统，当我们ls / 的时候，linux 会吧所有磁盘，所有分区下的且挂载在根目录下的所有目录列出来。<br>挂载文件系统到某个目录下，例如&quot;mount /dev/cdrom /mnt&quot;，挂载成功后/mnt目录中的文件全都暂时不可见了，且挂载后权限和所有者(如果指定允许普通用户挂载)等的都改变了，知道为什么吗？</p><p>下面就以通过&quot;mount /dev/cdrom /mnt&quot;为例，详细说明挂载过程中涉及的细节。</p><p>在将文件系统/dev/cdrom(此处暂且认为它是文件系统)挂载到挂载点/mnt之前，挂载点/mnt是根文件系统中的一个目录，&quot;/&quot;的data block中记录了/mnt的一些信息，其中包括inode号inode_n，而在inode table中，/mnt对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601464489659.png" alt></p><p>当文件系统/dev/cdrom挂载到/mnt上后，/mnt此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1601464507230.png" alt></p><ul><li>在根文件系统的inode table中，为/mnt重新分配一个inode记录m，该记录的block指针block_m指向文件系统/dev/cdrom中的data block。</li><li>/mnt分配了新的inode记录m，那么在&quot;/&quot;目录的data block中，也需要修改其inode指针为inode_m以指向m记录。</li><li>同时，原来inode table中的inode记录n就被标记为暂时不可用。</li></ul><p>block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。</p><blockquote><p>挂载完成后，将在/proc/self/{mounts,mountstats,mountinfo}这三个文件中写入挂载记录和相关的挂载信息，并会将/proc/self/mounts中的信息同步到/etc/mtab文件中，当然，如果挂载时加了-n参数，将不会同步到/etc/mtab。</p></blockquote><p>而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。由于卸载只是移除inode记录，所以使用挂载点和文件系统都可以实现卸载，因为它们是联系在一起的。</p><p>下面是分析或结论。</p><ul><li>(1).挂载点挂载时的inode记录是新分配的。</li></ul><p>挂载前挂载点/mnt的inode号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt</span></span><br><span class="line">100663447 drwxr-xr-x. 2 root root 6 Aug 12  2015 /mnt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line"><span class="comment"># 挂载后挂载点的inode号</span></span><br><span class="line">[root@server2 tmp]<span class="comment"># ll -id /mnt </span></span><br><span class="line">1856 dr-xr-xr-x    8 root root  2048 Dec 10  2015 mnt</span><br><span class="line">由此可以验证，inode号确实是重新分配的。</span><br></pre></td></tr></table></figure><ul><li>(2).挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。</li></ul><p>在挂载前，向挂载点中创建几个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]<span class="comment"># touch /mnt/a.txt</span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mkdir /mnt/abcdir</span></span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">[root@server2 tmp]<span class="comment"># mount /dev/cdrom /mnt</span></span><br></pre></td></tr></table></figure><p>挂载后，挂载点中将找不到刚创建的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]# ll /mnt</span><br><span class="line">total 636</span><br><span class="line">-r--r--r-- 1 root root     14 Dec 10  2015 CentOS_BuildTag</span><br><span class="line">dr-xr-xr-x 3 root root   2048 Dec 10  2015 EFI</span><br><span class="line">-r--r--r-- 1 root root    215 Dec 10  2015 EULA</span><br><span class="line">-r--r--r-- 1 root root  18009 Dec 10  2015 GPL</span><br><span class="line">dr-xr-xr-x 3 root root   2048 Dec 10  2015 images</span><br><span class="line">dr-xr-xr-x 2 root root   2048 Dec 10  2015 isolinux</span><br><span class="line">dr-xr-xr-x 2 root root   2048 Dec 10  2015 LiveOS</span><br><span class="line">dr-xr-xr-x 2 root root 612352 Dec 10  2015 Packages</span><br><span class="line">dr-xr-xr-x 2 root root   4096 Dec 10  2015 repodata</span><br><span class="line">-r--r--r-- 1 root root   1690 Dec 10  2015 RPM-GPG-KEY-CentOS-7</span><br><span class="line">-r--r--r-- 1 root root   1690 Dec 10  2015 RPM-GPG-KEY-CentOS-Testing-7</span><br><span class="line">-r--r--r-- 1 root root   2883 Dec 10  2015 TRANS.TBL</span><br></pre></td></tr></table></figure><p>卸载后，挂载点/mnt中的文件将再次可见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server2 tmp]# umount /mnt</span><br><span class="line">[root@server2 tmp]# ll /mnt</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 6 Jun  9 08:18 abcdir</span><br><span class="line">-rw-r--r-- 1 root root 0 Jun  9 08:18 a.txt</span><br></pre></td></tr></table></figure><p>之所以会这样，是因为挂载文件系统后，挂载点原来的inode记录暂时被标记为不可用，关键是没有指向该inode记录的inode指针了。在卸载文件系统后，又重新启用挂载点原来的inode记录，&quot;/&quot;目录下的mnt的inode指针又重新指向该inode记录。</p><ul><li>(3).挂载后，挂载点的元数据和data block是分别存放在不同文件系统上的。</li><li>(4).挂载点即使在挂载后，也还是属于源文件系统的文件。</li></ul><h3><span id="文件描述符">文件描述符</span></h3><p>先看一段最文件描述符的官方说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">维基百科:文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</span><br></pre></td></tr></table></figure><ul><li><p>作用<br>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p></li><li><p>概念定义</p><ul><li>文件描述符 是 用来访问资源(文件，输入输出设备等)的一种抽象指示符。</li><li>文件描述符 是POSIX(Portable Operating System Interface)规范的组成部分</li><li>文件描述符 通常是非负整数，C 语言中使用int类型。</li></ul></li><li><p>FD 具体可以指向什么</p><ul><li>文件/目录 files/directories</li><li>输入输出源 input/output</li><li>管道 pipes</li><li>套接字 sockets</li><li>其他 Unix 文件类型 other Unix files</li></ul></li><li><p>默认的fds</p><ul><li>每一个 Unix 进程中，通常会有三个预制的 FD。它们分别是</li><li>标准输入 Standard input 标准输入 用于程序接受数据</li><li>标准输出 Standard output 标准输出 用于程序输出数据</li><li>标准错误(输出) Standard error 标准错误 用于程序输出错误或者诊断信息</li></ul></li><li><p>文件描述符的意义<br>一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p></li></ul><p>除了文件描述符表，系统还需要维护另外两张表：<br>打开文件表（Open file table）<br>i-node 表（i-node table）</p><p>文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个，它们三者之间的关系如下图所示。</p><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1602570064485.png" alt></p><h4><span id="文件描述符的意义">文件描述符的意义</span></h4><blockquote><p>首先，为什么不把文件位置干脆存放在索引节点中，而要多此一举，设一个新的数据结构呢？我们知道，Linux中的文件是能够共享的，假如把文件位置存放在索引节点中，则如果有两个或更多个进程同时打开同一个文件时，它们将去访问同一个索引节点，于是一个进程的LSEEK操作将影响到另一个进程的读操作，这显然是不允许也是不可想象的。</p></blockquote><blockquote><p>另一个想法是既然进程是通过文件描述符访问文件的，为什么不用一个与文件描述符数组相平行的数组来保存每个打开文件的文件位置？这个想法也是不能实现的，原因就在于在生成一个新进程时，子进程要共享父进程的所有信息，包括文件描述符数组。</p></blockquote><blockquote><p>我们知道，一个文件不仅可以被不同的进程分别打开，而且也可以被同一个进程先后多次打开。一个进程如果先后多次打开同一个文件，则每一次打开都要分配一个新的文件描述符，并且指向一个新的file结构，尽管它们都指向同一个索引节点，但是，如果一个子进程不和父进程共享同一个file结构，而是也如上面一样，分配一个新的file结构，会出现什么情况了？让我们来看一个例子：</p></blockquote><blockquote><p>假设有一个输出重定位到某文件A的shell script（shell脚本），我们知道，shell是作为一个进程运行的，当它生成第一个子进程时，将以0作为A的文件位置开始输出，假设输出了2K的数据，则现在文件位置为2K。然后，shell继续读取脚本，生成另一个子进程，它要共享shell的file结构，也就是共享文件位置，所以第二个进程的文件位置是2K，将接着第一个进程输出内容的后面输出。如果shell不和子进程共享文件位置，则第二个进程就有可能重写第一个进程的输出了，这显然不是希望得到的结果。</p></blockquote><h4><span id="查看文件描述符">查看文件描述符</span></h4><p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p><p>lsof打开的文件可以是：</p><ul><li>普通文件</li><li>目录</li><li>网络文件系统的文件</li><li>字符或设备文件</li><li>(函数)共享库</li><li>管道，命名管道</li><li>符号链接</li><li>网络文件（例如：NFS file、网络socket，unix域名socket）</li><li>还有其它类型的文件，等等</li></ul><p>我们用java 新写一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String s =<span class="string">"/tmp/file.test"</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(s));</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，并用jps找到其对应的pid</p><p>利用lsof -i <pid>命令来查看</pid></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">java    36562 lizhipeng  mem    REG  253,0    142144    50547 /usr/lib64/libpthread-2.17.so</span><br><span class="line">java    36562 lizhipeng  mem    REG  253,0    163312    42066 /usr/lib64/ld-2.17.so</span><br><span class="line">java    36562 lizhipeng  mem    REG  253,0     32768 51151094 /tmp/hsperfdata_lizhipeng/36562</span><br><span class="line">java    36562 lizhipeng    0u   CHR  136,4       0t0        7 /dev/pts/4</span><br><span class="line">java    36562 lizhipeng    1u   CHR  136,4       0t0        7 /dev/pts/4</span><br><span class="line">java    36562 lizhipeng    2u   CHR  136,4       0t0        7 /dev/pts/4</span><br><span class="line">java    36562 lizhipeng    3r   REG  253,0  73861866 33613070 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/lib/rt.jar</span><br><span class="line">java    36562 lizhipeng    4r   REG  253,0   1027597 33613060 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/lib/jfr.jar</span><br><span class="line">java    36562 lizhipeng    5w   REG  253,0         0 33671497 /tmp/file.test</span><br></pre></td></tr></table></figure><p>我们可以看到 最后一行的5w就是我们打开的文件描述符，具体的命令以及使用方法请看<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html" target="_blank" rel="noopener">lsof 一切皆文件</a></p><h3><span id="pcb-进程控制块">PCB 进程控制块</span></h3><p>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。 在linux中 PCB 用task_struct 数据结构来表示</p><h4><span id="pcb">PCB</span></h4><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1603110089363.png" alt></p><h4><span id="fs_struct">fs_struct</span></h4><p>1、与进程相关的文件<br>首先，文件必须由进程打开，每个进程都有它自己当前的工作目录和它自己的根目录。task_struct的fs字段指向进程的fs_struct结构，files字段指向进程的files_struct结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line"> <span class="keyword">atomic_t</span> count;</span><br><span class="line"> <span class="keyword">rwlock_t</span> lock;</span><br><span class="line"> <span class="keyword">int</span> umask;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>, * <span class="title">altroot</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> * <span class="title">rootmnt</span>, * <span class="title">pwdmnt</span>, * <span class="title">altrootmnt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>count：共享这个表的进程个数</li><li>lock：用于表中字段的读/写自旋锁</li><li>umask：当打开文件设置文件权限时所使用的位掩码</li><li>root：根目录的目录项</li><li>pwd：当前工作目录的目录项</li></ul><h4><span id="files_struct">files_struct</span></h4><p>每个进程用一个 files_struct 结构来记录文件描述符的使用情况， 这个 files_struct结构称为用户打开文件表， 它是进程的私有数据。 files_struct 结构在include/linux/sched.h 中定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>  <span class="title">fdtab</span>;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> next_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/article/openerating-learning-vfs-2/openerating-learning-vfs-2-1603108815036.png" alt></p><h4><span id="ulimit">ulimit</span></h4><p>ulimit命令可以查看当前shell下的文件描述符的数量。</p><p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p><p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ulimit (选项)</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-a：显示目前资源限制的设定；</span><br><span class="line">-c ：设定core文件的最大值，单位为区块； </span><br><span class="line">-d &lt;数据节区大小&gt;：程序数据节区的最大值，单位为KB； </span><br><span class="line">-f &lt;文件大小&gt;：shell所能建立的最大文件，单位为区块； </span><br><span class="line">-H：设定资源的硬性限制，也就是管理员所设下的限制； </span><br><span class="line">-m &lt;内存大小&gt;：指定可使用内存的上限，单位为KB； </span><br><span class="line">-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数； </span><br><span class="line">-p &lt;缓冲区大小&gt;：指定管道缓冲区的大小，单位512字节； </span><br><span class="line">-s &lt;堆叠大小&gt;：指定堆叠的上限，单位为KB； </span><br><span class="line">-S：设定资源的弹性限制； </span><br><span class="line">-t ：指定CPU使用时间的上限，单位为秒； </span><br><span class="line">-u &lt;程序数目&gt;：用户最多可开启的程序数目； </span><br><span class="line">-v &lt;虚拟内存大小&gt;：指定可使用的虚拟内存上限，单位为KB。</span><br><span class="line">实例：</span><br></pre></td></tr></table></figure><p>来看一下具体的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0            #core文件的最大值为100 blocks。</span><br><span class="line">data seg size           (kbytes, -d) unlimited    #进程的数据段可以任意大。</span><br><span class="line">scheduling priority            (-e) 0</span><br><span class="line">file size              (blocks, -f) unlimited    #文件可以任意大。</span><br><span class="line">pending signals               (-i) 3794         #最多有98304个待处理的信号。</span><br><span class="line">max locked memory         (kbytes, -l) 64           #一个任务锁住的物理内存的最大值为32KB。</span><br><span class="line">max memory size          (kbytes, -m) unlimited    #一个任务的常驻物理内存的最大值。</span><br><span class="line">open files                  (-n) 1024         #一个任务最多可以同时打开1024的文件。</span><br><span class="line">pipe size            (512 bytes, -p) 8            #管道的最大空间为4096字节。</span><br><span class="line">POSIX message queues        (bytes, -q) 819200       #POSIX的消息队列的最大值为819200字节。</span><br><span class="line">real-time priority             (-r) 0</span><br><span class="line">stack size             (kbytes, -s) 10240        #进程的栈的最大值为10240字节。</span><br><span class="line">cpu time              (seconds, -t) unlimited    #进程使用的CPU时间。</span><br><span class="line">max user processes             (-u) 1024         #当前用户同时打开的进程（包括线程）的最大个数为98304。</span><br><span class="line">virtual memory          (kbytes, -v) unlimited    #没有限制进程的最大地址空间。</span><br><span class="line">file locks                  (-x) unlimited    #所能锁住的文件的最大个数没有限制。</span><br><span class="line">Linux默认的文件打开数是1024,现在设置打开数为2048.</span><br><span class="line"></span><br><span class="line">[root@Centos ~]# ulimit -n        --查看打开数为1024</span><br><span class="line">1024</span><br><span class="line">[root@Centos ~]# ulimit -n 2048   --设置打开数为2048</span><br><span class="line">[root@Centos ~]# ulimit -n        --再次查看</span><br><span class="line">2048</span><br></pre></td></tr></table></figure><h1><span id="特殊文件类型">特殊文件类型</span></h1><ul><li>Linux设备驱动程序工作原理<br>系统调用是操作系统内核和应用程序之间的接口，设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件， 应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，运行在核心态，它完成以下的功能：</li></ul><p>1.对设备初始化和释放.<br>2.把数据从内核传送到硬件和从硬件读取数据.<br>3.读取应用程序传送给设备文件的数据和回送应用程序请求的数据.<br>4.检测和处理设备出现的错误.</p><p>在Linux操作系统下有三类主要的设备文件类型：<strong>字符设备、块设备和网络接口</strong>。<br>字符设备和块设备的主要区别是：在对字符设备发出读/写请求时，实际的硬件I/O一般就紧接着发生了块设备则不然，它利用一块系统内存作缓冲区，当用户进程对设备请求能满足用户的要求，就返回请求的数据，如果不能，就调用请求函数来进行实际的I/O操作。这也就是进程管理的<strong>Page cache</strong>的作用，块设备是主要针对磁盘等慢速设备设计的，以免耗费过多的CPU时间来等待。</p><blockquote><p>换句话说， 当发生块设备的IO的时候， 操作系统实际是先写到<strong>Page cache</strong>上，而 pageCashe 会有一个映射规则，映射到某个块设备的具体地址，在发生操作以系统的IO的时候，比如说 写某个文件 当我们点击保存的时候，实际是写到了<strong>Page cache</strong>上， 此时操作系统将当前pageCash标记为脏页，之后如何将脏页刷新会磁盘就要看各个操作系统策略了。</p></blockquote><h2><span id="字符设备-块设备">字符设备、块设备</span></h2><p>每个设备文件都有其文件属性(c/b)，表示是字符设备还是块设备, 另外每个文件都有两个设备号，第一个是主设备号，标识驱动程序，第二个是从设备号，标识使用同一个设备驱动程序的不同的硬件设备，比如有两个软盘，就可以用 从设备号来区分他们。设备文件的的主设备号必须与设备驱动程序在登记时申请的主设备号一致，否则用户进程将无法访问到驱动程序。</p><p>我可以通过 ls 来看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">命令：ls -alti</span><br><span class="line">输出详解：</span><br><span class="line"><span class="comment"># =================== </span></span><br><span class="line">10605  (inode 编号)</span><br><span class="line">brw-rw----.   b 块设备， c 字符设备   </span><br><span class="line">1 </span><br><span class="line">root （所属用户）</span><br><span class="line">cdrom （用户组）   </span><br><span class="line">11,（主设备号）   </span><br><span class="line">0（次设备号） </span><br><span class="line">10月 12 17:41 </span><br><span class="line">sr0 设备名称</span><br><span class="line"><span class="comment"># =================== </span></span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">10445 brw-rw----.  1 root disk      8,   1 10月 12 17:41 sda1</span><br><span class="line">10446 brw-rw----.  1 root disk      8,   2 10月 12 17:41 sda2</span><br><span class="line">10444 brw-rw----.  1 root disk      8,   0 10月 12 17:41 sda</span><br><span class="line">10449 brw-rw----.  1 root disk      8,  16 10月 12 17:41 sdb</span><br><span class="line"> 8535 crw-------.  1 root root    247,   1 10月 12 17:41 usbmon1</span><br><span class="line">10104 crw-------.  1 root root    246,   0 10月 12 17:41 hidraw0</span><br><span class="line"> 8550 crw-------.  1 root root    247,   2 10月 12 17:41 usbmon2</span><br></pre></td></tr></table></figure><ul><li>文件操作的关键结构</li></ul><p>由于用户进程是通过设备文件同硬件打交道，对设备文件的操作方式不外乎就是一些系统调用，如 open，read，write，close…， 注意，不是fopen， fread，但是如何把系统调用和驱动程序关联起来呢?这需要了解一个非常关键的数据结构 <strong>file_operations</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*seek) (struct inode * ，struct file *， <span class="keyword">off_t</span> ，<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*read) (struct inode * ，struct file *， <span class="keyword">char</span> ，<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*write) (struct inode * ，struct file *， <span class="keyword">off_t</span> ，<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*readdir) (struct inode * ，struct file *， struct dirent * ，<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*select) (struct inode * ，struct file *， <span class="keyword">int</span> ，select_table *);</span><br><span class="line">    <span class="keyword">int</span> (*ioctl) (struct inode * ，struct file *， unsined <span class="keyword">int</span> ，<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct inode * ，struct file *， struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode * ，struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode * ，struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct inode * ，struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (struct inode * ，struct file *，<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*check_media_change) (struct inode * ，struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*revalidate) (<span class="keyword">dev_t</span> dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构的每一个成员的名字都对应着一个系统调用。用户进程利用系统调用在对设备文件进行诸如read/write操作时，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。这是linux的设备驱动程序工作的基本原理<br>这里不再详细阐述。</p><h2><span id="链接文件">链接文件</span></h2><p>软连接文件，详情请看上文 <strong>文件链接</strong></p><h2><span id="管道文件">管道文件</span></h2><ul><li>什么是管道？</li></ul><p>管道，英文为pipe。这是一个我们在学习Linux命令行的时候就会引入的一个很重要的概念。它的发明人是道格拉斯.麦克罗伊，这位也是UNIX上早期shell的发明人。他在发明了shell之后，发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出重定向加文件搞定，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$ ls /etc/ &gt; etc.txt</span><br><span class="line">[lizhipeng@CentOS7 ~]$ wc -l etc.txt</span><br></pre></td></tr></table></figure><p>但是这样未免显得太麻烦了。所以，管道的概念应运而生。目前在任何一个shell中，都可以使用“|”连接两个命令，shell会将前后两个进程的输入输出用一个管道相连，以便达到进程间通信的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$ ls -l /etc/ | wc -l</span><br></pre></td></tr></table></figure><p>对比以上两种方法，我们也可以理解为，管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。实际上管道的设计也是遵循UNIX的“一切皆文件”设计原则的，它本质上就是一个文件。Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。</p><p>虽然实现形态上是文件，但是<strong>管道本身并不占用磁盘或者其他外部存储的空间</strong>。在Linux的实现上，它占用的是内存空间。所以，<strong>Linux上的管道就是一个操作方式为文件的内存缓冲区</strong>。</p><p>Linux上的管道分两种类型：</p><ul><li>匿名管道</li><li>命名管道</li></ul><p>这两种管道也叫做有名或无名管道。匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。这保证了传输数据的安全性，当然也降低了管道了通用性，于是系统还提供了命名管道。</p><p>我们可以使用mkfifo或mknod命令来创建一个命名管道，这跟创建一个文件没有什么区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng<span class="meta">@CentOS</span>7 ~]$ mkfifo pip</span><br><span class="line">[lizhipeng<span class="meta">@CentOS</span>7 ~]$ ls</span><br><span class="line">prw-rw-r--. <span class="number">1</span> lizhipeng lizhipeng      <span class="number">0</span> <span class="number">11</span>月 <span class="number">17</span> <span class="number">13</span>:<span class="number">24</span> pip</span><br></pre></td></tr></table></figure><p>可以看到创建出来的文件类型比较特殊，是p类型。表示这是一个管道文件。有了这个管道文件，系统中就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件进行通信了。比如我们现在让一个进程写这个管道文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$ echo xxxxxxxxxxxxxx &gt; pip</span><br></pre></td></tr></table></figure><p>此时这个写操作会阻塞，因为管道另一端没有人读。这是内核对管道文件定义的默认行为。此时如果有进程读这个管道，那么这个写操作的阻塞才会解除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$  cat pip</span><br><span class="line">xxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>大家可以观察到，当我们cat完这个文件之后，另一端的echo命令也返回了。这就是命名管道</p><p>接下来我们来看一下匿名管道，我们需要用到 shell 的代码块 命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$ &#123; echo $BASHPID; read x ; &#125; | &#123; cat ; echo $BASHPID;  read y; &#125;</span><br><span class="line">37057</span><br></pre></td></tr></table></figure><p>{} 花括号的代码会先执行，遇到管道后，会开启另外一个进程，两个进程实现通讯。此时父进程输出了父进程的pid<br>且阻塞在了read x 这个代码块中，此时我们可以通过结果拿到父进程的 pid 37057</p><p>我们通过pstree来验证一下我们的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 ~]$ pstree -p</span><br><span class="line">...</span><br><span class="line">           ─sshd(36387)───bash(36388)─┬─bash(37057+</span><br><span class="line">           │            │             └─bash(37058+</span><br><span class="line">           │            └─sshd(36713)───sshd(36717)───bash(36718)───pstree(370+</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们看到了 37057 进程生出了 37058的子进程。我们来看一下管道的文件描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[lizhipeng@CentOS7 fd]$ ls -alt /proc/37057/fd</span><br><span class="line">总用量 0</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 0 -&gt; /dev/pts/4</span><br><span class="line">l-wx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 1 -&gt; pipe:[253711]</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 2 -&gt; /dev/pts/4</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 255 -&gt; /dev/pts/4</span><br><span class="line">dr-x------. 2 lizhipeng lizhipeng  0 11月 17 13:33 .</span><br><span class="line">dr-xr-xr-x. 9 lizhipeng lizhipeng  0 11月 17 13:30 ..</span><br><span class="line"></span><br><span class="line">[lizhipeng@CentOS7 fd]$ ls -alt /proc/37058/fd</span><br><span class="line">总用量 0</span><br><span class="line">lr-x------. 1 lizhipeng lizhipeng 64 11月 17 13:34 0 -&gt; pipe:[253711]</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 2 -&gt; /dev/pts/4</span><br><span class="line">lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 255 -&gt; /dev/pts/4</span><br><span class="line">dr-x------. 2 lizhipeng lizhipeng  0 11月 17 13:34 .</span><br><span class="line">dr-xr-xr-x. 9 lizhipeng lizhipeng  0 11月 17 13:30 ..</span><br></pre></td></tr></table></figure><p>由此我们可以看到，37057 通过重定向 1 号文件描述符来讲管道 重定向到了 37058 的0号描述符。<br>这就是匿名管道。</p><h2><span id="套接字文件数据通信的接口">套接字文件（数据通信的接口)</span></h2><p>请见下一章节。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/69289429" target="_blank" rel="noopener">浅谈Linux虚拟文件系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/55037128" target="_blank" rel="noopener">Linux文件系统庖丁解牛</a></li><li><a href="https://blog.csdn.net/weixin_37641832/article/details/103217311" target="_blank" rel="noopener">分钟图解 磁盘的结构（盘片、磁道、扇区、柱面）</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的？</a></li><li><a href="https://juejin.im/post/6844903668504854535" target="_blank" rel="noopener">Linux文件系统详解</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7016077.html" target="_blank" rel="noopener">第4章 ext文件系统机制原理剖析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 操作系统原理-文件系统(1)</title>
      <link href="/article/openerating-learning-vfs-1/"/>
      <url>/article/openerating-learning-vfs-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><div align="center"><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601175693517.png" alt></p></div><p><strong>虚拟文件系统</strong>（Virtual File System，简称VFS）是Linux内核的子系统之一，它为用户程序提供文件和文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节。借助VFS可以直接使用open()、read()、write()这样的系统调用操作文件，而无须考虑具体的文件系统和实际的存储介质。</p><p>通过VFS系统，Linux提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到Linux中。</p><p>&quot;一切皆文件&quot;是Linux的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是Linux的虚拟文件系统机制。</p><p>VFS之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到Linux内核中，即可安装和使用。</p><p>举个例子，比如Linux写一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = write(fd, buf, len);</span><br></pre></td></tr></table></figure><p>调用了write()系统调用，它的过程简要如下：</p><p>首先，勾起VFS通用系统调用sys_write()处理。<br>接着，sys_write()根据fd找到所在的文件系统提供的写操作函数，比如op_write()。<br>最后，调用op_write()实际的把数据写入到文件中。<br>操作示意图如下：</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601174927658.png" alt></p><h2><span id="文件系统">文件系统</span></h2><h1><span id="linux下常用文件系统介绍">Linux下常用文件系统介绍</span></h1><ul><li>swap 文件系统<br>swap文件系统用于Linux的交换分区。在Linux中，使用整个交换分区来提供虚拟内存，其分区大小一般应是系统物理内存的2倍，在安装Linux操作系统时，就应创建交换分区，它是Linux正常运行所必需的，其类型必须是swap,交换分区由操作系统自行管理</li><li>Btrfs 文件系统</li><li>Ext系列文件系统<br>ext是第一个专门为Linux设计的文件系统类型，称为扩展文件系统。目前已经到了第四版分别是ext2, ext3,ext4 其中 centOS6默认是ext4文件系统</li><li>xfs 文件系统</li><li>NFS文件系统</li><li>FAT系列文件系统</li></ul><h2><span id="比较">比较</span></h2><table><thead><tr><th>文件系统</th><th>最大文件名长度</th><th>最大文件大小</th><th>最大分区大小</th></tr></thead><tbody><tr><td>ext2</td><td>255 bytes</td><td>2 TB</td><td>16 TB</td></tr><tr><td>ext3</td><td>255 bytes</td><td>2 TB</td><td>16 TB</td></tr><tr><td>ext4</td><td>255 bytes</td><td>16 TB</td><td>1 EB</td></tr><tr><td>XFS</td><td>255 bytes</td><td>8 EB</td><td>8 EB</td></tr><tr><td>Btrfs</td><td>255 bytes</td><td>16 EB</td><td>16 EB</td></tr></tbody></table><h2><span id="选择">选择</span></h2><table><thead><tr><th>文件系统</th><th>适用场景</th><th>原因</th></tr></thead><tbody><tr><td>ext2</td><td>U盘</td><td>U盘一般不会存很多文件，且U盘的文件在电脑上有备份，安全性要求没那么高，由于ext2不写日志（journal），所以写U盘性能比较好。当然由于ext2的兼容性没有fat好，目前大多数U盘格式还是用fat</td></tr><tr><td>ext3</td><td>对稳定性要求高的地方</td><td>有了ext4后，好像没什么原因还要用ext3，ext4现在的问题是出来时间不长，还需要一段时间变稳定</td></tr><tr><td>ext4</td><td>小文件较少</td><td>ext系列的文件系统都不支持inode动态分配，所以如果有大量小文件需要存储的话，不建议用ext4</td></tr><tr><td>xfs</td><td>小文件多或者需要大的xttr空间，如openstack swift将数据文件的元数据放在了xttr里面</td><td>xfs支持inode动态分配，所以不存在inode不够的情况，并且xttr的最大长度可以达到64K</td></tr><tr><td>btrfs</td><td>没有频繁的写操作，且需要btrfs的一些特性</td><td>btrfs虽然还不稳定，但支持众多的功能，如果你需要这些功能，且不会频繁的写文件，那么选择btrfs</td></tr></tbody></table><br><br><br><br><h1><span id="文件系统的结构">文件系统的结构</span></h1><h2><span id="磁盘的组成原理">磁盘的组成原理</span></h2><p>除了固态硬盘之外，硬盘一般都由磁盘、主轴马达、磁头臂、磁头、永磁铁等部分组成。</p><h3><span id="盘片">盘片</span></h3><p>盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面，硬盘的存储介质是磁性材料，磁头通过电流改变磁盘的磁性来存储数据。硬盘在逻辑上被划分为<strong>磁道、柱面以及扇区</strong>。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601176496332.png" alt></p><h3><span id="扇区磁道">扇区，磁道</span></h3><p>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区。如下图：</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601176436899.png" alt><br>其中，最内侧磁道上的扇区面积最小，因此数据密度最大。</p><h3><span id="柱面">柱面</span></h3><p>硬盘通常由重叠的一组盘片构成,每个盘面都被划分为数目相等的磁道,并从外缘的“0”开始编号,具有相同编号的磁道形成一个圆柱,称之为磁盘的柱面。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601180215961.png" alt></p><h3><span id="分区">分区</span></h3><blockquote><p>为什么要对硬盘进行分区呢？</p></blockquote><p>因为我们必须要告诉操作系统：这块硬盘可以访问的区域是从 A 柱面到 B 柱面。如此一来，操作系统才能控制硬盘磁头去 A-B 范围内的柱面上访问数据。如果没有告诉操作系统这些信息，它就无法在磁盘上存取数据。所以对磁盘分区的要点是：记录每一个分区的起始与结束柱面。<br>实际上，分区时指定的开始和结束位置是柱面上的扇区(sector)：</p><p>下面我们以CentOS7 为例来看一下分区情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos <span class="comment"># 使 用dos---MBR 分区方式</span></span><br><span class="line">磁盘标识符：0x000ce1c0</span><br><span class="line"></span><br><span class="line">   设备    Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（逻辑卷）</span><br><span class="line"><span class="comment"># sda 分区</span></span><br><span class="line">磁盘 /dev/mapper/centos-root：18.2 GB, 18249416704 字节，35643392 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换分区</span></span><br><span class="line">磁盘 /dev/mapper/centos-swap：2147 MB, 2147483648 字节，4194304 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br></pre></td></tr></table></figure><h2><span id="分区的组成结构">分区的组成结构</span></h2><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601437351663.png" alt></p><h3><span id="mbr">MBR</span></h3><p>那么，这些分区的信息(起始柱面与结束柱面)被存放在磁盘的主引导区(Master Boot Recorder, MBR)。MBR 在一块硬盘的第 0 轨上，这也是计算机启动之后要去使用硬盘时必须读取的第一个区域。</p><p>这个区域内记录了硬盘里所有分区的信息即磁盘分区表，以及启动时可以写入引导程序的位置。因此 MBR 对于硬盘来说至关重要，如果它坏掉了，这块磁盘也就寿终正寝了。</p><p>主引导记录由三个部分组成：</p><ul><li>引导程序占用其中的前446字节（偏移0～1BDH）</li><li>随后的64字节（偏移1BEH～1FDH）为<strong>DPT</strong>（Disk Partition Table，硬盘分区表）</li><li>最后的两个字节“55 AA”（偏移1FEH～1FFH）是结束标志。</li></ul><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601197985916.png" alt></p><p>分区表:</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601198012018.png" alt></p><h3><span id="gdt">GDT</span></h3><p>Disk label type: gpt—GPT</p><p>在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。<br>跟现代的MBR一样，GPT也使用逻辑区块地址（LBA）取代了早期的CHS寻址方式。传统MBR信息存储于LBA 0，GPT头存储于LBA 1，接下来才是分区表本身。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601439159644.png" alt></p><p>为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了</p><ul><li>主分区数目不能超过4个的限制</li><li>关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。</li></ul><h3><span id="扩展阅读-lab-chs寻址"><strong>扩展阅读 LAB CHS寻址</strong></span></h3><blockquote><p>有了扇区（sector），有了柱面（cylinder），有了 磁头（head），显然可以定位数据了，这就是数据定位(寻址)方式之一，CHS（也称3D），对早期的磁盘（上图所示）非常有效，知道用哪个 磁头，读取哪个柱面上的第几扇区就OK了。CHS模式支持的硬盘容量有限，用8bit来存储 磁头地址，用10bit来存储柱面地址，用6bit来存储扇区地址，而一个扇区共有512Byte，这样使用CHS寻址一块硬盘最大容量为256 * 1024 * 63 * 512B = 8064 MB(1MB = 1048576B)（若按1MB=1000000B来算就是8.4GB）</p></blockquote><blockquote><p>但现在很多硬盘采用同密度盘片，意味着内外磁道上的扇区数量不同，扇区数量增加，容量增加，3D很难定位寻址，新的寻址模式：LBA(Logical Block Addressing)。在LBA地址中，地址不再表示实际硬盘的实际 物理地址（柱面、 磁头和扇区）。LBA编址方式将CHS这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的 物理扇区的C/H/S编号通过一定的规则转变为一线性的编号，系统效率得到大大提高，避免了烦琐的 磁头/柱面/扇区的寻址方式。在访问硬盘时，由硬盘控制器再将这种 逻辑地址转换为实际硬盘的 物理地址。</p></blockquote><blockquote><p>LBA下的编号，扇区编号是从0开始。逻辑扇区号LBA的公式：</p></blockquote><blockquote><p>LBA(逻辑扇区号)=磁头数 × 每磁道扇区数 × 当前所在柱面号 + 每磁道扇区数 × 当前所在磁头号 + 当前所在扇区号 – 1<br>例如：CHS=0/0/1，则根据公式LBA=255 × 63 × 0 + 63 × 0 + 1 – 1= 0</p></blockquote><blockquote><p>也就是说 物理0柱面0 磁头1扇区，是 逻辑0扇区。也就是说  LBA就是扇区的编号，  按照磁道  柱面 和 磁头 从小到大的顺序编号</p></blockquote><h1><span id="计算机启动的过程">计算机启动的过程</span></h1><h3><span id="1-bios-程序启动">1. BIOS 程序启动</span></h3><p>上个世纪70年代初，“只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。这块芯片里的程序叫做&quot;基本輸出輸入系統&quot;（Basic Input/Output System），简称为BIOS。</p><h3><span id="2-硬件自检">2. 硬件自检</span></h3><p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&quot;硬件自检&quot;（Power-On Self-Test），缩写为POST。<br>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。这时，BIOS需要知道，“下一阶段的启动程序&quot;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&quot;<strong>启动顺序</strong>”（Boot Sequence）。</p><p>打开BIOS的操作界面，里面有一项就是&quot;设定启动顺序&quot;。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601262435071.png" alt></p><h3><span id="3-主引导记录">3. 主引导记录</span></h3><p>BIOS按照&quot;启动顺序&quot;，把控制权转交给排在第一位的储存设备。</p><p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备。<br>这最前面的512个字节，就叫做&quot;<strong>主引导记录</strong>&quot;（Master boot record，缩写为MBR）。<br><strong>主引导记录&quot;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统</strong></p><h3><span id="4-启动管理器">4. 启动管理器</span></h3><p>在这种情况下，计算机读取&quot;主引导记录&quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&quot;启动管理器&quot;（boot loader），由用户选择启动哪一个操作系统。<strong>Linux环境中，目前最流行的启动管理器是Grub。</strong></p><h3><span id="5-操作系统">5. 操作系统</span></h3><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。<br>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab， CentOS 是systemd）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p><p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p><h1><span id="文件存贮">文件存贮</span></h1><p>文件系统到底是怎么管理磁盘的被？首先，操作系统会将磁盘分区后，同一个文件系统中，我们以ext系列为例来说明：<br>ext系统将空间（这里的空间是指的一段连续的磁盘空间）划分为不同的功能区，比如<strong>元数据区和数据区</strong>。元数据去主要存贮文件的一些属性，比如说大小，快信息，这些信息被存贮在inode当中，而数据去以datablock 为存贮单元，主要是存放了文件的数据。</p><p>因为磁盘上的数据要和内存交互，而内存通常是以4KB为单位的，所以从逻辑上，把磁盘按照4KB划分比较方便（称为一个block）。现在假设由一个文件系统管理64个blocks的一个磁盘区域：</p><h3><span id="顺序文件结构">顺序文件结构</span></h3><p>顾名思义，文件的存贮数据块是连续的空间。</p><p>优点是不需要额外的空间开销，只要在文件目录中指出文件的大小和首块的块号即可，对顺序的访问效率很高。适应于顺序存取且文件不经常修改的情况。<br>缺点是</p><ul><li>文件动态地增长和缩小时系统开销很大；</li><li>文件创建时要求用户提供文件的大小；</li><li>存储空间浪费较大。</li></ul><h3><span id="链式文件系统">链式文件系统</span></h3><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601270128799.png" alt></p><p>克服了连续文件的不足之处，但文件的随机访问系统开销较大。适应于顺序访问的文件。</p><h3><span id="索引式文件系统">索引式文件系统</span></h3><p>在UNIX时代，就已经实现了索引式的文件系统。它的原理是为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。而且文件中的块依然可以分散到不连续的零散空间中。其结构如下图所示</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601270186029.png" alt></p><p>既适应于顺序存访问，也适应于随机访问，是一种比较好的文件物理结构，但要有用于索引表的空间开销和文件索引的时间开销</p><h1><span id="ext-文件分区布局">Ext 文件分区布局</span></h1><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601441542937.png" alt></p><p>每个分区，将若干个块儿组成一个块组，每个块组会有以下几个结构</p><h2><span id="超级块">超级块</span></h2><p>1）超级块(Super Block)描述整个分区的文件系统信息，如inode/block的大小、总量、使用量、剩余量，以及文件系统的格式与相关信息。超级块在每个<strong>块组</strong>的开头都有一份拷贝（第一个块组必须有，后面的块组可以没有）。</p><p>为了保证文件系统在磁盘部分扇区出现物理问题的情况下还能正常工作，就必须保证文件系统的super block信息在这种情况下也能正常访问。所以一个文件系统的super block会在多个block group中进行备份，这些super block区域的数据保持一致。<br>超级块记录的信息有：</p><p>1、block 与 inode 的总量（分区内所有Block Group的block和inode总量）；<br>2、未使用与已使用的 inode / block 数量；<br>3、block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；<br>4、filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；<br>5、一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。</p><p>它的结构如图所示</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601270726287.png" alt></p><p>对于ext2/3/4文件系统，以上介绍的这些inode bitmap, data block bitmap和inode table，都可以通过一个名为&quot;dumpe2fs&quot;的工具来查看其在磁盘上的具体位置</p><h2><span id="gdt">GDT</span></h2><p>2）块组描述符表(GDT,Group Descriptor Table)由很多块组描述符组成，整个分区分成多个块组就对应有多少个块组描述符。<br>每个块组描述符存储一个块组的描述信息，如在这个块组中从哪里开始是inode Table，从哪里开始是Data Blocks，空闲的inode和数据块还有多少个等等。</p><h2><span id="inode-和-block-位图">Inode 和 Block 位图</span></h2><p>4）inode位图(inode Bitmap)和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。 Inode bitmap的作用是记录block group中Inode区域的使用情况，Ext文件系统中一个block group中可以有16384个Inode，代表着这个Ext文件系统中一个block group最多可以描述16384个文件。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601455772886.png" alt></p><h2><span id="inode">inode</span></h2><p>索引表的索引结构称为inode，是&quot;index node&quot;的简称，用来索引，跟踪一个文件的所有块。inode是文件索引结构组织形式的具体体现，一个文件就必须对应一个inode。</p><p>5）inode表(inode Table)由一个块组中的所有inode组成。一个文件除了数据需要存储之外，一些描述信息也需要存储，如文件类型，权限，文件大小，创建、修改、访问时间等，这些信息存在inode中而不是数据块中。</p><p>inode表占多少个块在格式化时就要写入块组描述符中。 在Ext2/Ext3文件系统中，每个文件在磁盘上的位置都由文件系统block group中的一个Inode指针进行索引，Inode将会把具体的位置指向一些真正记录文件数据的block块，需要注意的是这些block可能和Inode同属于一个block group也可能分属于不同的block group。我们把文件系统上这些真实记录文件数据的block称为Data blocks。</p><p>索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。</p><p><img src="/article/openerating-learning-vfs-1/openerating-learning-vfs-1-1601270268759.png" alt></p><p>ls -i 命令可以显示inode 号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  command ls -ilt</span><br><span class="line">total 24</span><br><span class="line">3003623(inode号) -rwxr-xr-x  1 root  root    78  8 10 16:43 jump</span><br><span class="line">3003622(inode号) -rwxr-xr-x  1 root  root   476  8 10 16:42 jumper.sh</span><br><span class="line">3003624(inode号) -rwxr-xr-x  1 root  root  3346  3 24  2019 imgcat</span><br></pre></td></tr></table></figure><h2><span id="data-block">data block</span></h2><p>6）数据块(Data Block)是用来放置文件内容数据的地方。根据不同的文件类型有以下几种情况：<br>对于普通文件，文件的数据存储在数据块中。<br>对于目录，该目录下的所有文件名和目录名存储在所在目录的数据块中，除了文件名外，ls -l命令看到的其它信息保存在该文件的inode中。</p><h1><span id="文件分区实践">文件分区实践</span></h1><p>我们根据实践一下磁盘分区的步骤，实践一下ext4下的文件管理系统的步骤。我们的系统如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux CentOS7 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>首先第一步，我们需要一块硬盘，用于我是CentOS7的系统，这里我在虚拟机上新建了一块硬盘,容量是1G，这块硬盘还没有格式，我可以在我的/dev 目录下找到这块硬盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# ls /dev/sd*</span><br><span class="line">/dev/sda  /dev/sda1  /dev/sda2  /dev/sdb</span><br></pre></td></tr></table></figure><p>查看分区,我一共有两块硬盘，一块是sda,一块是sdb。我们接下来需要格式化一下sdb.</p><h2><span id="格式化硬盘">格式化硬盘</span></h2><p>首先，我们需要用fdisk 将sdb</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux <span class="number">2.23</span><span class="number">.2</span>)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 <span class="number">0x30c1a40d</span> 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m  #获取帮助命令</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a <span class="keyword">new</span> empty GPT partition table</span><br><span class="line">   <span class="function">G   create an <span class="title">IRIX</span> <span class="params">(SGI)</span> partition table</span></span><br><span class="line"><span class="function">   l   list known partition types</span></span><br><span class="line"><span class="function">   m   print <span class="keyword">this</span> menu</span></span><br><span class="line"><span class="function">   n   add a new partition</span></span><br><span class="line"><span class="function">   o   create a new empty DOS partition table</span></span><br><span class="line"><span class="function">   p   print the partition table</span></span><br><span class="line"><span class="function">   q   quit without saving changes</span></span><br><span class="line"><span class="function">   s   create a new empty Sun disklabel</span></span><br><span class="line"><span class="function">   t   change a partition's system id</span></span><br><span class="line"><span class="function">   u   change display/entry units</span></span><br><span class="line"><span class="function">   v   verify the partition table</span></span><br><span class="line"><span class="function">   w   write table to disk and exit</span></span><br><span class="line"><span class="function">   x   extra <span class="title">functionality</span> <span class="params">(experts only)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">命令<span class="params">(输入 m 获取帮助)</span>：n</span></span><br><span class="line"><span class="function">Partition type:</span></span><br><span class="line"><span class="function">   p   <span class="title">primary</span> <span class="params">(<span class="number">0</span> primary, <span class="number">0</span> extended, <span class="number">4</span> free)</span>   （这里表示，我们没有任何分许，允许你创建4个可用分区，0个主分区，和一个逻辑分区）</span></span><br><span class="line"><span class="function">   e   extended</span></span><br><span class="line"><span class="function"><span class="title">Select</span> <span class="params">(<span class="keyword">default</span> p)</span>: p   （我们来创建主分区）</span></span><br><span class="line"><span class="function">分区号 <span class="params">(<span class="number">1</span><span class="number">-4</span>，默认 <span class="number">1</span>)</span>：    （选择分区号，默认即可）</span></span><br><span class="line"><span class="function">起始 扇区 <span class="params">(<span class="number">2048</span><span class="number">-2097151</span>，默认为 <span class="number">2048</span>)</span>：      （0-2048） # 前2048是系统预留空间 </span></span><br><span class="line"><span class="function">将使用默认值 2048</span></span><br><span class="line"><span class="function">Last 扇区, +扇区 or +size</span>&#123;K,M,G&#125; (<span class="number">2048</span>-<span class="number">2097151</span>，默认为 <span class="number">2097151</span>)：  （我们直接全部将<span class="number">1</span>g划分为这个分区）</span><br><span class="line">将使用默认值 <span class="number">2097151</span></span><br><span class="line">分区 <span class="number">1</span> 已设置为 Linux 类型，大小设为 <span class="number">1023</span> MiB</span><br></pre></td></tr></table></figure><h2><span id="创建文件系统">创建文件系统</span></h2><p>使用CentOS7 自带的文件系统格式工具，将sdb整个硬盘格式化成ext4文件格式。<br>mke2fs：ext系列文件系统专用管理工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@CentOS7 ~]<span class="comment"># mkfs.ext4 /dev/sdb</span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">/dev/sdb is entire device, not just one partition!</span><br><span class="line">无论如何也要继续? (y,n) y</span><br><span class="line">文件系统标签=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">块大小=4096 (<span class="built_in">log</span>=2)  </span><br><span class="line">分块大小=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">65536 inodes, 262144 blocks   <span class="comment"># inodes数量和blicks 是数量</span></span><br><span class="line">13107 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">第一个数据块=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups      <span class="comment"># 8个块组</span></span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group                   <span class="comment"># 每组 inode 的数量</span></span><br><span class="line">Superblock backups stored on blocks:    <span class="comment"># 超级快的存贮位置</span></span><br><span class="line">32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成</span><br><span class="line">正在写入inode表: 完成</span><br><span class="line">Creating journal (8192 blocks): 完成  <span class="comment"># 创建日志区</span></span><br><span class="line">Writing superblocks and filesystem accounting information: 完成</span><br></pre></td></tr></table></figure><h2><span id="查看分区">查看分区</span></h2><p>经过生面的步骤，我们已经将分区创建完毕，我们使用blkid 命令来查看一下分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# blkid</span><br><span class="line">/dev/sda1: UUID=&quot;79678d4f-9276-4d1e-8093-28623d77461e&quot; TYPE=&quot;xfs&quot;</span><br><span class="line">/dev/sda2: UUID=&quot;FtqgeH-yiRM-f1Wr-73LT-QkQf-2kgX-BkXYi1&quot; TYPE=&quot;LVM2_member&quot;</span><br><span class="line">/dev/sr0: UUID=&quot;2020-04-22-00-54-00-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot;</span><br><span class="line">/dev/mapper/centos-root: UUID=&quot;d0412c8e-07f5-4716-8be7-8ed2da9affca&quot; TYPE=&quot;xfs&quot;</span><br><span class="line">/dev/mapper/centos-swap: UUID=&quot;ac1ae2c7-d653-4496-97fa-d9315f56993f&quot; TYPE=&quot;swap&quot;</span><br><span class="line">/dev/sdb: UUID=&quot;6285b923-0ee4-444d-9c68-d6af94914bc3&quot; TYPE=&quot;ext4&quot;</span><br></pre></td></tr></table></figure><h2><span id="查看-超级块和块组">查看 超级块和块组</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          &lt;not available&gt;</span><br><span class="line">Filesystem UUID:          6285b923-0ee4-444d-9c68-d6af94914bc3</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              65536</span><br><span class="line">Block count:              262144</span><br><span class="line">Reserved block count:     13107</span><br><span class="line">Free blocks:              249189</span><br><span class="line">Free inodes:              65525</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      127</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Wed Sep 30 12:22:05 2020</span><br><span class="line">Last mount time:          n/a</span><br><span class="line">Last write time:          Wed Sep 30 12:22:05 2020</span><br><span class="line">Mount count:              0</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Wed Sep 30 12:22:05 2020</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          33 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:          256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      61f49ab4-d494-4be8-95b7-404358b685aa</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         (none)</span><br><span class="line">日志大小:             32M</span><br><span class="line">Journal length:           8192</span><br><span class="line">Journal sequence:         0x00000001</span><br><span class="line">Journal start:            0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767)</span><br><span class="line">  Checksum 0x4cc2, unused inodes 8181</span><br><span class="line">  主 superblock at 0, Group descriptors at 1-1</span><br><span class="line">  保留的GDT块位于 2-128</span><br><span class="line">  Block bitmap at 129 (+129), Inode bitmap at 145 (+145)</span><br><span class="line">  Inode表位于 161-672 (+161)</span><br><span class="line">  28521 free blocks, 8181 free inodes, 2 directories, 8181个未使用的inodes</span><br><span class="line">  可用块数: 142-144, 153-160, 4258-32767</span><br><span class="line">  可用inode数: 12-8192</span><br><span class="line">Group 1: (Blocks 32768-65535) [INODE_UNINIT]</span><br><span class="line">  Checksum 0xabae, unused inodes 8192</span><br><span class="line">  备份 superblock at 32768, Group descriptors at 32769-32769</span><br><span class="line">  保留的GDT块位于 32770-32896</span><br><span class="line">  Block bitmap at 130 (bg #0 + 130), Inode bitmap at 146 (bg #0 + 146)</span><br><span class="line">  Inode表位于 673-1184 (bg #0 + 673)</span><br><span class="line">  32639 free blocks, 8192 free inodes, 0 directories, 8192个未使用的inodes</span><br><span class="line">  可用块数: 32897-65535</span><br><span class="line">  可用inode数: 8193-16384</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/69289429" target="_blank" rel="noopener">浅谈Linux虚拟文件系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/55037128" target="_blank" rel="noopener">Linux文件系统庖丁解牛</a></li><li><a href="https://blog.csdn.net/weixin_37641832/article/details/103217311" target="_blank" rel="noopener">分钟图解 磁盘的结构（盘片、磁道、扇区、柱面）</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的？</a></li><li><a href="https://juejin.im/post/6844903668504854535" target="_blank" rel="noopener">Linux文件系统详解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入JVM字节码(2)</title>
      <link href="/article/bytecode-analysis-2-instance/"/>
      <url>/article/bytecode-analysis-2-instance/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>我们上一章节讨论了字节码的一些分布，具体的请看<a href="https://icefrozen.github.io/article/bytecode-analysis/" target="_blank" rel="noopener">深入JVM字节码(1) Java Class 详解</a>，字节码是对象生成的一个模板，本节将会从个源码分析来剖析一下，JVM是怎样加载类到内存的。</p><h2><span id="classloader">ClassLoader</span></h2><h2><span id="java类加载流程">JAVA类加载流程</span></h2><p>Java语言系统自带有三个类加载器:</p><ul><li><p><strong>Bootstrap ClassLoader</strong> 最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap</p></li><li><p>ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。</p></li><li><p><strong>Extention ClassLoader</strong> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。</p></li><li><p><strong>Appclass Loader</strong> 也称为SystemAppClass 加载当前应用的classpath的所有类。</p></li></ul><h2><span id="java-类加载顺序">JAVA 类加载顺序</span></h2><ul><li><p>Bootstrap CLassloder</p></li><li><p>Extention ClassLoader</p></li><li><p>AppClassLoader</p><ul><li>Java类都是通过java.lang.ClassLoader的某个实例来加载的，那么到底是谁来加载java.lang.ClassLoader呢，答案就是Bootstrap Class Loader。</li><li>Bootstrap ClassLoader用于加载JDK内部类，如rt.jar和其他JRE中lib目录的Java类库中的类。Bootstrap ClassLoader充当所有其他ClassLoader实例的父级。</li><li>Bootstrap ClassLoader是JVM核心的一部分，由原生代码编写，不同的平台可能会有不同的实现</li></ul></li></ul><h2><span id="appclassloader-和-extention-classloader">AppClassLoader 和 Extention ClassLoader</span></h2><p>系统类加载器，是指 Sun公司实现的<code>sun.misc.Launcher$AppClassLoader</code>。它负责加载系统类路径<code>java -classpath</code>或-D <code>java.class.path</code> 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器。</p><p>我们来看 <code>ClassLoader.getSystemClassLoader</code>的代码。<br>这是返回系统加载器的方法，该方法会在JVM启动早期被调用，主要是用来初始化 <code>AppClassLoader</code> 加载器。</p><p>并将系统类加载器放到当前线程的上下文当中。 返回是是scl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化系统加载器</span></span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看 scl 的初始化是在<code>initSystemClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">    sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从 launcher 中拿到class loader</span></span><br><span class="line">        scl = l.getClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scl = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            oops = pae.getCause();</span><br><span class="line">            <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                oops = oops.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scl 的生成过程我们要看 <code>SystemClassLoaderAction</code> 的run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 可以指定系统类加载器 通过参数的方式指定</span></span><br><span class="line">    String cls = System.getProperty(<span class="string">"java.system.class.loader"</span>);</span><br><span class="line">    <span class="keyword">if</span> (cls == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建类加载器的实例</span></span><br><span class="line">    Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="keyword">true</span>, parent)</span><br><span class="line">        .getDeclaredConstructor(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">        <span class="keyword">new</span> Object[] &#123; parent &#125;);</span><br><span class="line">    <span class="comment">// 设置上下文</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">    <span class="keyword">return</span> sys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会不会有个疑问，我们所说的 AppClassLoader在哪里出现的呢？别着急，我们接下来来看 <code>Launcher</code> ,因为ClassLoader 就是从这里出现的。</p><p>通过上面的分析，我们知道， 系统类的加载器是从 Launcher 中拿到的，接下来我们来看<code>sun.misc.Launcher</code>,它是一个java虚拟机的入口应用。 但是在我们OpenJDK home 目录下 src.zip 源码包中是不全的，因此我们需要看完整的JDK实现。</p><p>这里推荐几个扩展阅读:</p><ul><li><a href="https://www.jianshu.com/p/f98c3acd8df8" target="_blank" rel="noopener">JDK基础概念及目录结构</a></li><li><a href="https://blog.csdn.net/socrj/article/details/43916221" target="_blank" rel="noopener">jdk 源码结构</a></li><li><a href="https://blog.csdn.net/rain_zhao_0102/article/details/106041697" target="_blank" rel="noopener">idea 查看sun包下源码</a></li></ul><p>我们接下来主要看一下 <code>sun.misc.Launcher</code> 的实现。原本笔者是想打断开来看一下加载过程的，但是断点失败了，所有去查了一下相关资料：</p><blockquote><p>OpenJDK 对于 Launcher 类的描述：This class is used by the system to launch the main application.system 。</p></blockquote><blockquote><p>于是我又翻了翻 IBM 关于 Java 中 Debug 实现原理的介绍，文章地址如下：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/</a><br>文章中说到：JDI（Java Debug Interface）是三个模块中最高层的接口，在多数的 JDK 中，它是由 Java 语言实现的。参考 Oracle 的官方文档：<a href="https://docs.oracle.com/javase/9/docs/api/jdk.jdi-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/docs/api/jdk.jdi-summary.html</a><br>可以知道 jdi 是一个位于 tools.jar 包下的子包，而 tools.jar 也是由 BootStrap 类加载器负责加载的。<br>所以现在我们可以知道了，为 Java 提供 Debug 支持的类加载和 Launcher 的类加载都是由 Bootstrap 类加载器负责的，只是后者先发生，所以 debug 功能实现的时候，Launcher 的构造器早已运行结束了。</p></blockquote><h2><span id="launcher">Launcher</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="comment">//  省略其他</span></span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  省略其他</span></span><br><span class="line">    </span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also set the context class loader for the primordial thread.</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, install a security manager if requested</span></span><br><span class="line">        String s = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Launcher 是整个应用程序的入口启动类，主要是初始化了ExtClassLoader和AppClassLoader。</li></ul><p>首先我们来看 ExtClassLoader 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 java.ext.dirs</span></span><br><span class="line">    <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line">    <span class="comment">// 省略 try catch</span></span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    <span class="comment">// 目录注册 相当于缓存</span></span><br><span class="line">                    MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建 ExtClassLoader</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] path = (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> File[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line">    <span class="comment">// 创建 AppClassLoader  extcl 为他的父类</span></span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] urls =</span><br><span class="line">                (s == <span class="keyword">null</span>) ? <span class="keyword">new</span> URL[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>上文提到的 Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，</p><p>JVM启动时通过 Bootstrap 类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。</p><p>然后呢，我们前面已经分析了，JVM初始化sun.misc.Launcher并创建<code>Extension ClassLoader</code>和<code>AppClassLoader</code>实例。并将<code>ExtClassLoader</code>设置为<code>AppClassLoader</code>的父加载器。Bootstrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。</p><h2><span id="双亲委托机制">双亲委托机制</span></h2><p>一个类加载器查找class和resource时，是通过<code>委托模式</code>进行的，它首先判断这个<code>class</code>是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到<code>Bootstrap ClassLoader</code>，如果<code>Bootstrap classloader</code>找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p><p>这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了java的核心API被篡改。</p><ul><li><p>一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。<br>递归，重复第1部的操作。</p></li><li><p>如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。</p></li><li><p>Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。</p></li><li><p>ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。</p></li></ul><p><img src="/article/bytecode-analysis-2-instance/bytecode-analysis-2-instance-1598585313387.png" alt></p><p>我们还需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。</p><h2><span id="类加载过程机器双亲委托实现原理">类加载过程机器双亲委托实现原理</span></h2><p>我们先看这几个方法的层级<br><img src="/article/bytecode-analysis-2-instance/bytecode-analysis-2-instance-1598585731325.png" alt></p><h2><span id="loadclassstring">loadClass(String)</span></h2><p>AppClassLoader 的loadClass 直接调用的是 ClassLoader 的loadClass 方法</p><p>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">      <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 先从缓存查找该class对象，找到就不用重新加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果找不到，则委托给父类加载器去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有父类，则委托给启动加载器去加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否需要在加载时进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>findLoadedClass</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单的检查加载的类的名字是否为空或是无效</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((name == <span class="keyword">null</span>) || (name.length() == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((name.indexOf(<span class="string">'/'</span>) != -<span class="number">1</span>)</span><br><span class="line">        || (!VM.allowArraySyntax() &amp;&amp; (name.charAt(<span class="number">0</span>) == <span class="string">'['</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class <span class="title">findLoadedClass0</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure><p>我们发现findLoadedClass0是一个native方法。查了下openjdk源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jclass JNICALL</span><br><span class="line">Java_java_lang_ClassLoader_findLoadedClass0(JNIEnv *env, jobject loader,</span><br><span class="line">                                           jstring name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JVM_FindLoadedClass(env, loader, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM_FindLoadedClass 的实现</span></span><br><span class="line">JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_FindLoadedClass"</span>);</span><br><span class="line">  <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Handle <span class="title">h_name</span> <span class="params">(THREAD, JNIHandles::resolve_non_null(name)</span>)</span>;</span><br><span class="line">  Handle string = java_lang_String::internalize_classname(h_name, CHECK_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str   = java_lang_String::as_utf8_string(string());</span><br><span class="line">  <span class="comment">// Sanity check, don't expect null</span></span><br><span class="line">  <span class="keyword">if</span> (str == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> str_len = (<span class="keyword">int</span>)strlen(str);</span><br><span class="line">  <span class="keyword">if</span> (str_len &gt; Symbol::max_length()) &#123;</span><br><span class="line">    <span class="comment">//类名长度有限制</span></span><br><span class="line">    <span class="comment">// It's impossible to create this class;  the name cannot fit</span></span><br><span class="line">    <span class="comment">// into the constant pool.</span></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看全局变量表的名字</span></span><br><span class="line">  TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len, CHECK_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Security Note:</span></span><br><span class="line">  <span class="comment">//   The Java level wrapper will perform the necessary security check allowing</span></span><br><span class="line">  <span class="comment">//   us to pass the NULL as the initiating class loader.</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_loader</span><span class="params">(THREAD, JNIHandles::resolve(loader)</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">    is_lock_held_by_thread(h_loader,</span><br><span class="line">                           ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),</span><br><span class="line">                           THREAD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//全局符号字典查找该类的符号是否存在</span></span><br><span class="line">  klassOop k = SystemDictionary::find_instance_or_array_klass(klass_name,</span><br><span class="line">                                                              h_loader,</span><br><span class="line">                                                              Handle(),</span><br><span class="line">                                                              CHECK_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (k == NULL) ? NULL :</span><br><span class="line">            (jclass) JNIHandles::make_local(env, Klass::cast(k)-&gt;java_mirror());</span><br><span class="line">JVM_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段看不懂没关系，我会在JVM的启动的时候，再次分析，这里只需要知道是JVM负责查找Class就好了。</p><p>接着的逻辑就是类的双亲加载机制的实现。把类加载的任务交给父类加载器执行，直到父类加载器为空，此时会返回通过JDK提供的系统启动类加载器加载的类。<br>我们发现 findBootstrapClassOrNull 也是个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; findBootstrapClassOrNull(String name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findBootstrapClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return null if not found</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; findBootstrapClass(String name);</span><br></pre></td></tr></table></figure><p>由于篇幅有限，我们这里就不在介绍 findBootstrapClass 的jdk 源码了。</p><h2><span id="findclass">findClass</span></h2><p>该方法和它的名字一样，就是根据类的名字ClassLoader不提供该方法的具体实现，要求我们根据自己的需要来覆写该方法。<br>所以我们可以看一看URLClassLoader对findClass方法的实现，类加载的工作又被代理给了defineClass方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                        String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                        Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>defineClass<br>defineClass方法主要是把字节数组转化为类的实例。同时definClass方法为final的，故不可以覆写。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">       <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">       URL url = res.getCodeSourceURL();</span><br><span class="line">       <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">           String pkgname = name.substring(<span class="number">0</span>, i);</span><br><span class="line">           <span class="comment">// Check if package already loaded.</span></span><br><span class="line">           Manifest man = res.getManifest();</span><br><span class="line">           definePackageInternal(pkgname, man, url);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Now read the class bytes and define the class</span></span><br><span class="line">       java.nio.ByteBuffer bb = res.getByteBuffer();</span><br><span class="line">       <span class="keyword">if</span> (bb != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// Use (direct) ByteBuffer:</span></span><br><span class="line">           CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">           CodeSource cs = <span class="keyword">new</span> CodeSource(url, signers);</span><br><span class="line">           sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">           <span class="keyword">return</span> defineClass(name, bb, cs);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">byte</span>[] b = res.getBytes();</span><br><span class="line">           <span class="comment">// must read certificates AFTER reading bytes.</span></span><br><span class="line">           CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">           CodeSource cs = <span class="keyword">new</span> CodeSource(url, signers);</span><br><span class="line">           sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">           <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length, cs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后几个defineClass 会落在几个Natice方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(</span><br><span class="line">    String name, <span class="keyword">byte</span>[] b, </span><br><span class="line">    <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">    ProtectionDomain pd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(</span><br><span class="line">    String name, <span class="keyword">byte</span>[] b, </span><br><span class="line">    <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">    ProtectionDomain pd, String source);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(</span><br><span class="line">        String name, java.nio.ByteBuffer b,</span><br><span class="line">        <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd,</span><br><span class="line">        String source);</span><br></pre></td></tr></table></figure><p>这里不做分析了。</p><h2><span id="总结">总结</span></h2><p>到此我们就分析完了整个ClassLoader的加载过程，其中有很多细节我们了解，我们下一章再去分析，下一章节，我们主要针对于JVM的源码分析一下JVM启动过程。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></li><li><a href="https://www.jianshu.com/p/f98c3acd8df8" target="_blank" rel="noopener">JDK基础概念及目录结构</a></li><li><a href="https://blog.csdn.net/socrj/article/details/43916221" target="_blank" rel="noopener">jdk 源码结构</a></li><li><a href="https://blog.csdn.net/rain_zhao_0102/article/details/106041697" target="_blank" rel="noopener">idea 查看sun包下源码</a></li><li><a href="https://www.jianshu.com/p/5c2cd08dfe89" target="_blank" rel="noopener">JVM类加载器-源码分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入JVM字节码(1)</title>
      <link href="/article/bytecode-analysis/"/>
      <url>/article/bytecode-analysis/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>作为一个Java开发者，对技术的追求而不仅仅停留在会用API，会写基本功能上，要想在技术上有更高的造诣，就需要深入到原理层面去认识代码运行的机制。因此，本文从class字节码文件的结构入手，一步步来解剖二进制字节码的内部工作原理，这对深入理解JVM的运行机制大有裨益，同时，对于想要使用BCEL来动态改变Class字节码指令的工作也很有帮助(示例：<a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">JVM Class字节码之三-使用BCEL改变类属性</a>)。</p><h2><span id="class文件">Class文件</span></h2><p>Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。</p><p>Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><p>class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。</p><p>java文件通过javac编译后将得到一个.class文件，编译后生成Bclass文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图所示。JVM对于字节码是有规范要求的,规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如下图所示。<br><img src="/article/bytecode-analysis/bytecode-analysis-1598414451478.png" alt></p><h2><span id="class文件的结构">Class文件的结构</span></h2><p>一个典型的class文件分为：<code>MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes</code>这十个部分，用一个数据结构可以表示如下：</p><p><img src="/article/bytecode-analysis/bytecode-analysis-1552027989197.png" alt></p><p>下面对class文件中的每一项进行详细的解释：</p><h3><span id="magic">magic</span></h3><p>在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： <code>0XCAFEBABE</code> 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是 <code>0XCAFEBABE，</code> 那么就说明它不是class文件， 不能被JVM识别。</p><h3><span id="minor_version-和-major_version">minor_version 和 major_version</span></h3><p>紧接着魔数的四个字节是class文件的此版本号和主版本号。<br>随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。具体的版本号变迁这里不再讨论， 需要的读者自行查阅资料。</p><h3><span id="constant_pool">constant_pool</span></h3><p>在class文件中， 位于版本号后面的就是常量池相关的数据项。</p><p>常量池是class文件中的一项非常重要的数据。<br>常量池中存放了<code>文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符</code>。</p><p>对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的<code>this_class, super_class, field_info, attribute_info</code>等。</p><p>另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外，常量池中各个项也会相互引用。</p><p>常量池是一个类的结构索引，其它地方对“对象”的引用可以通过索引位置来代替，我们知道在程序中一个变量可以不断地被调用，要快速获取这个变量常用的方法就是通过索引变量。这种索引我们可以直观理解为“<code>内存地址的虚拟</code>”。我们把它叫静态池的意思就是说这里维护着经过编译“梳理”之后的相对固定的数据索引，它是站在整个JVM（进程）层面的共享池。</p><p>class文件中的项<strong>constant_pool_count</strong>的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， <strong>没有间隙的依次排放</strong>。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的<strong>索引为1</strong>, 而不为0,<br><strong>如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项</strong>。class文件中的每一种数据项都有自己的类型， 相同的道理，常量池中的每一种数据项也有自己的类型。 常量池中的数据项的类型如下表：</p><p><img src="/article/bytecode-analysis/bytecode-analysis-1597212567599.png" alt></p><p>每个数据项叫做一个<strong>XXX_info</strong>项，比如，一个常量池中一个<strong>CONSTANT_Utf8</strong>类型的项，就是一个<strong>CONSTANT_Utf8_info</strong> 。除此之外， 每个info项中都有一个标志值（tag），这个标志值表明了这个常量池中的info项的类型是什么， 从上面的表格中可以看出，一个CONSTANT_Utf8_info中的tag值为1，而一个CONSTANT_Fieldref_info中的tag值为9 。</p><p>Java程序是动态链接的， 在动态链接的实现中， 常量池扮演者举足轻重的角色。 除了存放一些字面量之外， 常量池中还存放着以下几种符号引用：</p><ul><li>1） 类和接口的全限定名</li><li>2） 字段的名称和描述符</li><li>3） 方法的名称和描述符</li></ul><p>我们有必要先了解一下class文件中的特殊字符串， 因为在常量池中， 特殊字符串大量的出现，这些特殊字符串就是上面说的全限定名和描述符。对于常量池中的特殊字符串的了解，可以参考此文档：<a href="http://www.jb51.net/article/116313.htm" target="_blank" rel="noopener">Java class文件格式之特殊字符串_动力节点Java学院整理</a></p><h2><span id="access_flag">access_flag</span></h2><p>保存了当前类的访问权限</p><h2><span id="this_cass">this_cass</span></h2><p>保存了当前类的全局限定名在常量池里的索引</p><h2><span id="super-class">super class</span></h2><p>保存了当前类的父类的全局限定名在常量池里的索引</p><h2><span id="interfaces">interfaces</span></h2><p>保存了当前类实现的接口列表，包含两部分内容:</p><ul><li><code>interfaces_count</code> 指的是当前类实现的接口数目。</li><li><code>interfaces[]</code> 是包含interfaces_count个接口的全局限定名的索引的数组</li></ul><h2><span id="fields">fields</span></h2><p>保存了当前类的成员列表，包含两部分的内容：</p><ul><li><code>fields_count</code>是类变量和实例变量的字段的数量总和。</li><li><code>fileds[]</code>是包含字段详细信息的列表。</li></ul><h2><span id="methods">methods</span></h2><p>保存了当前类的方法列表，包含两部分的内容：</p><ul><li><code>methods_count</code>是该类或者接口显示定义的方法的数量。</li><li><code>method[]</code>是包含方法信息的一个详细列表。</li></ul><h2><span id="attributes">attributes</span></h2><p>包含了当前类的attributes列表，class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息,包含两部分内容：<br>class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。</p><ul><li><code>attributes_count</code>指的是 <code>attributes</code> 列表中包含的<code>attribute_info</code>的数量。</li><li><code>attributes[attributes_count]</code>   attributes列表</li></ul><p>属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。</p><ul><li>如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；</li><li>如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；</li><li>如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</li></ul><h2><span id="通过示例代码来手动分析class文件">通过示例代码来手动分析class文件</span></h2><p>上面大致讲解了一下class文件的结构，这里，我们拿一个class文件做一个简单的分析。</p><h2><span id="编译java文件">编译Java文件</span></h2><p>我们在这里新建一个java文件，ByteCodeShow.java，具体内容如下：(这里加上行数，后边会用到)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>| <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeShow</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>|     <span class="keyword">private</span> <span class="keyword">int</span> test;</span><br><span class="line"><span class="number">5</span>|     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">6</span>|          <span class="keyword">return</span> test;</span><br><span class="line"><span class="number">7</span>|     &#125;</span><br><span class="line"><span class="number">8</span>| &#125;</span><br></pre></td></tr></table></figure><p>然后再通过javac命令将此java文件编译成class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&gt; java -version</span><br><span class="line"></span><br><span class="line">java version <span class="string">"1.8.0_261"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_261-b12)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.261</span>-b12, mixed mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">$&gt; javac ByteCodeShow.java</span></span><br></pre></td></tr></table></figure><blockquote><p>注意我这里用的是<code>1.8.0_261</code> 版本</p></blockquote><p>编译之后的class文件十六进制结果如下所示，得到：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597216042924.png" alt><br>接下来我们就按照class文件的格式来分析上面的一串数字，还是按照之前的顺序来：</p><h2><span id="java文件字节码详解">Java文件字节码详解</span></h2><h3><span id="1-magic">1.  magic:</span></h3><p><code>CA FE BA BE</code> ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件</p><h3><span id="2-version字段">2. version字段：</span></h3><p><code>00 00 00 34</code>，前两个字节00是<code>minor_version</code>，后两个字节<code>0034</code>是<code>major_version</code>字段，对应的十进制值为<code>52</code>，也就是说当前class文件的主版本号为52，次版本号为0。下表是jdk 1.6 以后对应支持的 Class 文件版本号：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597217583447.png" alt></p><h3><span id="3-量池constant_pool">3. 量池，constant_pool:</span></h3><p>紧接着 version 字段下来的两个字节是：<code>00 12</code>代表常量池里包含的常量数目，因为字节码的常量池是从1开始计数的，这个常量池包含17(十进制为18)个（<code>0x0012-1</code>）常量。constant_pool:接下来就是分析这17个常量:</p><p>首先我们用<code>jclasslib bytecode viewer</code> 打开class 文件，来看一下这个class的常量分布。<br><img src="/article/bytecode-analysis/bytecode-analysis-1597220717605.png" alt></p><h4><span id="1-第一个变量-0a-00-04-00-0e">1. 第一个变量: <code>0A 00 04 00 0E</code></span></h4><p>首先，紧接着<code>constant_pool_count</code>的第一个字节：<code>0A</code>（<code>tag=10</code>）根据上面的表格表示 <code>CONSTANT_Methodref_info</code> 对类中声明方法的一个引用。<br>其结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">     u1 tag;             <span class="comment">//u1表示占一个字节 表示该方法所属的类在常量池里的索引</span></span><br><span class="line">     u2 class_index;    <span class="comment">//u2表示占两个字节 表示该方法的名称和类型的索引。常量池里的变量的索引从1开始。</span></span><br><span class="line">     u2 name_and_type_index;    <span class="comment">//u2表示占两个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示如下：</p><ul><li>0A    ：  tag  10表示这是一个<code>CONSTANT_Methodref_info</code>结构</li><li>00 04 ： class_index 指向常量池中第4个常量所表示的类</li><li>00 0E ： name_and_type_index 指向常量池中第14个常量所表示的方法</li></ul><h4><span id="2-第二个变量09-00-03-00-0f">2. 第二个变量<code>09 00 03 00 0F</code></span></h4><p>接着是第二个常量，它的<code>tag</code>是09，根据上面的表格可知，这表示的是一个<code>CONSTANT_Fieldref</code>的结构，它的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>09 :tag</li><li>00 03 :指向常量池中第3个常量所表示的类</li><li>00 0F :指向常量池中第15个常量所表示的变量</li></ul><h4><span id="3-第三个变量-07-00-10">3. 第三个变量 <code>07 00 10</code></span></h4><p>tag为<code>07</code>表示是一个<code>CONSTANT_Class</code>变量，这个变量的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">     u1 tag;         <span class="comment">// 07</span></span><br><span class="line">     u2 name_index;  <span class="comment">// 00 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了tag字段以外，还有一个name_index的值为<code>00 10</code>，即是指向常量池中第16个常量所表示的Class名称。</p><h4><span id="4-第四个变量07-00-11">4. 第四个变量<code>07 00 11</code></span></h4><p>同上，也是一个<code>CONSTANT_Class</code>变量，不过，指向的是第17个常量所表示的Class名称。</p><h4><span id="5-第五个变量-01-00-04-74-65-73-74">5. 第五个变量 <code>01 00 04 74 65 73 74</code></span></h4><p>tag为1，表示这是一个CONSTANT_Utf8结构，这种结构用UTF-8的一种变体来表示字符串，结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 length;     <span class="comment">//  length表示该字符串的字节数</span></span><br><span class="line">     u1 bytes[length];<span class="comment">//bytes字段包含该字符串的二进制表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>01 :tag  1表示这是一个CONSTANT_Utf8结构</li><li>00 04 :表示这个字符串的长度是4字节,也就是后面的四个字节74 65 73 74</li><li>74 65 73 74 :通过ASCII码表转换后，表示的是字符串<code>test</code><br>接下来的8个变量都是字符串，这里就不具体分析了。</li></ul><h4><span id="6-第十四个常量-0c-00-07-00-08">6. 第十四个常量 <code>0C 00 07 00 08</code></span></h4><p>tag为<code>0c</code>，表示这是一个<code>CONSTANT_NameAndType</code>结构，这个结构用来描述一个方法或者成员变量。具体结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">     u1 tag; </span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name_index表示的是该变量或者方法的名称，这里的值是0007，表示指向第7个常量，即是<code>&lt;init&gt;</code>。</li><li><code>descriptor_index</code>指向该方法的描述符的引用，这里的值是0008，表示指向第8个常量，即是<code>()V</code>，由前面描述符的语法可知，这个方法是一个无参的，返回值为void的方法。</li></ul><p>综合两个字段，可以推出这个方法是<code>void &lt;init&gt;()</code>。也即是指向这个NameAndType结构的Methodref的方法名为<code>void &lt;init&gt;()</code>，也就是说第一个常量表示的是<code>void &lt;init&gt;()</code>方法，这个方法其实就是此类的默认构造方法。</p><h4><span id="7-第十五个常量0c-00-05-00-06">7. 第十五个常量<code>0C 00 05 00 06</code></span></h4><p>也是一个<code>CONSTANT_NameAndType</code>，表示的方法名为<code>int test</code>，第2个常量引用了这个<code>NameAndType</code>，所以第二个常量表示的是<code>int test()</code>方法。</p><h4><span id="8-第16和17个常量也是字符串可以按照前面的方法分析">8. 第16和17个常量也是字符串，可以按照前面的方法分析。</span></h4><h4><span id="9-完整的常量池">9.  <strong>完整的常量池</strong></span></h4><p>最后，通过以上分析，完整的常量池如下：</p><table><thead><tr><th>序号</th><th>编码</th><th>长度</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>00 12</td><td>2</td><td>长度</td><td>常量池的数目 18-1=17</td></tr><tr><td>1</td><td>0A 00 04 00 0E</td><td>5</td><td>CONSTANT_Methodref_info</td><td>指向第4和第14个常量表示： 方法：java.lang.Ojbect void <init>()</init></td></tr><tr><td>2</td><td>09 00 03 00 0F</td><td>5</td><td>CONSTANT_Fieldref</td><td>指向第3和第15个常量表示： com.classLoader.ByteCodeShow int test() &lt;test:i&gt;</td></tr><tr><td>3</td><td>07 00 10</td><td>3</td><td>CONSTANT_Class_info</td><td>16个常量表示： com.classLoader.ByteCodeShow</td></tr><tr><td>4</td><td>07 00 11</td><td>3</td><td>CONSTANT_Class_info</td><td>17个常量表示： java.lang.Ojbect</td></tr><tr><td>5</td><td>01 00 04 74 65 73 74</td><td>7</td><td>CONSTANT_Utf8_info</td><td>4个字符串，4个byte数组：表示 字符串test</td></tr><tr><td>6</td><td>01 00 01 49</td><td>4</td><td>CONSTANT_Utf8_info</td><td>1个字符串 表示 I</td></tr><tr><td>7</td><td>01 00 06 3C 69 6E 69 74 3E</td><td>9</td><td>CONSTANT_Utf8_info</td><td>字符串: &lt;init&gt;</td></tr><tr><td>8</td><td>01 00 03 28 29 56</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串 ()V<init></init></td></tr><tr><td>9</td><td>01 00 04 43 6F 64 65</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串：Code</td></tr><tr><td>10</td><td>01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65</td><td>18</td><td>CONSTANT_Utf8_info</td><td>字符串：LineNumberTable</td></tr><tr><td>11</td><td>01 00 03 28 29 49</td><td>6</td><td>CONSTANT_Utf8_info</td><td>字符串：()I</td></tr><tr><td>12</td><td>01 00 0A 53 6F 75 72 63 65 46 69 6C 65</td><td>13</td><td>CONSTANT_Utf8_info</td><td>字符串：SourceFile</td></tr><tr><td>13</td><td>01 00 11 42 79 74 65 43 6F 64 65 53 68 6F 77 2E 6A 76 61</td><td>20</td><td>CONSTANT_Utf8_info</td><td>ByteCodeShow.java</td></tr><tr><td>14</td><td>0C 00 07 00 08</td><td>5</td><td>CONSTANT_NameAndType_info</td><td>引用第7 第8个变量：&lt;init&gt; ()V</td></tr><tr><td>15</td><td>0C 00 05 00 06</td><td>5</td><td>CONSTANT_NameAndType_info</td><td>引用第5 第6个变量：test I</td></tr><tr><td>16</td><td>01 00 1C 63 6F 6D 2F 63 6C 61 73 73 4C 6F 61 64 65 72 2F 42 79 74 65 43 6F 64 65 53 68 6F 77</td><td>31</td><td>CONSTANT_Utf8_info</td><td>字符串：com/classLoader/ByteCodeShow</td></tr><tr><td>17</td><td>01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</td><td>19</td><td>CONSTANT_Utf8_info</td><td>字符串：java/lang/Object</td></tr></tbody></table><p>通过这样分析其实非常的累，我们只是为了了解class文件的原理才来一步一步分析每一个二进制字节码。JDK提供了现成的工具可以直接解析此二进制文件，即javap工具(在JDK的bin目录下)，我们通过javap命令来解析此class文件：</p><p><code>javap -v -p -s -sysinfo -constants ByteCodeShow.class</code></p><p>解析得到的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$&gt; javap -v -p -s -sysinfo -constants ByteCodeShow<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Classfile</span> ... /<span class="title">src</span>/<span class="title">main</span>/<span class="title">java</span>/<span class="title">com</span>/<span class="title">classLoader</span>/<span class="title">ByteCodeShow</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-8-12</span>; size <span class="number">292</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">950e1f</span>3fd392c0f658144989ddee2453</span><br><span class="line">  Compiled from <span class="string">"ByteCodeShow.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">classLoader</span>.<span class="title">ByteCodeShow</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#14         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#15         // com/classLoader/ByteCodeShow.test:I</span><br><span class="line">   #3 = Class              #16            // com/classLoader/ByteCodeShow</span><br><span class="line">   #4 = Class              #17            // java/lang/Object</span><br><span class="line">   #5 = Utf8               test</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               ()I</span><br><span class="line">  #12 = Utf8               SourceFile</span><br><span class="line">  #13 = Utf8               ByteCodeShow.java</span><br><span class="line">  #14 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #15 = NameAndType        #5:#6          // test:I</span><br><span class="line">  #16 = Utf8               com/classLoader/ByteCodeShow</span><br><span class="line">  #17 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> test;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.classLoader.ByteCodeShow();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field test:I</span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"ByteCodeShow.java"</span></span><br></pre></td></tr></table></figure><p>关于此表每一项的详细分析，可以参考国外的这一篇文档：<a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a><br>关于此表中Method操作指令<code>aload_1,getfield,ireturn</code>的作用，可以参考云溪社区的这篇文章：<br><a href="https://yq.aliyun.com/articles/7242?spm=5176.100239.blogcont7243.8.3d63c7fjRFN0C" target="_blank" rel="noopener">JVM Class详解之二 Method字节码指令</a></p><p>接下来继续看其他的字段。</p><h3><span id="4-access_flagu200-21">4. access_flag(u2:00 21)</span></h3><p><code>00 21</code>这两个字节的数据表示这个变量的访问标志位，JVM对访问标示符的规范如下：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597224177466.png" alt></p><p>这个表里面无法直接查询到 <code>0021</code>这个值，原因是0021=0020+0001，也就是表示当前class的 <code>access_flag</code> 是<code>ACC_PUBLIC|ACC_SUPER</code>。<code>ACC_PUBLIC</code>和代码里的<code>public</code> 关键字相对应。<code>ACC_SUPER</code>表示当用<code>invokespecial</code>指令来调用父类的方法时需要特殊处理。</p><h3><span id="5-this_classu20003">5. this_class(u2:0003)</span></h3><p><code>00 03</code>, <code>this_class</code>指向<code>constant pool</code>的索引值，该值必须是<code>CONSTANT_Class_info</code>类型，这里是3，即指向常量池中的第三项，即是<code>com.classLoader.ByteCodeShow</code>。</p><h3><span id="6-super_classu20004">6. super_class(u2:0004)</span></h3><p><code>00 04</code>:super_class存的是父类的名称在常量池里的索引，这里指向第四个常量，即是“java/lang/Object”。</p><h3><span id="7-interfaces">7. interfaces</span></h3><p><code>interfaces</code>包含<code>interfaces_count和interfaces[]</code>两个字段。因为这里没有实现接口，所以就不存在<code>interfces</code>选项，所以这里的interfaces_count为0（0000），所以后面的内容也对应为空。</p><h3><span id="8-fields">8. fields</span></h3><ul><li>00 01 :fields count    //表示成员变量的个数，此处为1个</li><li>00 02 00 05 00 06 00 00  : //成员field_info 变量的结构</li></ul><p>每个成员变量对应一个<code>field_info</code>结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">     u2 access_flags;      <span class="comment">//0002</span></span><br><span class="line">     u2 name_index;        <span class="comment">//0005</span></span><br><span class="line">     u2 descriptor_index;  <span class="comment">//0006</span></span><br><span class="line">     u2 attributes_count;  <span class="comment">//0000</span></span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>access_flags为0002，即是<code>ACC_PRIVATE</code></p></li><li><p>name_index指向常量池的第五个常量，为“test”</p></li><li><p>descriptor_index指向常量池的第6个常量为“I”<br>三个字段结合起来，说明这个变量是”private int test”。</p></li><li><p>接下来的是<code>attribute</code>字段，用来描述该变量的属性，因为这个变量没有附加属性，所以<code>attributes_count</code>为0，<code>attribute_info</code>为空。</p></li></ul><h3><span id="9-methods">9. methods</span></h3><p><code>00 02 00 01 00 07 00 08 00 01 00 09 ...</code><br>最前面的2个字节是<code>method_count</code></p><ul><li><p>method_count：<code>00 02</code>，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个<code>&lt;init&gt;</code>方法，这个是类的默认构造方法。</p></li><li><p>method_info</p></li></ul><p>接下来的内容是两个<code>method_info</code>结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags; </span><br><span class="line">     u2 name_index;      </span><br><span class="line">     u2 descriptor_index; </span><br><span class="line">     u2 attributes_count; </span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>00 01 00 07 00 08 00 01</code> method:<br>前三个字段和field_info一样，可以分析出第一个方法是“public void ()”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">01</span> ACC_PUBLIC</span><br><span class="line"><span class="number">00</span> <span class="number">07</span>  &lt;init&gt;</span><br><span class="line"><span class="number">00</span> <span class="number">08</span>  V()</span><br></pre></td></tr></table></figure><ul><li>attribute_info</li></ul><p>接下来是<code>attribute</code>字段，也即是这个方法的附加属性，这里的<code>attributes_count =1</code>，也即是有一个属性。<br>每个属性的都是一个<code>attribute_info</code>结构，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index; <span class="comment">// 00 09</span></span><br><span class="line">     u4 attribute_length;     <span class="comment">// 00 00 00 1D</span></span><br><span class="line">     u1 info[attribute_length];  <span class="comment">// 表示 attribute 具体info</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 预定义了部分 <code>attribute</code>，但是编译器自己也可以实现自己的<code>attribute</code>写入class文件里，供运行时使用。不同的<code>attribute</code>通过<code>attribute_name_index</code>来区分。JVM规范里对以下attribute进行了很多的预定义：<br><img src="/article/bytecode-analysis/bytecode-analysis-1597226853638.png" alt></p><p>这里的<code>attribute_name_index</code>值为0009，表示指向第9个常量，即是<code>Code</code>。<code>Code Attribute</code>的作用是保存该方法的结构如所对应的字节码，具体的结构如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">     u2 attribute_name_index; </span><br><span class="line">     u4 attribute_length;  </span><br><span class="line">     u2 max_stack;       </span><br><span class="line">     u2 max_locals;     </span><br><span class="line">     u4 code_length;    </span><br><span class="line">     u1 code[code_length];    </span><br><span class="line">     u2 exception_table_length;  </span><br><span class="line">     &#123; </span><br><span class="line">          u2 start_pc;        </span><br><span class="line">          u2 end_pc;          </span><br><span class="line">          u2 handler_pc;      </span><br><span class="line">          u2 catch_type;      </span><br><span class="line">     &#125; exception_table[exception_table_length];</span><br><span class="line">     u2 attributes_count;    </span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>attribute_length</code>表示<code>attribute</code>所包含的字节数，这里为<code>0000001D</code>，即是39个字节，不包含<code>attribute_name_index</code>和<code>attribute_length</code>字段。</li><li><code>max_stack</code> 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里是0001</li><li><code>max_locals</code> 表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里是0001.</li><li>code_length表示该方法的所包含的字节码的字节数以及具体的指令码。  这里的字节码长度为<code>00000005</code>，即是后面的5个字节 <code>2A B7 00 01 B1</code>为对应的字节码指令的指令码。</li></ul><p>参照下表可以将上面的指令码翻译成对应的助记符：</p><table><thead><tr><th>指令编号</th><th>具体指令命令</th></tr></thead><tbody><tr><td>2a</td><td>aload_0</td></tr><tr><td>b7</td><td>invokespecial</td></tr><tr><td>00</td><td>nop</td></tr><tr><td>01</td><td>aconst_null</td></tr><tr><td>b1</td><td>return</td></tr></tbody></table><p>这即是该方法被调用时，虚拟机所执行的字节码</p><ul><li><p><code>exception_table</code>:这里存放的是处理异常的信息。每个<code>exception_table</code>表项由<code>start_pc，end_pc</code>，<code>handler_pc</code>，<code>catch_type</code>组成。</p></li><li><p><code>start_pc和end_pc</code>：表示在code数组中的从<code>start_pc</code>到<code>end_pc</code>处（包含<code>start_pc</code>，不包含<code>end_pc</code>）的指令抛出的异常会由这个表项来处理;</p></li><li><p><code>handler_pc</code>：表示处理异常的代码的开始处。<code>catch_type</code>表示会被处理的异常类型，它指向常量池里的一个异常类。当<code>catch_type</code>为0时，表示处理所有的异常，这个可以用来实现<code>finally</code>的功能。</p></li></ul><p>不过，这段代码里没有异常处理，所以<code>exception_table_length</code>为0000，所以我们不做分析。</p><p>接下来是该方法的附加属性，<code>attributes_count</code>为0001，表示有一个附加属性。</p><ul><li>attribute_name_index为<code>000A</code>，指向第十个常量，为<code>LineNumberTable</code>。这个属性用来表示<code>code</code>数组中的字节码和<code>java</code>代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数。<code>LineNumberTable</code>的结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 line_number_table_length;</span><br><span class="line">     &#123; u2 start_pc;</span><br><span class="line">     u2 line_number;</span><br><span class="line">&#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两个字段分别表示这个<code>attribute</code>的名称是<code>LineNumberTable</code>以及长度为<code>00000006</code>。接下来的<code>0001</code>表示<code>line_number_table_length</code>，表示<code>line_number_table</code>有一个表项，其中<code>start_pc</code>为 <code>00 00</code>，<code>line_number</code>为 <code>00 03</code>，表示第3行代码从code的第0个指令码开始。<br>我们第3行的代码恰好是定义这个类的类名</p><p>后面的内容是第二个方法，具体就不再分析了。</p><h3><span id="10-attributes">10. attributes</span></h3><p>最后剩下的内容是<code>attributes</code>，这里的<code>attributes</code>表示整个class文件的附加属性，不过结构还是和前面的<code>attribute</code>保持一致。<code>00 01</code>表示有一个attribute。<br>Attribute结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_name_index为000c，指向第12个常量，为<code>SourceFile</code>，说明这个属性是Source</li><li>attribute_length为00000002</li><li>sourcefile_index为000d，表示指向常量池里的第13个常量，为<code>ByteCodeShow.java</code>。<br>这个属性表明当前的class文件是从ByteCodeShow文件编译而来。</li></ul><p>好，让我们完整的感受一下字节码的全貌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">CA FE BA BE     &gt; magic</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span>     &gt; minor_version : major_version </span><br><span class="line"><span class="number">00</span> <span class="number">12</span>           &gt; constant_pool_count = <span class="number">17</span></span><br><span class="line">---------  constant_pool ----- </span><br><span class="line">[<span class="number">1</span>]: <span class="number">0</span>A <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">0</span>E    </span><br><span class="line">[<span class="number">2</span>]: <span class="number">09</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">0F</span>     </span><br><span class="line">[<span class="number">3</span>]: <span class="number">07</span> <span class="number">00</span> <span class="number">10</span> </span><br><span class="line">[<span class="number">4</span>]: <span class="number">07</span> <span class="number">00</span> <span class="number">11</span> </span><br><span class="line">[<span class="number">5</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> </span><br><span class="line">[<span class="number">6</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">49</span> </span><br><span class="line">[<span class="number">7</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">06</span> <span class="number">3</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>E </span><br><span class="line">[<span class="number">8</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> </span><br><span class="line">[<span class="number">9</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> </span><br><span class="line">[<span class="number">10</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">0F</span> <span class="number">4</span>C <span class="number">69</span> <span class="number">6</span>E <span class="number">65</span> <span class="number">4</span>E <span class="number">75</span> <span class="number">6</span>D <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>C <span class="number">65</span> </span><br><span class="line">[<span class="number">11</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">49</span> </span><br><span class="line">[<span class="number">12</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">0</span>A <span class="number">53</span> <span class="number">6F</span> <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> <span class="number">69</span> <span class="number">6</span>C <span class="number">65</span> </span><br><span class="line">[<span class="number">13</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">11</span> <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">53</span> <span class="number">68</span> <span class="number">6F</span> <span class="number">77</span> <span class="number">2</span>E <span class="number">6</span>A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> </span><br><span class="line">[<span class="number">14</span>]: <span class="number">0</span>C <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">08</span> </span><br><span class="line">[<span class="number">15</span>]: <span class="number">0</span>C <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">06</span>  </span><br><span class="line">[<span class="number">16</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>C <span class="number">63</span> <span class="number">6F</span> <span class="number">6</span>D <span class="number">2F</span> <span class="number">63</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">4</span>C <span class="number">6F</span> <span class="number">61</span> <span class="number">64</span> <span class="number">65</span> <span class="number">72</span> <span class="number">2F</span> <span class="number">42</span> <span class="number">79</span> <span class="number">74</span> <span class="number">65</span> <span class="number">43</span> <span class="number">6F</span> <span class="number">64</span> <span class="number">65</span> <span class="number">53</span> <span class="number">68</span> <span class="number">6F</span> <span class="number">77</span> </span><br><span class="line">[<span class="number">17</span>]: <span class="number">01</span> <span class="number">00</span> <span class="number">10</span> <span class="number">6</span>A <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2F</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">6</span>E <span class="number">67</span> <span class="number">2F</span> <span class="number">4F</span> <span class="number">62</span> <span class="number">6</span>A <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> </span><br><span class="line">---------  constant_pool end ----- </span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">21</span> &gt; access_flag (ACC_PUBLIC|ACC_SUPER)</span><br><span class="line"><span class="number">00</span> <span class="number">03</span> &gt; this_class (constant pool[<span class="number">3</span>] = com.classLoader.ByteCodeShow)</span><br><span class="line"><span class="number">00</span> <span class="number">04</span> &gt; super_class (constant pool[<span class="number">4</span>] = java.lang.Object)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> &gt; interfaces (empty)</span><br><span class="line">----------------- fields -------------------------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; fields count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">---fields.field_info[<span class="number">1</span>] (<span class="keyword">private</span> <span class="keyword">int</span> test)------</span><br><span class="line"><span class="number">00</span> <span class="number">02</span> &gt; access_flags (ACC_PRIVATE)</span><br><span class="line"><span class="number">00</span> <span class="number">05</span> &gt; name_index (constant pool[<span class="number">5</span>] = test)</span><br><span class="line"><span class="number">00</span> <span class="number">06</span> &gt; descriptor_index(constant pool[<span class="number">6</span>] = I)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> &gt; attributes_count</span><br><span class="line"></span><br><span class="line">(field_info[<span class="number">1</span>].attribute_info empty)</span><br><span class="line"></span><br><span class="line">---field_info[<span class="number">1</span>] end ------</span><br><span class="line"></span><br><span class="line">----------fields end ------------------</span><br><span class="line"></span><br><span class="line">--------- methods --------------:</span><br><span class="line"><span class="number">00</span> <span class="number">02</span>  &gt; method_count</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">1</span>](<span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()) -----------</span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; access_flags(ACC_PUBLIC)</span><br><span class="line"><span class="number">00</span> <span class="number">07</span> &gt; name_index(constant pool[<span class="number">7</span>]=&lt;init&gt;)</span><br><span class="line"><span class="number">00</span> <span class="number">08</span> &gt; descriptor_index (constant pool[<span class="number">8</span>]=V())</span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; attributes_count </span><br><span class="line">--------methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute) -------------</span><br><span class="line"><span class="number">00</span> <span class="number">09</span>           &gt; attribute_name_index(constant pool[<span class="number">8</span>]=Code [Code_attribute])</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1</span>D     &gt; attribute_length(<span class="number">39</span>)</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>           &gt; max_stack</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>           &gt; max_locals</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>     &gt; code_length</span><br><span class="line"><span class="number">2</span>A B7 <span class="number">00</span> <span class="number">01</span> B1  &gt; code</span><br><span class="line"><span class="number">00</span> <span class="number">00</span>           &gt; exception_table_length</span><br><span class="line">------ exception_table_length empty -----------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">01</span> &gt; attributes_count(methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute).attributes)</span><br><span class="line">---------- methods.method_info[<span class="number">1</span>].attribute_info[<span class="number">1</span>](Code_attribute).attributes</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">0</span>A       &gt; attribute_name_index(constant pool[<span class="number">10</span>]=LineNumberTable)</span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> &gt; attribute_length</span><br><span class="line"><span class="number">00</span> <span class="number">01</span>       &gt; line_number_table_length</span><br><span class="line"><span class="number">00</span> <span class="number">00</span>       &gt; start_pc</span><br><span class="line"><span class="number">00</span> <span class="number">03</span>       &gt; line_number</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">1</span>](<span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()) end -----------</span><br><span class="line"></span><br><span class="line">----------- methods.method_info[<span class="number">2</span>](<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span>) -----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 01 &gt; <span class="title">access_flags</span><span class="params">(ACC_PUBLIC)</span></span></span><br><span class="line"><span class="function">00 05 &gt; <span class="title">name_index</span><span class="params">(constant pool[<span class="number">5</span>]=tes)</span></span></span><br><span class="line"><span class="function">00 0B &gt; <span class="title">descriptor_index</span> <span class="params">(constant pool[<span class="number">11</span>]=I)</span></span></span><br><span class="line"><span class="function">00 01 &gt; attributes_count </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods.method_info[2].attribute_info[1]<span class="params">(Code_attribute)</span> -------------</span></span><br><span class="line"><span class="function">00 09           &gt; <span class="title">attribute_name_index</span><span class="params">(constant pool[<span class="number">8</span>]=Code [Code_attribute])</span></span></span><br><span class="line"><span class="function">00 00 00 1D     &gt; <span class="title">attribute_length</span><span class="params">(<span class="number">39</span>)</span></span></span><br><span class="line"><span class="function">00 01           &gt; max_stack</span></span><br><span class="line"><span class="function">00 01           &gt; max_locals</span></span><br><span class="line"><span class="function">00 00 00 05     &gt; code_length</span></span><br><span class="line"><span class="function">2A B4 00 02 AC  &gt; code</span></span><br><span class="line"><span class="function">00 00           &gt; exception_table_length</span></span><br><span class="line"><span class="function">------ exception_table_length empty -----------</span></span><br><span class="line"><span class="function">00 01 &gt; <span class="title">attributes_count</span><span class="params">(methods.method_info[<span class="number">2</span>].attribute_info[<span class="number">1</span>](Code_attribute)</span>.attributes)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---------- methods.method_info[2].attribute_info[1]<span class="params">(Code_attribute)</span>.attributes</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 0A       &gt; <span class="title">attribute_name_index</span><span class="params">(constant pool[<span class="number">10</span>]=LineNumberTable)</span></span></span><br><span class="line"><span class="function">00 00 00 06 &gt; attribute_length</span></span><br><span class="line"><span class="function">00 00       &gt; line_number_table_length</span></span><br><span class="line"><span class="function">00 00       &gt; start_pc</span></span><br><span class="line"><span class="function">00 06       &gt; line_number</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods.method_info[2] end ----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">--------methods end ----------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00 01  &gt; attributes count</span></span><br><span class="line"><span class="function">-------------- attributes[1]<span class="params">(SourceFile)</span> -------------</span></span><br><span class="line"><span class="function">00 0C       &gt; attribute_name_index</span></span><br><span class="line"><span class="function">00 00 00 02 &gt; attribute_length</span></span><br><span class="line"><span class="function">00 0D       &gt; <span class="title">sourcefile_index</span><span class="params">(constant pool[<span class="number">13</span>]=SourceFile)</span></span></span><br></pre></td></tr></table></figure><p>来看一下可视化的形式</p><ul><li>一般信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235336051.png" alt></li></ul><ul><li><p>字段信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235378949.png" alt></p></li><li><p>方法信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235407217.png" alt><br><img src="/article/bytecode-analysis/bytecode-analysis-1597235437611.png" alt></p></li><li><p>属性信息<br><img src="/article/bytecode-analysis/bytecode-analysis-1597235452547.png" alt></p></li></ul><h2><span id="字节码修改技术">字节码修改技术</span></h2><p>对<code>Java Class</code>字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。那通过了解字节码，我们可以做些什么呢？</p><p>其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节。</p><ul><li><p><code>ASM</code> 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p></li><li><p>目前字节码修改技术有ASM，javassist，cglib，BCEL等。cglib就是基于封装的Asm. Spring 就是使用cglib代理库。关于cglib的使用介绍，可以参考：<a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></p></li><li><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p></li></ul><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="http://blog.jamesdbloom.com/JavaCodeToByteCode_PartOne.html" target="_blank" rel="noopener">Java Code to Byte Code</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li><li><a href="http://www.cnblogs.com/paddix/p/5282004.html" target="_blank" rel="noopener">从字节码层面看“HelloWorld”</a></li><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM官网</a></li><li><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></li><li><a href="http://blog.csdn.net/danchu/article/details/70238002" target="_blank" rel="noopener">CGLIB(Code Generation Library)详解</a></li><li><a href="http://blog.csdn.net/anhuidelinger/article/details/8947791" target="_blank" rel="noopener">JVM之字节码——Class文件格式</a></li><li><a href="https://yq.aliyun.com/articles/7241?spm=5176.100239.blogcont7243.7.3d63c7fjRFN0C#" target="_blank" rel="noopener">云溪社区–JVM Class详解之一</a></li><li><a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">云溪社区–JVM Class字节码之三-使用BCEL改变类属性</a></li><li><a href="http://blog.csdn.net/yczz/article/details/14497897" target="_blank" rel="noopener">国外翻译文章：Java 编程的动态性，用 BCEL 设计字节码</a></li><li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(4)</title>
      <link href="/article/java-cms-gc/"/>
      <url>/article/java-cms-gc/</url>
      
        <content type="html"><![CDATA[<h2><span id="cms-垃圾回收器简介">CMS 垃圾回收器简介</span></h2><p>由于上一篇博文已经详细介绍了，这里就不在赘述，有兴趣可以围观一下<a href="https://icefrozen.github.io/article/Java-garbage-collection-analysis-2/" target="_blank" rel="noopener">Java垃圾回收详解(2)<br>GC方式介绍</a></p><p>这里做一个简单的回顾:</p><ul><li><p>获取最短回收停顿时间为目标的多线程并发收集器</p></li><li><p>cms 只会回收老年代和永久带（1.8开始为元数据区，需要设置- <code>CMSClassUnloadingEnabled</code>, <strong>不会收集年轻带</strong>；</p></li><li><p>cms 是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到<strong>92%</strong>；</p></li></ul><h2><span id="cms-过程详解">CMS 过程详解</span></h2><h2><span id="cms收集器的7个阶段">CMS收集器的7个阶段：</span></h2><ul><li><p>初始标记（CMS initial mark）</p></li><li><p>并发标记（CMS concurrent mark）</p></li><li><p>并发预清理（CMS concurrent-preclean）</p></li><li><p>并发可取消的预清理 （CMS concurrent-abortable-preclean）</p></li><li><p>重新标记（CMS remark）</p></li><li><p>并发清除（CMS concurrent sweep）</p></li><li><p>并发重置（CMS concurrent-reset）</p></li><li><p>流程大致如下<br><img src="/article/java-cms-gc/1552636690413java-cms-gc_.png" alt></p></li></ul><ul><li>具体过程如下<br><img src="/article/java-cms-gc/1552636737931java-cms-gc_.png" alt></li></ul><h2><span id="cms-阶段详解">CMS 阶段详解</span></h2><h3><span id="初始标记idling阶段">初始标记（Idling）阶段</span></h3><p>这是CMS中两次stop-the-world事件中的一次。这一步的作用是标记存活的对象，有两部分：</p><ol><li>标记老年代中所有的<code>GC Roots</code>对象，如下图节点1；</li><li>标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；<br><img src="/article/java-cms-gc/1552640918028java-cms-gc_.png" alt></li></ol><p>在Java语言里，可作为<a href="https://icefrozen.github.io/article/Java-garbage-collection-analysis-3/" target="_blank" rel="noopener">GC Roots对象</a>的包括如下几种：</p><ol><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；</li><li>方法区中的类静态属性引用的对象 ；</li><li>方法区中的常量引用的对象 ；</li><li>本地方法栈中JNI的引用的对象；</li></ol><p><strong><em>为了加快此阶段处理速度，减少停顿时间，可以开启初始标记并行化，<code>-XX:+CMSParallelInitialMarkEnabled</code>，同时调大并行标记的线程数，线程数不要超过cpu的核数</em></strong></p><h3><span id="并发标记-initialmarking阶段">并发标记 （InitialMarking）阶段</span></h3><p>从“初始标记”阶段标记的对象开始找出所有存活的对象,也就是从<code>GC_ROOTS</code> 触发，标记所有存活对象，由于第一次的结果，所以这次的标记并<strong>不需要STW</strong>。</p><p><strong>因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的</strong>。</p><p>否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；<br>并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；</p><p>如下图所示，也就是节点1、2、3，最终找到了节点4和5。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。<br><img src="/article/java-cms-gc/1552641393363java-cms-gc_.png" alt><br>最后将6标记为存活,如下图所示：<br><img src="/article/java-cms-gc/1552641923916java-cms-gc_.png" alt></p><ul><li><strong>Card Table 是什么</strong></li></ul><blockquote><p>HotSpot 的一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p></blockquote><h3><span id="预清理-precleaning-阶段">预清理 （Precleaning） 阶段</span></h3><p>通过参数 <code>CMSPrecleaningEnabled</code> 选择关闭该阶段，默认启用，主要做两件事情：</p><ol><li><p>处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象。</p></li><li><p>在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty，然后扫描这些dirty card</p></li></ol><h3><span id="可中断的预清理abortablepreclean阶段">可中断的预清理（AbortablePreclean）阶段</span></h3><p>该阶段发生是有前提的：</p><ul><li><p>CMS 由于是在老年代垃圾扫描，但是大部分的老年代对象都是被 <code>GC_ROOTS</code> 引用的，如上图的 current obj 这个对象，虽然在老年代，但是其引用还是在年轻带，并且在并发标记阶段，也有可能老年代的某些对象别重新被新生代的对象重新引用。所以在gc的时候<strong>不仅需要扫描老年代也需要扫描新生代确定 <code>GC_ROOTS</code></strong> 。</p></li><li><p>全量的扫描新生代和老年代会不会很慢？肯定会,CMS 号称是停顿时间最短的GC，如此长的停顿时间肯定是不能接受的。 生代Eden区的内存使用量大于参数<code>CMSScheduleRemarkEdenSizeThreshold</code> 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。</p></li><li><p>如果新生代很多，超过了上述的阈值,如果在扫描新生代前进行一次Minor GC，那么在下一阶段remard的时候，新生代的对象会很少，从而节省很多时间。</p></li><li><p>CMS 有两个参数：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMSScheduleRemarkEdenSizeThreshold</span><br><span class="line">CMSScheduleRemarkEdenPenetration</span><br></pre></td></tr></table></figure><p>默认值分别是2M、50%。两个参数组合起来的意思是预清理后，eden空间使用超过2M时启动可中断的并发预清理（<code>CMS-concurrent-abortable-preclean</code>），直到eden空间使用率达到50%时中断，进入remark阶段。</p><ul><li><p>如果能在可中止的预清理阶段发生一次 Minor GC,那就万事大吉、天下太平了。 这里有一个小问题,可终止的预清理要执行多长时间来保证发生一次Minor GC?答案是没法保证。道理很简单，因为垃圾回收是JVM自动调度的,什么时候进行GC我们控制不了。但此阶段总有一个执行时间吧？是的。</p></li><li><p>CMS提供了一个参数<code>CMSMaxAbortablePrecleanTime</code> ，默认为5S。只要到了5S，不管发没发生Minor GC，有没有到<code>CMSScheduleRemardEdenPenetration</code>都会中止此阶段，进入remark。如果在5S内还是没有执行Minor GC怎么办？CMS提供<code>CMSScavengeBeforeRemark</code>参数，使remark前强制进行一次Minor GC。</p></li></ul><p>这样做利弊都有。好的一面是减少了remark阶段的停顿时间;坏的一面是Minor GC后紧跟着一个remark pause。如此一来，停顿时间也比较久。</p><p>我们来结合日志来看一下这个阶段<br>CMS日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7688.150</span>: [CMS-concurrent-preclean-start]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.186</span>: [CMS-concurrent-preclean: <span class="number">0.034</span>/<span class="number">0.035</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.186</span>: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"></span><br><span class="line"><span class="number">7688.465</span>: [GC <span class="number">7688.465</span>: [ParNew: <span class="number">1040940</span>K-&gt;<span class="number">1464</span>K(<span class="number">1044544</span>K), <span class="number">0.0165840</span> secs] <span class="number">1343593</span>K-&gt;<span class="number">304365</span>K(<span class="number">2093120</span>K), </span><br><span class="line"></span><br><span class="line"><span class="number">0.0167509</span> secs]<span class="number">7690.093</span>: [CMS-concurrent-abortable-preclean: <span class="number">1.012</span>/<span class="number">1.907</span> secs]  <span class="number">7690.095</span>: [GC[YG occupancy: <span class="number">522484</span> K (<span class="number">1044544</span> K)]</span><br><span class="line"></span><br><span class="line"><span class="number">7690.095</span>: [Rescan (parallel) , <span class="number">0.3665541</span> secs]<span class="number">7690.462</span>: [weak refs processing, <span class="number">0.0003850</span> secs] [<span class="number">1</span> CMS-remark: <span class="number">302901</span>K(<span class="number">1048576</span>K)] <span class="number">825385</span>K(<span class="number">2093120</span>K), <span class="number">0.3670690</span> secs]</span><br></pre></td></tr></table></figure><p>7688.186启动了可终止的预清理，在随后的三秒内启动了Minor GC，然后进入了Remark阶段.实际上为了减少remark阶段的STW时间</p><h3><span id="重新标记finalmarking">重新标记（FinalMarking）</span></h3><p>这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。<br>这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做cms的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:当此阶段耗时较长的时候，可以加入参数<code>-XX:+CMSScavengeBeforeRemark</code>，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间。<br>由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。</p><p>另外，还可以开启并行收集：-XX:+CMSParallelRemarkEnabled</p><h3><span id="并发清理-cms-concurrent-sweep">并发清理 （ CMS-concurrent-sweep ）</span></h3><p>这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。注意这个阶段会产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。</p><h3><span id="并发重置-cms-concurrent-reset">并发重置 （ CMS-concurrent-reset ）</span></h3><p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p><h2><span id="cms-调优">CMS 调优</span></h2><h2><span id="cms-jvm-参数">CMS JVM 参数</span></h2><table><thead><tr><th>参数名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>-XX:+<code>PrintCommandLineFlags</code></td><td style="text-align:left">打印出启动参数行</td></tr><tr><td>-XX:+<code>UseConcMarkSweepGC</code></td><td style="text-align:left">参数指定使用CMS垃圾回收器</td></tr><tr><td>-XX:+<code>UseCMSInitiatingOccupancyOnly</code></td><td style="text-align:left">命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过 <code>CMSInitiatingOccupancyFraction</code> 的值进行每一次CMS收集，而不仅仅是第一次。然而，请记住大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。因此，只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应该使用该标志。</td></tr><tr><td>-XX:<code>CMSInitiatingOccupancyFraction</code>=80</td><td style="text-align:left">参数指定CMS垃圾回收器在老年代达到80%的时候开始工作，如果不指定那么默认的值为92%</td></tr><tr><td>-XX:+<code>CMSClassUnloadingEnabled</code></td><td style="text-align:left">开启永久带（jdk1.8以下版本）或元数据区（jdk1.8及其以上版本）收集，如果没有设置这个标志，一旦永久代或元数据区耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC</td></tr><tr><td>-XX:+<code>UseParNewGC</code></td><td style="text-align:left">使用cms时默认这个参数就是打开的，不需要配置，cms只回收老年代，年轻带只能配合Parallel New或Serial回收器；</td></tr><tr><td>-XX:+<code>CMSParallelRemarkEnabled</code></td><td style="text-align:left">减少Remark阶段暂停的时间，启用并行Remark，如果Remark阶段暂停时间长，可以启用这个参数  用于重新标记阶段是否采用多线程并行执行</td></tr><tr><td>-XX:+CMSScavengeBeforeRemark</td><td style="text-align:left">若Remark阶段暂停时间太长，可以启用这个参数，在Remark执行之前，先做一次ygc。因为这个阶段，年轻带也是cms的gcroot，cms会扫描年轻带指向老年代对象的引用，如果年轻带有大量引用需要被扫描，会让Remark阶段耗时增加</td></tr><tr><td>-XX:<code>CMSFullGCsBeforeCompaction</code>=0 <br>-XX:+<code>UseCMSCompactAtFullCollection</code></td><td style="text-align:left">两个参数是针对cms垃圾回收器碎片做优化的，CMS是不会移动内存的， 运行时间长了，会产生很多内存碎片， 导致没有一段连续区域可以存放大对象，出现<code>promotion failed</code>、<code>concurrent mode failure</code>, 导致fullgc，启用<code>UseCMSCompactAtFullCollection</code> 在FULL GC的时候， 对年老代的内存进行压缩。<code>-XX:CMSFullGCsBeforeCompaction=0</code> 则是代表多少次FGC后对老年代做压缩操作，默认值为0，代表每次都压缩, 把对象移动到内存的最左边，可能会影响性能,但是可以消除碎片,这两个错误会在后面的章节中详细介绍</td></tr><tr><td>-XX:+<code>CMSConcurrentMTEnabled</code> <br> -XX:<code>ConcGCThreads</code>=4</td><td style="text-align:left">定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。如果未设置这个参数，JVM会根据并行收集器中的<code>-XX:ParallelGCThreads</code>参数的值来计算出默认的并行CMS线程数,此字段如果不清楚的情况下不要设置<br><code>ParallelGCThreads = (ncpus &lt;=8 ? ncpus : 8+(ncpus-8)*5/8)</code>(ncpus为cpu个数)<br><code>ConcGCThreads =(ParallelGCThreads + 3)/4</code></td></tr><tr><td>-XX:+<code>ExplicitGCInvokesConcurrent</code> <br>-XX:+<code>ExplicitGCInvokesConcurrentAndUnloadsClasses</code></td><td style="text-align:left">开启foreground CMS GC，CMS gc 有两种模式，background和foreground，正常的cms gc使用background模式，就是我们平时说的cms gc；当并发收集失败或者调用了System.gc()的时候，就会导致一次full gc，这个fullgc是不是cms回收，而是Serial单线程回收器，加入了参数<code>-XX:+ExplicitGCInvokesConcurrent</code>后，执行full gc的时候，就变成了CMS foreground gc，它是并行full gc，只会执行cms中stop the world阶段的操作，效率比单线程Serial full GC要高；需要注意的是它只会回收old，因为cms收集器是老年代收集器；而正常的Serial收集是包含整个堆的，加入了参数<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>,代表永久带也会被cms收集；</td></tr><tr><td>-XX:+CMSParallelInitialMarkEnabled</td><td style="text-align:left">初始标记阶段是否采用多线程并行执行</td></tr><tr><td>- -XX:+PrintGCDetails</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCCause</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCTimeStamps</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -XX:+PrintGCDateStamps</td><td style="text-align:left">日志详细打印参数</td></tr><tr><td>- -Xloggc:…/logs/gc.log</td><td style="text-align:left">日志详细打印参数</td></tr></tbody></table><h2><span id="日志分析">日志分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [GC (CMS Final Remark)</span><br><span class="line">  [YG occupancy: <span class="number">199103</span> K (<span class="number">306688</span> K)]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [Rescan (parallel) , <span class="number">0.0027865</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.293</span>-<span class="number">0800</span>: <span class="number">6.966</span>: [weak refs processing, <span class="number">0.0000397</span> secs]</span><br><span class="line">  2017-07-27T10:42:56.294-0800: 6.966: [class unloading, 0.0004163 secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.294</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub symbol table, <span class="number">0.0006806</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.295</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub string table, <span class="number">0.0001862</span> secs]</span><br><span class="line">  [<span class="number">1</span> CMS-remark: <span class="number">1569615</span>K(<span class="number">1756416</span>K)]</span><br><span class="line">  <span class="number">1768718</span>K(<span class="number">2063104</span>K),</span><br><span class="line"><span class="number">0.0043575</span> secs]</span><br><span class="line">[Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [GC (CMS Final Remark（最终标记阶段，标记老年代中所有存活的对象，包括在此前的并发标记过程中创建/修改的引用）)</span><br><span class="line">  [YG occupancy: <span class="number">199103</span> K（当前年轻代的使用量） (<span class="number">306688</span> K（年轻代总大小）)]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.291</span>-<span class="number">0800</span>: <span class="number">6.963</span>: [Rescan (parallel) , <span class="number">0.0027865</span> secs]（在程序暂停时重新进行扫描，以完成存活对象的标记。此时 Rescan 是并行执行的）</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.293</span>-<span class="number">0800</span>: <span class="number">6.966</span>: [weak refs processing, <span class="number">0.0000397</span> secs]（第一个子阶段，处理弱引用）</span><br><span class="line">  2017-07-27T10:42:56.294-0800: 6.966: [class unloading, 0.0004163 secs]（第二个子阶段，卸载不使用的类）</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.294</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub symbol table, <span class="number">0.0006806</span> secs]</span><br><span class="line">  <span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span>T10:<span class="number">42</span>:<span class="number">56.295</span>-<span class="number">0800</span>: <span class="number">6.967</span>: [scrub string table, <span class="number">0.0001862</span> secs]（最后一个子阶段，清理持有 <span class="class"><span class="keyword">class</span> 级别 <span class="title">metadata</span> 的符号表，以及内部化字符串对应的 <span class="title">string</span> <span class="title">tables</span>）</span></span><br><span class="line">  [1 CMS-remark: 1569615K(1756416K)]（此阶段完成后老年代的使用量和总容量）</span><br><span class="line">  <span class="number">1768718</span>K(<span class="number">2063104</span>K),（此阶段完成后整个堆内存的使用量和总容量）</span><br><span class="line"><span class="number">0.0043575</span> secs]</span><br><span class="line">[Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><h2><span id="cms-gc-分析">CMS gc 分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/第一步 初始标记 这一步会停顿</span><br><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: <span class="number">299570</span>K(<span class="number">307200</span>K)] <span class="number">323315</span>K(<span class="number">491520</span>K), <span class="number">0.0026208</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.345</span>: CMS_Initial_Mark                 [      <span class="number">10</span>          <span class="number">0</span>              <span class="number">1</span>    ]      [     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>    ]  <span class="number">0</span>   </span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0028494</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步 并发标记</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.012</span>/<span class="number">0.012</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步 预清理</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.001</span>/<span class="number">0.001</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步 可被终止的预清理</span></span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第五步 重新标记</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 72704 K (184320 K)][Rescan (parallel) , 0.0009069 secs][weak refs processing, 0.0000083 secs][class unloading, 0.0002626 secs][scrub symbol table, 0.0003789 secs][scrub string table, 0.0001326 secs][1 CMS-remark: 299570K(307200K)] 372275K(491520K), 0.0017842 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] </span><br><span class="line">         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.360</span>: CMS_Final_Remark                 [      <span class="number">10</span>          <span class="number">0</span>              <span class="number">1</span>    ]      [     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>    ]  <span class="number">0</span>   </span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0018800</span> seconds</span><br><span class="line"><span class="comment">//第六步 清理</span></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.007</span>/<span class="number">0.007</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="comment">//第七步 重置</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.002</span>/<span class="number">0.002</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure><p>CMS 的处理流程讲完了，由于篇幅有些长，分一下章节，下次会围绕CMS 的后续问题 展开一些讨论 欢迎阅读。</p><hr><h2><span id="参考">参考:</span></h2><p><a href="http://120.52.51.16/www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf" target="_blank" rel="noopener">垃圾回收统一理论</a><br><a href="http://www.math.grin.edu/~rebelsky/Courses/CS302/99S/Presentations/GC/" target="_blank" rel="noopener">Introduction to Garbage Collection</a><br><a href="https://hllvm-group.iteye.com/group/topic/38223" target="_blank" rel="noopener">R大：并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为? </a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为? </a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(6)</title>
      <link href="/article/java-cms-gc-log/"/>
      <url>/article/java-cms-gc-log/</url>
      
        <content type="html"><![CDATA[<h2><span id="定位gc日志中stw时间较长的行为">定位GC日志中STW时间较长的行为</span></h2><h4><span id="打印所有stw停顿">打印所有STW停顿</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCApplicationStoppedTime和-XX:+PrintGCApplicationConcurrentTime</span><br></pre></td></tr></table></figure><h4><span id="找出所有暂停时间超过阈值的地方如下">找出所有暂停时间超过阈值的地方，如下：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;match($0,/.*stopped:(.*)seconds,/,a);if(a[1]&gt;0.5) print $0&#125;&apos; /data1/proxy_web_release/gclogs/gc.log.20170617_015811</span><br></pre></td></tr></table></figure><h2><span id="gc-常见问题">GC 常见问题</span></h2><h3><span id="promotion-failed">promotion failed</span></h3><p>GC日志中有时候会发现如下类似的带有“promotion failed”的日志，伴随着这类日志一般都会有较长的STW暂停时间，因此也会对线上应用造成较大影响。接下来对“promotion failed”这种GC异常情况进行一下分析：<br>一个常见的promotion failed的gc日志示例：</p><p><code class="hljs css">2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:20</span><span class="hljs-class">.381</span>+0800: 77708<span class="hljs-class">.486</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-06-17T23:33:20.382+0800: 77708.487: [ParNew (promotion failed): 3774912K-&gt;3679034K(3774912K), 0.2991519 secs]</span>2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:20</span><span class="hljs-class">.681</span>+0800: 77708<span class="hljs-class">.786</span>: <span class="hljs-attr_selector">[CMS: 3270027K-&gt;3522738K(6291456K), 1.9341892 secs]</span> 6332035<span class="hljs-tag">K-</span>&gt;3522738<span class="hljs-tag">K</span>(10066368<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 71553K-&gt;71553K(1116160K)]</span>, 2<span class="hljs-class">.2340311</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=5.61 sys=0.06, real=2.24 secs]</span><br>2017<span class="hljs-tag">-06-17T23</span><span class="hljs-pseudo">:33</span><span class="hljs-pseudo">:22</span><span class="hljs-class">.616</span>+0800: 77710<span class="hljs-class">.721</span>: <span class="hljs-tag">Total</span> <span class="hljs-tag">time</span> <span class="hljs-tag">for</span> <span class="hljs-tag">which</span> <span class="hljs-tag">application</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">were</span> <span class="hljs-tag">stopped</span>: 2<span class="hljs-class">.2411722</span> <span class="hljs-tag">seconds</span>, <span class="hljs-tag">Stopping</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">took</span>: 0<span class="hljs-class">.0002553</span> <span class="hljs-tag">seconds</span><br></code></p><p>young gc 在2017-06-17T23:33:20.382触发，young gc过程花费时间为0.2991519 s，回收前后整个young区占用内存从3774912K变为3679034K。随后触发了一次Full GC来对整个堆进行STW的回收，年老代GC回收花了1.9341892 s，回收后年老代空间从3270027K变成3522738K（整个年轻代对象都promote到年老代去了），整个JVM堆空间从6332035K降低到3522738K。整个Full GC花费的时间是 2.24s（业务线程暂停时间）。</p><h4><span id="promotion-failed发生的场景">promotion failed发生的场景</span></h4><p>young GC时，对象需要从年轻代提升到年老代，但年老代可用空间由于各种原因存放不下这些对象，这时会抛出promotion failed，然后触发一次Full GC来对年老代和永久代（metaspace）进行回收，所以发生promotion failed时是会暂停业务线程引起停顿的，需要特别留意。</p><h4><span id="什么情况下对象会从年轻代往年老代提升呢">什么情况下对象会从年轻代往年老代提升呢？</span></h4><ul><li>年轻代中对象到达一定年龄的对象在minor gc时会向年老代提升。</li><li>minor gc时一个survivor空间无法装下所有年轻代存活的对象时，部分未到达年龄的对象也会向年老代提前提升。</li></ul><h4><span id="young-gc的悲观策略">Young GC的“悲观策略”</span></h4><p>有的情况下，如果JVM判断本次young GC需要提升的大小年老代放不下就会放弃本次young GC，而是直接触发一次Full GC。这种情况被称为young GC的”悲观策略“。ParNew收集器里”悲观策略“相关判断逻辑在ParNewGeneration的collect里，collection_attempt_is_safe定义在基类DefNewGeneration里，将真正的判断逻辑_next_gen-&gt;promotion_attempt_is_safe交给了next_gen（也就是CMS回收器），promotion_attempt_is_safe代码在ConcurrentMarkSweepGeneration里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the next generation is too full to accommodate worst-case promotion</span></span><br><span class="line">  <span class="comment">// from this generation, pass on collection; let the next generation</span></span><br><span class="line">  <span class="comment">// do it.</span></span><br><span class="line">  <span class="keyword">if</span> (!collection_attempt_is_safe()) &#123;</span><br><span class="line">    gch-&gt;set_incremental_collection_failed();  <span class="comment">// slight lie, in that we did not even attempt one</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool DefNewGeneration::collection_attempt_is_safe() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!to()-&gt;is_empty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">" :: to is not empty :: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_next_gen == NULL) &#123;</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    _next_gen = gch-&gt;next_gen(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _next_gen-&gt;promotion_attempt_is_safe(used());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="cms预测本次young-gc需要promote的大小老年代是否可以放下的条件是">CMS预测本次young gc需要promote的大小老年代是否可以放下的条件是：</span></h4><ul><li>老年代可用空间大于gc_stats统计的新生代每次平均晋升的大小。</li><li>老年代可以容纳目前新生代的所有对象。</li></ul><p>两个条件满足一个即可正常触发young GC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool ConcurrentMarkSweepGeneration::promotion_attempt_is_safe(size_t max_promotion_in_bytes) <span class="keyword">const</span> &#123;</span><br><span class="line">  size_t available = max_available();</span><br><span class="line">  size_t av_promo  = (size_t)gc_stats()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">  bool   res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes);</span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print_cr(</span><br><span class="line">      <span class="string">"CMS: promo attempt is%s safe: available("</span> SIZE_FORMAT <span class="string">") %s av_promo("</span> SIZE_FORMAT <span class="string">"),"</span></span><br><span class="line">      <span class="string">"max_promo("</span> SIZE_FORMAT <span class="string">")"</span>,</span><br><span class="line">      res? <span class="string">""</span>:<span class="string">" not"</span>, available, res? <span class="string">"&gt;="</span>:<span class="string">"&lt;"</span>,</span><br><span class="line">      av_promo, max_promotion_in_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下这次GC情况就是触发了young GC的“悲观策略”，实际这次young GC没有执行，而是直接进行了一次Full GC。：</p><p><code class="hljs css">2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.761</span>+0800: 274170<span class="hljs-class">.361</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-09-24T20:18:01.762+0800: 274170.362: [ParNew: 6291456K-&gt;6291456K(7864320K), 0.0000411 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;18389797<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0011756</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.763</span>+0800: 274170<span class="hljs-class">.362</span>: <span class="hljs-attr_selector">[Full GC (Allocation Failure) 2018-09-24T20:18:01.763+0800: 274170.363: [CMS: 12098341K-&gt;12111250K(12582912K), 6.4734175 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;12111250<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 82207K-&gt;82207K(1124352K)]</span>, 6<span class="hljs-class">.4746029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.90 sys=1.03, real=6.48 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:08</span><span class="hljs-class">.238</span>+0800: 274176<span class="hljs-class">.838</span>: <span class="hljs-tag">Total</span> <span class="hljs-tag">time</span> <span class="hljs-tag">for</span> <span class="hljs-tag">which</span> <span class="hljs-tag">application</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">were</span> <span class="hljs-tag">stopped</span>: 6<span class="hljs-class">.5035487</span> <span class="hljs-tag">seconds</span>, <span class="hljs-tag">Stopping</span> <span class="hljs-tag">threads</span> <span class="hljs-tag">took</span>: 0<span class="hljs-class">.0008020</span> <span class="hljs-tag">seconds</span><br></code></p><p>因此，当GC log出现promotion failed时肯定是不满足”悲观策略“的判断进行了并行的新生代的垃圾回收，在最后往年老代提升空间不够时才报出的。</p><h4><span id="promotion-failed时触发的full-gc的两种情况">promotion failed时触发的Full GC的两种情况</span></h4><p>采用CMS作为老年代垃圾回收器的时候，当发生promotion failed时会触发一次Full GC，但这次Full GC可能存在两种情况。JVM根据某些条件判断本次Full GC是否需要“整理”来决定这次Full GC是使用单线程的带标记整理（mark-sweep-compact）的Serial GC的算法（do_compaction_work）来进行整个堆的垃圾回收，还是使用CMS自己的mark-sweep（do_mark_sweep_work）来做一次 多线程的foregroud GC 来对老年代进行回收。<br>是否需要整理的判断条件如下:</p><ul><li><ol><li>UseCMSCompactAtFullCollection参数开启（默认开启）。</li></ol></li><li><ol start="2"><li>上次正常的backgroud GC后Full GC（全局Full GC或者老年代foreground GC）的次数_full_gcs_since_conc_gc（每次background GC执行完sweeping阶段就会设置为0）达到启动参数设置的阈值CMSFullGCsBeforeCompaction（默认是0，也就是默认就是每次都“compact”）。</li></ol></li><li><ol start="3"><li>如果是用户触发的System GC，那么直接进行compact。</li></ol></li><li><ol start="4"><li>如果上一次young gc晋升时失败了(incremental_collection_failed为true)或者“预测本次晋升可能失败”，那么也直接进行compact。</li></ol></li></ul><p>所以实际上发现，能走到并行的foregroud GC的条件比较苛刻，默认情况下都是执行单线程带compact的Serial Old GC算法（Lisp2算法实现，在genMarkSweep.cpp中）来对整个堆进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*should_compact =</span><br><span class="line">    UseCMSCompactAtFullCollection &amp;&amp;</span><br><span class="line">    ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||</span><br><span class="line">     GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||</span><br><span class="line">     gch-&gt;incremental_collection_will_fail(<span class="keyword">true</span> <span class="comment">/* consult_young */</span>));</span><br><span class="line">  ...</span><br><span class="line"> <span class="function">bool <span class="title">incremental_collection_will_fail</span><span class="params">(bool consult_young)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">assert</span>(heap()-&gt;collector_policy()-&gt;is_two_generation_policy(),</span><br><span class="line">           <span class="string">"the following definition may not be suitable for an n(&gt;2)-generation system"</span>);</span><br><span class="line">    <span class="keyword">return</span> incremental_collection_failed() ||</span><br><span class="line">           (consult_young &amp;&amp; !get_gen(<span class="number">0</span>)-&gt;collection_attempt_is_safe());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4><span id="msc实现的serial-old-gc">MSC实现的Serial Old GC</span></h4><p>如果需要压缩就使用“带压缩”算法的单线程的Serial Old GC来进行整堆的Full GC，否则使用CMS自己的多线程的foreground GC来对老年代进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (should_compact) &#123;</span><br><span class="line">    <span class="comment">// If the collection is being acquired from the background</span></span><br><span class="line">    <span class="comment">// collector, there may be references on the discovered</span></span><br><span class="line">    <span class="comment">// references lists that have NULL referents (being those</span></span><br><span class="line">    <span class="comment">// that were concurrently cleared by a mutator) or</span></span><br><span class="line">    <span class="comment">// that are no longer active (having been enqueued concurrently</span></span><br><span class="line">    <span class="comment">// by the mutator).</span></span><br><span class="line">    <span class="comment">// Scrub the list of those references because Mark-Sweep-Compact</span></span><br><span class="line">    <span class="comment">// code assumes referents are not NULL and that all discovered</span></span><br><span class="line">    <span class="comment">// Reference objects are active.</span></span><br><span class="line">    ref_processor()-&gt;clean_up_discovered_references();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">      save_heap_summary();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do_compaction_work(clear_all_soft_refs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the GC time limit been exceeded?</span></span><br><span class="line">    DefNewGeneration* young_gen = _young_gen-&gt;as_DefNewGeneration();</span><br><span class="line">    size_t max_eden_size = young_gen-&gt;max_capacity() -</span><br><span class="line">                           young_gen-&gt;to()-&gt;capacity() -</span><br><span class="line">                           young_gen-&gt;from()-&gt;capacity();</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    GCCause::Cause gc_cause = gch-&gt;gc_cause();</span><br><span class="line">    size_policy()-&gt;check_gc_overhead_limit(_young_gen-&gt;used(),</span><br><span class="line">                                           young_gen-&gt;eden()-&gt;used(),</span><br><span class="line">                                           _cmsGen-&gt;max_capacity(),</span><br><span class="line">                                           max_eden_size,</span><br><span class="line">                                           full,</span><br><span class="line">                                           gc_cause,</span><br><span class="line">                                           gch-&gt;collector_policy());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_mark_sweep_work(clear_all_soft_refs, first_state,</span><br><span class="line">      should_start_over);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>MSC的具体实现在GenMarkSweep类中（genMarkSweep.cpp)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concurrentMarkSweepGeneration.cpp</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::do_compaction_work(bool clear_all_soft_refs) &#123;</span><br><span class="line">...</span><br><span class="line">GenMarkSweep::invoke_at_safepoint(_cmsGen-&gt;level(),</span><br><span class="line">    ref_processor(), clear_all_soft_refs);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//genMarkSweep.cpp</span></span><br><span class="line"><span class="keyword">void</span> GenMarkSweep::invoke_at_safepoint(<span class="keyword">int</span> level, ReferenceProcessor* rp, bool clear_all_softrefs) &#123;</span><br><span class="line">  guarantee(level == <span class="number">1</span>, <span class="string">"We always collect both old and young."</span>);</span><br><span class="line">  <span class="keyword">assert</span>(SafepointSynchronize::is_at_safepoint(), <span class="string">"must be at a safepoint"</span>);</span><br><span class="line"></span><br><span class="line">  GenCollectedHeap* gch = GenCollectedHeap::heap(); <span class="comment">//处理整个堆</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h4><span id="并行的foreground-gc">并行的foreground GC</span></h4><p>如果使用并行的foreground GC，整个过程都是暂停应用的，而且是<em>同步</em>的（但仍然是多线程进行处理），为了提高效率，会跳过其中一些阶段。那么这些省下来的阶段主要是并行阶段：Precleaning、AbortablePreclean，Resizing。<br>另外，如果当前backgroud的GC正在进行中，如果走到了foreground GC，那么foreground GC会在下一个安全点接管未完成的backgroud GC的后续步骤，这样还能跳过一些之前backgroud GC已经完成的阶段。</p><p>concurrentMarkSweepGeneration.cpp中相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A work method used by the foreground collector to do</span></span><br><span class="line"><span class="comment">// a mark-sweep, after taking over from a possibly on-going</span></span><br><span class="line"><span class="comment">// concurrent mark-sweep collection.</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::do_mark_sweep_work(bool clear_all_soft_refs,</span><br><span class="line">  CollectorState first_state, bool should_start_over) &#123;</span><br><span class="line">  <span class="keyword">if</span> (PrintGC &amp;&amp; Verbose) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print_cr(<span class="string">"Pass concurrent collection to foreground "</span></span><br><span class="line">      <span class="string">"collector with count %d"</span>,</span><br><span class="line">      _full_gcs_since_conc_gc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">    <span class="keyword">case</span> Idling:</span><br><span class="line">      <span class="keyword">if</span> (first_state == Idling || should_start_over) &#123;</span><br><span class="line">        <span class="comment">// The background GC was not active, or should</span></span><br><span class="line">        <span class="comment">// restarted from scratch;  start the cycle.</span></span><br><span class="line">        _collectorState = InitialMarking;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If first_state was not Idling, then a background GC</span></span><br><span class="line">      <span class="comment">// was in progress and has now finished.  No need to do it</span></span><br><span class="line">      <span class="comment">// again.  Leave the state as Idling.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="comment">// In the foreground case don't do the precleaning since</span></span><br><span class="line">      <span class="comment">// it is not done concurrently and there is extra work</span></span><br><span class="line">      <span class="comment">// required.</span></span><br><span class="line">      _collectorState = FinalMarking;</span><br><span class="line">  &#125;</span><br><span class="line">  collect_in_foreground(clear_all_soft_refs, GenCollectedHeap::heap()-&gt;gc_cause());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For a mark-sweep, compute_new_size() will be called</span></span><br><span class="line">  <span class="comment">// in the heap's do_collection() method.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CMSCollector::collect_in_foreground(bool clear_all_soft_refs, GCCause::Cause cause) &#123;</span><br><span class="line"><span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">      <span class="keyword">case</span> InitialMarking:</span><br><span class="line">        register_foreground_gc_start(cause);</span><br><span class="line">        init_mark_was_synchronous = <span class="keyword">true</span>;  <span class="comment">// fact to be exploited in re-mark</span></span><br><span class="line">        checkpointRootsInitial(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Marking, <span class="string">"Collector state should have changed"</span></span><br><span class="line">          <span class="string">" within checkpointRootsInitial()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Marking:</span><br><span class="line">        <span class="comment">// initial marking in checkpointRootsInitialWork has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before initial mark: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          bool res = markFromRoots(<span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">assert</span>(res &amp;&amp; _collectorState == FinalMarking, <span class="string">"Collector state should "</span></span><br><span class="line">            <span class="string">"have changed"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> FinalMarking:</span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before re-mark: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        checkpointRootsFinal(<span class="keyword">false</span>, clear_all_soft_refs,</span><br><span class="line">                             init_mark_was_synchronous);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Sweeping, <span class="string">"Collector state should not "</span></span><br><span class="line">          <span class="string">"have changed within checkpointRootsFinal()"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Sweeping:</span><br><span class="line">        <span class="comment">// final marking in checkpointRootsFinal has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before sweep: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sweep(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Resizing, <span class="string">"Incorrect state"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Resizing: &#123;</span><br><span class="line">        <span class="comment">// Sweeping has been completed; the actual resize in this case</span></span><br><span class="line">        <span class="comment">// is done separately; nothing to be done in this state.</span></span><br><span class="line">        _collectorState = Resetting;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Resetting:</span><br><span class="line">        <span class="comment">// The heap has been resized.</span></span><br><span class="line">        <span class="keyword">if</span> (VerifyDuringGC &amp;&amp;</span><br><span class="line">            GenCollectedHeap::heap()-&gt;total_collections() &gt;= VerifyGCStartAt) &#123;</span><br><span class="line">          Universe::verify(<span class="string">"Verify before reset: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        save_heap_summary();</span><br><span class="line">        reset(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">assert</span>(_collectorState == Idling, <span class="string">"Collector state should "</span></span><br><span class="line">          <span class="string">"have changed"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="keyword">case</span> AbortablePreclean:</span><br><span class="line">        <span class="comment">// Elide the preclean phase</span></span><br><span class="line">        _collectorState = FinalMarking;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ShouldNotReachHere();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreground GC由于没有压缩导致本次GC完还是没有足够空间存放的补救<br>很多情况下，如果走到了foreground GC没有进行compact，碎片问题还是没法得到解决。因此如果这次foreground GC后还是空间不足的话，就会接着进行一次彻底的Full GC，并清理软引用来尽可能回收内存，标记回收软引用后，CMS就会将is_compact设置成true，这样这最后一次Full GC就会使用单线程（VM Thread）的带标记整理（mark-sweep-compact）的Serial Old GC的算法（do_compaction_work）来进行整个堆的垃圾回收。如果这次Full GC还是不行就抛出OOM了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try a full collection; see delta for bug id 6266275</span></span><br><span class="line">    <span class="comment">// for the original code and why this has been simplified</span></span><br><span class="line">    <span class="comment">// with from-space allocation criteria modified and</span></span><br><span class="line">    <span class="comment">// such allocation moved out of the safepoint path.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = gch-&gt;attempt_allocation(size, is_tlab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">  result = expand_heap_and_allocate(size, is_tlab);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we reach this point, we're really out of memory. Try every trick</span></span><br><span class="line">  <span class="comment">// we can to reclaim memory. Force collection of soft references. Force</span></span><br><span class="line">  <span class="comment">// a complete compaction of the heap. Any additional methods for finding</span></span><br><span class="line">  <span class="comment">// free memory should be here, especially if they are expensive. If this</span></span><br><span class="line">  <span class="comment">// attempt fails, an OOM exception will be thrown.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">UIntFlagSetting <span class="title">flag_change</span><span class="params">(MarkSweepAlwaysCompactCount, <span class="number">1</span>)</span></span>; <span class="comment">// Make sure the heap is fully compacted</span></span><br><span class="line"></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clear_all_soft_refs &amp;&amp; !*should_compact) &#123;</span><br><span class="line">    <span class="comment">// We are about to do a last ditch collection attempt</span></span><br><span class="line">    <span class="comment">// so it would normally make sense to do a compaction</span></span><br><span class="line">    <span class="comment">// to reclaim as much space as possible.</span></span><br><span class="line">    <span class="keyword">if</span> (CMSCompactWhenClearAllSoftRefs) &#123;</span><br><span class="line">      <span class="comment">// Default: The rationale is that in this case either</span></span><br><span class="line">      <span class="comment">// we are past the final marking phase, in which case</span></span><br><span class="line">      <span class="comment">// we'd have to start over, or so little has been done</span></span><br><span class="line">      <span class="comment">// that there's little point in saving that work. Compaction</span></span><br><span class="line">      <span class="comment">// appears to be the sensible choice in either case.</span></span><br><span class="line">      *should_compact = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="promote-failed后gc日志打印的占用大小释疑">promote failed后GC日志打印的占用大小释疑</span></h4><p>当出现promote failed时，有的情况下会发现，本次触发的young GC后，年轻代的内存占用比回收前还上涨了。如下面示例这次：<br>这次Minor GC后，居然年轻代的占用空间还从3088943K涨到了3476337K。这个需要了解下Minor GC的过程：Minor GC开始后，遍历GC Roots，碰到eden区和from区的对象就把它挪到to区，但是并不会马上释放老的对象，直到GC完成后才会释放。如果GC出现晋升失败，这种情况下是不会释放这些老对象的，尽管to区里已经有一些eden区和from区对象的副本了。但是GC不管是否成功都会在结束后对from区和to区进行切换，这个时候原来的to区变成from区了，由于GC日志统计的只是eden+from的使用大小，GC前统计的eden+from变成了eden（未释放老对象）+原来的to（包含eden存活的部分拷贝+原来from存活的备份拷贝），这样是有可能统计出来比之前要大的。</p><p><code class="hljs css">2017<span class="hljs-tag">-10-13T18</span><span class="hljs-pseudo">:11</span><span class="hljs-pseudo">:03</span><span class="hljs-class">.817</span>+0800: 341300<span class="hljs-class">.509</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-10-13T18:11:03.818+0800: 341300.509: [ParNew (promotion failed): 3088943K-&gt;3476337K(3495296K), 0.2446697 secs]</span>2017<span class="hljs-tag">-10-13T18</span><span class="hljs-pseudo">:11</span><span class="hljs-pseudo">:04</span><span class="hljs-class">.063</span>+0800: 341300<span class="hljs-class">.754</span>: <span class="hljs-attr_selector">[CMS: 3953608K-&gt;2518422K(6291456K), 1.4883145 secs]</span> 7042552<span class="hljs-tag">K-</span>&gt;2518422<span class="hljs-tag">K</span>(9786752<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 73035K-&gt;73035K(1116160K)]</span>, 1<span class="hljs-class">.7337265</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.32 sys=0.02, real=1.73 secs]</span><br></code></p><h3><span id="concurrent-mode-failure">concurrent mode failure</span></h3><p>有的时候GC日志中还会出现“concurrent mode failure”类似的异常，一般这种异常会伴随着较长的STW时间发生。出现这种情况的前提是使用了CMS作为年老代的垃圾回收器。CMS是一款并发收集器，GC回收线程和业务的用户线程是并发执行的（除了初始标记和重新标记外其他阶段都是可以和业务线程并行的），并发执行意味着在垃圾回收执行的同时还会不停有新的对象promote到年老代。在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过剩余的空间（担保失败），就会触发concurrent mode failure。</p><p><code class="hljs css">2018<span class="hljs-tag">-05-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.818</span>+0800: 101200<span class="hljs-class">.681</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-05-05T15:32:56.819+0800: 101200.682: [ParNew: 5242832K-&gt;5242832K(5242880K), 0.0000388 secs]</span>2018<span class="hljs-tag">-05</span><br><span class="hljs-tag">-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.819</span>+0800: 101200<span class="hljs-class">.682</span>: <span class="hljs-attr_selector">[CMS2018-05-05T15:32:56.873+0800: 101200.736: [CMS-concurrent-sweep: 0.212/0.240 secs]</span> <span class="hljs-attr_selector">[Times: user=0.26 sys=0.00, real=0.23 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 7033555<span class="hljs-tag">K-</span>&gt;7033541<span class="hljs-tag">K</span>(9437184<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0766034</span> <span class="hljs-tag">secs</span>] 12276388<span class="hljs-tag">K-</span>&gt;12276374<span class="hljs-tag">K</span>(14680064<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 75013K-&gt;75013K(1118208K)]</span>, 0<span class="hljs-class">.0777029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.08 secs]</span><br></code></p><p>如上面这次concurrent mode failure，对象分配失败请求一次年轻代GC，但是这次年轻代GC并没有真正执行，根据历史promote的大小和当前年老代的空间剩余大小估算，剩余年老代空间可能不够存放promote上来的对象。因此直接触发了一次Full GC，由于当时backgroup GC正在进行中，所以这时会中止backgroup gc，然后执行一次Full GC或者foreground GC。如这次Full GC总共花费了0.08s，最终年老代空间从7033555K调整成7033541K，整个过程是STW的。</p><h4><span id="导致concurrent-mode-failure的几种情况">导致concurrent mode failure的几种情况</span></h4><p>当JVM需要申请老年代空间但剩余可用空间不够时，会去判断当前年老代是否正在进行中，如果是在进行中，除了执行Full GC外还会报告concurrent mode failure，以下几种情况会导致concurrent mode failure：</p><ol><li>年轻代发生young GC需要promote对象到老年代但老年代可用空间不够，且老年代正在执行background GC。</li><li>年轻代由于“悲观策略”放弃young GC需要触发Full GC或者CMS的foreground GC，且老年代正在执行background GC。</li><li>新分配对象大小超过-XX:PretenureSizeThreshold阈值直接在老年代分配但老年代可用空间不够，且老年代正在执行background GC。</li></ol><p>所以promotion failed不一定会导致concurrent mode failure；当然，concurrent mode failure也不一定都是由于promotion failed后的Full GC导致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMSCollector::acquire_control_and_collect</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">    report_concurrent_mode_interruption();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如下日志：本次“concurrent mode failure”就是由于young GC时“promotion failed”之后的Full GC导致的，而对象直接在年老代分配但老年代可用空间不够时，：<br><code class="hljs css">2017<span class="hljs-tag">-07-13T21</span><span class="hljs-pseudo">:37</span><span class="hljs-pseudo">:21</span><span class="hljs-class">.616</span>+0800: 2317149<span class="hljs-class">.720</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2017-07-13T21:37:21.616+0800: 2317149.721: [ParNew (promotion failed): 3774912K-&gt;3702108K(3774912K), 0.3012695 secs]</span>2017<span class="hljs-tag">-07-13T21</span><span class="hljs-pseudo">:37</span><span class="hljs-pseudo">:21</span><span class="hljs-class">.918</span>+0800: 2317150<span class="hljs-class">.022</span>: <span class="hljs-attr_selector">[CMS2017-07-13T21:37:21.929+0800: 2317150.034: [CMS-concurrent-abortable-preclean: 3.608/4.392 secs]</span> <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=4.39 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 5408872<span class="hljs-tag">K-</span>&gt;5935072<span class="hljs-tag">K</span>(6291456<span class="hljs-tag">K</span>), 2<span class="hljs-class">.6779990</span> <span class="hljs-tag">secs</span>] 8578988<span class="hljs-tag">K-</span>&gt;5935072<span class="hljs-tag">K</span>(10066368<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 72542K-&gt;72542K(1116160K)]</span>, 2<span class="hljs-class">.9802519</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=2.98 secs]</span><br></code></p><p>如下日志：对象在年轻代分配但年轻代由于“悲观策略”并不真正执行而是直接触发一次Full GC。</p><p><code class="hljs css">2018<span class="hljs-tag">-05-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.818</span>+0800: 101200<span class="hljs-class">.681</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-05-05T15:32:56.819+0800: 101200.682: [ParNew: 5242832K-&gt;5242832K(5242880K), 0.0000388 secs]</span>2018<span class="hljs-tag">-05</span><br><span class="hljs-tag">-05T15</span><span class="hljs-pseudo">:32</span><span class="hljs-pseudo">:56</span><span class="hljs-class">.819</span>+0800: 101200<span class="hljs-class">.682</span>: <span class="hljs-attr_selector">[CMS2018-05-05T15:32:56.873+0800: 101200.736: [CMS-concurrent-sweep: 0.212/0.240 secs]</span> <span class="hljs-attr_selector">[Times: user=0.26 sys=0.00, real=0.23 secs]</span><br>(<span class="hljs-tag">concurrent</span> <span class="hljs-tag">mode</span> <span class="hljs-tag">failure</span>): 7033555<span class="hljs-tag">K-</span>&gt;7033541<span class="hljs-tag">K</span>(9437184<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0766034</span> <span class="hljs-tag">secs</span>] 12276388<span class="hljs-tag">K-</span>&gt;12276374<span class="hljs-tag">K</span>(14680064<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 75013K-&gt;75013K(1118208K)]</span>, 0<span class="hljs-class">.0777029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.08 secs]</span><br></code></p><p>promotion failed也不一定会导致concurrent mode failure。如果当前CMS的background gc没有在执行的话就不会出现“concurrent mode failure”，而是显示Full GC。</p><p><code class="hljs css">2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.761</span>+0800: 274170<span class="hljs-class">.361</span>: <span class="hljs-attr_selector">[GC (Allocation Failure) 2018-09-24T20:18:01.762+0800: 274170.362: [ParNew: 6291456K-&gt;6291456K(7864320K), 0.0000411 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;18389797<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), 0<span class="hljs-class">.0011756</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=0.00 sys=0.00, real=0.00 secs]</span><br>2018<span class="hljs-tag">-09-24T20</span><span class="hljs-pseudo">:18</span><span class="hljs-pseudo">:01</span><span class="hljs-class">.763</span>+0800: 274170<span class="hljs-class">.362</span>: <span class="hljs-attr_selector">[Full GC (Allocation Failure) 2018-09-24T20:18:01.763+0800: 274170.363: [CMS: 12098341K-&gt;12111250K(12582912K), 6.4734175 secs]</span> 18389797<span class="hljs-tag">K-</span>&gt;12111250<span class="hljs-tag">K</span>(20447232<span class="hljs-tag">K</span>), <span class="hljs-attr_selector">[Metaspace: 82207K-&gt;82207K(1124352K)]</span>, 6<span class="hljs-class">.4746029</span> <span class="hljs-tag">secs</span>] <span class="hljs-attr_selector">[Times: user=4.90 sys=1.03, real=6.48 secs]</span><br></code></p><h2><span id="解决方案">解决方案</span></h2><h2><span id="原因1cms触发太晚">原因1：CMS触发太晚</span></h2><ul><li>说明</li></ul><p>CMS的backgroup GC触发时机太晚，会导致在backgroup GC完成前，年老代剩余可用空间放不下新提升上来的或者直接在年老代分配的对象，从而触发Full GC并中断并发过程。</p><ul><li>方案</li></ul><p>通过参数-XX:CMSInitiatingOccupancyFraction=N -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSWaitDuration=M 调小，更早、更快触发年老代backgroup GC。<br>CMSInitiatingOccupancyFraction默认值是92%，CMS backgroup GC扫描间隔默认是：2000（2s）。<br>但注意这里并不是调的越小越好，越小年老代GC频率会越高，整体业务暂停的时间有可能会更长。另外，某些情况下，该参数设置太小导致年老代空间触发backgroup GC前可用的空间根本放不下所有晋升上来的长生命周期的对象，从而导致JVM一直不停地做年老代GC，严重影响业务性能。</p><h2><span id="原因2cms-gc回收处理效率太低">原因2：CMS GC回收处理效率太低</span></h2><ul><li><p>说明<br>CMS是一个并发的垃圾回收器，用于CMS各个阶段的GC线程数默认值是： ConcGCThreads = （ParallelGCThreads+3）/4。</p><p>而这里ParallelGCThreads表示的是GC并行时使用的线程数。比如如果新生代使用ParNew，那么ParallelGCThreads也就是新生代GC线程数。默认情况下，当CPU数量小于8时，ParallelGCThreads的值就是CPU的数量，当CPU数量大于8时，ParallelGCThreads的值等于3+5*cpuCount/8。</p><p>例如，在32核机器上，新生代并行GC线程数为 3 + 5*32/8 = 23，所以对应的CMS的并发线程数为 （23 +3） / 4 = 6。</p></li><li><p>方案<br>通过参数 -XX:ParallelGCThreads和-XX：ConcGCThreads来分别增加年轻代GC并行处理和年老代GC并发处理的能力。但这里也并不是越大越好，因为CMS的很多阶段都是和业务线程并发进行的，如果用于GC的线程数太多也会更多抢占业务线程的处理时间片，从而影响业务性能，所以这里需要进行实际场景的验证测试。</p></li></ul><h2><span id="原因3年老代空间碎片太多">原因3:年老代空间碎片太多</span></h2><ul><li>说明<br>CMS收集器采用的标记-清除算法，并不对年老代进行回收后的内存整理（虽然GC后会进行一些连续空间的合并）。因此多次GC后会存在较多的空间碎片。所以可能导致年老代剩余空间足够，但在大对象提升时由于没有连续的可用空间导致提升失败。</li><li>方案<br>通过-XX:+UseCMSCompactAtFullCollection和-XX:CMSFullGCsBeforeCompaction=n来让JVM在多少次Full GC后进行年老代空间的碎片整理。但是这两个参数起到的是”病后用药“的作用，前提是已经发生了Full GC才触发（所以有一些比较曲线救国的办法就是在凌晨低峰期间：代码中定时调用System.gc来触发一次Full GC从而进行年老代的空间整理）。</li></ul><p>如果碎片问题确实比较严重，可以考虑改用G1垃圾回收器（G1每次GC都会对region进行整理）。</p><h2><span id="原因4年轻代提升速度过快">原因4：年轻代提升速度过快</span></h2><ul><li>说明<br>不管是promotion failed还是concurrent mode failure，都是由于提升时年老代可用空间不够导致的，因此提升速度过快是导致这些问题的直接原因。具体会导致提升过快的非业务原因有几点：<ol><li>年轻代对象晋升年龄阈值太小。</li><li>eden区太小，触发年轻代GC太容易。</li><li>survivor空间溢出（未满年龄的对象提前晋升，参考前面的Desired survivor size的计算）。</li><li>业务中大对象较多，超过阈值直接在年老代中分配。</li></ol></li><li>方案<ol><li>调整-XX:MaxTenuringThreshold（默认15），提高年轻代晋升年龄。</li><li>注意：这里并不代表真正达到这个年龄才晋升，但JVM计算一个desired survivor size大小，survivor区对象如果累计到某一个age值的对象大小大于desired survivor size，下次晋升时大于等于该年龄的对象就会被提前promote到年老代，这里这个age值就是动态计算出来的。</li><li>eden区和survior可用区默认比例是（8:1)，survior区分s0和s1两部分，同一时刻只有一个区可用。所以实际可用大小为xmn的1/10。一般可以通过扩大eden区来减少年轻代GC次数，让年轻代对象到达触发年龄的速度慢一点。调整eden去和survior比例使用： -XX:SurvivorRatio=N。</li><li>survivor空间溢出的直接原因是计算的Desired survivor size太小，导致很多未满年龄的对象提前晋升到年老代，可以通过降低-XX:TargetSurvivorRatio=N（默认50，就是一个s0或者s1的一半），尽量避免提前晋升的溢出问题。</li><li>针对大对象，可以通过-XX:PretenureSizeThreshold来设置直接在年老代分配的对象阈值，默认是0，即：由JVM动态决定（PS：这个参数尽量不要用，除非对自己的业务细节访问模型很清楚）。</li></ol></li></ul><p>最后：如果以上调整都没办法彻底解决GC问题，那么应该考虑在系统内存可用范围内扩大整个heap的大小了。</p><h3><span id="延伸阅读如何手动触发full-gc">延伸阅读：如何手动触发Full GC？</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有开启-XX:+DisableExplicitGC的前提下调用System.gc()就会发生FullGC</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>或者通过jmap命令触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live pid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(5)</title>
      <link href="/article/java-cms-gc-2/"/>
      <url>/article/java-cms-gc-2/</url>
      
        <content type="html"><![CDATA[<h3><span id="回顾">回顾</span></h3><p>继上一节，讨论了CMS的gc 流程，本篇讨论几个遗留的问题。</p><h4><span id="cms-的缺点">CMS 的缺点</span></h4><h4><span id="cms-gc-和full-gc-和-minor-gc-的区别">CMS GC 和Full GC 和 Minor GC 的区别</span></h4><ul><li><p>CMS GC</p><p>通过一个后台线程触发，触发机制是默认每隔2秒判断一下当前老年代的内存使用率是否达到阈值，当然具体的触发条件没有这么简单，如果是则触发一次cms gc，在该过程中只会标记出存活对象，然后清除死亡对象，期间会产生碎片空间。</p></li><li><p>Full GC</p><p>是通过 vm thread 执行的，整个过程是 stop-the-world，在该过程中会判断当前 gc 是否需要进行compact，即把存活对象移动到内存的一端，可以有效的消除cms gc产生的碎片空间。</p></li></ul><ul><li><p>Minor GC</p><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：</p><p>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。<br>对年轻代的 Eden 和 Survivor 区进行了标记和复制操作，无碎片。</p></li></ul><h4><span id="cms-gc-如何触发">CMS GC 如何触发</span></h4><p>对于 cms gc 来说，触发条件很简单，实现位于 ConcurrentMarkSweepThread 类中，相当于Java 中的Thread，该线程随着堆一起初始化，在该类的 run 方法中有这么一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_should_terminate) &#123;</span><br><span class="line">    sleepBeforeNextCycle();</span><br><span class="line">    <span class="keyword">if</span> (_should_terminate) <span class="keyword">break</span>;</span><br><span class="line">    GCCause::Cause cause = _collector-&gt;_full_gc_requested ?</span><br><span class="line">      _collector-&gt;_full_gc_cause : GCCause::_cms_concurrent_mark;</span><br><span class="line">    _collector-&gt;collect_in_background(<span class="keyword">false</span>, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sleepBeforeNextCycle()</code>保证了最晚每 2 秒（-XX:CMSWaitDuration）进行一次判断，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConcurrentMarkSweepThread::sleepBeforeNextCycle() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!_should_terminate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CMSIncrementalMode) &#123;</span><br><span class="line">      icms_wait();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Wait until the next synchronous GC, a concurrent full gc</span></span><br><span class="line">      <span class="comment">// request or a timeout, whichever is earlier.</span></span><br><span class="line">      wait_on_cms_lock(CMSWaitDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check if we should start a CMS collection cycle</span></span><br><span class="line">    <span class="keyword">if</span> (_collector-&gt;shouldConcurrentCollect()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .. collection criterion not yet met, let's go back</span></span><br><span class="line">    <span class="comment">// and wait some more</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>shouldConcurrentCollect()</code>方法决定了是否可以触发本次 cms gc，分为以下几种情况：</p><ol><li><p>如果<code>_full_gc_requested</code>为真，说明有明确的需求要进行gc，比如调用<code>System.gc()</code>;</p></li><li><p>CMS 默认采用 jvm 运行时的统计数据判断是否需要触发 cms gc，如果需要根据 <code>CMSInitiatingOccupancyFraction</code> 的值进行判断，需要设置参数<code>-XX:+UseCMSInitiatingOccupancyOnly</code></p></li><li><p>如果开启了<code>UseCMSInitiatingOccupancyOnly</code>参数，判断当前老年代使用率是否大于阈值，则触发 cms gc，该阈值可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>进行设置，如果没有设置，默认为92%</p></li><li><p>如果之前的 ygc 失败过，或则下次新生代执行 ygc 可能失败，这两种情况下都需要触发 cms gc；</p></li><li><p>CMS 默认不会对永久代进行垃圾收集，如果希望对永久代进行垃圾收集，需要设置参数<code>-XX:+CMSClassUnloadingEnabled</code>如果开启了CMSClassUnloadingEnabled，根据永久带的内存使用率判断是否触发 cms gc；</p></li><li><p>…还有一些其它情况<br>如果有上述几种情况，说明需要执行一次 cms gc，通过调用<code>_collector-&gt;collect_in_background(false, cause)</code> 进行触发，注意这个方法名中的in_background</p></li></ol><p>FULL GC 如何触发<br>触发 full gc 的主要原因是在eden区为对象或TLAB分配内存失败，导致一次 ygc，在 GenCollectorPolicy 类的satisfy_failed_allocation()方法中有这么一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do an incremental collection.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try a full collection; see delta for bug id 6266275</span></span><br><span class="line">    <span class="comment">// for the original code and why this has been simplified</span></span><br><span class="line">    <span class="comment">// with from-space allocation criteria modified and</span></span><br><span class="line">    <span class="comment">// such allocation moved out of the safepoint path.</span></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法是由 vm thread 执行的，整个过程都是 stop-the-world，如果当前<code>incremental_collection_will_fail</code>方法返回 false，则会放弃本次的 ygc，直接触发一次 full gc，<code>incremental_collection_will_fail</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">incremental_collection_will_fail</span><span class="params">(bool consult_young)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assumes a 2-generation system; the first disjunct remembers if an</span></span><br><span class="line">    <span class="comment">// incremental collection failed, even when we thought (second disjunct)</span></span><br><span class="line">    <span class="comment">// that it would not.</span></span><br><span class="line">    <span class="keyword">assert</span>(heap()-&gt;collector_policy()-&gt;is_two_generation_policy(),</span><br><span class="line">           <span class="string">"the following definition may not be suitable for an n(&gt;2)-generation system"</span>);</span><br><span class="line">    <span class="keyword">return</span> incremental_collection_failed() ||</span><br><span class="line">           (consult_young &amp;&amp; !get_gen(<span class="number">0</span>)-&gt;collection_attempt_is_safe());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中参数 <code>consult_young</code> 为 <code>false</code>，如果i<code>ncremental_collection_failed()</code>返回 <code>true</code>，会导致执行很慢很慢很慢的full gc，如果上一次 ygc 过程中发生 <code>promotion failure</code>时，会设置 <code>_incremental_collection_failed</code>为 <code>true</code>，即方法<code>incremental_collection_failed()</code>返回 true，相当于触发了 full gc。</p><p>还有一种情况是，当发生ygc之后，还是没有足够的内存进行分配，这时会继续触发 full gc，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we reach this point, we're really out of memory. Try every trick</span></span><br><span class="line">  <span class="comment">// we can to reclaim memory. Force collection of soft references. Force</span></span><br><span class="line">  <span class="comment">// a complete compaction of the heap. Any additional methods for finding</span></span><br><span class="line">  <span class="comment">// free memory should be here, especially if they are expensive. If this</span></span><br><span class="line">  <span class="comment">// attempt fails, an OOM exception will be thrown.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">IntFlagSetting <span class="title">flag_change</span><span class="params">(MarkSweepAlwaysCompactCount, <span class="number">1</span>)</span></span>; <span class="comment">// Make sure the heap is fully compacted</span></span><br><span class="line"></span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                       <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                       size             <span class="comment">/* size */</span>,</span><br><span class="line">                       is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                       number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="full-gc-中的compact">FULL GC 中的compact</span></h3><p>每次触发 full gc，会根据<code>should_compact</code> 标识进行判断是否需要执行 compact ，判断实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*should_compact =</span><br><span class="line">      UseCMSCompactAtFullCollection &amp;&amp;</span><br><span class="line">        ((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||</span><br><span class="line">         GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||</span><br><span class="line">         gch-&gt;incremental_collection_will_fail(<span class="keyword">true</span> <span class="comment">/* consult_young */</span>));</span><br></pre></td></tr></table></figure><p><code>UseCMSCompactAtFullCollection</code>默认开启，但是否要进行 compact，还得看后面的条件：</p><ol><li>最近一次cms gc 以来发生 full gc 的次数<code>_full_gcs_since_conc_gc</code>（这个值每次执行完 cms gc 的sweeping 阶段就会设置为0）达到阈值<code>CMSFullGCsBeforeCompaction</code>。</li><li>用户强制执行了gc，如<code>System.gc()</code>。</li><li>上一次 ygc 已经失败（发生了promotion failure），或预测下一次 ygc 不会成功。</li></ol><p>如果上述条件都不满足，是否就一直不进行 compact，这样碎片问题就得不到缓解了，幸好还有补救的机会，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clear_all_soft_refs &amp;&amp; !*should_compact) &#123;</span><br><span class="line">        <span class="comment">// We are about to do a last ditch collection attempt</span></span><br><span class="line">        <span class="comment">// so it would normally make sense to do a compaction</span></span><br><span class="line">        <span class="comment">// to reclaim as much space as possible.</span></span><br><span class="line">      <span class="keyword">if</span> (CMSCompactWhenClearAllSoftRefs) &#123;</span><br><span class="line">          <span class="comment">// Default: The rationale is that in this case either</span></span><br><span class="line">          <span class="comment">// we are past the final marking phase, in which case</span></span><br><span class="line">          <span class="comment">// we'd have to start over, or so little has been done</span></span><br><span class="line">          <span class="comment">// that there's little point in saving that work. Compaction</span></span><br><span class="line">          <span class="comment">// appears to be the sensible choice in either case.</span></span><br><span class="line">        *should_compact = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We have been asked to clear all soft refs, but not to</span></span><br><span class="line">          <span class="comment">// compact. Make sure that we aren't past the final checkpoint</span></span><br><span class="line">          <span class="comment">// phase, for that is where we process soft refs. If we are already</span></span><br><span class="line">          <span class="comment">// past that phase, we'll need to redo the refs discovery phase and</span></span><br><span class="line">          <span class="comment">// if necessary clear soft refs that weren't previously</span></span><br><span class="line">          <span class="comment">// cleared. We do so by remembering the phase in which</span></span><br><span class="line">          <span class="comment">// we came in, and if we are past the refs processing</span></span><br><span class="line">          <span class="comment">// phase, we'll choose to just redo the mark-sweep</span></span><br><span class="line">          <span class="comment">// collection from scratch.</span></span><br><span class="line">        <span class="keyword">if</span> (_collectorState &gt; FinalMarking) &#123;</span><br><span class="line">            <span class="comment">// We are past the refs processing phase;</span></span><br><span class="line">            <span class="comment">// start over and do a fresh synchronous CMS cycle</span></span><br><span class="line">          _collectorState = Resetting; <span class="comment">// skip to reset to start new cycle</span></span><br><span class="line">          reset(<span class="keyword">false</span> <span class="comment">/* == !asynch */</span>);</span><br><span class="line">          *should_start_over = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="comment">// else we can continue a possibly ongoing current cycle</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的 full gc，参数<code>clear_all_soft_refs</code>为 false，不会清理软引用，如果在执行完 full gc，空间还是不足的话，会执行一次彻底的 full gc，尝试清理所有的软引用，想方设法的收集可用内存，这种情况<code>clear_all_soft_refs</code>为 true，而且<code>CMSCompactWhenClearAllSoftRefs</code>默认为 true，在垃圾收集完可以执行一次compact，如果真的走到了这一步，该好好的查查代码了，因为这次 gc 的暂停时间已经很长很长很长了。<br>根据对<code>should_compact</code>参数的判断，执行不同的算法进行 full gc，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (should_compact) &#123;</span><br><span class="line">    <span class="comment">// If the collection is being acquired from the background</span></span><br><span class="line">    <span class="comment">// collector, there may be references on the discovered</span></span><br><span class="line">    <span class="comment">// references lists that have NULL referents (being those</span></span><br><span class="line">    <span class="comment">// that were concurrently cleared by a mutator) or</span></span><br><span class="line">    <span class="comment">// that are no longer active (having been enqueued concurrently</span></span><br><span class="line">    <span class="comment">// by the mutator).</span></span><br><span class="line">    <span class="comment">// Scrub the list of those references because Mark-Sweep-Compact</span></span><br><span class="line">    <span class="comment">// code assumes referents are not NULL and that all discovered</span></span><br><span class="line">    <span class="comment">// Reference objects are active.</span></span><br><span class="line">    ref_processor()-&gt;clean_up_discovered_references();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_state &gt; Idling) &#123;</span><br><span class="line">      save_heap_summary();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do_compaction_work(clear_all_soft_refs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the GC time limit been exceeded?</span></span><br><span class="line">    DefNewGeneration* young_gen = _young_gen-&gt;as_DefNewGeneration();</span><br><span class="line">    size_t max_eden_size = young_gen-&gt;max_capacity() -</span><br><span class="line">                           young_gen-&gt;to()-&gt;capacity() -</span><br><span class="line">                           young_gen-&gt;from()-&gt;capacity();</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    GCCause::Cause gc_cause = gch-&gt;gc_cause();</span><br><span class="line">    size_policy()-&gt;check_gc_overhead_limit(_young_gen-&gt;used(),</span><br><span class="line">                                           young_gen-&gt;eden()-&gt;used(),</span><br><span class="line">                                           _cmsGen-&gt;max_capacity(),</span><br><span class="line">                                           max_eden_size,</span><br><span class="line">                                           full,</span><br><span class="line">                                           gc_cause,</span><br><span class="line">                                           gch-&gt;collector_policy());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_mark_sweep_work(clear_all_soft_refs, first_state,  should_start_over);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于引用和和gc 处理 将会在下节讨论</p><p><em>参考：</em></p><p><a href="https://www.jianshu.com/p/55670407fdb9" target="_blank" rel="noopener">关于CMS垃圾收集算法的一些疑惑</a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Retry 源码分析</title>
      <link href="/article/retry-2-spring-retry/"/>
      <url>/article/retry-2-spring-retry/</url>
      
        <content type="html"><![CDATA[<p>前面我们用自己的代理模式完成一些重试的操作，接下来我们将分析一下 <code>SpringRetry</code> 的实现方式<code>spring-retry</code> 项目实现了重试和熔断功能，目前已用于SpringBatch、Spring Integration等项目</p><h2><span id="详解">详解</span></h2><h1><span id="quickstart">QuickStart</span></h1><p>我们首先来看一下使用。<br>首先我们引入使用,这里我们使用的是<code>1.3</code>版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.retry/spring-retry --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * spring-retry1.3.x版本开始提供建造者模式支持了，可</span></span><br><span class="line"><span class="comment">         * RetryTemplate template = RetryTemplate.builder()</span></span><br><span class="line"><span class="comment">                .maxAttempts(5)</span></span><br><span class="line"><span class="comment">                .customPolicy(new SimpleRetryPolicy()).build();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">// 设置重试策略</span></span><br><span class="line">        SimpleRetryPolicy simpleRetryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        simpleRetryPolicy.setMaxAttempts(<span class="number">5</span>);</span><br><span class="line">        template.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        Object result = template.execute(</span><br><span class="line">                <span class="keyword">new</span> RetryCallback&lt;Object, Throwable&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 第一次请求，不算重试， 所以第一次请求时，context.getRetryCount()值为0</span></span><br><span class="line">                        System.out.println(context.getRetryCount());</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span> + (context.getRetryCount() + <span class="number">1</span>) + <span class="string">"次调用失败!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> RecoveryCallback&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"走recover逻辑了! \t异常类是"</span> + lastThrowable.getClass().getName()</span><br><span class="line">                                + <span class="string">"\t异常信息是"</span> + lastThrowable.getMessage();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下调用结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">走recover逻辑了! 异常类是java.lang.RuntimeException异常信息是第<span class="number">5</span>次调用失败!</span><br></pre></td></tr></table></figure><h1><span id="详解">详解</span></h1><h2><span id="类关系">类关系</span></h2><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596005961.png" alt></p><h2><span id="概念详解">概念详解</span></h2><ul><li><p><strong>RetryOperations</strong> 和 <strong>RetryTemplate</strong><br>RetryOperations定义了重试的API，RetryTemplate提供了模板实现，线程安全的，同于Spring 一贯的API风格，RetryTemplate将重试、熔断功能封装到模板中，提供健壮和不易出错的API供大家使用。</p></li><li><p><strong>RetryCallback</strong> 和 <strong>RecoverCallback</strong><br>通过RetryCallback定义需重试的业务服务，当重试超过最大重试时间或最大重试次数后可以调用RecoveryCallback进行恢复，比如返回假数据或托底数据。</p></li><li><p><strong>RetryPolicy</strong><br>当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p></li><li><p><strong>RetryListener</strong>和<strong>RetryStatistics</strong><br>RetryListener实现拦截器模式,这里主要用于统计等，当然也可以用户自定义拦截器。</p></li><li><p><strong>BackOff</strong> ：补偿值，一般指失败后多久进行重试的延迟值。</p></li><li><p><strong>Sleeper</strong> ：暂停应用的工具，通常用来应用补偿值。</p></li><li><p><strong>RetryContext</strong> ：重试上下文，代表了能被重试动作使用的资源。</p></li><li><p><strong>RetryState</strong> ：重试状态，通常包含一个重试的键值。</p></li></ul><h2><span id="分解详解">分解详解</span></h2><h3><span id="retryoperations"><strong>RetryOperations</strong></span></h3><ul><li>首先看一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryOperations</span> </span>&#123;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RetryState retryState)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> E, ExhaustedRetryException</span>;</span><br><span class="line">    &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">execute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback, RecoveryCallback&lt;T&gt; recoveryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">            RetryState retryState)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，new 出一个 <code>RetryTemplate</code> 对象后，核心是在 <code>template.execute()</code>,传递一个 <code>RetryCallback</code>，内部执行我们需要重试的具体方法。</p><p>这里我们看到 <code>RetryOperations</code> 具体定义了 <code>execute</code> 方法，用于去执行我们的相关逻辑。这里我们看到了有个 <code>RetryState</code> 对象，这里的主要是重试的状态，这个我们暂且略过，我们先来看一下<strong>重试策略</strong></p><h3><span id="retrypolicy">RetryPolicy</span></h3><p>那什么时候需重试？<code>spring-retry</code>是当抛出相关异常后执行重试策略，定义重试策略时需要定义需重试的异常（如因远程调用失败的可以重试、而因入参校对失败不应该重试）。只读操作可以重试，幂等写操作可以重试，但是非幂等写操作不能重试，重试可能导致脏写，或产生重复数据。</p><ol><li><strong>接口</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//是否需要重试</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// retry 生命周期函数</span></span><br><span class="line"><span class="function">RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重试接口定义了四个接口，具体的重试策略就是通过具体的实现类来完成的。<br><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596007673.png" alt></p><ol start="2"><li><strong>重试策略</strong><br>重试策略有哪些呢？spring-retry提供了如下重试策略。</li></ol><ul><li><strong>NeverRetryPolicy</strong> ：只允许调用RetryCallback一次，不允许重试；</li><li><strong>AlwaysRetryPolicy</strong> ：允许无限重试，直到成功，此方式逻辑不当会导致死循环；</li><li><strong>SimpleRetryPolicy</strong> ：固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</li><li><strong>TimeoutRetryPolicy</strong> ：超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</li><li><strong>MaxAttemptsRetryPolicy</strong>： 简单重试策略，仅通过重试次数判断是否能够重试，不推荐使用。</li><li><strong>CircuitBreakerRetryPolicy</strong> ：有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate，稍后详细介绍该策略；</li><li><strong>CompositeRetryPolicy</strong> ：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</li></ul><p>接下来我们分析一下<code>SimpleRetryPolicy</code> 类的基本实现。</p><ol start="3"><li><strong>构造函数</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量，重试次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_ATTEMPTS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 实际重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maxAttempts;</span><br><span class="line"><span class="comment">// 错误分类器 classify包作为retry的辅助类，主要应用于RetryPolicy的canRetry()方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件</span></span><br><span class="line"><span class="keyword">private</span> BinaryExceptionClassifier retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryPolicy</span><span class="params">(<span class="keyword">int</span> maxAttempts, Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; retryableExceptions,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> traverseCauses, <span class="keyword">boolean</span> defaultValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.maxAttempts = maxAttempts;</span><br><span class="line"><span class="keyword">this</span>.retryableClassifier = <span class="keyword">new</span> BinaryExceptionClassifier(retryableExceptions, defaultValue);</span><br><span class="line"><span class="keyword">this</span>.retryableClassifier.setTraverseCauses(traverseCauses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单介绍一下 <code>retryableClassifier</code> 这个成员<br><code>classify</code> 包作为retry的辅助类，主要应用于 <code>RetryPolicy</code> 的 <code>canRetry()</code> 方法中，通过比较捕获的异常与定义的异常直接关系，决定是否符合重试条件,现在只要知道他是 用于分类的就好了。</p><ol start="4"><li><strong>函数实现</strong></li></ol><ul><li>canRetry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable t = context.getLastThrowable();</span><br><span class="line"><span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; <span class="keyword">this</span>.maxAttempts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于识别 这个异常时时我们需要的异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">retryForException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.retryableClassifier.classify(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看看出，当异常使我们需要重试的异常且次数小于制定重试次数的时候，进行重试。<code>getLastThrowable</code> 是重试上下文中捕获的最后的异常类型</p><ul><li>open</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RetryContext <span class="title">open</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryContext(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open 这个方法用于协调资源，是重试一开始的时候会被主流程调用，这里主要是new了一个<br><code>SimpleRetryContext上</code>下文。 所以我们如果想继续了解 这个重试策略，就要简单了解一下 <code>RetryContext</code> 上下文了。</p><ol start="5"><li><strong>SimpleRetryContext</strong><br>我们首先来看一下 <code>SimpleRetryContext</code> 这个类的定义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>SimpleRetryContext</code> 紧紧就是一个 <code>RetryContextSupport</code> 实现。我们再来看这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryContextSupport</span> <span class="keyword">extends</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">RetryContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RetryContext parent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminate = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Throwable lastException;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryContextSupport</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 一些 getset 方法</span></span><br><span class="line">    <span class="comment">// 用于记录异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastException = throwable;</span><br><span class="line"><span class="keyword">if</span> (throwable != <span class="keyword">null</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AttributeAccessorSupport</code> 就是一个属性类，让继承他的类可以实现增加属性。</li><li><code>RetryContext</code> 定义一些状态和属性以及  <code>AttributeAccessorSupport</code> 实现的接口方法。具体的代码不贴了，想了解的可以去翻阅源码。</li></ul><ul><li><strong>异常记录</strong><br>SimpleRetryPolicy 的异常注册其实是注册到了context中。当我们捕获了异常，就会将异常封装到这个上下文中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleRetryPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerThrowable</span><span class="params">(RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line">SimpleRetryContext simpleContext = ((SimpleRetryContext) context);</span><br><span class="line">simpleContext.registerThrowable(throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="retrytemplate">RetryTemplate</span></h3><p>到此基本的概念就讲完了。接下来先看下RetryTemplate主要流程实现：</p><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596191348.png" alt></p><p>我来看一下几个关键的成员变量</p><ol><li><strong>成员变量</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GLOBAL_STATE = <span class="string">"state.global"</span>;</span><br><span class="line"><span class="comment">// 回退策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> BackOffPolicy backOffPolicy = <span class="keyword">new</span> NoBackOffPolicy();</span><br><span class="line"><span class="comment">// 重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 重试的监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RetryListener[] listeners = <span class="keyword">new</span> RetryListener[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 重试上下文</span></span><br><span class="line"><span class="keyword">private</span> RetryContextCache retryContextCache = <span class="keyword">new</span> MapRetryContextCache();</span><br><span class="line"><span class="comment">// ？</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> throwLastExceptionOnExhausted;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>核心方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">   <span class="comment">//重试策略</span></span><br><span class="line">   RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">   <span class="comment">//退避策略</span></span><br><span class="line">   BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">   <span class="comment">//重试上下文，当前重试次数等都记录在上下文中</span></span><br><span class="line">   RetryContext context = open(retryPolicy, state);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同步管理器注册context 用于将context链接成一个context链儿</span></span><br><span class="line">   RetrySynchronizationManager.register(context);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拦截器模式，执行RetryListener#open</span></span><br><span class="line">      <span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// .... running 必须问true 否则 抛出异常，代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get or Start the backoff context...</span></span><br><span class="line">BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">backOffContext = (BackOffContext) resource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">backOffContext = backOffPolicy.start(context);</span><br><span class="line"><span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否可以重试执行</span></span><br><span class="line">      <span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//执行RetryCallback回调</span></span><br><span class="line">            lastException = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常</span></span><br><span class="line">            lastException = e;</span><br><span class="line">            <span class="comment">//异常时，要进行下一次重试准备</span></span><br><span class="line">            <span class="comment">//遇到异常后，注册该异常的失败次数</span></span><br><span class="line">            registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">            <span class="comment">//执行RetryListener#onError</span></span><br><span class="line">            doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">            <span class="comment">//如果可以重试，执行退避算法，比如休眠一小段时间后再重试</span></span><br><span class="line">            <span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    backOffPolicy.backOff(backOffContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">                    lastException = e;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//state != null &amp;&amp; state.rollbackFor(context.getLastThrowable())</span></span><br><span class="line">            <span class="comment">//在有状态重试时，如果是需要执行回滚操作的异常，则立即抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果是有状态重试，且有GLOBAL_STATE属性，则立即跳出重试终止；当抛出的异常是非需要执行回滚操作的异常时，才会执行到此处，CircuitBreakerRetryPolicy会在此跳出循环；</span></span><br><span class="line">         <span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      exhausted = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//重试失败后，如果有RecoveryCallback，则执行此回调，否则抛出异常</span></span><br><span class="line">      <span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//清理环境</span></span><br><span class="line">      close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">      <span class="comment">//执行RetryListener#close，比如统计重试信息</span></span><br><span class="line">      doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">      <span class="comment">//RetrySynchronizationManager 清空</span></span><br><span class="line">      RetrySynchronizationManager.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上述代码，感觉很头疼，我们来提几个问题。</p><ol><li><code>MapRetryContextCache</code> 是干啥用的？</li><li><code>RetryContext context = open(retryPolicy, state)</code>中open 方法和state是什么;</li><li><code>RetrySynchronizationManager.register(context)</code>; 为什么要注册这个？</li><li><code>BackOffContext</code> 是干什么用的</li><li><code>状态重试</code>和<code>回滚操作</code>是什么意思？</li></ol><p>接下来我们来逐一分解这些流程。</p><h3><span id="有状态or无状态">有状态or无状态</span></h3><ul><li><p><strong>无状态重试</strong>，是在一个循环中执行完重试策略，即重试上下文保持在一个线程上下文中，在一次调用中进行完整的重试策略判断。非常简单的情况，如远程调用某个查询方法时是最常见的无状态重试。</p></li><li><p><strong>有状态重试</strong>，有两种情况需要使用有状态重试，事务操作需要回滚或者熔断器模式。事务操作需要回滚场景时，当整个操作中抛出的是数据库异常 DataAccessException，则不能进行重试需要回滚，而抛出其他异常则可以进行重试，可以通过 <code>RetryState</code> 实现：</p></li></ul><p>我们来具体看一下 <code>RetryState</code> 的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryState</span> </span>&#123;</span><br><span class="line"><span class="comment">//状态缓存使用的key</span></span><br><span class="line"><span class="function">Object <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 强制刷新状态</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isForceRefresh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判定当前的异常是否需要回归，默认是true.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">rollbackFor</span><span class="params">(Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最简单的情况下，重试只是一个while循环，<code>RetryTemplate</code> 可以一直尝试，直到成功或失败。RetryContext包含一些状态来决定是重试还是中止，但是这个状态位于堆栈上，不需要将它存储在全局的任何位置，因此我们将此称为无状态重试。无状态重试和有状态重试之间的区别包含在RetryPolicy的实现中（<code>RetryTemplate</code>可以同时处理这两种情况），在无状态重试中，回调总是在重试失败时在同一个线程中执行。</p><p>当我出现数据库事务性的失败的时候，我们需要回滚，这样我们会在整个 <code>template</code> 中加上try catch 代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前状态的名称，当把状态放入缓存时，通过该key查询获取</span></span><br><span class="line">Object key = <span class="string">"mykey"</span>;</span><br><span class="line"><span class="comment">//是否每次都重新生成上下文还是从缓存中查询，即全局模式（如熔断器策略时从缓存中查询）</span></span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//对DataAccessException进行回滚</span></span><br><span class="line">BinaryExceptionClassifier rf =</span><br><span class="line">        <span class="keyword">new</span> BinaryExceptionClassifier(Collections.&lt;Class&lt;? extends Throwable&gt;&gt;singleton(DataAccessException<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh, rf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// state 提出来，可以保证status 在多个 template 的exectue中可以共享一些数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span> i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = template.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchDataAccessException(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, () -&gt; <span class="string">"default"</span>, state);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(DataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 执行回滚操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这些情况下，无状态重试是不够的，因为重新抛出和回滚必然会离开<code>RetryOperations.execute()</code>方法，并可能丢失堆栈上的上下文。</p><p>为了避免丢失它，我们必须引入一种存储策略，将它从堆栈中取出并（至少）放入堆存储中，为此，Spring Retry提供了一种存储策略 <code>RetryContextCache</code>，可以将其注入 <code>RetryTemplate</code> 。<code>RetryContextCache</code> 的默认实现在内存中，使用一个简单的Map，它有一个严格执行的最大容量，以避免内存泄漏，但它没有任何高级缓存功能，如生存时间。如果需要，应该考虑注入具有这些特性的Map，在集群环境中对多个进程的高级使用可能还会考虑使用某种集群缓存实现<code>RetryContextCache</code>（不过，即使在集群环境中，这也可能是多余的）。</p><p><code>RetryOperations</code> 的部分职责是在失败的操作在新执行中返回时识别它们（通常封装在新事务中），为了促进这一点，Spring Retry提供了 <code>RetryState</code> 抽象，这与 <code>RetryOperations</code> 中的特殊 <code>execute</code> 方法一起工作。识别失败操作的方法是跨重试的多个调用标识状态，要标识状态，用户可以提供 <code>RetryState</code> 对象，该对象负责返回标识该项的唯一键，标识符用作<code>RetryContextCache</code> 中的键。</p><p>了解这个之后，我们可以来分析解决了 <code>RetryState</code> 的问题，我们来分析一下open 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RetryContext <span class="title">open</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    Object key = state.getKey();</span><br><span class="line">    <span class="keyword">if</span> (state.isForceRefresh()) &#123;</span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is no cache hit we can avoid the possible expense of the</span></span><br><span class="line">    <span class="comment">// cache re-hydration.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// The cache is only used if there is a failure.</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RetryContext context = <span class="keyword">this</span>.retryContextCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.retryContextCache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RetryException(<span class="string">"Inconsistent state for failed item: no history found. "</span></span><br><span class="line">                    + <span class="string">"Consider whether equals() or hashCode() for the item might be inconsistent, "</span></span><br><span class="line">                    + <span class="string">"or if you need to supply a better ItemKeyGenerator"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The cache could have been expired in between calls to</span></span><br><span class="line">        <span class="comment">// containsKey(), so we have to live with this:</span></span><br><span class="line">        <span class="keyword">return</span> doOpenInternal(retryPolicy, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a clean slate for state that others may be inspecting</span></span><br><span class="line">    context.removeAttribute(RetryContext.CLOSED);</span><br><span class="line">    context.removeAttribute(RetryContext.EXHAUSTED);</span><br><span class="line">    context.removeAttribute(RetryContext.RECOVERED);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码我们可以了解到， 当 state 为空的时候，证明是无状态重试，那么在exectue的时候，优先执行open方法，open 方法又去执行了 <code>doOpenInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RetryContext <span class="title">doOpenInternal</span><span class="params">(RetryPolicy retryPolicy, RetryState state)</span> </span>&#123;</span><br><span class="line">    RetryContext context = retryPolicy.open(RetrySynchronizationManager.getContext());</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setAttribute(RetryContext.STATE_KEY, state.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">        registerContext(context, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doOpenInternal</code> 方法是调用的  policy 的 open 方法，也就是 <code>simplePolicy</code> 的open 方法，<br><code>simplepolicy</code> 的方法就是创建一个 context。 另外在创建的 时候传入了一个父类 <code>context</code><br>那么 <code>RetrySynchronizationManager</code> 是在什么时候注册的呢？</p><p>实在从上面的代码看到，是在 <code>open</code> 方法结束之后，注册的，也就是说，如果同一个线程可如果多次重试，那么 <code>context</code> 是会保留的下来的，是一个链式结构。</p><p>在多个Context 之间可以共享 <code>state</code> 而这个 state 可以放到外边，多个<code>template</code> 可以共享一个<code>state</code><br>当我们的 <code>state</code> 状态设置成 不强制刷新，则会从 <code>this.retryContextCache</code> 中去寻找相关<code>key</code>对应的<code>context</code>用来复用，这样一来就实现了 多个<code>context</code> 共享一个 <code>state</code>.</p><hr><h3><span id="回退策略">回退策略</span></h3><p>重试时的退避策略是什么？是立即重试还是等待一段时间后重试，比如是网络错误，立即重试将导致立即失败，最好等待一小段时间后重试，还要防止很多服务同时重试导致DDos。</p><p><img src="/article/retry-2-spring-retry/retry-2-spring-retry-1596171720.png" alt></p><ul><li><p><strong>NoBackOffPolicy</strong> ：无退避算法策略，即当重试时是立即重试；</p></li><li><p><strong>FixedBackOffPolicy</strong> ：固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒；</p></li><li><p><strong>UniformRandomBackOffPolicy</strong> ：随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在[minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒；</p></li><li><p><strong>ExponentialBackOffPolicy</strong> ：指数退避策略，需设置参数 <code>sleeper、initialInterval、maxInterval</code>和<code>multiplier，initialInterval</code>指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，<code>multiplier</code>指定乘数，即下一次休眠时间为当前休眠时间*multiplier；</p></li><li><p><strong>ExponentialRandomBackOffPolicy</strong> ：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致DDos，使用随机休眠时间来避免这种情况。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.retry.backoff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line"><span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"><span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(<span class="number">3</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"><span class="comment">//退避策略：固定时间退避策略</span></span><br><span class="line">FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line"><span class="comment">// 每次重试间隔5000</span></span><br><span class="line">backOffPolicy.setBackOffPeriod(<span class="number">5000</span>); </span><br><span class="line">template.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">String result = template.execute(context -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们继承图可以看到，固定时间的退避策略继承了 <code>StatelessBackOffPolicy</code> 无状态的退避策略，无状态的退避策略的start 方法 返回null<br>从template 的流程中看到，退避策略一旦出了问题，会直接抛出异常，中断重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatelessBackOffPolicy.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BackOffContext <span class="title">start</span><span class="params">(RetryContext status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="熔断策略">熔断策略</span></h3><p>熔断策略解决的是 当我们随意组合了重试策略，比如说一直重试的时候，保护系统的一种机制，可以根据重试时间来中断重拾，这种中断方式会根据实际请求的来动态调整，我们来看使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">CircuitBreakerRetryPolicy retryPolicy =</span><br><span class="line">        <span class="comment">// 这里使用了 一直重试</span></span><br><span class="line">        <span class="keyword">new</span> CircuitBreakerRetryPolicy(<span class="keyword">new</span> AlwaysRetryPolicy());</span><br><span class="line"><span class="comment">// 超时时间5s</span></span><br><span class="line">retryPolicy.setOpenTimeout(<span class="number">5000</span>);</span><br><span class="line">retryPolicy.setResetTimeout(<span class="number">5000</span>);</span><br><span class="line">template.setRetryPolicy(retryPolicy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object key = <span class="string">"circuit"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(key, isForceRefresh);</span><br><span class="line">        String result = template.execute(<span class="keyword">new</span> RetryCallback&lt;String, RuntimeException&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + context.getRetryCount());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> RecoveryCallback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(RetryContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, state);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说是全局模式呢？我们配置了isForceRefresh为false，则在获取上下文时是根据key “circuit”从缓存中获取，从而拿到同一个上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object key = <span class="string">"circuit"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isForceRefresh = <span class="keyword">false</span>;</span><br><span class="line">RetryState state = <span class="keyword">new</span> DefaultRetryState(key,isForceRefresh);</span><br><span class="line"><span class="comment">//如下RetryTemplate代码说明在有状态模式下，不会在循环中进行重试。</span></span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熔断器策略配置代码，<code>CircuitBreakerRetryPolicy</code> 需要配置三个参数：</p><ul><li><code>delegate</code>：是真正判断是否重试的策略，当重试失败时，则执行熔断策略；</li><li><code>openTimeout</code>：openWindow，配置熔断器电路打开的超时时间，当超过openTimeout之后熔断器电路变成半打开状态（主要有一次重试成功，则闭合电路）；</li><li><code>resetTimeout</code>：timeout，配置重置熔断器重新闭合的超时时间。</li></ul><p>断熔断器电路是否打开的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line">   <span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">   <span class="keyword">if</span> (!retryable) &#123;<span class="comment">//重试失败</span></span><br><span class="line">      <span class="comment">//在重置熔断器超时后，熔断器器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="comment">//当在熔断器打开状态时，熔断器电路打开，立即熔断</span></span><br><span class="line">         <span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//重试成功</span></span><br><span class="line">      <span class="comment">//在熔断器电路半打开状态时，断路器电路闭合，重置上下文</span></span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">         <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line">   <span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从如上代码可看出spring-retry的熔断策略相对简单：</p><ul><li>当重试失败，且在熔断器打开时间窗口[0,openWindow) 内，立即熔断；</li><li>当重试失败，且在指定超时时间后(&gt;timeout)，熔断器电路重新闭合；</li><li>在熔断器半打开状态[openWindow, timeout] 时，只要重试成功则重置上下文，断路器闭合。</li></ul><h2><span id="总结">总结</span></h2><p>从template 的流程我们可以看出spring 工程师的设计思想。<br>1、 核心是一个 while(retry) {} 的循环<br>2、 增加了 listener 等监听机制<br>3、 在 retry 的前后加入了 接口用来实现不同的重试策略<br>4、 在不同的重试策略中，加入了重试的退避策略<br>5、 在不同的策略中和重试主流程中加入了 status 状态用于共享数据。</p><p>我们根据这些机制的不断组合，可以实现更多的重试机制。 核心代码不是很多，也很好理解。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://developer.aliyun.com/article/92899" target="_blank" rel="noopener">spring-retry重试与熔断详解—《亿级流量》内容补充</a></li><li><a href="https://segmentfault.com/a/1190000019932970" target="_blank" rel="noopener">Spring 指南（spring-retry）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之Atomic和LongAddr类（2）</title>
      <link href="/article/java-concurrence-2-1/"/>
      <url>/article/java-concurrence-2-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一节，我们讨论了Atomic类的实现原理，以及代码分析。这一节我来看 <code>LongAddr</code> 类。<code>LongAdder</code> 是JDK8添加到JUC中的。它是一个线程安全的、比Atomic*系工具性能更好的&quot;计数器&quot;。</p><p>首先我们来看一下 Doug Lea 大神对这个类的概述 <code>LongAddr</code></p><blockquote><p><code>LongAdder</code> 中会维护一个或多个变量，这些变量共同组成一个long型的和(这个和就是 <code>LongAddr</code> 的值)。<br>当多个线程同时更新值时，为了减少竞争，可能会动态地增加这组变量的数量。“sum”方法（等效于longValue方法）返回这组变量的“和”值。</p></blockquote><blockquote><p>当我们的场景是为了统计技术，而不是为了更细粒度的同步控制时，并且是在多线程更新的场景时，<code>LongAdder</code> 类比<code>AtomicLong</code>更好用。</p></blockquote><p>在小并发的环境下，论更新的效率，两者都差不多。但是高并发的场景下，LongAdder有着明显更高的吞吐量，但是有着更高的空间复杂度。</p><h2><span id="atomic缺陷">Atomic缺陷</span></h2><p>AtomicLong 的 Add() 是依赖自旋不断的 CAS 去累加一个 Long 值。如果在竞争激烈的情况下，CAS 操作不断的失败，就会有大量的线程不断的自旋尝试 CAS 会造成 CPU 的极大的消耗。</p><h2><span id="longaddr详解">LongAddr详解</span></h2><h2><span id="longaddr-类图">LongAddr 类图</span></h2><p><img src="/article/java-concurrence-2-1/java-concurrence-2-1-105130.png" alt></p><p>这里主要涉及两个主要的类</p><ul><li>Striped64</li><li>LongAddr<br>如果我们要了解 <code>LongAddr</code>， 就要先了解 <code>LongAddr</code> 如何使用。</li></ul><h2><span id="longaddr的使用">LongAddr的使用</span></h2><p>LongAddr 在主要方法体现在一下几个地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">longAdder.add(<span class="number">20L</span>);     <span class="comment">// 增加20</span></span><br><span class="line">longAdder.increment();     <span class="comment">// +1</span></span><br><span class="line">longAdder.decrement();     <span class="comment">// -1 </span></span><br><span class="line"><span class="keyword">long</span> sum = longAdder.sum(); <span class="comment">// 获取 longaddr 值</span></span><br><span class="line"><span class="keyword">long</span> sumThenReset = longAdder.sumThenReset();   <span class="comment">// 将long addr 置零并且获取值</span></span><br><span class="line">longAdder.reset();  <span class="comment">//置零</span></span><br></pre></td></tr></table></figure><h2><span id="add-方法">Add 方法</span></h2><p>对于累加器 最核心的方法就是 add 方法了，我们来看一下add 方法的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 cells 数组不为空，对参数进行 casBase 操作，如果 casBase 操作失败。可能是竞争激烈，进入第二步。</li><li>如果 cells 为空，直接进入 <code>longAccumulate()</code>;</li><li>m = cells 数组长度减一，如果数组长度小于 1，则进入 <code>longAccumulate()</code></li></ol><p>如果都没有满足以上条件，则对当前线程进行某种 hash 生成一个数组下标，对下标保存的值进行 cas 操作。如果操作失败，则说明竞争依然激烈，则进入 <code>longAccumulate()</code>.</p><p>从类图上来看，<code>LongAdder</code> 没有任何的成员比变量，那么add 方法所用的基本上都是<code>Striped64</code> 类中的变量。<code>LongAddr</code> 继承了 <code>Striped64</code> 类，而 <code>Striped64</code> 是计数器的核心功能点.</p><p>这里我们提一个问题:</p><ol><li>Cell 是什么？</li><li>CasBase 方法是什么？</li><li>LongAccumulate 方法又在干什么？</li></ol><p>要解答以上三个问题，我们需要了解一下  Striped64 到底干了什么事情。</p><h2><span id="striped64">Striped64</span></h2><p><code>Striped64</code> 是在java8中添加用来支持累加器的并发组件，它可以在并发环境下使用来做某种计数。</p><h3><span id="设计思路">设计思路</span></h3><p><code>Striped64</code>: 设计思路是在竞争激烈的时候尽量分散竞争，在实现上 <code>Striped64</code> 维护了一个<code>base Count</code>和一个<code>Cell</code>数组。</p><p>计数线程会首先试图更新 <code>base</code> 变量，如果成功则退出计数，否则会认为当前竞争是很激烈的，那么就会通过 <code>Cell</code> 数组来分散计数</p><p><code>Striped64</code> 根据线程来计算哈希，然后将不同的线程分散到不同的Cell数组的 <code>index</code> 上，然后这个线程的计数内容就会保存在该 <code>Cell</code> 的位置上面，基于这种设计，最后的总计数需要结合 <code>base</code> 以及散落在Cell数组中的计数内容。</p><p><img src="/article/java-concurrence-2-1/java-concurrence-2-1-102933.png" alt></p><p>我们来看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cell组</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Unsafe方法，用于</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** CPU数量 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/**Cell数组 2的平方. */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line">    <span class="comment">/** Base value 基础值 */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line">    <span class="comment">/** cells 正在扩容的标志位*/</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line">    Striped64() &#123;&#125;</span><br><span class="line">    <span class="comment">// Cas基础值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** casCellsBusy cas替换，表示正在扩容*/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casCellsBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取线程的 Probe 可以理解为随机数种子  */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">advanceProbe</span><span class="params">(<span class="keyword">int</span> probe)</span> </span>&#123;</span><br><span class="line">        probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">        probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        probe ^= probe &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);</span><br><span class="line">        <span class="keyword">return</span> probe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; sk = Striped64<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            BASE = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"base"</span>));</span><br><span class="line">            CELLSBUSY = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">            Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ... ... ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这，我们可以回答一下上面的几个问题了<br>我们在看一下 <code>add</code> 的代码,分析得到了一下结论</p><p>1、 <code>Cell</code> 是什么<br><code>Cell</code> 就是加了 避免为共享的类 <code>Cell</code> 里面只有一个value值， 更新Cell 的value 值值能通过 cas 方法</p><p>2、 <code>casBase</code> 是更新 <code>base value</code> 的方法， <code>Striped64</code> 有 <code>cell</code> 数组，如果竞争激烈，也就是 <code>casBase</code> 方法 失败，那么意味着多个线程竞争修改 <code>base</code> value值</p><p>3、发生竞争，就去 <code>cell</code> 数组中选择一个 <code>cell</code> 去更新，选择计算 <code>getProbe() &amp; m</code>的值，其中m为 <code>cell</code> 数组个数。</p><p>4、 如果找到了 cell 则执行cell 的cas操作，如果找不到，或者cas操作也失败了则执行 <code>longAccumulate</code> 方法</p><h3><span id="longaccumulate">longAccumulate</span></h3><p>来看一下 <code>longAccumulate</code> 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// ThreadLocalRandom 初始化主要是为了得到 threadLocalRandomProbe 值</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;  <span class="comment">// cells 数组不为空</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// 判断是否有其他线程在扩容</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// 创建一个 Cell </span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// casCellsBusy</span></span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;        </span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// 在cas 下做二次校验 </span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;     <span class="comment">// 赋值成功</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;      <span class="comment">// cells 变成0 以防出异常退出</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;          <span class="comment">// 如果创建了这退出</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// 没有创建成功则继续循环，说明在复制的时候出错了</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))    <span class="comment">// 如果找到cell 直接用cas操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;                       <span class="comment">// 这里仅仅是扩容 没有负责</span></span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Cell数组扩容 </span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                h = advanceProbe(h);         </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一下代表cell 为空 cells == as 表示前面已经经历过 第一层的判断了 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// 初始化</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// case操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从判断上来看，我们一共发现了三个主要逻辑判断<br>在 longAccumulate 中有几个标记位，我们也先理解一下</p><ol><li><code>cellsBusy</code> <code>cells</code> 的操作标记位，如果正在修改、新建、操作 <code>cells</code> 数组中的元素会,会将其 cas 为 1，否则为0。</li><li><code>wasUncontended</code> 表示 <code>cas</code> 是否失败，如果失败则考虑操作升级。</li><li><code>collide</code> 是否冲突，如果冲突，则考虑扩容 <code>cells</code> 的长度。</li></ol><p>整个 for(;;) 死循环，都是以 cas 操作成功而告终。否则则会修改上述描述的几个标记位，重新进入循环。</p><ul><li><p>1、如果Cell不为空 (<code>if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0)</code>)</p><ul><li>果 cell[i] 某个下标为空，则 new 一个 cell，并初始化值，然后退出</li><li>如果 上层传过来的结果是 cas 失败，继续循环。</li><li>如果 cell 不为空，且 cell cas 成功，退出</li><li>如果 cell 的数量，大于等于 cpu 数量或者已经扩容了，继续重试。（扩容没意义）</li><li>设置 collide 为 true。</li><li>获取 cellsBusy 成功就对 cell 进行扩容，获取 cellBusy 失败则重新 hash 再重试。</li></ul></li><li><p>2、 是否能 更新 <code>cellsBusy</code> 值 ，走到这里表示 如果Cell 为空, 这个步骤讲的是需要开始初始化 cell(<code>(cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy())</code>)</p></li><li><p>3、<code>cellsBusy</code> 获取失败,表示有可能别的进程在扩容，则自己去更新 base 值， <code>baseCas</code> ，操作成功退出，不成功则重试<br><code>if (casBase(v = base, ((fn == null) ? v + x :fn.applyAsLong(v, x))</code></p></li></ul><p>至此 longAccumulate 就分析完了。之所以这个方法那么复杂，我认为有两个原因</p><ol><li>是因为并发环境下要考虑各种操作的原子性，所以对于锁都进行了 double check。</li><li>操作都是逐步升级，以最小的代价实现功能。</li></ol><h3><span id="sum-方法">Sum 方法</span></h3><p>它需要累计base和Cell数组中的Cell中的计数，base中的计数为线程竞争不是很激烈的时候累计的数，而在线程竞争比较激烈的时候就会将计数的任务分散到Cell数组中，所以在sum方法里，需要合并两处的计数值。</p><p>除了获取总计数，我们有时候想reset一下，下面的代码展示了这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 大家注意到，这里并没有加锁，也就是标明，sum 调用的时候是允许，其他线程继续更新的。这种只是调用返回的一个快照值，在返回sum的过程中，有可能更新还在继续</strong>。</p><h2><span id="reset-方法">reset 方法</span></h2><p>reset 方法将 base 和每个cell 当中的 value 值重置成0<br>但是有几个需要注意的地方</p><ol><li>reset 方法不会重置 cell 数组的数量。</li><li>reset 调用的前提 是没有线程再去更新值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="striped64在concurrenthashmap">Striped64在ConcurrentHashMap</span></h2><p><code>Striped64</code> 的计数方法在java8的 <code>ConcurrentHashMap</code> 中也有使用，具体的实现细节可以参考 <code>addCount</code> 方法，下面来看一下 <code>ConcurrentHashMap</code> 的size方法的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/30d328e9353b" target="_blank" rel="noopener">Java 并发计数组件Striped64详解</a></li><li><a href="https://xilidou.com/2018/11/27/LongAdder/" target="_blank" rel="noopener">从 LongAdder 中窥见并发组件的设计思路</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之常见的并发工具类(1)</title>
      <link href="/article/java-concurrence-3/"/>
      <url>/article/java-concurrence-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>本文会对java JUC 下的并发包做一个统一的讲解，针对于源码分析环境，需要取查看博主的另外一个系列——<a href="https://icefrozen.github.io/tags/#%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">多线程</a>，这里对细节不在深入。</p><ul><li><p><strong>Semaphore</strong> 信号量是一类经典的同步工具。信号量通常用来限制线程可以同时访问的（物理或逻辑）资源数量。</p></li><li><p><strong>CountDownLatch</strong> 一种非常简单、但很常用的同步辅助类。其作用是在完成一组正在其他线程中执行的操作之前,允许一个或多个线程一直阻塞。</p></li><li><p><strong>CyclicBarrier</strong> 一种可重置的多路同步点，在某些并发编程场景很有用。它允许一组线程互相等待，直到到达某个公共的屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。</p></li><li><p><strong>Phaser</strong> 一种可重用的同步屏障，功能上类似于<code>CyclicBarrier和CountDownLatch</code>，但使用上更为灵活。非常适用于在多线程环境下同步协调分阶段计算任务（Fork/Join框架中的子任务之间需同步时，优先使用Phaser）</p></li><li><p><strong>Exchanger</strong> 允许两个线程在某个汇合点交换对象，在某些管道设计时比较有用。Exchanger提供了一个同步点，在这个同步点，一对线程可以交换数据。每个线程通过exchange()方法的入口提供数据给他的伙伴线程，并接收他的伙伴线程提供的数据并返回。当两个线程通过Exchanger交换了对象，这个交换对于两个线程来说都是安全的。Exchanger可以认为是 SynchronousQueue 的双向形式，在运用到遗传算法和管道设计的应用中比较有用。</p></li></ul><h2><span id="详解">详解</span></h2><h1><span id="countdownlatch">CountDownLatch</span></h1><h2><span id="功能">功能</span></h2><p>等待多线程完成的的同步工具，其作用是在完成一组正在其他线程中执行的操作之前,允许一个或多个线程一直阻塞，在AQS的相关博文中有详细的分析。<a href="https://icefrozen.github.io/article/Java-AQS2/" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)CountDownLatch的分析来解读AQS的共享功能</a></p><h2><span id="举例">举例</span></h2><p>启动10个线程，当10个线程都执行完毕之后才能继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threads.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) result += j;</span><br><span class="line">            <span class="comment">// 线程执行完毕result 之后，计数器 -1 如果-1 后latch 值还是 &gt; 0 则阻塞</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":finsh result:"</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// CountDownLatch 保证 只有在所有的线程执行完毕之后，才能执行 也就是 CountDownLatch  的值为 0</span></span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"end latch"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="详解">详解</span></h2><p>CountDownLatch 的核心 其实就两个方法:await 和 countDown</p><h3><span id="构造方法">构造方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当 status 不为0 则返回失败，根据AQS 的特性，一旦获取失败，则进入等待队列。</span></span><br><span class="line">       <span class="comment">// 具体的 要参考 AQS 的实现</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> c = getState();</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">       <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="await-方法">await 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 依赖于 获取共享锁，如果是 返回获取失败，则表示 需要加锁，在构造函数的时候，将status 设置成了一个具体的值，</span></span><br><span class="line">        <span class="comment">// 所以在调用 await 的时候，线程阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里加入的都是共享锁的Node</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="countdown-方法">countDown 方法</span></h3><p>释放锁，本质是stats - 1 先去释放，如果释放成功，去唤醒所有的共享锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 可以看到，这里如果 tryReleaseShared 释放成功，以为这status == 0 </span></span><br><span class="line">        <span class="comment">// 释放所有的共享Node</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="cyclicbarrier">CyclicBarrier</span></h1><h2><span id="功能">功能</span></h2><p>一种可重置的多路同步点，在某些并发编程场景很有用。它允许一组线程互相等待，直到到达某个公共的屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 <em>CyclicBarrier</em> 很有用。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。<br>看下图：</p><p><img src="/article/java-concurrence-3/java-concurrence-3-125404.png" alt></p><h2><span id="举例">举例</span></h2><p>一下例子，表示只有所有的线程都执行完成之后，才能继续进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTestCyclicBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threads.length, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"============ wake up all ============"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">": await"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">": wake up wait:"</span> + (System.currentTimeMillis() - l));</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="详解">详解</span></h2><h3><span id="构造函数">构造函数</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，当前屏障是否被破坏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 实现的Lock */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition用来实现wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** 等待的屏障数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* 到达屏障要执行的Runnable */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment">     * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment">     * generation or when broken.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从CyclicBarrier的成员来看，它本质上是基于ReentrantLock独占锁实现，通过Lock和Condition的结合，在加上计数器来实现。它的核心方法是await()。</p><h3><span id="核心await-方法">核心await 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">/**获取CyclicBaerrier的内部锁*/</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">/**获取锁*/</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**存储当前的Generation*/</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">/**判断当前的屏障是否被破坏，如果破坏则抛出BrokenBarrierException异常*/</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">/**判断当前线程是否被interrupted，如果被打断，则breakBarrier破坏屏障*/</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/**记录当前屏障等待个数*/</span> </span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 最后一个预留到达屏障的线程</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="comment">/**执行barrierCommand指令*/</span></span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">/**执行下一个Generation*/</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">/**如果barrierCommand执行失败，进行屏障破坏处理*/</span></span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程不是最后一个到达的线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)<span class="comment">///调用Condition的await()方法阻塞</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)<span class="comment">///调用Condition的awaitNanos()方法阻塞</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">/**如果当前线程被中断，则判断是否有其他线程已经使屏障破坏。若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程*/</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，核心的思想就是先判断当前执行的线程是否到达了最后一个屏障，如果到达最后一个屏障：“判断barrierCommand是否为空，不为空执行barrierCommand任务，接着执行nextGeneration方法。在nextGeneration方法中通过Condition的signalAll唤醒其它阻塞的线程开始继续执行。”</p><h1><span id="semaphore">Semaphore</span></h1><h2><span id="功能">功能</span></h2><p>Semaphore管理着一组许可（permit）,许可的初始数量可以通过构造函数设定，操作时首先要获取到许可，才能进行操作，操作完成后需要释放许可。如果没有获取许可，则阻塞到有许可被释放。如果初始化了一个许可为1的Semaphore，那么就相当于一个不可重入的互斥锁</p><p>Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。</p><h2><span id="举例">举例</span></h2><p>洗手间是有10个槽位，在同一时刻，只能为10个人提供该服务。<code>Semaphore</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSemaphore</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">10</span>;</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; washRoom= <span class="keyword">new</span> HashMap&lt;&gt;(solt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        washRoom.put(i, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是有10个槽位，所以每次是能有10个线程执行</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(solt);</span><br><span class="line">    Runnable r  = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有获取到坑位，则阻塞</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="keyword">int</span> name = Integer.parseInt(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> index = name % <span class="number">10</span>;</span><br><span class="line">            List&lt;String&gt; list = washRoom.get(index);</span><br><span class="line">            list.add(name + <span class="string">""</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt * <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.setName(i + <span class="string">""</span>);</span><br><span class="line">        threads[i] =  thread;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(washRoom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="详解">详解</span></h2><h3><span id="构造函数">构造函数</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="acquire">acquire</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="release">release</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 Semaphore 的本质是一个基于 AQS的共享锁的方法，这里不做具体的分析。</p><h1><span id="phaser">Phaser</span></h1><h2><span id="功能">功能</span></h2><table><thead><tr><th>同步器</th><th>作用</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归0后，所有等待的线程继续执行</td></tr><tr><td>CyclicBarrier</td><td>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</td></tr><tr><td>Phaser</td><td>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）</td></tr></tbody></table><ul><li><p>phase(阶段)<br>我们知道，在CyclicBarrier中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。Phaser也有栅栏，在Phaser中，栅栏的名称叫做<strong>phase(阶段)</strong>，在任意时间点，Phaser只处于某一个phase(阶段)，初始阶段为0，最大达到<strong>Integerr.MAX_VALUE</strong>，然后再次归零。当所有<strong>parties参与者都到达后，phase值会递增</strong>。</p></li><li><p>parties(参与者)<br>parties(参与者)其实就是CyclicBarrier中的参与线程的概念。CyclicBarrier中的参与者在初始构造指定后就不能变更，而Phaser既可以在初始构造时指定参与者的数量，也可以中途通过register、bulkRegister、arriveAndDeregister等方法注册/注销参与者。</p></li><li><p>arrive(到达) / advance(进阶)<br>Phaser注册完parties（参与者）之后，参与者的初始状态是unarrived的，当参与者到达（arrive）当前阶段（phase）后，状态就会变成arrived。当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生进阶（advance）——也就是phase值+1。</p></li></ul><h2><span id="举例">举例</span></h2><h3><span id="example1">Example1</span></h3><p>有时候我们希望所有线程到达指定点后再同时开始执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> solt = <span class="number">3</span>;</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行开始任务:"</span> + phaser.getPhase());</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase:"</span> + i + <span class="string">"="</span> + phaser.getPhase());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 注册solt个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        phaser.register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者使用</span></span><br><span class="line">    <span class="comment">//phaser.bulkRegister(solt);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample1-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> registeredParties = phaser.getRegisteredParties();</span><br><span class="line">    <span class="keyword">int</span> arrivedParties = phaser.getArrivedParties();</span><br><span class="line">    System.out.println(<span class="string">"registeredParties:"</span> + registeredParties);</span><br><span class="line">    System.out.println(<span class="string">"arrivedParties:"</span> + arrivedParties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PhaserTestExample1-0: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-1: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-2: 执行开始任务:0</span><br><span class="line">PhaserTestExample1-2: 执行完任务，当前phase:1=1</span><br><span class="line">PhaserTestExample1-1: 执行完任务，当前phase:1=1</span><br><span class="line">PhaserTestExample1-0: 执行完任务，当前phase:1=1</span><br><span class="line">registeredParties:3</span><br><span class="line">arrivedParties:0</span><br></pre></td></tr></table></figure><p>以上示例中，创建了3个线程，并通过 <code>register</code> 或者 <code>bulkRegister</code>，方法注册Phaser的参与者数量为3。当某个线程调用<code>arriveAndAwaitAdvance</code> 方法后，<code>arrive</code>数量会加1，如果数量没有满足总数（参与者数量3），当前线程就是一直等待，当最后一个线程到达后，phase(阶段) 会 + 1， 然后所有线程都会继续往下执行。</p><blockquote><p>注意：arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考awaitAdvanceInterruptibly方法。</p></blockquote><h3><span id="example2">Example2</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//注册主线程,当外部条件满足时,由主线程打开开关</span></span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":任务准备"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + i + <span class="string">""</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    phaser.bulkRegister(solt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample2-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部条件:等待用户输入命令</span></span><br><span class="line">    System.out.println(<span class="string">"Press ENTER to continue"</span>);</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    reader.readLine();</span><br><span class="line">    <span class="comment">// 放开阀门 主线程打开了开关</span></span><br><span class="line">    phaser.arriveAndDeregister();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> registeredParties = phaser.getRegisteredParties();</span><br><span class="line">    <span class="keyword">int</span> arrivedParties = phaser.getArrivedParties();</span><br><span class="line">    System.out.println(<span class="string">"registeredParties:"</span> + registeredParties);</span><br><span class="line">    System.out.println(<span class="string">"arrivedParties:"</span> + arrivedParties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PhaserTestExample2-0:任务准备</span><br><span class="line">PhaserTestExample2-2:任务准备</span><br><span class="line">Press ENTER to continue</span><br><span class="line">PhaserTestExample2-1:任务准备</span><br><span class="line">[输入回车]</span><br><span class="line">PhaserTestExample2-1: 执行完任务，当前phase =1</span><br><span class="line">PhaserTestExample2-0: 执行完任务，当前phase =1</span><br><span class="line">PhaserTestExample2-2: 执行完任务，当前phase =1</span><br><span class="line">registeredParties:3</span><br><span class="line">arrivedParties:0</span><br></pre></td></tr></table></figure><p>由于 Phaser 设置的阶段为1 当所有线程到达的时候，发现是阶段到达的阶段是0，不是1，于是所有线程继续等待，当执行 arriveAndDeregister 的时候，所有已经执行到0的阶段参与者都+1， 发现自己到达的阶段和 Phaser 一直，则运行。以上示例中，只有当用户按下回车之后，任务才真正开始执行。这里主线程Main相当于一个协调者，用来控制开关打开的时机，arriveAndDeregister方法不会阻塞，该方法会将到达数加1，同时减少一个参与者数量，最终返回线程到达时的phase值。</p><h3><span id="example3">Example3</span></h3><p>通过Phaser控制任务的执行轮数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PhaserTestExample3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> solt = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[solt];</span><br><span class="line">    Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">            <span class="comment">//如果返回 True 则Phaser结束</span></span><br><span class="line">            <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= solt  || registeredParties == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    phaser.bulkRegister(solt);</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123; <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">            <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solt; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"PhaserTestExample3-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------PHASE[<span class="number">0</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br><span class="line">---------------PHASE[<span class="number">1</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">---------------PHASE[<span class="number">2</span>],Parties[<span class="number">3</span>] ---------------</span><br><span class="line">PhaserTestExample3-<span class="number">1</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">2</span>: 执行完任务</span><br><span class="line">PhaserTestExample3-<span class="number">0</span>: 执行完任务</span><br></pre></td></tr></table></figure><p>以上示例中，我们在创建Phaser对象时，覆写了onAdvance方法，这个方法类似于CyclicBarrier中的barrierAction任务。<br>也就是说，当最后一个参与者到达时，会触发onAdvance方法，入参phase表示到达时的phase值，registeredParties表示到达时的参与者数量，返回true表示需要终止Phaser。</p><p>我们通过phase + 1 &gt;= repeats ，来控制阶段（phase）数的上限为2（从0开始计），最终控制了每个线程的执行任务次数为repeats次。如果返回 True 则Phaser结束</p><h3><span id="example4">Example4</span></h3><p>Phaser支持分层功能，我们先来考虑下如何用利用Phaser的分层来实现高并发时的优化，在示例三中，我们其实创建了10个线程，然后10个线程共用一个Phaser对象，如下图：</p><p><img src="/article/java-concurrence-3/java-concurrence-3-1615185688374.png" alt></p><p>如果任务数继续增大，那么同步产生的开销会非常大，利用Phaser分层的功能，我们可以限定每个Phaser对象的最大使用线程（任务数），如下图：</p><p><img src="/article/java-concurrence-3/java-concurrence-3-1615185703185.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASKS_PER_PHASER = <span class="number">4</span>;      <span class="comment">// 每个Phaser对象对应的工作线程（任务）数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">                <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Tasker[] taskers = <span class="keyword">new</span> Tasker[<span class="number">10</span>];</span><br><span class="line">        build(taskers, <span class="number">0</span>, taskers.length, phaser);       <span class="comment">// 根据任务数,为每个任务分配Phaser对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskers.length; i++) &#123;          <span class="comment">// 执行任务</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(taskers[i]);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Tasker[] taskers, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Phaser phaser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &gt; TASKS_PER_PHASER) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i += TASKS_PER_PHASER) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">                build(taskers, i, j, <span class="keyword">new</span> Phaser(phaser));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; ++i)</span><br><span class="line">                taskers[i] = <span class="keyword">new</span> Tasker(i, phaser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tasker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        Tasker(<span class="keyword">int</span> i, Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">            <span class="keyword">this</span>.phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!phaser.isTerminated()) &#123;   <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">                <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务, index:"</span> + <span class="keyword">this</span>.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---------------PHASE[0],Parties[3] ---------------</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">---------------PHASE[1],Parties[3] ---------------</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">---------------PHASE[2],Parties[3] ---------------</span><br><span class="line">Thread-0: 执行完任务, index:0</span><br><span class="line">Thread-8: 执行完任务, index:8</span><br><span class="line">Thread-1: 执行完任务, index:1</span><br><span class="line">Thread-6: 执行完任务, index:6</span><br><span class="line">Thread-9: 执行完任务, index:9</span><br><span class="line">Thread-3: 执行完任务, index:3</span><br><span class="line">Thread-5: 执行完任务, index:5</span><br><span class="line">Thread-4: 执行完任务, index:4</span><br><span class="line">Thread-7: 执行完任务, index:7</span><br><span class="line">Thread-2: 执行完任务, index:2</span><br></pre></td></tr></table></figure><h2><span id="详解">详解</span></h2><p>由于Phaser的实现过于复杂，本篇章不做详解，又想去请看Phaser的源码分析</p><h1><span id="exchanger">Exchanger</span></h1><h2><span id="功能">功能</span></h2><p>Exchanger类允许在2个线程间定义同步点，当2个线程到达这个点，他们相互交换数据类型，使用第一个线程的数据类型变成第二个的，然后第二个线程的数据类型变成第一个的</p><h2><span id="举例">举例</span></h2><p>以下的例子，将两个线程间的线程名交换，交换之前阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchangerTestExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    Runnable r = () -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String myName = Thread.currentThread().getName();</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(myName + <span class="string">" want to exchange data and i waiting"</span>);</span><br><span class="line">            String hisName = exchanger.exchange(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(myName + <span class="string">": "</span> + hisName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads[i].setName(<span class="string">"exchangerTestExample-"</span> + i);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exchangerTestExample-1 want to exchange data and i waiting</span><br><span class="line">[...]</span><br><span class="line">exchangerTestExample-0 want to exchange data and i waiting</span><br><span class="line">exchangerTestExample-0: exchangerTestExample-1</span><br><span class="line">exchangerTestExample-1: exchangerTestExample-0</span><br></pre></td></tr></table></figure><p>根据上面的输出，我们得出结论，当第一个线程阻塞在 <code>exchanger.exchange(Thread.currentThread().getName())</code> 方法中，因为 exchanger 没有数据因而线程阻塞，当第二个线程执行到 相同的位置的时候，发现里面有数据，则立刻交换，并且唤醒第一个线程。</p><h2><span id="详解">详解</span></h2><p>Exchanger 是一种无锁算法</p><h3><span id="构造">构造</span></h3><ul><li>构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    participant = <span class="keyword">new</span> Participant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除非当前线程被中断，否则一直等待另一个线程到达这个交换点，然后将交换的数据x传输给它，并收到另一个线程传过来的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 和上一个方法功能基本一样，只不过这个方法增加了等待超时时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure><h3><span id="participant-和-node">Participant 和 Node</span></h3><p>Participant 是将 Node 封装成了  ThreadLocal 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Node 结构如下</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;                  <span class="comment">// arena的下标，多个槽位的时候利用</span></span><br><span class="line">    <span class="keyword">int</span> bound;                  <span class="comment">// 上一次记录的Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> collides;               <span class="comment">// 在当前bound下CAS失败的次数；</span></span><br><span class="line">    <span class="keyword">int</span> hash;                   <span class="comment">// 用于自旋；</span></span><br><span class="line">    Object item;                <span class="comment">// 这个线程的当前项，也就是需要交换的数据；</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;      <span class="comment">//做releasing操作的线程传递的项；</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked;     <span class="comment">//挂起时设置线程值，其他情况下为null；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们讲几个概念</p><ul><li>index：arena的下标，多个槽位的时候利用；</li><li>bound：上一次记录的Exchanger.bound；</li><li>collides：在当前bound下CAS失败的次数；</li><li>hash：伪随机数，用于自旋；</li><li>item：这个线程的当前项，也就是需要交换的数据；</li><li>match：交换的数据；</li><li>parked：挂起时设置线程值，其他情况下为null；</li></ul><p>我们现阶段先对这个几个有个印象，接下来我们详细分析一下交换的过程。</p><h3><span id="exchange-方法">exchange 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// NULL_ITEM 是一个替代的对象，这里可以简单理解为默认值</span></span><br><span class="line">    <span class="comment">// 主要是因为 slotExchange 和  arenaExchange 并没有做非空的判断</span></span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> ||</span><br><span class="line">        (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// disambiguates null return</span></span><br><span class="line">        (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Elimination array; null until enabled (within slotExchange).</span></span><br><span class="line"><span class="comment"> * Element accesses use emulation of volatile gets and CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br></pre></td></tr></table></figure><p>我们看到这里有几个核心点</p><ol><li>slotExchange 方法</li><li>arenaExchange 方法</li><li>arena 是干什么用的。</li></ol><p>看到这，我们首先解决几个核心属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Participant participant;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node[] arena;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Node slot;</span><br></pre></td></tr></table></figure><p>为什么会有 arena数组槽? slot为单个槽，arena为数组槽, 他们都是Node类型。在这里可能会感觉到疑惑，slot作为Exchanger交换数据的场景，应该只需要一个就可以了啊?</p><p>为何还多了一个Participant 和数组类型的arena呢?</p><p>一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是Exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争是才会生成arena数组。 那么怎么将Node与当前线程绑定呢？<br>Participant，Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中记录在arena中的下标index。</p><p>根据逻辑，我们可以知道，当arena 为空或者 <code>slotExchange</code> 为空的时候，执行 <code>arenaExchange</code> 方法。当我们第一次调用exchange 方法的时候，必然 arena 为空。我们往下看，看看 <code>slotExchange</code> 究竟干甚了什么？</p><h3><span id="slotexchange">slotExchange</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">slotExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程node对象</span></span><br><span class="line">    Node p = participant.get();</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();  </span><br><span class="line">    <span class="comment">// 若果线程被中断，就直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (t.isInterrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">        <span class="comment">// 将slot值赋给q</span></span><br><span class="line">        <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line">            <span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;</span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">            <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">                arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arena != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// caller must reroute to arenaExchange</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里表示当前线程是以第一个线程进来交换数据</span></span><br><span class="line">            <span class="comment">// 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程</span></span><br><span class="line">            <span class="comment">// 将需要交换的数据先存放在当前线程变量p中 </span></span><br><span class="line">            <span class="comment">// 这里将 第一个想成的Node 放到了 solt 当中</span></span><br><span class="line">            p.item = item;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, <span class="keyword">null</span>, p))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot</span></span><br><span class="line">            <span class="comment">// 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据</span></span><br><span class="line">            p.item = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// await release</span></span><br><span class="line">    <span class="comment">// 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，</span></span><br><span class="line">    <span class="comment">// 等待其它线程交换数据然后唤醒当前线程</span></span><br><span class="line">    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">    <span class="keyword">long</span> end = timed ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="keyword">int</span> spins = (NCPU &gt; <span class="number">1</span>) ? SPINS : <span class="number">1</span>;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="comment">// 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot</span></span><br><span class="line">    <span class="comment">// 如果另一个线程 将p.match 设置上，这里就可以跳出自选了</span></span><br><span class="line">    <span class="keyword">while</span> ((v = p.match) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 下面的逻辑主要是自旋等待，直到spins递减到0为止</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// h 表示一个随机数 这样计算似的 h 可以在正负当中来回摆动 概率是1：1</span></span><br><span class="line">            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>)</span><br><span class="line">                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 让出cpu</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果slot ！= p 证明已经有一个线程准备搞好了，这时候需要回到 while 判断match 是否存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slot != p)</span><br><span class="line">            spins = SPINS;</span><br><span class="line">        <span class="comment">// 此处表示未设置超时或者时间未超时 需要将本线程阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; arena == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (!timed || (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 给p挂机线程的值赋值</span></span><br><span class="line">            p.parked = t;</span><br><span class="line">            <span class="keyword">if</span> (slot == p)</span><br><span class="line">                <span class="comment">// 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起</span></span><br><span class="line">                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">            p.parked = <span class="keyword">null</span>;</span><br><span class="line">            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arena不为null则v为null,其它为超时则v为超时对象TIMED_OUT，并且跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            v = timed &amp;&amp; ns &lt;= <span class="number">0L</span> &amp;&amp; !t.isInterrupted() ? TIMED_OUT : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    p.hash = h;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序首先通过participant获取当前线程节点Node。检测是否中断，如果中断return null，等待后续抛出InterruptedException异常。<ul><li><p>如果slot不为null，则进行slot消除，成功直接返回数据V，否则失败，则创建arena消除数组。 (如果slot不为null 则证明第一个进入交换区的线程已经准备好数据也就是拿到了q,然后让将自己的q 赋值给match， 然后惊醒slot消除)</p></li><li><p>如果slot为null，但arena不为null，则返回null，进入arenaExchange逻辑。 (arena 不为null 的逻辑在solt 不为null 且赋值 <strong><em>U.compareAndSwapObject(this, SLOT, q, null)</em></strong> 失败),证明一瞬间 SLOT 发生了金正，改变了原来的非Q的状态。</p></li><li><p>如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入spin+block(自旋+阻塞)模式。</p></li><li><p>在自旋+阻塞模式中，首先取得结束时间和自旋次数。如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋(改自旋使用当前节点中的hash，并改变之)和退让。当自旋数为0后，假如slot发生了改变(slot != p)则重置自旋数并重试。</p></li><li><p>否则假如：当前未中断&amp;arena为null&amp;(当前不是限时版本或者限时版本+当前时间未结束)：阻塞或者限时阻塞。假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：不限时版本：置v为null；限时版本：</p></li><li><p>如果时间结束以及未中断则TIMED_OUT；否则给出null(原因是探测到arena非空或者当前线程中断)。 match不为空时跳出循环。</p></li></ul></li></ul><h3><span id="arenaexchange">arenaExchange</span></h3><p>此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据。</p><p>Exchanger最复杂的地方就是它的多槽位交换（arenaExchange），我们先看下，什么时候会触发多槽位交换？</p><p>单槽交换（slotExchange）中有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node q;;) &#123;</span><br><span class="line">    <span class="comment">// 将slot值赋给q</span></span><br><span class="line">    <span class="keyword">if</span> ((q = slot) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了</span></span><br><span class="line">        <span class="comment">// 通过CAS将slot设置成null</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, SLOT, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Object v = q.item;</span><br><span class="line">            q.match = item;</span><br><span class="line">            Thread w = q.parked;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(w);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create arena on contention, but continue until slot null</span></span><br><span class="line">        <span class="keyword">if</span> (NCPU &gt; <span class="number">1</span> &amp;&amp; bound == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, <span class="number">0</span>, SEQ))</span><br><span class="line">            arena = <span class="keyword">new</span> Node[(FULL + <span class="number">2</span>) &lt;&lt; ASHIFT];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果在单槽交换中，同时出现了多个配对线程竞争修改slot槽位，导致某个线程CAS修改slot失败时，就会初始化arena多槽数组，后续所有的交换都会走arenaExchange,多槽交换方法arenaExchange的整体流程和slotExchange类似，主要区别在于它会根据当前线程的数据携带结点Node中的index字段计算出命中的槽位。如果槽位被占用，说明已经有线程先到了，之后的处理和slotExchange一样；<br>如果槽位有效且为null，说明当前线程是先到的，就占用槽位，然后按照：spin-&gt;yield-&gt;block这种锁升级的顺序进行优化的等待，等不到配对线程就会进入阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timed 为true表示设置了超时时间，ns为&gt;0的值，反之没有设置超时时间</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title">arenaExchange</span><span class="params">(Object item, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> ns)</span> </span>&#123;</span><br><span class="line">        Node[] a = arena;</span><br><span class="line">        <span class="comment">// 获取当前线程中的存放的node</span></span><br><span class="line">        Node p = participant.get();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p.index;;) &#123;                      <span class="comment">// access slot at i</span></span><br><span class="line">            <span class="keyword">int</span> b, m, c; <span class="keyword">long</span> j;                       <span class="comment">// j is raw array offset</span></span><br><span class="line">            Node q = (Node)U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; U.compareAndSwapObject(a, j, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Object v = q.item;                     <span class="comment">// release</span></span><br><span class="line">                q.match = item;</span><br><span class="line">                Thread w = q.parked;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.item = item;                         <span class="comment">// offer</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, <span class="keyword">null</span>, p)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> end = (timed &amp;&amp; m == <span class="number">0</span>) ? System.nanoTime() + ns : <span class="number">0L</span>;</span><br><span class="line">                    Thread t = Thread.currentThread(); <span class="comment">// wait</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = p.hash, spins = SPINS;;) &#123;</span><br><span class="line">                        Object v = p.match;</span><br><span class="line">                        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            U.putOrderedObject(p, MATCH, <span class="keyword">null</span>);</span><br><span class="line">                            p.item = <span class="keyword">null</span>;             <span class="comment">// clear for next use</span></span><br><span class="line">                            p.hash = h;</span><br><span class="line">                            <span class="keyword">return</span> v;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            h ^= h &lt;&lt; <span class="number">1</span>; h ^= h &gt;&gt;&gt; <span class="number">3</span>; h ^= h &lt;&lt; <span class="number">10</span>; <span class="comment">// xorshift</span></span><br><span class="line">                            <span class="keyword">if</span> (h == <span class="number">0</span>)                <span class="comment">// initialize hash</span></span><br><span class="line">                                h = SPINS | (<span class="keyword">int</span>)t.getId();</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp;          <span class="comment">// approx 50% true</span></span><br><span class="line">                                     (--spins &amp; ((SPINS &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">                                Thread.yield();        <span class="comment">// two yields per wait</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) != p)</span><br><span class="line">                            spins = SPINS;       <span class="comment">// releaser hasn't set match yet</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; m == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                 (!timed ||</span><br><span class="line">                                  (ns = end - System.nanoTime()) &gt; <span class="number">0L</span>)) &#123;</span><br><span class="line">                            U.putObject(t, BLOCKER, <span class="keyword">this</span>); <span class="comment">// emulate LockSupport</span></span><br><span class="line">                            p.parked = t;              <span class="comment">// minimize window</span></span><br><span class="line">                            <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                                U.park(<span class="keyword">false</span>, ns);</span><br><span class="line">                            p.parked = <span class="keyword">null</span>;</span><br><span class="line">                            U.putObject(t, BLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                                 U.compareAndSwapObject(a, j, p, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (m != <span class="number">0</span>)                <span class="comment">// try to shrink</span></span><br><span class="line">                                U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ - <span class="number">1</span>);</span><br><span class="line">                            p.item = <span class="keyword">null</span>;</span><br><span class="line">                            p.hash = h;</span><br><span class="line">                            i = p.index &gt;&gt;&gt;= <span class="number">1</span>;        <span class="comment">// descend</span></span><br><span class="line">                            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">if</span> (timed &amp;&amp; m == <span class="number">0</span> &amp;&amp; ns &lt;= <span class="number">0L</span>)</span><br><span class="line">                                <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                            <span class="keyword">break</span>;                     <span class="comment">// expired; restart</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.item = <span class="keyword">null</span>;                     <span class="comment">// clear offer</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.bound != b) &#123;                    <span class="comment">// stale; reset</span></span><br><span class="line">                    p.bound = b;</span><br><span class="line">                    p.collides = <span class="number">0</span>;</span><br><span class="line">                    i = (i != m || m == <span class="number">0</span>) ? m : m - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                         !U.compareAndSwapInt(<span class="keyword">this</span>, BOUND, b, b + SEQ + <span class="number">1</span>)) &#123;</span><br><span class="line">                    p.collides = c + <span class="number">1</span>;</span><br><span class="line">                    i = (i == <span class="number">0</span>) ? m : i - <span class="number">1</span>;          <span class="comment">// cyclically traverse</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = m + <span class="number">1</span>;                         <span class="comment">// grow</span></span><br><span class="line">                p.index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="总结">总结</span></h3><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/luoyoub/article/details/80635652" target="_blank" rel="noopener">JUC五种常见同步工具类总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/38012490" target="_blank" rel="noopener">Java并发编程——CyclicBarrie</a></li><li><a href="https://segmentfault.com/a/1190000015979879" target="_blank" rel="noopener">Java多线程进阶（二二）—— J.U.C之synchronizer框架：Phaser</a></li><li><a href="https://blog.csdn.net/qq_38293564/article/details/80564183" target="_blank" rel="noopener">Java并发编程之Exchanger详解</a></li><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html" target="_blank" rel="noopener">JUC工具类: Exchanger详解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之Atomic和LongAddr类（1）</title>
      <link href="/article/java-concurrence-2/"/>
      <url>/article/java-concurrence-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><h2><span id="atomic与longaddr解决什么问题">Atomic与LongAddr解决什么问题</span></h2><p>解决变量赋值的原子性问题。 底层采用的是CAS的自旋的方式来实现的。CAS会有ABA和性能的问题，Atomic 采用版本号的方式来解决ABA的问题。ABA问题是否会对业务产生影响，还需要业务方自己评估，大部分情况下比如一些非金融业务系统中，ABA不会对业务造成影响。<br>至于性能问题，CAS自旋的方式确实会造成一些CPU的空转，因为严格意义上来说CAS不能算是锁，所以说CAS的也有适用范围。</p><p>自旋操作适用于线程竞争力度大，线程执行时间比较短的情况。这种情况下，CAS自旋空转的等待时间表少，如线程运行时间比较长，最好的方式还是使用重量级的锁，比如说 synchronized AQS等重量级的锁。</p><h2><span id="atomic类与longaddr类简单对比">Atomic类与LongAddr类简单对比</span></h2><p>我们来看一个实例程序 分别来计算 <code>synchronized</code>,<code>Atomic</code>,<code>LongAdder</code> 运行N秒，累加数量的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例： 同时运行5秒，检查谁的次数最多</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// synchronized 方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Atomic方式</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong acount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// LongAdder 方式  （jdk1.8,新计数器）</span></span><br><span class="line">    <span class="keyword">private</span> LongAdder lacount = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    <span class="comment">// 运行时间，毫秒数</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> time=<span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 同步代码块的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"SyncThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + count);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    acount.incrementAndGet(); <span class="comment">// acount++;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"AtomicThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + acount.incrementAndGet());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLongAdder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">while</span> (System.currentTimeMillis() - starttime &lt; time) &#123; <span class="comment">// 运行两秒</span></span><br><span class="line">                    lacount.increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"LongAdderThread spend:"</span> + (endtime - starttime) + <span class="string">"ms"</span> + <span class="string">" v:"</span> + lacount.sum());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdderDemo demo = <span class="keyword">new</span> LongAdderDemo();</span><br><span class="line">        demo.testSync();</span><br><span class="line">        demo.testAtomic();</span><br><span class="line">        demo.testLongAdder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看耗时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">SyncThread spend:<span class="number">10000</span>ms v:<span class="number">102578641</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832099</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832100</span></span><br><span class="line">AtomicThread spend:<span class="number">10000</span>ms v:<span class="number">243832101</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309048936</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309098061</span></span><br><span class="line">LongAdderThread spend:<span class="number">10000</span>ms v:<span class="number">309356235</span></span><br></pre></td></tr></table></figure><blockquote><p>从耗时就可以看出来，在相同的时间内，LongAddr执行的效率最高，可以是sync关键字的2倍，是Atomic的1.5倍左右。<br>本次的数据仅在这个测试用例中生效。每个单元的执行效率还是要根据具体的业务来看。</p></blockquote><h2><span id="类图">类图</span></h2><p><img src="/article/java-concurrence-2/java-concurrence-2-211756.png" alt></p><h2><span id="atomic-详解">Atomic 详解</span></h2><h2><span id="atomic-家族概述">Atomic 家族概述</span></h2><ul><li><strong>AtomicBoolean</strong>  boolean 类型的atomic类</li><li><strong>AtomicInteger</strong>  Integer 类型 atomic 类</li><li><strong>AtomicIntegerArray</strong>  List元素为Integer ，且元素支持原子更新的类</li><li><strong>AtomicIntegerFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新</li><li><strong>AtomicLong</strong>    Long类型的atomic类</li><li><strong>AtomicLongArray</strong> List元素为Long ，且元素支持原子更新的类</li><li><strong>AtomicLongFieldUpdater</strong>   基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新</li><li><strong>AtomicMarkableReference</strong> 是带了布尔型标记位(Boolean mark)的引用型原子量，每次执行CAS操作是需要对比该标记位，如果标记满足要求，则操作成功，否则操作失败。</li><li><strong>AtomicReference</strong> 提供了一个可以原子读写的对象引用变量</li><li><strong>AtomicReferenceArray</strong>  List元素为引用类型 ，且元素支持原子更新的类</li><li><strong>AtomicReferenceFieldUpdater</strong> 基于反射的实用工具，可以对指定类的指定 volatile object 字段进行原子更新</li><li><strong>AtomicStampedReference</strong> 是带了整型标记值(int stamp)的引用型原子变量，每次执行CAS操作时需要对比版本，如果版本满足要求，则操作成功，否则操作失败，用于防止CAS操作的ABA问题。</li></ul><h2><span id="atomic-详解">Atomic 详解</span></h2><p>下面我们来具体分析一下 <code>AtomicInteger</code> 这个类<br>AtomicInteger 的核心字段一共有三个</p><ol><li>unsafe 对象</li><li>value 值</li><li>valueOffset在对象中的偏移量</li></ol><p>方法如下图：</p><p><img src="/article/java-concurrence-2/java-concurrence-2-102243.png" alt></p><ul><li>Unsafe 更新值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// atomic 具体的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>几个核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unsafe 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 省略其他</span></span><br></pre></td></tr></table></figure><p>从这个方法就能看出，其实Atomic其实调用的是Unsafe类中的 <code>do while</code> 代码块来实现CAS交换的，而<code>Unsafe</code>中这个方法<code>compareAndSwapInt</code>是一个Native的方法。</p><p>unsafe对象在类初始化的时候，已经将<code>Atomic</code> 中用于存放直的value 的偏移量生成 <code>valueOffset</code>， 用于更新操作。<br>再在更新的时候，调用 <code>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</code> 方法，意思是，将本类的<code>valueOffset</code>的偏移量更新成<code>update</code>值，如果<code>this</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。</p><p>我们来看一下OpenJDK中的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a> 方法</p><ul><li>CAS底层原理</li></ul><p>CAS底层使用JNI调用C代码实现的，如果你有Hotspot源码，那么在Unsafe.cpp里可以找到它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//openjdk-jdk8u源码：/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>compareAndSwapInt</code> 和  compareAndSwapLong 实现是在 <code>Unsafe_CompareAndSwapInt</code> 和 <code>Unsafe_CompareAndSwapLong</code><br>下面我们深入到 <code>Unsafe_CompareAndSwapInt</code> 中去。</p><h3><span id="unsafe_compareandswapint-方法">Unsafe_CompareAndSwapInt 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  <span class="comment">// p是取出的对象</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// addr是p中offset处的地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();   <span class="comment">// &gt;1 = true</span></span><br><span class="line">  <span class="comment">// __asm__说明是ASM汇编，__volatile__禁止编译器优化</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">                    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">                    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">                    : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br><span class="line"><span class="string">  return exchange_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp</span></span><br><span class="line"><span class="string">static inline bool is_MP() &#123;</span></span><br><span class="line"><span class="string">    assert(_processor_count &gt; 0, "</span>invalid processor count<span class="string">");</span></span><br><span class="line"><span class="string">    // 我们可以利用 -XX:-AssumeMP 这个参数关闭多核运行状态 </span></span><br><span class="line"><span class="string">    return _processor_count &gt; 1 || AssumeMP;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">static int _processor_count;              // number of processors</span></span><br></pre></td></tr></table></figure><p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌汇编模板</span></span><br><span class="line"><span class="comment">// 第1行：汇编语句</span></span><br><span class="line">asm ( assembler template</span><br><span class="line">     <span class="comment">// 第2行：输出参数，以','分割</span></span><br><span class="line">      : <span class="function">output <span class="title">operands</span>               <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">     <span class="comment">// 第3行：输入参数，以','分割</span></span></span><br><span class="line"><span class="function">      : input <span class="title">operands</span>                <span class="params">(optional)</span></span></span><br><span class="line"><span class="function">      : list of clobbered registers   </span></span><br><span class="line"><span class="function">        <span class="params">(optional)</span>   </span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><p>对照下面的源码，关键字<code>asm</code>和<code>__asm__</code>用于说明随后的字符串是内联汇编代码块。<code>volatile</code> 或 <code>__volatile__</code> 是可选的，可以将它们添加到 <code>asm</code> 后面，禁止某些编译器的优化。其实，<code>asm</code>和<code>__asm__</code>几乎是相同的，惟一的区别是，当预处理程序宏中使用内联汇编时，<code>asm</code>在编译过程中可能会引发警告，<code>volatile</code>也是同样的道理。因此Atomic::cmpxchg函数中汇编指令部分源码可以作如下解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义表达的意思，后面再说</span></span><br><span class="line"><span class="comment">// 第1行：表示汇编指令 cmpxchgl</span></span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>)</span> "cmpxchgl %1,<span class="params">(%<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="function">    <span class="comment">// 输出参数，"=a"表示把数据保存到eax寄存器中，"="表示这类操作数是只写的</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 这里的意思就是把 exchange_value的值保存到CPU的eax寄存器当中 (输出参数)</span></span></span><br><span class="line"><span class="function">    : "</span>=a<span class="string">" (exchange_value)</span></span><br><span class="line"><span class="string">    // 输入参数："</span>r<span class="string">"表示任意寄存器，"</span>a<span class="string">"表示eax寄存器</span></span><br><span class="line"><span class="string">    : "</span>r<span class="string">" (exchange_value), "</span>a<span class="string">" (compare_value), "</span>r<span class="string">" (dest), "</span>r<span class="string">" (mp)</span></span><br><span class="line"><span class="string">    // 这里列出需要使用的寄存器：cc表示汇编代码将改变条件寄存器，memory表示有内存被修改</span></span><br><span class="line"><span class="string">    // 前面也提到过，这里仅列出指令改变的寄存器，输入输出使用的寄存器不放入其中，因此'a'不需要放到这儿</span></span><br><span class="line"><span class="string">    // 如果汇编指令修改了eax而输入输出没有用到eax，那么就需要在这儿加上'a'</span></span><br><span class="line"><span class="string">     : "</span>cc<span class="string">", "</span>memory<span class="string">");</span></span><br></pre></td></tr></table></figure><p>这里的 <code>cmpxchgl %1,(%3)</code> 中的 %1 和 %3 中的数字表示参数列表：[&quot;=a&quot; (exchange_value),“r” (exchange_value),“a” (compare_value),“r” (dest), “r” (mp)] 的下标，这里指的是<code>&quot;r&quot; (exchange_value)</code> 和 <code>&quot;r&quot; (dest)</code></p><ul><li>compare_value 表示 期望内存中的值，即旧值</li><li>exchange_value 表示 更新后的值，即新值</li><li>dest 表示 java对象对应属性的内存地址， (dest) 获取地址dest指向的值</li></ul><p><code>cmpxchg</code>指令即交换比较指令，让目标操作数先和AL，AX，EAX寄存器中的值进行比较：</p><ul><li>如果相等，将源操作数直接装载到目标操作数，并将寄存器标志位ZF(zero flag)置为1</li><li>如果不相等，将目标操作数转载到AL，AX，EAX寄存器，并将ZF清0</li></ul><p>那上面的代码中哪一个是源操作数，哪一个是目标操作数？这又涉及到汇编语言编程风格的问题，在DOS/Windows下的汇编语言采用Intel风格，而Unix和Linux系统中，更多采用的是AT&amp;T风格，这两者在语法格式上有很大不同，具体到操作数，有如下区别：</p><ul><li>AT&amp;T 汇编格式：指令 源操作数 目标操作数</li><li>Intel汇编格式：指令 目标操作数 源操作数</li></ul><p>还有一个需要注意的区别就是：操作数的字长。</p><ul><li>AT&amp;T 汇编格式：由操作符的最后一个字母决定，后缀b、w、l分别表示操作数为字节(byte,8bit)、字(word,16bit)、长字(long,32bit)</li><li>Intel汇编格式：用byte ptr、word ptr等前缀来表示，比如：mov al, byte ptr val</li></ul><p>那么表达式其实就是<code>cmpxchgl exchange_value ,dest</code>。<br>EAX寄存器中存的是&quot;a&quot; (compare_value)， 也就是<code>cmpxchgl</code>中l表示的寄存器的值也就是期望值，目标操作数是<code>dest</code>指向的值，即内存中存储的值，源操作数是<code>exchange_value</code>，即新值。将期望内存中的值与实际内存值比较，如果相等，则把<code>exchange_value</code>新值装载到dest内存中，并把新值写入<code>EAX</code>中；如果不相等，把<code>dest</code>地址的实际值放入EAX中。</p><blockquote><p>而C/C++内联汇编的特性架起了这样一座桥梁：一边是C语言，一边是汇编语言，在汇编中可以接收C传过来的参数，并且汇编指令也可以把值写入C语言变量中。</p></blockquote><p><code>LOCK_IF_MP</code> 是内联函数，定位如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p><code>os::is_MP</code>判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p><ul><li><strong>cmp $0, #mp</strong><ul><li>cmp是比较命令，两个操作数：$0表示立即操作数0，理解为常量。</li><li>mp为参数，从<code>%4</code>处引用而来，而<code>%4</code>表示 <code>&quot;r&quot;(mp)</code>，即把<code>mp</code>的值存储到任意寄存器。mp如何来？看函数代码的第一句：<code>int mp = os::is_MP()</code>，用于判断是否是多处理器机器, mp 如果为false（表示单核） 那就是0</li></ul></li><li>je lf;<ul><li>je为跳转指令，当ZF=1时，跳转到指定位置，这里表示跳转到标签1</li></ul></li><li>lock :表示Lock前缀</li><li>1<br>表示标签，类似于goto语句 <code>1: cmpxchgl %1,(%3)</code></li></ul><p>这里便于大家理解，写一个伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmp(var1, var2) &#123;</span><br><span class="line">    zf ;</span><br><span class="line">    <span class="keyword">if</span> (var1 == var2) &#123;</span><br><span class="line">        zf = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zf = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zf</span><br><span class="line">&#125;</span><br><span class="line">zf = cmp(<span class="number">0</span>, mp)  <span class="comment">// zf 标志位 </span></span><br><span class="line"><span class="keyword">if</span> (zf == <span class="number">1</span>) &#123;</span><br><span class="line">    goto:<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lock();</span><br><span class="line">    goto:<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译过来就是，如果是在多处理器上运行则先添加<code>LOCK#</code>前缀后，再执行cmpxchgl命令，如果是单处理器，则直接执行 <code>cmpxchgl</code> 命令。那为什么在多处理器机器上要先添加<code>LOCK#</code>前缀。</p><h3><span id="lock前缀">Lock前缀</span></h3><p>Lock前缀指令导致在执行指令期间，声言处理器的LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存（因为它会锁住总线，导致其他CPU不能访问总线，也就不能访问系统内存，在Intel486和Pentium处理器中都是这种策略）。</p><blockquote><p>在最近的处理器里，LOCK# 信号一般不锁总线，而是锁缓存，因为锁总线开销的比较大。在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK# 信号。相反，它会锁定这块区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上的处理器缓存的内存区域数据。</p></blockquote><p>由于我们操作的是count这个值，这个变量是用<code>volatile</code> 变量修饰的，所以保证了线程见的可见性。关于<code>volatile</code> 变量的细节，我会单独另一篇文章讨论。</p><p>下面我们来总结一下：<br><strong>当执行CAS操作的时候，我们先判断机器的核数，如果是多核CPU,则调用 lock cmpxchgl 这个汇编执行，lock执行会根据cpu的型号和架构，来选择总线锁还是缓存锁，来实行原子更新。更新之后，由于更新的值为<code>volatile</code> 变量修饰，（JVM层面规定是内存屏障），强制其他核心从主内存当中读值。这样以来就实现了原子更新</strong>。</p><h3><span id="unsafe_compareandswaplong-方法">Unsafe_CompareAndSwapLong 方法</span></h3><p>在 <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp" target="_blank" rel="noopener">unsafe.cpp</a>  的源码中，Int 和 Long 的swap 略有不同。我们来看一下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapLong"</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">p</span> <span class="params">(THREAD, JNIHandles::resolve(obj))</span></span>;</span><br><span class="line">  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));</span><br><span class="line">  <span class="keyword">if</span> (VM_Version::supports_cx8())</span><br><span class="line">    <span class="keyword">return</span> (jlong)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    jboolean success = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 不支持，则直接锁住对象</span></span><br><span class="line">    <span class="function">ObjectLocker <span class="title">ol</span><span class="params">(p, THREAD)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (*addr == e) &#123; *addr = x; success = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>可以看到，如果不支持<code>cx8</code>，那么就需要用到<code>ObjectLocker</code>锁，那么什么 <code>VM_Version::supports_cx8()</code> 的底层实现又是什么呢？篇幅应县个，这里不做详细的分析，源代码在：在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/vm_version.hpp" target="_blank" rel="noopener">vm_version.hpp</a>里</p><p>底层则是判断CUP 是否支持 <code>CMPXCHG8B</code> 指令，简单来说就是CUP是否支持对寄存器的8字节的比较。在早期的CUP一般不支持，现代的CPU一般都在会支持。</p><h2><span id="atomicreference-类">AtomicReference 类</span></h2><p>这个类主要负责对于引用类型的赋值，他的核心代码很简单就是讲原来的<code>compareAndSwapInt</code> 换成了 <code>compareAndSwapObject</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// unsafe类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span> </span>&#123;</span><br><span class="line">    Object var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getObjectVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapObject(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照既定的惯例，我们来找到<code>compareAndSwapObject</code> 的native方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapObject(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject e_h, jobject x_h))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapObject"</span>);</span><br><span class="line">  oop x = JNIHandles::resolve(x_h); <span class="comment">// 新值</span></span><br><span class="line">  oop e = JNIHandles::resolve(e_h); <span class="comment">// 预期值</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  <span class="comment">// 在内存中的具体位置</span></span><br><span class="line">  HeapWord* addr = (HeapWord *)index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="comment">// 调用了另一个方法</span></span><br><span class="line">  oop res = oopDesc::atomic_compare_exchange_oop(x, addr, e, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果返回的res等于e，则判定满足compare条件（说明res应该为内存中的当前值），但实际上会有ABA的问题</span></span><br><span class="line">  jboolean success  = (res == e); </span><br><span class="line">  <span class="keyword">if</span> (success) </span><br><span class="line">    <span class="comment">// success为true时，说明此时已经交换成功（调用的是最底层的cmpxchg指令）</span></span><br><span class="line">    <span class="comment">// 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作，配合垃圾收集器</span></span><br><span class="line">    update_barrier_set((<span class="keyword">void</span>*)addr, x); </span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p><code>compareAndSwapObject</code> 方法其实比较的就是两个 <code>Java Object</code> 的地址，如果相等则将新的地址（Java Object）赋给该字段。</p><p>我们看一下atomic_compare_exchange_oop 在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/oops/oop.inline.hpp" target="_blank" rel="noopener">oop.inline.hpp</a>的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> oop <span class="title">oopDesc::atomic_compare_exchange_oop</span><span class="params">(oop exchange_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">volatile</span> HeapWord *dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                oop compare_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">bool</span> prebarrier)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseCompressedOops) &#123; </span><br><span class="line">      <span class="comment">// 如果使用了压缩普通对象指针(CompressedOops)，有一个重新编解码的过程</span></span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((narrowOop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// encode exchange and compare value from oop to T</span></span><br><span class="line">    narrowOop val = encode_heap_oop(exchange_value); <span class="comment">// 新值</span></span><br><span class="line">    narrowOop cmp = encode_heap_oop(compare_value); <span class="comment">// 预期值</span></span><br><span class="line">    <span class="comment">// 这里调用了  cmpxchg 方法</span></span><br><span class="line">    narrowOop old = (narrowOop) Atomic::cmpxchg(val, (narrowOop*)dest, cmp); </span><br><span class="line">    <span class="keyword">return</span> decode_heap_oop(old);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prebarrier) &#123;</span><br><span class="line">      update_barrier_set_pre((oop*)dest, exchange_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里表示 执行cmpxchg的汇编指令采用 支持 </span></span><br><span class="line">    <span class="keyword">return</span> (oop)Atomic::cmpxchg_ptr(exchange_value, (oop*)dest, compare_value); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  cmpxchg_ptr 的汇编指令集 和 cmpxchg 不同的是 采用了 cmpxchgq 指令</span></span><br><span class="line">__asm__ __volatile__ (LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgq %1,(%3)"</span></span><br><span class="line">                         : <span class="string">"=a"</span> (exchange_value)</span><br><span class="line">                         : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><br><span class="line">                         : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br><span class="line">    <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="atomicstampedreference-与-atomicmarkablereference">AtomicStampedReference 与  AtomicMarkableReference</span></h2><p>上面的普通的CAS操作都会有ABA的问题，其根本原因在于在CAS操作过程中，操作者不知道被操作的只中途是否发生过改变，那么解决方案就很自然，当改变一个只，就给这个值附上一个版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法, 传入引用和戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期值并且 当前版本戳等于预期版本戳, 将更新新的引用和新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前引用 等于 预期引用, 将更新新的版本戳到内存</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptStamp</span><span class="params">(V expectedReference, <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置当前引用的新引用和版本戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure><p>我们来看用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(str1,<span class="number">1</span>);</span><br><span class="line">reference.compareAndSet(str1,str2,reference.getStamp(),reference.getStamp()+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们比较时候，不仅要传递<code>expected</code> 和<code>new</code> 值，还要去传递版本戳，我们来看一下他的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AtomicStampedReference</code> 可以知道，引用变量中途被更改了几次。有时候，我们并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 <code>AtomicMarkableReference。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicMarkableReference</span><span class="params">(V initialRef, <span class="keyword">boolean</span> initialMark)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialMark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="atomicreferenceatomicstampedreference与-atomicmarkablereference-的区别">AtomicReference，AtomicStampedReference与 AtomicMarkableReference 的区别</span></h2><table><thead><tr><th>类</th><th>区别</th></tr></thead><tbody><tr><td><strong>AtomicReference</strong></td><td>通过volatile和Unsafe提供的CAS函数实现原子操作。 <br>自旋+CAS的无锁操作保证共享变量的线程安全.value是volatile类型，这保证了：当某线程修改value的值时，其他线程看到的value的值都是最新的值，即修改之后的volatile的值通过CAS设置value<br>这保证了：某线程池通过CAS函数（如compareAndSet函数）设置value时，它的操作时原子性的，即线程在操作vu略时不会被中断。<br> 但是CAS操作可能存在ABA问题</td></tr><tr><td><strong>AtomicStampedReference</strong></td><td>构造方法中initialStamp（时间戳）用来唯一标识引用变量，在构造器内部，实例化了一个Pair对象，Pair对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现ABA的问题。</td></tr><tr><td><strong>AtomicMarkableReference</strong></td><td>AtomicStampedReference 时间戳 只有true 和false</td></tr></tbody></table><h2><span id="fieldupdater">FieldUpdater</span></h2><p><code>FieldUpdater</code> 包含了<br><code>AtomicIntegerFieldUpdater</code>, <code>AtomicLongFieldUpdater</code> 和 <code>AtomicReferenceFieldUpdater</code> 这3个修改类的成员的原子类型的原理和用法相似</p><p>以 AtomicIntegerFieldUpdater 为例来分析一下特性及其源码</p><h2><span id="特性">特性</span></h2><p><code>AtomicIntegerFieldUpdater</code> 可以对指定&quot;类的 <code>volatile int</code> 类型的成员&quot;进行原子更新。它是基于反射原理实现的。<br><code>AtomicIntegerFieldUpdater</code> 以下几个限制</p><ul><li>（1）字段必须是 <strong>volatile</strong> 类型</li><li>（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</li><li>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</li><li>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</li><li>（5）对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</li></ul><h2><span id="实例代码">实例代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater aifu = AtomicIntegerFieldUpdater.newUpdater(Student.class, "number");</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> compareAndSet = aifu.compareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.weakCompareAndSet(student, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        aifu.set(student, <span class="number">1</span>);</span><br><span class="line">        aifu.lazySet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.get(student);</span><br><span class="line">        aifu.getAndSet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndIncrement(student);</span><br><span class="line">        aifu.getAndDecrement(student);</span><br><span class="line">        aifu.getAndAdd(student, <span class="number">1</span>);</span><br><span class="line">        aifu.incrementAndGet(student);</span><br><span class="line">        aifu.decrementAndGet(student);</span><br><span class="line">        aifu.addAndGet(student, <span class="number">1</span>);</span><br><span class="line">        aifu.getAndUpdate(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.updateAndGet(student, operand -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.getAndAccumulate(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">        aifu.accumulateAndGet(student, <span class="number">1</span>, (left, right) -&gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AtomicIntegerFieldUpdaterDemo 必须能够访问  number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Student</code> number 是private 修饰的，则会抛出 <code>$Student with modifiers &quot;private volatile&quot;</code> 异常</p><p>如果我们将<code>Student</code> 放到其他包下，则会抛出 <code>Atomic can not access a member of class {your bean} with modifiers &quot;volatile</code></p><h2><span id="源码分析">源码分析</span></h2><p>AtomicIntegerFieldUpdater 和  AtomicLongFieldUpdater 实现类有些不同<br>FieldUpdater 都继承与  AtomicXXFieldUpdater类，这些类提供了CAS的基本方法。</p><p>这是AtomicLongFieldUpdater<br><img src="/article/java-concurrence-2/java-concurrence-2-141202.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 AtomicIntegerFieldUpdater 底层用的是  AtomicIntegerFieldUpdaterImpl 实现<br>而  AtomicLongFieldUpdater 底层用的是 CASUpdater 或者 LockedUpdater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicLongFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                           String fieldName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (AtomicLong.VM_SUPPORTS_LONG_CAS)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CASUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CASUpdater</code> 和  <code>LockedUpdater</code> 区别就在于 是否支持  cmpxchg 源操作数为64个bit的CPU 原语言。我们从这个指令就可以看出 除了long和double类型, Java基本数据类型都是的简单读写都是原子的.</p><p><code>LockedUpdater</code> 与 <code>CASUpdater</code> 的区别在于核心的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CASUpdater </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">return</span> U.compareAndSwapLong(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LockedUpdater </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(T obj, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">            accessCheck(obj);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> v = U.getLong(obj, offset);</span><br><span class="line">                <span class="keyword">if</span> (v != expect)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                U.putLong(obj, offset, update);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到了 <code>CASUpdater</code> 是直接调用 <code>compareAndSwapLong</code> 方法 而 <code>LockedUpdater</code> 则是通过加锁的方式实现 CAS</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li><li><a href="https://www.hicsc.com/post/2020031059" target="_blank" rel="noopener">007 番外：JVM CAS机制的实现原理</a></li><li><a href="https://chriswhocodes.com/hotspot_options_jdk8.html" target="_blank" rel="noopener">VM Options Explorer - JDK8 HotSpot</a></li><li><a href="https://crowhawk.github.io/2018/02/10/volatile/" target="_blank" rel="noopener">Java volatile 关键字底层实现原理解析</a></li><li><a href="https://www.zhihu.com/question/65372648" target="_blank" rel="noopener">cas做了锁了总线或缓存行还是volatile做了锁总线或缓存行?</a></li><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/os.hpp" target="_blank" rel="noopener">os.hpp</a></li><li><a href="https://blog.csdn.net/qqqqq1993qqqqq/article/details/75211993" target="_blank" rel="noopener">并发实战——原子类AtomicReference及底层源码CompareAndSwapObject分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TSL详解(3)</title>
      <link href="/article/tcpip-4-SSL-TLS-3/"/>
      <url>/article/tcpip-4-SSL-TLS-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>TLS 握手协议包含如下几步:</p><ul><li>交换 Hello 消息, 交换随机数和支持的密码套件列表, 以协商出密码套件和对应的算法。检查会话是否可恢复</li><li>交换必要的密码参数以允许 client 和 server 协商预备主密钥 premaster secret</li><li>交换证书和密码信息以允许 client 和 server 进行身份认证</li><li>从预备主密钥 premaster secret 和交换的随机数中生成主密钥 master secret</li><li>为 TLS 记录层提供安全参数(主要是密码块)</li><li>允许 client 和 server 验证它们的对端已经计算出了相同的安全参数, 而且握手过程不被攻击者篡改</li></ul><p>下面行文思路会按照 TLS 首次握手，会话恢复的顺序，依次对比 TLS 1.2 和 TLS 1.3 在握手上的不同，并且结合 Wireshark 抓取实际的网络包进行分析讲解。最后分析一下 TLS 1.3 新出的 0-RTT 是怎么回事。</p><h2><span id="tls12握手过程">TLS1.2握手过程</span></h2><h2><span id="tls12握手示意图">TLS1.2握手示意图</span></h2><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-100409.png" alt></p><h2><span id="握手流程分析">握手流程分析</span></h2><h3><span id="0hello_request">（0）hello_request</span></h3><p>HelloRequest 消息可以在任何时间由 Server 发送。</p><p>这个消息的含义: HelloRequest 是一个简单的通知，告诉 Client 应该开始重协商流程。在响应过程中，Client 应该在方便的时候发送一个 ClientHello 消息。这个消息并不是意图确定哪端是 Client 或 Server，而仅仅是发起一个新的协商。Server 不应该在 Client 发起连接后立即发送一个 HelloRequest。</p><p>如果 Client当前正在协商一个会话时，HelloRequest 这个消息会被 Client忽略。如果 Client 不想重新协商一个会话，或 Client 希望响应一个 no_renegotiation alert 消息，那么也可能忽略 HelloRequest 消息。因为握手消息意图先于应用数据被传送，它希望协商会在少量记录消息被 Client 接收之前开始。如果 Server 发送了一个 HelloRequest 但没有收到一个 ClientHello 响应，它应该用一个致命错误 alert 消息关闭连接。在发送一个 HelloRequest 之后，Server 不应该重复这个请求直到随后的握手协商完成。</p><h3><span id="1client-hello">（1）Client Hello</span></h3><p>当一个 <code>Client</code> 第一次连接一个 <code>Server</code> 时，发送的第一条消息必须是 <code>ClientHello</code>。<code>Client</code> 也能发送一个 <code>ClientHello</code> 作为对 <code>HelloRequest</code> 的响应，或用于自身的初始化以便在一个已有连接中重新协商安全参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uint32 gmt_unix_time;   <span class="comment">//时间戳</span></span><br><span class="line">   opaque random_bytes[<span class="number">28</span>]; <span class="comment">//随机数</span></span><br><span class="line">&#125; Random;</span><br><span class="line">   </span><br><span class="line">struct &#123;</span><br><span class="line">   ProtocolVersion client_version;  <span class="comment">// 版本</span></span><br><span class="line">   Random random;                   <span class="comment">// 随机数</span></span><br><span class="line">   SessionID session_id;            <span class="comment">// session id</span></span><br><span class="line">   CipherSuite cipher_suites&lt;<span class="number">2</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">2</span>&gt;;  <span class="comment">// 密码套件</span></span><br><span class="line">   <span class="comment">// 压缩算法，一般不启动</span></span><br><span class="line">   CompressionMethod compression_methods&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">8</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   <span class="comment">// Clients 可以通过在扩展域中发送数据来请求 Server 的扩展功能 后边详解</span></span><br><span class="line">   select (extensions_present) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">false</span>:</span><br><span class="line">            struct &#123;&#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">true</span>:</span><br><span class="line">            Extension extensions&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ClientHello;</span><br></pre></td></tr></table></figure><ul><li>Session id由服务器生成，服务器普遍采用OpenSSL，而OpenSSL基本只生成32字节的session id，如果碰到其他字节长度的Session id，切莫认为是异常client hello。</li></ul><p><code>随机数的作用：生成主密钥 + 避免重放攻击</code></p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161429.png" alt></p><h3><span id="2server-hello">（2）Server Hello</span></h3><p>当 Server 能够找到一个可接受的算法集时，Server 发送这个消息作为对 ClientHello 消息的响应。如果不能找到这样的算法集, 它会发送一个握手失败 alert 消息作为响应。</p><p>Server Hello 消息的结构是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   <span class="comment">// Client 在 Client hello 消息中建议的较低版本和 Server 所能支持的最高版本</span></span><br><span class="line">   ProtocolVersion server_version;</span><br><span class="line">   <span class="comment">// 服务端随机数，独立于client 随机数</span></span><br><span class="line">   Random random;</span><br><span class="line">   SessionID session_id;</span><br><span class="line">   <span class="comment">// Server 在 ClientHello.cipher_suites 中所选择的单个密码套件</span></span><br><span class="line">   CipherSuite cipher_suite;</span><br><span class="line">   CompressionMethod compression_method;</span><br><span class="line">   <span class="comment">// 扩展的列表. 需要注意的是只有由 Client 给出的扩展才能出现在 Server 的列表中</span></span><br><span class="line">   select (extensions_present) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">false</span>:</span><br><span class="line">            struct &#123;&#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">true</span>:</span><br><span class="line">            Extension extensions&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>&gt;;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ServerHello;</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161539.png" alt></p><ul><li>SessionId<br>如果 ClientHello.session_id 非空，Server 将在它的会话缓存中进行匹配查询。如果匹配项被找到，且 Server 愿意使用指定的会话状态建立新的连接，Server 会将与 Client 所提供的相同的值返回回去。 我会在Session重用的章节分析</li></ul><h3><span id="3server-certificate-certificate-status">（3）Server Certificate (Certificate status)</span></h3><p><code>Server</code> 就必须发送一个 <code>Certificate</code>。<code>Server Certificate</code> 消息紧跟着 <code>ServerHello</code> 之后，<strong>通常他们俩者在同一个网络包中，即同一个 TLS 记录层消息中, 也有可能会紧跟着其他的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opaque ASN<span class="number">.1</span>Cert&lt;<span class="number">1</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">struct &#123;</span><br><span class="line">   ASN<span class="number">.1</span>Cert certificate_list&lt;<span class="number">0</span>..<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>&gt;;</span><br><span class="line">&#125; Certificate;</span><br></pre></td></tr></table></figure><ul><li><strong>certificate_list</strong>:</li></ul><p>这是一个证书序列(链)。每张证书都必须是 ASN.1Cert 结构。发送者的证书必须在列表的第一个位置。每个随后的证书必须直接证明它前面的证书。假设远端必须已经拥有它以便在任何情况下验证它，在这个假设下，因为证书验证要求根密钥是独立分发的，所以可以从链中省略指定根证书颁发机构的自签名证书。根证书集成到了 Client 的根证书列表中，没有必要包含在 Server 证书消息中。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-161900.png" alt></p><ul><li><strong>Certificate status</strong></li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162222.png" alt></p><p>如果 client hello 带了 扩展字段 ：<code>status_request</code> 则意味着请求要求服务器请求OCSP，服务器可以发送cettificate status到客户端，里面带上ocsp的信息</p><p>cettificate status  ：表示该证书的请求状态</p><p><strong>OCSP（Online Certificate Status Protocol ）是TLS协议的扩展协议</strong>，在TLS的使用中，客户端无法判断一个还没有过期的证书是否被吊销了。因为CA在颁发了证书之后大部分情况下都是等待这个证书过期了之后的自然失效，而如果CA出于某些原因要人为的吊销某个证书就没有了办法。</p><p>CA吊销这个证书肯定是有考虑的，所以客户端为了自身的安全也应该支持CA的这种需求。这个时候客户端在从服务端拿到了一个证书之后，去找服务端的接口去验证一下这个证书的是否过期这一信息。客户端由于网络有各种各样的情况，每个连接去验证国外的服务器的话就会带来完全不可控的用户体验和访问延时，并且对于CA来说也是一个不小的并发连接。所以OCSP一般会被应用到服务端，给客户端节省这部分的时间。</p><p>服务端周期性的去连接CA的OCSP服务器，验证一个证书的合法性，存储在本地。当客户端与服务端进行TLS握手的时候，服务端在传送了证书链之后（certificate消息），会继续再传输一个certificate status消息，这个status消息就是服务端从CA的OCSP服务器那里获得而来的证书吊销状态信息，双方仍然是通过密码学的方式保证了客户端可以确认这个确认消息来源于CA。</p><p>浏览器没有命中 OCSP 缓存。Ocsp 一般的更新周期是 7 天，firefox 的查询周期也是 7 天，也就说是 7 天中才会发生一次 ocsp 的查询。</p><h3><span id="3server-key-exchange-message">（3）Server Key Exchange Message</span></h3><p>这个消息会紧随在 Server 证书消息之后发送(如果是一个匿名协商的话，会紧随在 Server Hello消息之后发送)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   <span class="comment">// 选择秘钥算法类型</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   KeyExchangeAlgorithm 类型的不同，加入了不同的参数。</span></span><br><span class="line"><span class="comment">   对于匿名协商，不需要证书，所以也不需要身份验证，没有证书。</span></span><br><span class="line"><span class="comment">   DHE 开头的协商算法，Server 需要发给 Client 动态的 DH 参数 ServerDHParams 和 数字签名。这里的数字签名会包含 Client 端传过来的随机数，Server 端生成的随机数和 ServerDHParams。</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">      <span class="keyword">case</span> dh_anon:</span><br><span class="line">            ServerDHParams params;</span><br><span class="line">      <span class="keyword">case</span> dhe_dss:</span><br><span class="line">      <span class="keyword">case</span> dhe_rsa:</span><br><span class="line">            ServerDHParams params;</span><br><span class="line">            digitally-signed struct &#123;</span><br><span class="line">               opaque client_random[<span class="number">32</span>];</span><br><span class="line">               opaque server_random[<span class="number">32</span>];</span><br><span class="line">               ServerDHParams params;</span><br><span class="line">            &#125; signed_params;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于  rsa dh_dss dh_rsa 则不发送该消息</span></span><br><span class="line">      <span class="keyword">case</span> rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_dss:</span><br><span class="line">      <span class="keyword">case</span> dh_rsa:</span><br><span class="line">            struct &#123;&#125; ;</span><br><span class="line">      <span class="comment">/* 消息忽略 rsa, dh_dss, 和dh_rsa */</span></span><br><span class="line">      <span class="keyword">case</span> ec_diffie_hellman:</span><br><span class="line">            ServerECDHParams    params;</span><br><span class="line">            Signature           signed_params; </span><br><span class="line">   &#125;;</span><br><span class="line">&#125; ServerKeyExchange;</span><br></pre></td></tr></table></figure><p><code>ServerKeyExchange</code> 消息由 Server 发送，但仅在 Server 证书消息(如果发送了)没有包含足够的数据以允许 Client 交换一个预密钥时。这个限制对于如下的密钥交换算法是成立的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要发送 ServerKeyExchange </span></span><br><span class="line">DHE_DSS</span><br><span class="line">DHE_RSA</span><br><span class="line">ECDHE_ECDSA       </span><br><span class="line">ECDHE_RSA</span><br></pre></td></tr></table></figure><p>对于上面前 4 个密码套件，证书中是不包含这些动态的 <code>DH</code> 信息<code>(DH 参数和 DH 公钥</code>)，所以需要使用 <code>Server Key Exchange</code> 消息传递这些信息。传递的信息需要使用 Server 私钥进行签名加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态DH 算法   Server 不应该发送该消息</span></span><br><span class="line">DH_anon</span><br><span class="line">ECDH_anon  <span class="comment">//匿名的 ECDH + 无签名证书</span></span><br></pre></td></tr></table></figure><p>对于上面后 2 个密码套件，是匿名协商，使用的静态的 DH/ECDH 密钥协商算法，而且它们也没有证书消息(Server Certificate 消息)，所以同样需要使用 <code>Server Key Exchange</code> 消息传递这些信息。传递的静态 DH 信息需要使用 Server 私钥进行签名加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需发送消息的 ServerKeyExchange</span></span><br><span class="line">RSA</span><br><span class="line">DH_DSS</span><br><span class="line">DH_RSA</span><br></pre></td></tr></table></figure><p>一般 HTTPS 都会部署这 4 种密码套件：<code>ECDHE_RSA、DHE_RSA、ECDHE_ECDSA、RSA</code>。</p><ul><li>静态DH和动态DH算法<br>DH密钥协商又可以分为<strong>静态DH和动态DH</strong>两种，</li></ul><p><strong>静态DH</strong>： 服务器端的DH参数和服务器公钥是固定的，每一次客户端请求连接得到的DH参数和公钥也都是一样的。</p><p>使用静态DH方式好处是不用每次建立连接时都去重新生成参数，节省了时间，提高了性能，不过致命的缺点就是安全性问题，一旦参数泄露就麻烦了。</p><p><strong>动态DH</strong>： 每次客户端和服务器端建立连接时，都会重新创建DH参数和服务器公钥，即使中间出现密钥泄露，也只是这次通信可能造成信息泄露影响，把损失大大地降低。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162431.png" alt></p><h3><span id="4certificate-request">（4）Certificate Request</span></h3><p>双向认证时，服务器会发送certificate request，表明自己想要收到客户端的证书</p><p>一个非匿名的 Server 可以选择性地请求一个 Client 发送的证书，如果相互选定的密码套件合适的话。如果 ServerKeyExchange 消息发送了的话，就紧跟在 ServerKeyExchange 消息的后面。如果 ServerKeyExchange 消息没有发送的话，就跟在 Server Certificate 消息后面。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162512.png" alt></p><h3><span id="5server-hello-done">（5）Server Hello Done</span></h3><p>ServerHelloDone 消息已经被 Server 发送以表明 ServerHello 及其相关消息的结束。发送这个消息之后, Server 将会等待 Client 发过来的响应。</p><p>这个消息意味着 Server 发送完了所有支持密钥交换的消息，Client 能继续它的密钥协商，证书校验等步骤。</p><p>在收到 ServerHelloDone 消息之后，Client 应当验证 Server 提供的是否是有效的证书，如果有要求的话, 还需要进一步检查 Server hello 参数是否可以接受。</p><h3><span id="6client-certificate">（6）Client Certificate</span></h3><p>这是 Client 在收到一个 ServerHelloDone 消息后发送的第一个消息。这个消息只能在 Server 请求一个证书时发送。</p><p>如果没有合适的证书，Client 必须发送一个不带证书的证书消息。即, certificate_list 结构体的长度是 0。如果 Client 不发送任何证书，Server 可以自行决定是否可以在不验证 Client 的情况下继续握手，或者回复一个致命 handshake_failure 警报 alert 信息。而且, 如果证书链某些方面不能接受(例如, 它没有被一个知名的可信 CA 签名)，Server 可以自行决定是否继续握手(考虑到 Client 无认证)或发送一个致命的警报 alert 信息。</p><p>Client 证书的数据结构和 Server Certificate 是相同的。</p><p>Client Certificate 消息的目的是传递 Client 的证书链给 Server；当验证 CertificateVerify 消息时(当 Client 的验证基于签名时)Server 会用它来验证或计算预备主密钥(对于静态的 Diffie-Hellman)。证书必须适用于已协商的密码套件的密钥交换算法, 和任何已协商的扩展.</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162548.png" alt></p><h3><span id="7-client-key-exchange-message">（7） Client Key Exchange Message</span></h3><p>这个消息始终由 Client 发送。如果有 Client Certificate 消息的话，Client Key Exchange 紧跟在 Client Certificate 消息之后发送。如果不存在Client Certificate 消息的话，它必须是在 Client 收到 ServerHelloDone 后发送的第一个消息。</p><p>这个消息的含义是，在这个消息中设置了预备主密钥，或者通过 RSA 加密后直接传输，或者通过传输 Diffie-Hellman 参数来允许双方协商出一致的预备主密钥。</p><p>当 Client 使用一个动态的 Diffie-Hellman 指数时，这个消息就会包含 Client 的 Diffie-Hellman 公钥。如果 Client 正在发送一个包含一个静态 DH 指数(例如，它正在进行 fixed_dh Client 认证)的证书时，这个消息必须被发送但必须为空。</p><p>这个消息的选项依赖于选择了哪种密钥交互方法。关于 KeyExchangeAlgorithm 的定义，见 Server Key Exchange Message 这一节。</p><p>ClientKeyExchange 消息的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; implicit, explicit &#125; PublicValueEncoding;</span><br><span class="line">struct &#123;</span><br><span class="line">      select (PublicValueEncoding) &#123;</span><br><span class="line">         <span class="keyword">case</span> implicit: struct &#123; &#125;;</span><br><span class="line">         <span class="keyword">case</span> explicit: ECPoint ecdh_Yc;</span><br><span class="line">      &#125; ecdh_public;</span><br><span class="line">&#125; ClientECDiffieHellmanPublic;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">   select (KeyExchangeAlgorithm) &#123;</span><br><span class="line">      <span class="keyword">case</span> rsa:</span><br><span class="line">            EncryptedPreMasterSecret;</span><br><span class="line">      <span class="keyword">case</span> dhe_dss:</span><br><span class="line">      <span class="keyword">case</span> dhe_rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_dss:</span><br><span class="line">      <span class="keyword">case</span> dh_rsa:</span><br><span class="line">      <span class="keyword">case</span> dh_anon:</span><br><span class="line">            ClientDiffieHellmanPublic;</span><br><span class="line">      <span class="keyword">case</span> ec_diffie_hellman: </span><br><span class="line">            ClientECDiffieHellmanPublic;</span><br><span class="line">   &#125; exchange_keys;</span><br><span class="line">&#125; ClientKeyExchange;</span><br></pre></td></tr></table></figure><p>从 exchange_keys 的 case 中可以看到主要分为 3 种处理方式：EncryptedPreMasterSecret(RSA、ClientDiffieHellmanPublic(DH)、ClientECDiffieHellmanPublic(ECD)。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-162746.png" alt></p><h3><span id="8-certificate-verify">（8） Certificate verify</span></h3><p>发送这个类型的握手需要2个前提条件</p><ul><li>（1）：服务器端请求了客户端证书</li><li>（2）：客户端发送了非0长的证书</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   digitally-<span class="keyword">signed</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         opaque handshake_messages[handshake_messages_length];</span><br><span class="line">   &#125;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure><p>这里 <code>handshake_messages</code> 是指发送或接收到的所有握手消息，从 <code>client hello</code> 开始到但不包括本消息，包含握手消息的类型和长度域。</p><p>需要注意的是这要求两端要么缓存消息，要么计算用所有可用的 <code>hash</code> 算法计算运行时的 <code>hash</code> 值直到计算 <code>CertificateVerify</code> 的 hash 值为止。</p><p>在签名中使用的 <code>hash</code> 和签名算法必须是 <code>CertificateRequest</code> 消息中 <code>supported_signature_algorithms</code> 字段所列出的算法中的一种。</p><h3><span id="9-change-cipher">（9） Change cipher</span></h3><p>这是一个无关紧要的数据。在TLS1.3中就被废弃了(可以发送、也可以不发送)。<br>需要注意的是，该数据本身不被计算握手摘要，因为它的type不是Handshake。<br>发送改报文表示自己后续的发送数据会被新秘钥加密。</p><h3><span id="10-encrypted-handshake-message">（10） Encrypted handshake message</span></h3><p>这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据，发送了什么数据。来保证中间没人篡改报文。<br>其次，这个报文作用就是确认秘钥的正确性。因为Encrypted handshake message是使用对称秘钥进行加密的第一个报文，如果这个报文加解密校验成功，那么就说明对称秘钥是正确的。</p><p>具体 这个 Encrypted handshake message 怎么计算，就是把当前（准备发送Encrypted handshake message）前，自己收到的数据和发送的数据进行一次简单运算（hash+加密，详细见下文）。</p><blockquote><p>如果中间有人篡改了报文，比如，把客户端的client hello中的提供的加密套件改成了 一个弱秘钥算法，那么对于server而言，收到的client hello 和 客户端实际发送的是不同的，假设server收到的叫做client_hello_bad，这样，server 在计算Encrypted handshake message时，因为使用了client_hello_bad，计算完成之后，会发送给客户端，客户端为了确定握手数据是否被篡改，也需要模拟server端计算这个Encrypted handshake message，显然 客户端 计算 Encrypted handshake message 用的client hello 不是client_hello_bad，这样，客户端计算出来的，就和 服务端发过来的不同了，验证自然失败。</p></blockquote><blockquote><p>其次，某端要验证 Encrypted handshake message，必然需要先解密 Encrypted handshake message（因为他是用共享秘钥加密的），如果验证失败，也可能是 两端秘钥协商不成功。但是不管怎么样，无论是秘钥协商不成功还是数据被人篡改，都需要断开连接，即让握手失败。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">      opaque verify_data[verify_data_length];</span><br><span class="line">   &#125; Finished;</span><br><span class="line">   <span class="comment">// PRF 密码套件中的摘要算法</span></span><br><span class="line">   verify_data = </span><br><span class="line">      PRF(master_secret, finished_label, Hash(handshake_messages))</span><br><span class="line">         [<span class="number">0</span>..verify_data_length-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>加密过程</p><ul><li>finished_label: client finished / server finished</li><li>handshake_messages：handshake_messages 的值包括了从 ClientHello 开始一直到（但不包括）Finished 消息的所有握手消息</li><li>master_secret： 主密钥 对称秘钥</li></ul><p>计算完摘要后（md_result + Hash(handshake_messages)），按这种格式：“client finished”+ md_result，作为prf的输入。PRF的输出指定为12字节。12字节的数据前填充4字节message头部信息，就可以送入对称加密流程进行加密了。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-163533.png" alt></p><p>解密后的：<br><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-163555.png" alt></p><h2><span id="密码套件">密码套件</span></h2><p>Client 所支持的密码套件列表 格式如下:</p><p><code>TLS(协议)_ECDHE(秘钥交换协议)_RSA(签名算法)_WITH_AES_256_CBC(对称加密算法)_SHA（消息认证码）</code></p><p>密钥协商算法是 ECDHE，身份验证算法是 ECDSA，加密模式是 AES_256_GCM，由于 GCM 是属于 AEAD 加密模式，所以整个密码套件无须另外的 HMAC，SHA384 指的是 PRF 算法。</p><h2><span id="密钥生成规则">密钥生成规则</span></h2><p>在 TLS 1.2 中，有 3 种密钥：<strong>预备主密钥、主密钥和会话密钥(密钥块)</strong>，这几个密钥都是有联系的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">      uint32 gmt_unix_time;</span><br><span class="line">      opaque random_bytes[<span class="number">28</span>];</span><br><span class="line">   &#125; Random;</span><br><span class="line">   </span><br><span class="line">struct &#123;</span><br><span class="line">      ProtocolVersion client_version;</span><br><span class="line">      opaque random[<span class="number">46</span>];</span><br><span class="line">   &#125; PreMasterSecret;  </span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">      uint8 major;</span><br><span class="line">      uint8 minor;</span><br><span class="line">   &#125; ProtocolVersion;</span><br></pre></td></tr></table></figure><ul><li>RSA 算法生成预备主密钥<br>C对于 RSA 握手协商算法来说，Client 会生成的一个 48 字节的预备主密钥，client 收到 ServerHelloDone 消息以后，拿到 Server 的公钥和 random 会生成预备主密钥 (Premaster)，计算出来的预备主密钥会经过 RSA/ECDSA 算法加密，并通过 ClientKeyExchange 消息发送给 Server。Server 用私钥来解密。</li></ul><ul><li><p>(EC)DHE生成预备主密钥<br>对于 (EC)DHE 来说，预备主密钥是双方通过椭圆曲线算法生成的，双方各自生成临时公私钥对，保留私钥，将公钥发给对方，然后就可以用自己的私钥以及对方的公钥通过椭圆曲线算法来生成预备主密钥，预备主密钥长度取决于 DH/ECDH 算法公钥。预备主密钥长度是 48 字节或者 X 字节。</p></li><li><p>主密钥<br>是由<code>预备主密钥</code>、<code>ClientHello random</code>和 <code>ServerHello random</code>通过 PRF 函数生成的。主密钥长度是 48 字节。可以看出，只要我们知道预备主密钥或者主密钥便可以解密抓包数据，所以 TLS 1.2 中抓包解密调试只需要一个主密钥即可，SSLKEYLOG 就是将主密钥导出来，在 Wireshark 里面导入就可以解密相应的抓包数据。</p></li><li><p>会话密钥(密钥块)<br>是由主密钥、SecurityParameters.server_random 和 SecurityParameters.client_random 数通过 PRF 函数来生成，会话密钥里面包含对称加密密钥、消息认证和 CBC 模式的初始化向量，对于非 CBC 模式的加密算法来说，就没有用到这个初始化向量。</p></li></ul><p>Session ID 缓存和 Session Ticket 里面保存的也是主密钥，而不是会话密钥，这样每次会话复用的时候再用双方的随机数和主密钥导出会话密钥，从而实现每次加密通信的会话密钥不一样，即使一个会话的主密钥泄露了或者被破解了也不会影响到另一个会话。</p><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-1598323150644.png" alt></p><h2><span id="会话复用握手过程">会话复用握手过程</span></h2><p>Client 和 Server 只要一关闭连接，短时间内再次访问 HTTPS 网站的时候又需要重新连接。新的连接会造成网络延迟，并消耗双方的计算能力。有没有办法能复用之前的 TLS 连接呢？办法是有的，这就涉及到了 TLS 会话复用机制。</p><h3><span id="session信息">Session信息</span></h3><p>Session 是服务器为每一个client 保存的会话上下文，一般用于恢复会话使用。</p><p>Session 主要保存以下几个配置</p><ul><li>会话标识符(session identifier): 每个会话的唯一标识符</li><li>对端的证书(peer certificate):</li><li>压缩算法(compression method):</li><li>密码套件(cipher spec): Client 和 Server 协商共同协商出来的密码套件</li><li>主密钥(master secret):</li></ul><h3><span id="sessionid-方式">SessionId 方式</span></h3><ul><li>流程</li></ul><p>对于已经建立的SSL会话，使用session id为key（session id来自第一次请求的server hello中的session id字段），主密钥为value组成一对键值，保存在本地，服务器和客户端都保存一份。</p><p>当第二次握手时，客户端若想使用会话复用</p><ul><li><p>client 则发起的client hello中session id会置上对应的值。</p></li><li><p>服务器收到这个client hello，解析session id，查找本地是否有该session id，如果有，判断当前的加密套件和上个会话的加密套件是否一致，一致则允许使用会话复用，于是自己的server hello 中session id也置上和client hello中一样的值。</p></li><li><p>双方互发 ChangeCipherSpec + Finished 消息恢复通讯</p></li></ul><p>基于 Session ID 会话恢复的流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure><ul><li><p>优点</p><ul><li>减少网络延迟，握手耗时从 2-RTT -&gt; 1-RTT</li><li>减少了 Client 和 Server 端的负载，减少了加密运算的 CPU 资源消耗</li></ul></li><li><p>缺点</p><ul><li>Server 存储会话信息，限制了 Server 的扩展能力。</li><li>分布式系统中，如果只是简单的在 Server 的内存中存储 Session Cache，那么多台机器的数据同步也是一个问题。</li></ul></li></ul><h3><span id="session-ticket-的会话恢复">Session Ticket 的会话恢复</span></h3><p>用来替代 <code>Session ID</code> 会话恢复的方案是使用会话票证（<code>Session ticket</code>）。使用这种方式，除了所有的状态都保存在客户端（与 HTTP Cookie 的原理类似）之外，其消息流与服务器会话缓存是一样的。</p><p>其思想是服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在 <code>ClientHello</code> 的扩展字段 <code>session_ticket</code> 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。</p><ul><li><strong>(1). 获取 SessionTicket</strong><br>Client 在进行一次完整握手以后才能获取到 SessionTicket。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello</span><br><span class="line">(empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                           (empty SessionTicket extension)</span><br><span class="line">                                             Certificate*</span><br><span class="line">                                       ServerKeyExchange*</span><br><span class="line">                                       CertificateRequest*</span><br><span class="line">                           &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                          NewSessionTicket</span><br><span class="line">                                       [ChangeCipherSpec]</span><br><span class="line">                           &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure><ul><li>1：客户端发起client hello，拓展中带上空的session ticket TLS，表明自己支持session ticket。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-104846.png" alt></p><ul><li>2：服务器在握手过程中，如果支持session ticket，则发送New session ticket类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息，当然，最简单的就是只发送master key。为了让中间人不可见，这个session ticket部分会进行编码、加密等操作。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-104839.png" alt></p><ul><li><p>3：客户端收到这个session ticket，就把当前的master key和这个ticket组成一对键值保存起来。服务器无需保存任何会话信息，客户端也无需知道session ticket具体表示什么。</p></li><li><p>4：当客户端尝试会话复用时，会在client hello的拓展中加上session ticket，然后服务器收到session ticket，回去进行解密、解码能相关操作，来恢复会话信息。如果能够恢复会话信息，那么久提取会话信息的主密钥进行后续的操作。</p></li></ul><ul><li>(2). <strong>基于 SessionTicket 的会话恢复</strong><br>当 Client 本地获取了 SessionTicket 以后，下次想要进行简短握手，就可以使用这个 SessionTicket 了。</li></ul><pre><code class="language-C">Client                                                ServerClientHello(SessionTicket extension)     --------&gt;                                                ServerHello                              (empty SessionTicket extension)                                          NewSessionTicket                                          [ChangeCipherSpec]                              &lt;--------             Finished[ChangeCipherSpec]Finished                      --------&gt;Application Data              &lt;-------&gt;     Application Data</code></pre><ul><li>客户端第二次发起请求，根据目的ip port查找，查找master key和session ticket，然后把session ticket加在client hello中的拓展中。同时也需要session id。</li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-105050.png" alt></p><ul><li><p>如果 Server 支持 SessionTicket 会话恢复，则会在 ServerHello 中回复一个空的 SessionTicket 扩展。Server 将会话信息进行加密保护，生成一个新的 ticket，通过 NewSessionTicket 子消息发给 Client。发送完</p></li><li><p>NewSessionTicket 消息以后，紧跟着发送 ChangeCipherSpec 和 Finished 消息。Client 收到上述消息以后，回应 ChangeCipherSpec 和 Finished 消息，会话恢复成功。</p></li></ul><p><img src="/article/tcpip-4-SSL-TLS-3/tcpip-4-SSL-TLS-3-105102.png" alt></p><h2><span id="tls-常见的攻击举例">TLS 常见的攻击举例</span></h2><h3><span id="heartbleed心脏出血">Heartbleed（心脏出血）</span></h3><h3><span id="replay-attacks重放攻击">Replay Attacks（重放攻击）</span></h3><h3><span id="降级攻击freaklogjam-和-curveswap">降级攻击(FREAK，LogJam 和 CurveSwap)</span></h3><p>降级攻击一般包括两种：</p><ul><li>加密套件降级攻击 (cipher suite rollback)</li><li>协议降级攻击（version roll back）。</li></ul><p>降级攻击的原理就是攻击者伪造或者修改 client hello 消息，使得客户端和服务器之间使用比较弱的加密套件或者协议完成通信。<br>为了应对降级攻击，现在 server 端和浏览器之间都实现了 SCSV 功能，原理参考 <a href="https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00%E3%80%82" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00。</a><br>一句话解释就是如果客户端想要降级，必须发送 TLS_SCSV 的信号，服务器如果看到 TLS_SCSV，就不会接受比服务端最高协议版本低的协议。</p><h3><span id="重新协商攻击">重新协商攻击</span></h3><p>重新协商（tls renegotiation）分为两种：</p><ul><li>加密套件重协商 (cipher suite renegotiation)</li><li>协议重协商（protocol renegotiation）。</li></ul><p>重新协商会有两个隐患：</p><ul><li>重协商后使用弱的安全算法。这样的后果就是传输内容很容易泄露。</li><li>重协商过程中不断发起完全握手请求，触发服务端进行高强度计算并引发服务拒绝。 对于重协商，最直接的保护手段就是禁止客户端主动重协商，当然出于特殊场景的需求，应该允许服务端主动发起重协商。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/justinzengTM/article/details/104054056" target="_blank" rel="noopener">总结HTTPS握手层和加密层</a></li></ul><blockquote><p>本文大部分来自 以下内容的 节选</p></blockquote><ul><li><a href="https://halfrost.com/https_tls1-2_handshake/" target="_blank" rel="noopener">HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TSL详解(2)</title>
      <link href="/article/tcpip-4-SSL-TLS-2/"/>
      <url>/article/tcpip-4-SSL-TLS-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>前面章节，我们简单介绍了TLS的秘钥交换的算法。接下来我们来讲一下SSL层。</p><h2><span id="tls层ssl层">TLS层SSL层</span></h2><p><strong>TLS是介于网络层和传输层之间的半层。</strong></p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-123531.png" alt></p><h2><span id="协议层分类">协议层分类</span></h2><p>TLS/SSL 协议位于应用层和传输层 TCP 协议之间。TLS 粗略的划分又可以分为 2 层：</p><ul><li>靠近应用层的握手协议 <strong>TLS Handshaking Protocols</strong></li><li>靠近 TCP 的记录层协议 <strong>TLS Record Protocol</strong></li></ul><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-125556.png" alt></p><h2><span id="ssltcl层">SSL/TCL层</span></h2><h3><span id="握手协议">握手协议</span></h3><p>TLS 握手协议还能细分为 5 个子协议：</p><p>如上图</p><ul><li>change_cipher_spec (在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)： 密码切换协议</li><li>alert： 告警协议</li><li>handshake： 握手协议</li><li>application_data： 应用数据协议</li><li>heartbeat (这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议) 心跳协议</li></ul><p>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。<br>基本过程</p><ul><li><p>1、 client 端想server 端获取公钥</p></li><li><p>2、 双方协商生成&quot;对话密钥&quot;</p></li><li><p>3、 双方用对话秘钥进行通讯</p></li><li><p><strong>一个TCL1.2 秘钥交换的大致过程</strong></p></li></ul><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-112851.png" alt></p><hr><br><br><br><h2><span id="协议详解">协议详解</span></h2><h2><span id="记录层协议">记录层协议</span></h2><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-133951.png" alt></p><p>记录层将上层的信息块分段为 <code>TLSPlaintext</code> 记录<br><code>TLSPlaintext</code> 记录规范如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         ContentType type;</span><br><span class="line">         ProtocolVersion legacy_record_version;</span><br><span class="line">         uint16 length;</span><br><span class="line">         opaque fragment[TLSPlaintext.length];</span><br><span class="line">   &#125; TLSPlaintext;</span><br></pre></td></tr></table></figure><p>记录层将上层的信息块分段为 <code>TLSPlaintext</code> 记录，<code>TLSPlaintext</code> 中包含 2^14 字节或更少字节块的数据。根据底层 <code>ContentType</code> 的不同，消息边界的处理方式也不同。TLS 1.3 中的规则比 TLS 1.2 中强制执行的规则更加严格。</p><p>握手消息可以合并为单个 <code>TLSPlaintext</code> 记录，或者在几个记录中分段，前提是：</p><ul><li><p>握手消息不得与其他记录类型交错。也就是说，如果握手消息被分成两个或多个记录，则它们之间不能有任何其他记录。</p></li><li><p>握手消息绝不能跨越密钥更改。实现方必须验证密钥更改之前的所有消息是否与记录边界对齐; 如果没有，那么他们必须用 “unexpected_message” alert 消息终止连接。因为 ClientHello，EndOfEarlyData，ServerHello，Finished 和 KeyUpdate 消息可以在密钥更改之前立即发生，所以实现方必须将这些消息与记录边界对齐。</p></li><li><p>实现方绝不能发送握手类型的零长度片段，即使这些片段包含填充。</p></li><li><p>另外 Alert 消息禁止在记录之间进行分段，并且多条 <code>alert</code> 消息不得合并为单个 <code>TLSPlaintext</code> 记录。换句话说，具有 alert 类型的记录必须只包含一条消息。</p></li></ul><p>应用数据消息包含对 TLS 不透明的数据。应用数据消息始终应该受到保护。可以发送应用数据的零长度片段，因为它们可能作为流量分析对策使用。应用数据片段可以拆分为多个记录，也可以合并为一个记录。</p><h3><span id="字段详解">字段详解</span></h3><h4><span id="contenttype">ContentType</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    invalid(<span class="number">0</span>),</span><br><span class="line">    change_cipher_spec(<span class="number">20</span>),</span><br><span class="line">    alert(<span class="number">21</span>),</span><br><span class="line">    handshake(<span class="number">22</span>),</span><br><span class="line">    application_data(<span class="number">23</span>),</span><br><span class="line">    heartbeat(<span class="number">24</span>),  <span class="comment">/* RFC 6520 */</span></span><br><span class="line">&#125; ContentType;</span><br></pre></td></tr></table></figure><table><thead><tr><th>消息头类型</th><th>ContentType</th><th>协议内容</th></tr></thead><tbody><tr><td>change_cipher_spec</td><td>0x014</td><td>在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在)： 密码切换协议</td></tr><tr><td>alert</td><td>0x015</td><td>告警协议</td></tr><tr><td>handshake</td><td>0x016</td><td>握手协议</td></tr><tr><td>application_data</td><td>0x017</td><td>数据传输协议</td></tr><tr><td>heartbeat (TLS 1.3 新增)</td><td>0x018</td><td>心跳协议</td></tr></tbody></table><h4><span id="protocolversion-协议版本">ProtocolVersion 协议版本</span></h4><table><thead><tr><th>协议版本</th><th>version</th></tr></thead><tbody><tr><td>TLS 1.3</td><td>0x0304</td></tr><tr><td>TLS 1.2</td><td>0x0303</td></tr><tr><td>TLS 1.1</td><td>0x0302</td></tr><tr><td>TLS 1.0</td><td>0x0301</td></tr><tr><td>SSL 3.0</td><td>0x0300</td></tr></tbody></table><h4><span id="fragment">fragment</span></h4><ul><li>length:</li></ul><p><code>TLSPlaintext.fragment</code> 的长度(以字节为单位)。长度不得超过 2 ^ 14 字节。接收超过此长度的记录的端点必须使用 <code>&quot;record_overflow&quot; alert</code> 消息终止连接。</p><ul><li>fragment:</li></ul><p>正在传输的数据。此字段的值是透明的，它并被视为一个独立的块，由类型字段指定的更高级别协议处理。</p><p>TLS 记录层协议在整个 TLS 协议中的定位如下：</p><blockquote><p>封装处理 TLS 上层(握手层)中的平行子协议(TLS 1.3 中是 5 个子协议，TLS 1.2 及更老的版本是 4 个子协议)，加上消息头，打包往下传递给 TCP 处理。</p></blockquote><p>对上层应用数据协议进行密码保护，对其他的子协议只是简单封装(即不加密)</p><h2><span id="tls-密码切换协议change_cipher_spec">TLS 密码切换协议（change_cipher_spec）</span></h2><blockquote><p>change_cipher_spec 在TSL1.3 可能被删除</p></blockquote><p><code>change_cipher_spec</code> (以下简称 CCS 协议) 协议，是 TLS 记录层对应用数据是否进行加密的分界线。客户端或者服务端一旦收到对端发来的 CCS 协议，就表明接下来传输数据过程中可以对应用数据协议进行加密了。</p><p>TLS 记录层在处理上层 5 个协议(密码切换协议，警告协议，握手协议，心跳协议，应用数据协议)的时候，TLS 不同版本对不同协议加密的情况不同，具体情况如下：</p><table><thead><tr><th>议版本</th><th>密码切换协议</th><th>警告协议</th><th>握手协议</th><th>心跳协议</th><th>应用数据协议</th></tr></thead><tbody><tr><td>TLS 1.3</td><td>无</td><td>✅(根据连接状态不同进行加密，即一部分会加密)</td><td>✅(一部分加密)</td><td>❌</td><td>✅</td></tr><tr><td>TLS 1.2</td><td>❌</td><td>❌</td><td>❌</td><td>无</td><td>✅</td></tr></tbody></table><p>协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; change_cipher_spec(<span class="number">1</span>), (<span class="number">255</span>) &#125; type;</span><br><span class="line">&#125; ChangeCipherSpec;</span><br></pre></td></tr></table></figure><p>经过 TLS 记录层包装以后，结构如下:</p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141552.png" alt></p><h2><span id="tls-警告协议alert">TLS 警告协议（alert）</span></h2><p><code>TLS</code> 提供 <code>alert</code> 内容类型用来表示关闭信息和错误。<br>与其他消息一样，alert 消息也会根据当前连接状态的进行加密。</p><p>在 <code>TLS</code> 1.3 中，错误的严重性隐含在正在发送的警报类型中，并且可以安全地忽略 “<code>level</code>” 字段。<br>&quot;<code>close_notify</code>&quot; <code>alert</code> <code>用于表示连接从一个方向开始有序的关闭。收到这样的警报后，TLS</code> 实现方应该表明应用程序的数据结束。</p><p>收到错误警报后，<code>TLS</code> 实现方应该向应用程序表示出现了错误，并且不允许在连接上发送或接收任何其他数据。</p><p>协议数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; warning(<span class="number">1</span>), fatal(<span class="number">2</span>), (<span class="number">255</span>) &#125; AlertLevel;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AlertLevel level;</span><br><span class="line">    AlertDescription description;</span><br><span class="line">&#125; Alert;</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141226.png" alt></p><ul><li>TLS 1.2 的所有警告描述信息：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation(<span class="number">100</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),           <span class="comment">/* new */</span></span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><ul><li><strong>TLS 1.3 的所有警告描述信息：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    close_notify(<span class="number">0</span>),</span><br><span class="line">    unexpected_message(<span class="number">10</span>),</span><br><span class="line">    bad_record_mac(<span class="number">20</span>),</span><br><span class="line">    decryption_failed_RESERVED(<span class="number">21</span>),</span><br><span class="line">    record_overflow(<span class="number">22</span>),</span><br><span class="line">    decompression_failure_RESERVED(<span class="number">30</span>),</span><br><span class="line">    handshake_failure(<span class="number">40</span>),</span><br><span class="line">    no_certificate_RESERVED(<span class="number">41</span>),</span><br><span class="line">    bad_certificate(<span class="number">42</span>),</span><br><span class="line">    unsupported_certificate(<span class="number">43</span>),</span><br><span class="line">    certificate_revoked(<span class="number">44</span>),</span><br><span class="line">    certificate_expired(<span class="number">45</span>),</span><br><span class="line">    certificate_unknown(<span class="number">46</span>),</span><br><span class="line">    illegal_parameter(<span class="number">47</span>),</span><br><span class="line">    unknown_ca(<span class="number">48</span>),</span><br><span class="line">    access_denied(<span class="number">49</span>),</span><br><span class="line">    decode_error(<span class="number">50</span>),</span><br><span class="line">    decrypt_error(<span class="number">51</span>),</span><br><span class="line">    export_restriction_RESERVED(<span class="number">60</span>),</span><br><span class="line">    protocol_version(<span class="number">70</span>),</span><br><span class="line">    insufficient_security(<span class="number">71</span>),</span><br><span class="line">    internal_error(<span class="number">80</span>),</span><br><span class="line">    inappropriate_fallback(<span class="number">86</span>),</span><br><span class="line">    user_canceled(<span class="number">90</span>),</span><br><span class="line">    no_renegotiation_RESERVED(<span class="number">100</span>),</span><br><span class="line">    missing_extension(<span class="number">109</span>),</span><br><span class="line">    unsupported_extension(<span class="number">110</span>),</span><br><span class="line">    certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">    unrecognized_name(<span class="number">112</span>),</span><br><span class="line">    bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">    bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">    unknown_psk_identity(<span class="number">115</span>),</span><br><span class="line">    certificate_required(<span class="number">116</span>),</span><br><span class="line">    no_application_protocol(<span class="number">120</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; AlertDescription;</span><br></pre></td></tr></table></figure><p>TLS 1.3 比 TLS 1.2 新增了 9 个警告描述信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inappropriate_fallback(<span class="number">86</span>),</span><br><span class="line">missing_extension(<span class="number">109</span>),</span><br><span class="line">certificate_unobtainable_RESERVED(<span class="number">111</span>),</span><br><span class="line">unrecognized_name(<span class="number">112</span>),</span><br><span class="line">bad_certificate_status_response(<span class="number">113</span>),</span><br><span class="line">bad_certificate_hash_value_RESERVED(<span class="number">114</span>),</span><br><span class="line">unknown_psk_identity(<span class="number">115</span>),</span><br><span class="line">certificate_required(<span class="number">116</span>),</span><br><span class="line">no_application_protocol(<span class="number">120</span>),</span><br></pre></td></tr></table></figure><h2><span id="数据传输协议application_data">数据传输协议（application_data）</span></h2><p>应用数据协议就是 TLS 上层的各种协议，TLS 主要保护的数据就是应用数据协议的数据。<br><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-141131.png" alt><br>TLS 记录层会根据加密模式的不同在应用数据的末尾加上 MAC 校验数据。</p><h2><span id="心跳协议">心跳协议</span></h2><p>这个协议是 TLS 1.3 新增的。更加细节可以看这篇文章<a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TLS_Heartbeat.md" target="_blank" rel="noopener">《TLS &amp; DTLS Heartbeat Extension》</a>， [RFC 6520] 翻译的。感兴趣的可以去看看这篇文章。这篇文章还涉及到了 DTLS 和 PMTU 发现。</p><p>协议数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    heartbeat_request(<span class="number">1</span>),</span><br><span class="line">    heartbeat_response(<span class="number">2</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HeartbeatMessageType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HeartbeatMessageType type;</span><br><span class="line">    uint16 payload_length;</span><br><span class="line">    opaque payload[HeartbeatMessage.payload_length];</span><br><span class="line">    opaque padding[padding_length];</span><br><span class="line">&#125; HeartbeatMessage;</span><br></pre></td></tr></table></figure><p>经过 TLS 记录层包装以后，结构如下:</p><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-145352.png" alt></p><p>根据 [RFC6066] 中的定义，在协商的时候，HeartbeatMessage 的总长度不得超过 2 ^ 14 或 max_fragment_length。<br><code>HeartbeatMessage</code> 的长度为 TLS 的 <code>TLSPlaintext.length</code> 和 <code>DTLS</code> 的 <code>DTLSPlaintext.length</code>。此外，类型 <code>type</code> 字段的长度是 1 个字节，并且 <code>payload_length</code> 的长度是 2 个字节。因此，padding_length 是TLSPlaintext.length - <code>payload_length</code> - 3 用于 <code>TLS，DTLSPlaintext.length - payload_length - 3</code> 用于 <code>DTLS</code>。<code>padding_length</code> 必须至少为 16。</p><p><code>HeartbeatMessage</code> 的发送方必须使用至少 16 个字节的随机填充。必须忽略收到的 <code>HeartbeatMessage</code> 消息的填充。</p><h2><span id="握手协议">握手协议</span></h2><p>握手协议是整个 <code>TLS</code> <code>协议簇中最最核心的协议，HTTPS</code> 能保证安全也是因为它的功劳。</p><p>握手协议由多个子消息构成，服务端和客户端第一次完成一次握手需要 <code>2-RTT</code>。</p><p>握手协议的目的是为了双方协商出密码块，这个密码块会交给 TLS 记录层进行密钥加密。也就是说握手协议达成的“共识”(密码块)是整个 TLS 和 <code>HTTPS</code> 安全的基础。</p><p>握手协议在 <code>TLS 1.2</code>和 <code>TLS 1.3</code> 中发生了很大的变化。<code>TLS 1.3</code> 的 <strong>0-RTT</strong>是一个全新的概念。两个版本在密钥协商上，密码套件选择上都有很大不同。</p><ul><li>TLS 1.2 协议数据结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request(<span class="number">0</span>), </span><br><span class="line">    client_hello(<span class="number">1</span>), </span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    certificate(<span class="number">11</span>), </span><br><span class="line">    server_key_exchange (<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>), </span><br><span class="line">    server_hello_done(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>), </span><br><span class="line">    client_key_exchange(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>)</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;</span><br><span class="line">    uint24 length;</span><br><span class="line">    select (HandshakeType) &#123;</span><br><span class="line">        <span class="keyword">case</span> hello_request:       HelloRequest;</span><br><span class="line">        <span class="keyword">case</span> client_hello:        ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:        ServerHello;</span><br><span class="line">        <span class="keyword">case</span> certificate:         Certificate;</span><br><span class="line">        <span class="keyword">case</span> server_key_exchange: ServerKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> certificate_request: CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> server_hello_done:   ServerHelloDone;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:  CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> client_key_exchange: ClientKeyExchange;</span><br><span class="line">        <span class="keyword">case</span> finished:            Finished;</span><br><span class="line">    &#125; body;</span><br><span class="line">&#125; Handshake;</span><br></pre></td></tr></table></figure><ul><li>TLS 1.3 协议数据结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议类型</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    hello_request_RESERVED(<span class="number">0</span>),</span><br><span class="line">    client_hello(<span class="number">1</span>),</span><br><span class="line">    server_hello(<span class="number">2</span>),</span><br><span class="line">    hello_verify_request_RESERVED(<span class="number">3</span>),</span><br><span class="line">    new_session_ticket(<span class="number">4</span>),</span><br><span class="line">    end_of_early_data(<span class="number">5</span>),</span><br><span class="line">    hello_retry_request_RESERVED(<span class="number">6</span>),</span><br><span class="line">    encrypted_extensions(<span class="number">8</span>),</span><br><span class="line">    certificate(<span class="number">11</span>),</span><br><span class="line">    server_key_exchange_RESERVED(<span class="number">12</span>),</span><br><span class="line">    certificate_request(<span class="number">13</span>),</span><br><span class="line">    server_hello_done_RESERVED(<span class="number">14</span>),</span><br><span class="line">    certificate_verify(<span class="number">15</span>),</span><br><span class="line">    client_key_exchange_RESERVED(<span class="number">16</span>),</span><br><span class="line">    finished(<span class="number">20</span>),</span><br><span class="line">    certificate_url_RESERVED(<span class="number">21</span>),</span><br><span class="line">    certificate_status_RESERVED(<span class="number">22</span>),</span><br><span class="line">    supplemental_data_RESERVED(<span class="number">23</span>),</span><br><span class="line">    key_update(<span class="number">24</span>),</span><br><span class="line">    message_hash(<span class="number">254</span>),</span><br><span class="line">    (<span class="number">255</span>)</span><br><span class="line">&#125; HandshakeType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HandshakeType msg_type;    <span class="comment">/* handshake type */</span></span><br><span class="line">    uint24 length;             <span class="comment">/* bytes in message */</span></span><br><span class="line">    select (Handshake.msg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> client_hello:          ClientHello;</span><br><span class="line">        <span class="keyword">case</span> server_hello:          ServerHello;</span><br><span class="line">        <span class="keyword">case</span> end_of_early_data:     EndOfEarlyData;</span><br><span class="line">        <span class="keyword">case</span> encrypted_extensions:  EncryptedExtensions;</span><br><span class="line">        <span class="keyword">case</span> certificate_request:   CertificateRequest;</span><br><span class="line">        <span class="keyword">case</span> certificate:           Certificate;</span><br><span class="line">        <span class="keyword">case</span> certificate_verify:    CertificateVerify;</span><br><span class="line">        <span class="keyword">case</span> finished:              Finished;</span><br><span class="line">        <span class="keyword">case</span> new_session_ticket:    NewSessionTicket;</span><br><span class="line">        <span class="keyword">case</span> key_update:            KeyUpdate;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; Handshake</span><br></pre></td></tr></table></figure><p><img src="/article/tcpip-4-SSL-TLS-2/tcpip-4-SSL-TLS-2-144932.png" alt></p><p><strong>握手消息类型虽然有很多种，但是最终传到 TLS 记录层，有些会被合并到一条消息。</strong></p><h2><span id="参考">参考</span></h2><ul><li><a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">RFC8446</a></li><li><a href="https://halfrost.com/https-begin/" target="_blank" rel="noopener">HTTPS 温故知新（一） —— 开篇</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(4)-SSL/TLS详解(1)</title>
      <link href="/article/tcpip-4-SSL-TLS/"/>
      <url>/article/tcpip-4-SSL-TLS/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><h2><span id="ssltsl-协议">SSL/TSL 协议</span></h2><p>**SSL（安全套接字层）**是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接。</p><p><strong>TLS:(Transport Layer Security)</strong>: 是SSL协议（Secure Sockets Layer）的升级版，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。现在习惯将这个两个组合在一起称为<strong>SSL/TLS</strong>，它是一种用于加密的安全协议就好了。</p><h2><span id="发展史">发展史</span></h2><ul><li>1995: SSL 2.0. 由 Netscape 提出，这个版本由于设计缺陷，并不安全，很快被发现有严重漏洞，已经废弃。</li><li>1996: SSL 3.0. 写成 RFC，开始流行。目前（2015年）已经不安全，必须禁用。</li><li>1999: TLS 1.0. 互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。</li><li>2006: TLS 1.1. 作为 RFC 4346 发布。主要 fix 了 CBC 模式相关的如 BEAST 攻击等漏洞。</li><li>2008: TLS 1.2. 作为 RFC 5246 发布。增进安全性。目前（2015 年）应该主要部署的版本，请确保你使用的是这个版本。</li><li>2018：8月10日 RFC8446 TLS 1.3 协议正式发布，它剔除了 TLS 1.2 协议中不安全的因素，极大地增强了协议的安全性和性能。</li></ul><h2><span id="作用">作用</span></h2><p>TCP/IP 协议栈</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-123531.png" alt></p><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ul><li>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>（2） 篡改风险（tampering）：第三方可以修改通信内容。</li><li>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ul><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><ul><li>（1） 所有信息都是加密传播，第三方无法窃听。</li><li>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</li><li>（3） 配备身份证书，防止身份被冒充。</li></ul><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><h2><span id="加密算法">加密算法</span></h2><h2><span id="单项加密">单项加密</span></h2><p>单项加密，又称不可逆的加密<br>特性：</p><ul><li>定长输出: 无论原始数据是多大，结果大小都相同的</li><li>雪崩效应: 输入的微小改变，将会引起结果的巨大改变</li><li>单向加密算法：MD5（128位）、SHA1、SHA256、SHA384、SHA512</li></ul><p>缺点： 雪崩，不可逆</p><p>主要用途： 特征码</p><h2><span id="对称加密">对称加密</span></h2><p>在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。</p><p>收信方收到密文后，若想解读原文，则需要使用<strong>加密用过的密钥及相同算法的逆算法</strong>对密文进行解密，在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥和加密算法。</p><p>缺点： 不安全，局限性，需要知道对称加密秘钥</p><p>优点：加密解密速度快</p><h2><span id="公钥加密非对称加密">公钥加密（非对称加密）</span></h2><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-214134.png" alt></p><p>现代互联网普遍用的加密手段。</p><ul><li><p>特点：</p><ul><li>公钥公开，私钥保密</li><li>公钥加密，私钥解密</li><li>私钥加密，公钥解密</li></ul></li><li><p>用途:  接收方用发送方的公钥解密，若能解密就以为这这个数据一定是拥有该公钥对应的私钥的人发送的，实现了身份认证机制。</p><ul><li>数字签名</li><li>HTTPS/OPENSSL/SSL</li><li>区块链</li></ul></li><li><p>公钥加密算法<br>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。<br>使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。</p></li><li><p>缺点： 加密解密速度较慢，无法对大规模的数据进行加密<br>一般情况下非对称加密用来数字签名的。</p></li><li><p>RSA 算法原理<br>做个连接 不做过多解读 <a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA 算法原理</a></p></li><li><p>ECC 算法<br><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">Elliptic Curve Cryptography: a gentle introduction</a></p></li></ul><h2><span id="数字签名">数字签名</span></h2><p>私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密,在这个意义上来说，加密就毫无意义。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，也就是说对原始消息的哈希特征值进行加密，保证这个消息不会被其他第三方串改。</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110824.png" alt></p><ul><li>数字签名的作用<ul><li>防止伪造；</li><li>防止抵赖；</li><li>检测篡改。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">    KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">    kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">    KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">    PrivateKey sk = kp.getPrivate();</span><br><span class="line">    PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待签名的消息:</span></span><br><span class="line">    <span class="keyword">byte</span>[] message = <span class="string">"Hello, I am Bob!"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥签名:</span></span><br><span class="line">    Signature s = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">    s.initSign(sk);</span><br><span class="line">    s.update(message);</span><br><span class="line">    <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">    System.out.println(String.format(<span class="string">"signature: %x"</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥验证:</span></span><br><span class="line">    Signature v = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">    v.initVerify(pk);</span><br><span class="line">    v.update(message);</span><br><span class="line">    <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">    System.out.println(<span class="string">"valid? "</span> + valid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="现代加密过程">现代加密过程</span></h2><p>非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势</p><p>如下图：</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110512.png" alt></p><p><strong>加密解密过程和原理详细说明：</strong><br><strong>1、发送端B :</strong></p><ul><li><p>（1）为保证安全，要对报文加密。加密方法有三类：对称加密、公钥加密和单向加密。对称加密不安全，单向加密是不可逆的，因而使用公钥加密。<br>公钥加密安全（一般为2048位），但是加密过程太慢了，不适用当前网络需求</p></li><li><p>（2）为了解决上述问题，B可以用单向加密提取出报文的特征码（<strong>特征码能保证报文的数据完整性</strong>），再使用自身的私钥对特征码进行公钥加密（特征码数据小，对其进行公钥加密速度快），并把加密后的特征码附加到报文后。（使用私钥加密是为了验证身份）但是，这种方式能实现数据完整性和身份验证的检验，但是却缺失了报文的数据保密性</p></li><li><p>（3）为了解决上述问题，B在把加密的特征码附加到报文后，把特征码和报文当做一个数据（假设为data），使用对称加密算法对该数据(data)加密得出一个密码，再把密码附加到该数据(data)后。为了使得在传输过程中密码不被其他人获取或篡改，使用A的公钥对密码进行加密（只有A的私钥能对其解密），把加密的密码附加到数据data后，再这些数据一并发送给A。</p></li></ul><blockquote><p><strong>对称加密算法有很多种，那么如何选择加密算法呢？ 这是因为前面会有个加密算法协商的过程，客户端和服务器各自支持的加密算法不一样，所有在数据加密传输过程中工会有加密算法协商的过程</strong>。</p></blockquote><p><strong>2、接收端A：</strong></p><ul><li>（1）A接收到B传来的报文，利用自身的私钥对其解密，获得密码。因为只有A的私钥能对B传来的报文（使用A的公钥加密密码）解密，所以能防止其他人对该传输的报文进行解密而获得其中的信息，保证了数据的保密性。</li><li>（2）A利用获得的密码解密其中对称加密的数据，获得经过加密的特征码和原报文。</li><li>（3）A使用B的公钥对该特征码解密，能解密则说明该报文是B发送过来的，实现了身份验证。（假设解密后的特征码是fcode）</li><li>（4）A使用同等单向加密算法对接收到的原报文提取其特征码。使用该特征码和解密后获得的特征码(fcode)做比较，如果一样，则说明原报文的数据完整。</li></ul><p>以上这种方式能保证数据完整性、身份验证和数据的保密性，在加密和解密的过程中都要用到对方的公钥，<strong>如何在传输过程中安全可靠地获得对方的公钥就成了关键的一环</strong>，</p><p>遗留问题</p><ul><li><strong>1. 公钥如何安全的获取服务器公钥？</strong></li><li><strong>2. 对称加密的秘钥如何生成，加密算法如何协商？</strong></li></ul><p>要解决三个问题必须要客户端和服务器进行协商，协商出双方一致的秘钥算法。所以，客户端和服务器必须有一个完整的秘钥交换机制。</p><h2><span id="秘钥交换">秘钥交换</span></h2><h2><span id="直接秘钥交换">直接秘钥交换</span></h2><p>由于公钥公开，所以当客户端连接服务器的时候，服务器会给客户端发自己公钥，然后客户端用公钥加密密码（也就是对称秘钥），发送给服务器，服务器有私钥，可以解密数据。这样就实现了数据加密的传输。 这种秘钥交换在https 里映射为对<strong>称秘钥的交换</strong></p><blockquote><p>虽然公钥是公开的，但是也并不意味着和所有人都可以拥有公钥,公钥的公开是指公钥可以在网络上传输。<br>如果你能保证公钥和私钥一样，能安全的进行交换，那么双方的传输安全是没有问题。一般情况下为<strong>人肉传输/线下传输</strong>。比如：公钥放到专用的安全U盘上，然后在去服务器传输。</p></blockquote><p><strong>漏洞</strong>： 公钥会暴露给中间人。</p><p>原因：秘钥在网络上传输导致的。但是很多时候，无法进行线下传输，秘钥交换必不可少。</p><p>实现：RSA秘钥交换算法</p><h2><span id="dh算法解决秘钥交换漏洞">DH算法解决秘钥交换漏洞</span></h2><p>如果要解决中间人替换漏洞：<strong>Diffie-Hellman</strong>算法应运而生。<br>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p><p><strong>DH算法的过程</strong>：</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-214429.png" alt></p><p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p><ul><li><p>1、通信方A和通信方B约定一个初始数 <code>g</code>，如<code>g=5</code>，一个质数<code>p</code>，如p=23，g和p是公开的,且<code>1&lt; g &lt; p</code></p></li><li><p>2、Alice生成一个随机数<code>a</code>，<code>a</code>是保密的，如<code>a=6</code></p></li><li><p>3、Alice 计算 <code>A=g^a%p</code> 发送给B  即：<code>g^a%p=5^6%23=8</code></p></li><li><p>4、B生成一个随机数b，b是保密的，如 <code>b=15</code></p></li><li><p>5、Bob计算<code>B=g^b%p</code>发送给A，B=g^b%p=5^15%23=19</p></li><li><p>6、A接收到<code>g^b%p</code>后，再使用保密的a，计算<code>(g^b%p)^a%p=19^6%23=2</code></p></li><li><p>7、B接收到<code>g^a%p</code>后，再使用保密的b，计算(<code>g^a%p)^b%p=8^15%23=2</code></p></li><li><p>算法实现如下</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; createDiffieHellman &#125; = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = createDiffieHellman(<span class="number">512</span>)   <span class="comment">// 内部已经有随机值a</span></span><br><span class="line"><span class="keyword">let</span> clientKey = client.generateKeys();  <span class="comment">// 生成A</span></span><br><span class="line"><span class="keyword">let</span> prime = client.getPrime();          <span class="comment">// 生成 p</span></span><br><span class="line"><span class="keyword">let</span> generator = client.getGenerator()   <span class="comment">// 生成g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次传输   传输prime（p） 和 generator（g）  和 clientKey (A  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = createDiffieHellman(prime, generator)  <span class="comment">// 内部生成随机值b 保存 p 和 g </span></span><br><span class="line"><span class="keyword">let</span> serverKey = server.generateKeys()               <span class="comment">//  生成B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次传输 服务传输  serverKey (B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算  B^a%p</span></span><br><span class="line"><span class="keyword">let</span> secretClient = client.computeSecret(serverKey)</span><br><span class="line"><span class="comment">// 计算  A^b%p</span></span><br><span class="line"><span class="keyword">let</span> secretServer = server.computeSecret(clientKey)</span><br><span class="line"><span class="comment">//  secretServer == secretClient</span></span><br><span class="line"><span class="built_in">console</span>.log(secretClient.toString(<span class="string">"hex"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(secretServer.toString(<span class="string">"hex"</span>))</span><br></pre></td></tr></table></figure><p>解决：秘钥不用再公开传输<br>详见：<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman_key_exchange</a></p><blockquote><p>ECC 算法就是DH算法的一个实现</p></blockquote><h2><span id="秘钥交换协议的常用实现">秘钥交换协议的常用实现</span></h2><h3><span id="rsa密钥交换算法直接交换">RSA密钥交换算法（直接交换）</span></h3><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-122153.png" alt></p><ul><li><p>（1）：任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。</p></li><li><p>（2）：客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行 加密，生成C，把C发送到服务器。</p></li><li><p>（3）：服务器收到C，使用公钥对应的私钥进行解密，得到S。</p></li><li><p>（4）：上述交换步骤后，客户端和服务器都得到了S，S为密钥（<strong>预主密钥</strong>）。</p></li></ul><blockquote><p>一般预备主密钥还要经过一个随机数及其序列号生成主密钥，用于防止重放攻击使用</p></blockquote><h3><span id="dhe算法流程文字描述如下">DHE算法流程文字描述如下：</span></h3><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-122821.png" alt></p><p>DHE算法流程文字描述如下：</p><ul><li><p>（1）：客户端计算一个随机值Xa，使用Xa作为指数，即计算Pa = q^Xa mod p，其中q和p是全世界公认的一对值。客户端把Pa发送至服务器，Xa作为自己私钥，仅且自己知道。</p></li><li><p>（2）：服务器和客户端计算流程一样，生成一个随机值Xb，使用Xb作为指数，计算   Pb = q^Xb mod p，将结果Pb发送至客户端，Xb仅自己保存。</p></li><li><p>（3）：客户端收到Pb后计算Sa = Pb ^Xa mod p；服务器收到Pa后计算Sb = Pa^Xb mod p</p></li><li><p>（4）：算法保证了Sa = Sb = S，故密钥交换成功，S为密钥（预主密钥）。</p></li></ul><p>上述密钥交换流程中，和RSA密钥交换有较大不同，DHE密钥交换时，服务器私钥没有参与进来。也就是说，私钥即使泄漏，也不会导致会话加密密钥S被第三方解密。</p><p>实际使用过程中，私钥的功能被削弱到用来身份认证（上图中没有画出）。</p><p>上图中DHE参数和Pb都是通过server key exchange发送给客户端，Pa通过client key exchange发送给服务器。server key exchange的结尾处需要使用服务器私钥对该报文本身进行签名，以表明自己拥有私钥（图中为了表明私钥没有参与密钥计算，没有画出，但不影响理解DHE算法）。</p><h3><span id="ecdhe-or-ecdh-密钥交换算法">ECDHE or ECDH 密钥交换算法</span></h3><p>只要理解DHE密钥交换原理，那么理解ECDHE密钥交换原理其实并不难（如果不想深究的话）。<br>ECDHE的运算是把DHE中模幂运算替换成了点乘运算，速度更快，可逆更难。</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-123219.png" alt></p><p>ECDHE算法流程文字描述如下：</p><ul><li><p>（1）：客户端随机生成随机值Ra，计算Pa(x, y) = Ra * Q(x, y)，Q(x, y)为全世界公认的某个椭圆曲线算法的基点。将Pa(x, y)发送至服务器。</p></li><li><p>（2）：服务器随机生成随机值Rb，计算Pb(x,y) - Rb * Q(x, y)。将Pb(x, y)发送至客户端。</p></li><li><p>（3）：客户端计算Sa(x, y) = Ra * Pb(x, y)；服务器计算Sb(x, y) = Rb *Pa(x, y)</p></li><li><p>（4）：算法保证了Sa = Sb = S，提取其中的S的x向量作为密钥（预主密钥）。</p></li></ul><p><strong>ECDHE与ECDH算法的区别</strong><br>字面少了一个E，E代表了“临时”，即在握手流程中，作为服务器端，ECDH少了一步计算Pb的过程，Pb用证书中的公钥代替，而证书对应的私钥就是Xb。由此可见，使用ECDH密钥交换算法，服务器必须采用ECC证书；服务器不发送server key exchange报文，因为发送certificate报文时，证书本身就包含了Pb信息。</p><p><strong>ECDHE与RSA的区别</strong><br>    ECDHE（DHE）算法属于DH类密钥交换算法， 私钥不参与密钥的协商，故即使私钥泄漏，客户端和服务器之间加密的报文都无法被解密，这叫 前向安全（forward secrity）。由于ECDHE每条会话都重新计算一个密钥（Ra、Rb），故一条会话被解密后，其他会话仍旧安全。（随机数 + 会话序列帧）</p><p>然而，ECDH算法服务器端的私钥是固定的，即证书的私钥作为Rb，故ECDH不被认为前向安全，因为私钥泄漏相当于Rb泄漏，Rb泄漏，导致会话密钥可被第三方计算。ECDH交换算法已经被OpenSSL废</p><h2><span id="中间人劫持-man-in-the-middle-attack-mitm">中间人劫持-Man-In-The-Middle attack MITM。</span></h2><p>中间人攻击</p><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-103447.png" alt></p><h2><span id="mitmproxy模拟中间人挟持">mitmproxy模拟中间人挟持</span></h2><p>解决：当发送方要发送公钥的时候，不发送公钥，而是发送一个<strong>数字证书</strong>，证书中会包含一些具体信息。接收方收到证书后验证证书真伪，然后获取证书内的公钥。<br>所以安全可靠地获取对方的公钥靠CA(Certificate Authority )证书授权中心来实现。</p><h2><span id="ca证书体系">CA证书体系</span></h2><h2><span id="ca是什么">CA是什么？</span></h2><p>上面提到的数字证书就是CA发行的。CA是<strong>Certificate Authority</strong>的缩写，也叫“证书授权中心”。它是负责管理和签发证书的第三方机构，作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。</p><p>所以，CA实际上是一个机构，负责“证件”印制核发。就像负责颁发身份证的公安局、负责发放行驶证、驾驶证的车管所。</p><h2><span id="ca证书的信任链">CA证书的信任链</span></h2><p>实际上，证书之间的信任关系，是可以嵌套的。比如，C 信任 A1，A1 信任 A2，A2 信任 A3…这个叫做证书的信任链。只要你信任链上的头一个证书，那后续的证书，都是可以信任滴。<br>　<br><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-110350.png" alt></p><p>处于最顶上的树根位置的那个证书，就是“根证书”。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明“根证书”可靠捏？实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴）。<br>　　聪明的同学此刻应该意识到了：根证书是整个证书体系安全的根本。所以，如果某个证书体系中，根证书出了问题（不再可信了），那么所有被根证书所信任的其它证书，也就不再可信了。</p><h2><span id="ca证书的结构">CA证书的结构</span></h2><ul><li><strong>1、CA证书标准：x.509</strong><br>x.509: 定义了证书结构和认证协议标准；（基于公钥和数字签名）<br>用于：IP安全、TLS/SSL（传输层安全）和S/MIME（安全电子邮件通信）<br><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-112110.png" alt></li></ul><p><strong>x.509证书标准详细说明：</strong></p><ul><li>（1）版本号（默认为1，如果有多个扩展，可能为3）</li><li>（2）证书序列号（是一个整数，在CA中唯一标识，表明发行了多少个证书）</li><li>（3）算法参数 （标志用了那种算法）</li><li>（4）发行者的名称（CA自己的名字）</li><li>（5）有效期限</li><li>（6）主体名称（证书拥有者名称）(很关键！！！)（个人用户使用的是个人用户名，主机使用的必须是主机名而不是ip地址）</li><li>（7）<strong>公钥（最重要）（公钥由证书拥有者提供）</strong></li><li>（8）发行者的ID（CA的唯一编号）</li><li>（9）主体的ID（CA生成的证书拥有者唯一编号）</li><li>（10）扩展</li><li><strong>（11）CA的签名（用于验证CA的来源合法性） CA是相对于发送方B和接收方A的第三方，是具有公信力的机构。</strong></li></ul><h2><span id="证书的验证过程">证书的验证过程</span></h2><p>假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你</p><ul><li><p>颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；而这个上级机构他的证书又是同样的方法由CA颁发的。</p></li><li><p>首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的</p></li><li><p>颁发者证书的公钥，解密你的证书的特征码，然后再用收到的证书中的加密算法，再使用同样的单向加密算法提取收到证书的特征码，比较这两个特征码是否一样，如果一样，则表示获得你的的数字证书是完整的。</p></li><li><p>从证书中获取你的公钥</p></li></ul><p><img src="/article/tcpip-4-SSL-TLS/tcpip-4-SSL-TLS-120425.png" alt></p><h2><span id="遗留问题">遗留问题</span></h2><p>通过我们前面的认识，我们来回答下了几个问题</p><ul><li><strong>1. 公钥如何安全的获取</strong>：        通过CA证书的方式来获取 解决中间人攻击</li><li><strong>2. 对称加密的秘钥如何生成/获取</strong>  通过DH算法来获取（秘钥协商）</li></ul><p>那么我们接下来就要讨论一下，在应用层面上来说，服务器客户端双方怎么能快速的达成秘钥的交换和生成。<br>如果要交换秘钥，TLS在连接之前会进行握手操作，该操作用于交换秘钥，协商加密算法等等，用于建立安全的连接。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626" target="_blank" rel="noopener">签名算法</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://blog.csdn.net/mrpre/article/details/78025940" target="_blank" rel="noopener">TLS/SSL 协议详解 (30) SSL中的RSA、DHE、ECDHE、ECDH流程与区别</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（四）</title>
      <link href="/article/java-thrift-4-2/"/>
      <url>/article/java-thrift-4-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一届主要讨论了<code>Thrift</code>编解码中的二进制协议格式。这是一种比较大众的协议。本节来讨论二进制协议的另一种加强版本。<code>TCompactProtocol</code></p><h2><span id="编解码">编解码</span></h2><p>对于二进制编码，经常需要对数据进行压缩以节省空间，varint可以压缩较小的正数，但是对于负数varint反而更浪费空间，zigzag编码可以处理负数，使负数也可以使用varint编码压缩，protobuf和thrift都使用二者结合的方式来压缩数字类型。</p><p>原码、反码、补码<br>首先，计算机为了方便位运算，使用补码来存储数字。</p><p>然后回顾下：</p><ul><li><strong>原码：最高位为符号位，剩余位表示绝对值；</strong></li><li><strong>反码：除符号位外，对原码剩余位依次取反；</strong></li><li><em>补码：对于正数，补码为其自身；对于负数，除符号位外对原码剩余位依次取反然后+1。</em></li></ul><h2><span id="varint">varint</span></h2><p>本文以int类型为例，详细介绍如果通过varint+zigzag编码技术压缩数字。<br>首先，我们常用的数字其实多数都不是很大，比如：商品的价值、动态计数等，对于这些不是很大的数字，二进制的高位多数是0。<br>varint编码每个字节前1位表示下一个字节是否也是该数字的一部分，后7位表示实际的值，最后，先低位后高位，对于int类型来说，varint编码最少占用1个字节，最多占用5个字节。</p><p>varint编码java代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(idx = <span class="number">0</span>; (n &amp; -<span class="number">128</span>) != <span class="number">0</span>; n &gt;&gt;&gt;= <span class="number">7</span>) &#123;</span><br><span class="line">  bytes[idx++] = (<span class="keyword">byte</span>)(n &amp; <span class="number">127</span> | <span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line">bytes[idx++] = (<span class="keyword">byte</span>)n;</span><br></pre></td></tr></table></figure><p>例如，对于int类型1来说，二进制表示为 <code>00000000 00000000 00000000 00000001</code>，总共占用4个字节，然而，前3个字节都是0，varint就是通过压缩高位的0来达到节省空间的目的，使用varint压缩后，二进制表示为 <code>00000001</code>，只占用1个字节。</p><p>对于int类型2^30来说二进制表示为<br><code>01000000 00000000 00000000 00000000</code>，使用varint压缩后，二进制表示为<code>10000000 10000000 10000000 10000000 00000100</code>，占用5个字节。</p><p><img src="/article/java-thrift-4-2/java-thrift-4-2-210005.png" alt></p><h2><span id="zigzag">zigzag</span></h2><p>对于负数来说，因为最高位符号位始终为1，使用 <code>varint</code> 编码就很浪费空间，<code>zigzag</code> 编码就是解决负数的问题的，同时其对正数也没有很大的影响。</p><p>int类型zigzag变换的代码表示为<code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></p><ul><li><strong>左移1位可以消去符号位，低位补0</strong></li><li><strong>有符号右移31位将符号位移动到最低位，负数高位补1，正数高位补0</strong></li></ul><p>例如：对于正数来说，最低位符号位为0，其他位不变<br>对于负数，最低位符号位为1，其他位按位取反<br>-1的二进制表示为 <code>11111111 11111111 11111111 11111111</code>，zigzag变换后 <code>00000000 00000000 00000000 00000001</code>，再用varint编码，是不是很小了。</p><p>1的二进制表示为 <code>00000000 00000000 00000000 00000001</code>，zigzag变换后<code>00000001</code>，再用varint编码，依然很小。</p><h2><span id="解码">解码</span></h2><p>zigzag操作为<code>(n &gt;&gt;&gt; 1) ^ -(n &amp; 1)</code></p><p>正数：当前的数乘以2， zigzagY = x * 2<br>负数：当前的数乘以-2后减1, zigzagY = x * -2 - 1</p><ul><li>无符号右移1位</li><li>按位与1，然后取负值，这一步非常巧妙，对于正数就是0，负数就是-1</li><li>按位异或得到结果<ul><li>正数是与0按位异或</li><li>负数是与-1按位异或</li></ul></li></ul><p>-1 的解码过程为</p><ul><li><p><code>00000000 00000000 00000000 00000010</code>  = 无符号右移1位（(n &gt;&gt;&gt; 1)） = <code>00000000 00000000 00000000 00000001</code></p></li><li><p><code>00000000 00000000 00000000 00000010</code>  = 按位与1（都为1则为1，否则为0）（(n &amp; 1)）= <code>00000000 00000000 00000000 00000000</code> 为负数</p></li><li><p>上面两个记过异或 <code>00000000 00000000 00000000 00000001</code> (异或 -1 相同为0，不同为1) = <code>11111111 11111111 11111111 11111111</code> =  <code>00000000 00000000 00000000 00000001</code></p></li></ul><h2><span id="tcompactprotocol-代码详解">TCompactProtocol 代码详解</span></h2><p><code>TCompactProtocol</code>对于二进制编码，经常需要对数据进行压缩以节省空间，varint可以压缩较小的正数，但是对于负数varint反而更浪费空间，zigzag编码可以处理负数，使负数也可以使用varint编码压缩，protobuf和thrift都使用二者结合的方式来压缩数字类型。</p><p>来看一下二级制的图示<br><img src="/article/java-thrift-4-2/java-thrift-4-2-095010.png" alt></p><h2><span id="代码">代码</span></h2><p>下面代码省略了一些部分信息，保留了关键注释和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCompactProtocol</span> <span class="keyword">extends</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> TStruct ANONYMOUS_STRUCT = <span class="keyword">new</span> TStruct(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> TField TSTOP = <span class="keyword">new</span> TField(<span class="string">""</span>, TType.STOP, (<span class="keyword">short</span>)<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] ttypeToCompactType = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    ttypeToCompactType[TType.STOP] = TType.STOP;</span><br><span class="line">    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;</span><br><span class="line">    ttypeToCompactType[TType.BYTE] = Types.BYTE;</span><br><span class="line">    ttypeToCompactType[TType.I16] = Types.I16;</span><br><span class="line">    ttypeToCompactType[TType.I32] = Types.I32;</span><br><span class="line">    ttypeToCompactType[TType.I64] = Types.I64;</span><br><span class="line">    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;</span><br><span class="line">    ttypeToCompactType[TType.STRING] = Types.BINARY;</span><br><span class="line">    ttypeToCompactType[TType.LIST] = Types.LIST;</span><br><span class="line">    ttypeToCompactType[TType.SET] = Types.SET;</span><br><span class="line">    ttypeToCompactType[TType.MAP] = Types.MAP;</span><br><span class="line">    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PROTOCOL_ID = (<span class="keyword">byte</span>)<span class="number">0x82</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VERSION = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VERSION_MASK = <span class="number">0x1f</span>; <span class="comment">// 0001 1111</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> TYPE_MASK = (<span class="keyword">byte</span>)<span class="number">0xE0</span>; <span class="comment">// 1110 0000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TYPE_SHIFT_AMOUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Types</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOLEAN_TRUE   = <span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOLEAN_FALSE  = <span class="number">0x02</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE           = <span class="number">0x03</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16            = <span class="number">0x04</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32            = <span class="number">0x05</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64            = <span class="number">0x06</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE         = <span class="number">0x07</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BINARY         = <span class="number">0x08</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST           = <span class="number">0x09</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET            = <span class="number">0x0A</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP            = <span class="number">0x0B</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT         = <span class="number">0x0C</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Thrift 自己实现的short类型栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ShortStack lastField_ = <span class="keyword">new</span> ShortStack(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">short</span> lastFieldId_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If we encounter a boolean field begin, save the TField here so it can </span></span><br><span class="line"><span class="comment">   * have the value incorporated.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> TField booleanField_ = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If we read a field header, and it's a boolean field, save the boolean </span></span><br><span class="line"><span class="comment">   * value here so that readBool can use it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Boolean boolValue_ = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastField_.clear();</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a message header to the wire. Compact Protocol messages contain the</span></span><br><span class="line"><span class="comment">   * protocol version so we can migrate forwards in the future if need be.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(PROTOCOL_ID);</span><br><span class="line">    writeByteDirect((VERSION &amp; VERSION_MASK) | ((message.type &lt;&lt; TYPE_SHIFT_AMOUNT) &amp; TYPE_MASK));</span><br><span class="line">    writeVarint32(message.seqid);</span><br><span class="line">    writeString(message.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a struct begin. This doesn't actually put anything on the wire. We </span></span><br><span class="line"><span class="comment">   * use it as an opportunity to put special placeholder markers on the field</span></span><br><span class="line"><span class="comment">   * stack so we can get the field id deltas correct.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastField_.push(lastFieldId_);</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a struct end. This doesn't actually put anything on the wire. We use</span></span><br><span class="line"><span class="comment">   * this as an opportunity to pop the last field from the current struct off</span></span><br><span class="line"><span class="comment">   * of the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastFieldId_ = lastField_.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a field header containing the field id and field type. If the</span></span><br><span class="line"><span class="comment">   * difference between the current field id and the last one is small (&lt; 15),</span></span><br><span class="line"><span class="comment">   * then the field id will be encoded in the 4 MSB as a delta. Otherwise, the</span></span><br><span class="line"><span class="comment">   * field id will follow the type header as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field.type == TType.BOOL) &#123;</span><br><span class="line">      <span class="comment">// we want to possibly include the value, so we'll wait.</span></span><br><span class="line">      booleanField_ = field;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeFieldBeginInternal(field, (<span class="keyword">byte</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The workhorse of writeFieldBegin. It has the option of doing a </span></span><br><span class="line"><span class="comment">   * 'type override' of the type header. This is used specifically in the </span></span><br><span class="line"><span class="comment">   * boolean field case.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldBeginInternal</span><span class="params">(TField field, <span class="keyword">byte</span> typeOverride)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="comment">// short lastField = lastField_.pop();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there's a type override, use that.</span></span><br><span class="line">    <span class="keyword">byte</span> typeToWrite = typeOverride == -<span class="number">1</span> ? getCompactType(field.type) : typeOverride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we can use delta encoding for the field id</span></span><br><span class="line">    <span class="keyword">if</span> (field.id &gt; lastFieldId_ &amp;&amp; field.id - lastFieldId_ &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">      <span class="comment">// write them together</span></span><br><span class="line">      writeByteDirect((field.id - lastFieldId_) &lt;&lt; <span class="number">4</span> | typeToWrite);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// write them separate</span></span><br><span class="line">      writeByteDirect(typeToWrite);</span><br><span class="line">      writeI16(field.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="comment">// lastField_.push(field.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write the STOP symbol so we know there are no more fields in this struct.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(TType.STOP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a map header. If the map is empty, omit the key and value type </span></span><br><span class="line"><span class="comment">   * headers, as we don't need any additional information to skip it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.size == <span class="number">0</span>) &#123;</span><br><span class="line">      writeByteDirect(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeVarint32(map.size);</span><br><span class="line">      writeByteDirect(getCompactType(map.keyType) &lt;&lt; <span class="number">4</span> | getCompactType(map.valueType));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Write a list header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeCollectionBegin(list.elemType, list.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a set header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeCollectionBegin(set.elemType, set.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a boolean value. Potentially, this could be a boolean field, in </span></span><br><span class="line"><span class="comment">   * which case the field header info isn't written yet. If so, decide what the</span></span><br><span class="line"><span class="comment">   * right type header is for the value and then write the field header. </span></span><br><span class="line"><span class="comment">   * Otherwise, write a single byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (booleanField_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we haven't written the field header yet</span></span><br><span class="line">      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">      booleanField_ = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// we're not part of a field, so just write the value.</span></span><br><span class="line">      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//ZigZag编码：16位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(intToZigZag(i16));</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//ZigZag编码：32位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(intToZigZag(i32));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//ZigZag编码：64位 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint64(longToZigzag(i64));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    fixedLongToBytes(Double.doubleToLongBits(dub), data, <span class="number">0</span>);</span><br><span class="line">    trans_.write(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">      writeBinary(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"UTF-8 not supported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write a byte array, using a varint for the size. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">    writeBinary(bin.array(), bin.position() + bin.arrayOffset(), length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeVarint32(length);</span><br><span class="line">    trans_.write(buf, offset, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 其他层复写的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Abstract method for writing the start of lists and sets. List and sets on </span></span><br><span class="line"><span class="comment">   * the wire differ only by the type indicator.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeCollectionBegin</span><span class="params">(<span class="keyword">byte</span> elemType, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">14</span>) &#123;</span><br><span class="line">      writeByteDirect(size &lt;&lt; <span class="number">4</span> | getCompactType(elemType));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeByteDirect(<span class="number">0xf0</span> | getCompactType(elemType));</span><br><span class="line">      writeVarint32(size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write an i32 as a varint. Results in 1-5 bytes on the wire.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">TODO:</span> make a permanent buffer like writeVarint64?</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">byte</span>[] i32buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeVarint32</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &amp; ~<span class="number">0x7F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        i32buf[idx++] = (<span class="keyword">byte</span>)n;</span><br><span class="line">        <span class="comment">// writeByteDirect((byte)n);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i32buf[idx++] = (<span class="keyword">byte</span>)((n &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>);</span><br><span class="line">        <span class="comment">// writeByteDirect((byte)((n &amp; 0x7F) | 0x80));</span></span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans_.write(i32buf, <span class="number">0</span>, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write an i64 as a varint. Results in 1-10 bytes on the wire.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">byte</span>[] varint64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeVarint64</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &amp; ~<span class="number">0x7FL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        varint64out[idx++] = (<span class="keyword">byte</span>)n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        varint64out[idx++] = ((<span class="keyword">byte</span>)((n &amp; <span class="number">0x7F</span>) | <span class="number">0x80</span>));</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans_.write(varint64out, <span class="number">0</span>, idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert l into a zigzag long. This allows negative numbers to be </span></span><br><span class="line"><span class="comment">   * represented compactly as a varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">longToZigzag</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l &lt;&lt; <span class="number">1</span>) ^ (l &gt;&gt; <span class="number">63</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert n into a zigzag int. This allows negative numbers to be </span></span><br><span class="line"><span class="comment">   * represented compactly as a varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">intToZigZag</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;&lt; <span class="number">1</span>) ^ (n &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert a long into little-endian bytes in buf starting at off and going </span></span><br><span class="line"><span class="comment">   * until off+7.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixedLongToBytes</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">    buf[off+<span class="number">0</span>] = (<span class="keyword">byte</span>)( n        &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">1</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">8</span> ) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">2</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">3</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">4</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">5</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">6</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    buf[off+<span class="number">7</span>] = (<span class="keyword">byte</span>)((n &gt;&gt; <span class="number">56</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Writes a byte without any possibility of all that field header nonsense. </span></span><br><span class="line"><span class="comment">   * Used internally by other writing methods that know they need to write a byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] byteDirectBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeByteDirect</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    byteDirectBuffer[<span class="number">0</span>] = b;</span><br><span class="line">    trans_.write(byteDirectBuffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Writes a byte without any possibility of all that field header nonsense.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeByteDirect</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByteDirect((<span class="keyword">byte</span>)n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// Reading methods.</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a message header. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> protocolId = readByte();</span><br><span class="line">    <span class="keyword">if</span> (protocolId != PROTOCOL_ID) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"Expected protocol id "</span> + Integer.toHexString(PROTOCOL_ID) + <span class="string">" but got "</span> + Integer.toHexString(protocolId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> versionAndType = readByte();</span><br><span class="line">    <span class="keyword">byte</span> version = (<span class="keyword">byte</span>)(versionAndType &amp; VERSION_MASK);</span><br><span class="line">    <span class="keyword">if</span> (version != VERSION) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"Expected version "</span> + VERSION + <span class="string">" but got "</span> + version);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> type = (<span class="keyword">byte</span>)((versionAndType &gt;&gt; TYPE_SHIFT_AMOUNT) &amp; <span class="number">0x03</span>);</span><br><span class="line">    <span class="keyword">int</span> seqid = readVarint32();</span><br><span class="line">    String messageName = readString();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMessage(messageName, type, seqid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a struct begin. There's nothing on the wire for this, but it is our</span></span><br><span class="line"><span class="comment">   * opportunity to push a new struct begin marker onto the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    lastField_.push(lastFieldId_);</span><br><span class="line">    lastFieldId_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ANONYMOUS_STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Doesn't actually consume any wire data, just removes the last field for </span></span><br><span class="line"><span class="comment">   * this struct from the field stack.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="comment">// consume the last field we read off the wire.</span></span><br><span class="line">    lastFieldId_ = lastField_.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a field header off the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if it's a stop, then we can return immediately, as the struct is over.</span></span><br><span class="line">    <span class="keyword">if</span> (type == TType.STOP) &#123;</span><br><span class="line">      <span class="keyword">return</span> TSTOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> fieldId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mask off the 4 MSB of the type header. it could contain a field id delta.</span></span><br><span class="line">    <span class="keyword">short</span> modifier = (<span class="keyword">short</span>)((type &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (modifier == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// not a delta. look ahead for the zigzag varint field id.</span></span><br><span class="line">      fieldId = readI16();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// has a delta. add the delta to the last read field id.</span></span><br><span class="line">      fieldId = (<span class="keyword">short</span>)(lastFieldId_ + modifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TField field = <span class="keyword">new</span> TField(<span class="string">""</span>, getTType((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)), fieldId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this happens to be a boolean field, the value is encoded in the type</span></span><br><span class="line">    <span class="keyword">if</span> (isBoolType(type)) &#123;</span><br><span class="line">      <span class="comment">// save the boolean value in a special instance variable.</span></span><br><span class="line">      boolValue_ = (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the new field onto the field stack so we can keep the deltas going.</span></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Read a map header off the wire. If the size is zero, skip reading the key</span></span><br><span class="line"><span class="comment">   * and value type. This means that 0-length maps will yield TMaps without the</span></span><br><span class="line"><span class="comment">   * "correct" types.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readVarint32();</span><br><span class="line">    <span class="keyword">byte</span> keyAndValueType = size == <span class="number">0</span> ? <span class="number">0</span> : readByte();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMap(getTType((<span class="keyword">byte</span>)(keyAndValueType &gt;&gt; <span class="number">4</span>)), getTType((<span class="keyword">byte</span>)(keyAndValueType &amp; <span class="number">0xf</span>)), size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a list header off the wire. If the list size is 0-14, the size will </span></span><br><span class="line"><span class="comment">   * be packed into the element type header. If it's a longer list, the 4 MSB</span></span><br><span class="line"><span class="comment">   * of the element type header will be 0xF, and a varint will follow with the</span></span><br><span class="line"><span class="comment">   * true size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> size_and_type = readByte();</span><br><span class="line">    <span class="keyword">int</span> size = (size_and_type &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">15</span>) &#123;</span><br><span class="line">      size = readVarint32();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> type = getTType(size_and_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TList(type, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a set header off the wire. If the set size is 0-14, the size will </span></span><br><span class="line"><span class="comment">   * be packed into the element type header. If it's a longer set, the 4 MSB</span></span><br><span class="line"><span class="comment">   * of the element type header will be 0xF, and a varint will follow with the</span></span><br><span class="line"><span class="comment">   * true size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TSet(readListBegin());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a boolean off the wire. If this is a boolean field, the value should</span></span><br><span class="line"><span class="comment">   * already have been read during readFieldBegin, so we'll just consume the</span></span><br><span class="line"><span class="comment">   * pre-stored value. Otherwise, read a byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (boolValue_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> result = boolValue_.booleanValue();</span><br><span class="line">      boolValue_ = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readByte() == Types.BOOLEAN_TRUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] byteRawBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a single byte off the wire. Nothing interesting here.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">      trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      trans_.readAll(byteRawBuf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      b = byteRawBuf[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i16 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">short</span>)zigzagToInt(readVarint32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i32 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zigzagToInt(readVarint32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i64 from the wire as a zigzag varint.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zigzagToLong(readVarint64());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * No magic here - just read a double off the wire.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] longBits = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    trans_.readAll(longBits, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(bytesToLong(longBits));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reads a byte[] (via readBinary), and then UTF-8 decodes it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = readVarint32();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= length) &#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(trans_.getBuffer(), trans_.getBufferPosition(), length, <span class="string">"UTF-8"</span>);</span><br><span class="line">        trans_.consumeBuffer(length);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(readBinary(length), <span class="string">"UTF-8"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"UTF-8 not supported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a byte[] from the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = readVarint32();</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read a byte[] of a known length from the wire. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] readBinary(<span class="keyword">int</span> length) <span class="keyword">throws</span> TException &#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// These methods are here for the struct to call, but don't have any wire </span></span><br><span class="line">  <span class="comment">// encoding.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Internal reading methods</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i32 from the wire as a varint. The MSB of each byte is set</span></span><br><span class="line"><span class="comment">   * if there is another byte to follow. This can read up to 5 bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readVarint32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Read an i64 from the wire as a proper varint. The MSB of each byte is set </span></span><br><span class="line"><span class="comment">   * if there is another byte to follow. This can read up to 10 bytes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">readVarint64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">long</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">long</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift +=<span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// encoding helpers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Convert from zigzag int to int.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">zigzagToInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt;&gt; <span class="number">1</span>) ^ -(n &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Convert from zigzag long to long.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">zigzagToLong</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt;&gt; <span class="number">1</span>) ^ -(n &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note that it's important that the mask bytes are long literals, </span></span><br><span class="line"><span class="comment">   * otherwise they'll default to ints, and when you shift an int left 56 bits,</span></span><br><span class="line"><span class="comment">   * you just get a messed up int.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">bytesToLong</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((bytes[<span class="number">7</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">      ((bytes[<span class="number">6</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">      ((bytes[<span class="number">5</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">      ((bytes[<span class="number">4</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">      ((bytes[<span class="number">3</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((bytes[<span class="number">2</span>] &amp; <span class="number">0xffL</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((bytes[<span class="number">1</span>] &amp; <span class="number">0xffL</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((bytes[<span class="number">0</span>] &amp; <span class="number">0xffL</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// type testing and converting</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBoolType</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowerNibble = b &amp; <span class="number">0x0f</span>;</span><br><span class="line">    <span class="keyword">return</span> lowerNibble == Types.BOOLEAN_TRUE || lowerNibble == Types.BOOLEAN_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Given a TCompactProtocol.Types constant, convert it to its corresponding </span></span><br><span class="line"><span class="comment">   * TType value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getTType</span><span class="params">(<span class="keyword">byte</span> type)</span> <span class="keyword">throws</span> TProtocolException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> TType.STOP:</span><br><span class="line">        <span class="keyword">return</span> TType.STOP;</span><br><span class="line">      <span class="keyword">case</span> Types.BOOLEAN_FALSE:</span><br><span class="line">      <span class="keyword">case</span> Types.BOOLEAN_TRUE:</span><br><span class="line">        <span class="keyword">return</span> TType.BOOL;</span><br><span class="line">      <span class="keyword">case</span> Types.BYTE:</span><br><span class="line">        <span class="keyword">return</span> TType.BYTE;</span><br><span class="line">      <span class="keyword">case</span> Types.I16:</span><br><span class="line">        <span class="keyword">return</span> TType.I16;</span><br><span class="line">      <span class="keyword">case</span> Types.I32:</span><br><span class="line">        <span class="keyword">return</span> TType.I32;</span><br><span class="line">      <span class="keyword">case</span> Types.I64:</span><br><span class="line">        <span class="keyword">return</span> TType.I64;</span><br><span class="line">      <span class="keyword">case</span> Types.DOUBLE:</span><br><span class="line">        <span class="keyword">return</span> TType.DOUBLE;</span><br><span class="line">      <span class="keyword">case</span> Types.BINARY:</span><br><span class="line">        <span class="keyword">return</span> TType.STRING;</span><br><span class="line">      <span class="keyword">case</span> Types.LIST:</span><br><span class="line">        <span class="keyword">return</span> TType.LIST;</span><br><span class="line">      <span class="keyword">case</span> Types.SET:</span><br><span class="line">        <span class="keyword">return</span> TType.SET;</span><br><span class="line">      <span class="keyword">case</span> Types.MAP:</span><br><span class="line">        <span class="keyword">return</span> TType.MAP;</span><br><span class="line">      <span class="keyword">case</span> Types.STRUCT:</span><br><span class="line">        <span class="keyword">return</span> TType.STRUCT;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(<span class="string">"don't know what type: "</span> + (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Given a TType value, find the appropriate TCompactProtocol.Types constant.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">getCompactType</span><span class="params">(<span class="keyword">byte</span> ttype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ttypeToCompactType[ttype];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="写入方式">写入方式</span></h2><p>这里我们需要讲几个具体的例子</p><h3><span id="写bool类型">写bool类型。</span></h3><p>由于bool类型只有是否两种状态，且在我们的生成的代码当中是以TField的形式存在的，所有对于boolean的写入特殊处理。<br>写入bool类型的在struct 生成代码当中的的样例</p><p>TCompactProtocol写入Boolean分两种情况，</p><ul><li>1：该boolean值为TStruct中的内部成员时TField时，得写入header数据（即内容和数据类型压缩在一起写）；</li><li>2 ：如果不为TField内部类型的话，直接按byte写入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oprot.writeFieldBegin(BOOLTYPE_FIELD_DESC);  <span class="comment">//  BOOLTYPE_FIELD_DESC type = </span></span><br><span class="line">oprot.writeBool(struct.boolType);</span><br></pre></td></tr></table></figure><p>所以在下面用booleanField_ 先保存了TField 然后在后续执行  writeBool 判断一下booleanField_ 是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field.type == TType.BOOL) &#123;</span><br><span class="line">      booleanField_ = field;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeFieldBeginInternal(field, (<span class="keyword">byte</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (booleanField_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we haven't written the field header yet</span></span><br><span class="line">      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">      booleanField_ = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// we're not part of a field, so just write the value.</span></span><br><span class="line">      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="writefieldbegininternal-压缩写法"><code>writeFieldBeginInternal</code> 压缩写法</span></h3><p>writeFieldBeginInternal 每次写入一个Field 就说做一个记录，如果连续写的Field 不超过16个，那么他会将type 压缩写入。<br>具体的压缩过程。<br>第一，算出 Field的标号<br>第二， 把编号的低4为空余出来<br>第三，将type类型和Field的第四位拼起来。</p><p>比如：</p><ul><li><a href="http://field.id" target="_blank" rel="noopener">field.id</a> &gt; this.lastFieldId_  = 3  即 为 <code>0000 0011</code></li><li>&lt;&lt; 4   =       <code>0011 0000</code></li><li>找到field type   <code>this.getCompactType(field.type)</code></li><li>| 上 type   比如说Type 为 1</li><li>最终结果  <code>0011 0001</code> 写入</li></ul><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ttypeToCompactType[TType.STOP] = TType.STOP;</span><br><span class="line">    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;</span><br><span class="line">    ttypeToCompactType[TType.BYTE] = Types.BYTE;</span><br><span class="line">    ttypeToCompactType[TType.I16] = Types.I16;</span><br><span class="line">    ttypeToCompactType[TType.I32] = Types.I32;</span><br><span class="line">    ttypeToCompactType[TType.I64] = Types.I64;</span><br><span class="line">    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;</span><br><span class="line">    ttypeToCompactType[TType.STRING] = Types.BINARY;</span><br><span class="line">    ttypeToCompactType[TType.LIST] = Types.LIST;</span><br><span class="line">    ttypeToCompactType[TType.SET] = Types.SET;</span><br><span class="line">    ttypeToCompactType[TType.MAP] = Types.MAP;</span><br><span class="line">    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldBeginInternal</span><span class="params">(TField field, <span class="keyword">byte</span> typeOverride)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">                                            <span class="comment">// ttypeToCompactType[ttype]</span></span><br><span class="line">    <span class="keyword">byte</span> typeToWrite = typeOverride == -<span class="number">1</span> ? <span class="keyword">this</span>.getCompactType(field.type) : typeOverride;</span><br><span class="line">    <span class="comment">// 得到 差值 这个差值在 0 - 15 一个byte 就可。  </span></span><br><span class="line">    <span class="keyword">if</span> (field.id &gt; <span class="keyword">this</span>.lastFieldId_ &amp;&amp; field.id - <span class="keyword">this</span>.lastFieldId_ &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="comment">// 然后 &lt;&lt; 4 表示 把地四位 空余出来，</span></span><br><span class="line">        <span class="keyword">this</span>.writeByteDirect(field.id - <span class="keyword">this</span>.lastFieldId_ &lt;&lt; <span class="number">4</span> | typeToWrite);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeByteDirect(typeToWrite);</span><br><span class="line">        <span class="keyword">this</span>.writeI16(field.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lastFieldId_ = field.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="其他格式">其他格式</span></h3><ul><li>bool类型：<br>一个字节。</li></ul><blockquote><p>如果bool型的字段是结构体或消息的成员字段并且有编号，一个字节的高4位表示字段编号，低4位表示bool的值（0001:true， 0010：false），即：一个字节的低4位的值（true：1，false：2）.</p></blockquote><blockquote><p>如果bool型的字段单独存在，一个字节表示值，即：一个字节的值（true：1，false：2）.</p></blockquote><ul><li>Byte类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的值.</p></blockquote><ul><li>I16类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至三个字节的值.</p></blockquote><ul><li>I32类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的值.</p></blockquote><ul><li>I64类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至十个字节的值.</p></blockquote><ul><li>double类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），八个字节的值.注：把double类型的数据转成八字节保存，并用小端方式发送。</p></blockquote><ul><li>String类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的负载数据的长度，负载数据.</p></blockquote><ul><li>Struct类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），结构体负载数据，一个字节的结束标记.</p></blockquote><ul><li>MAP类型：</li></ul><blockquote><p>一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一至五个字节的map元素的个数，一个字节的键值类型组合（高4位键类型，低4位值类型），Map负载数据.</p></blockquote><ul><li>Set类型：</li></ul><blockquote><p>表示方式一：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的元素个数和值类型组合（高4位键元素个数，低4位值类型），Set负载数据.适用于<strong>Set中元素个数小于等于14个的情况</strong>。</p></blockquote><blockquote><p>表示方式二：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的键值类型（高4位全为1，低4位值类型），一至五个字节的map元素的个数，Set负载数据.<strong>适用于Set中元素个数大于14个的情况</strong>。</p></blockquote><ul><li>List类型：</li></ul><blockquote><p>表示方式一：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的元素个数和值类型组合（高4位键元素个数，低4位值类型），List负载数据.<br><strong>适用于Set中元素个数小于等于14个的情况。</strong></p></blockquote><blockquote><p>表示方式二：一个字节的编号与类型组合（高4位编号偏移1，低4位类型），一个字节的键值类型（高4位全为1，低4位值类型），一至五个字节的map元素的个数，List负载数据.<strong>适用于Set中元素个数大于14个的情况。</strong></p></blockquote><ul><li>消息（函数）类型：</li></ul><blockquote><p>一个字节的版本，一个字节的消息调用（请求：0x21，响应：0x41，异常：0x61，oneway：0x81），一至五个字节的消息名称长度，消息名称，消息参数负载数据，一个字节的结束标记。</p></blockquote><p>以上说明是基于相邻字段的编号小于等于15的情况。</p><p>如果字段相邻编号大于15，需要把类型和编号分开表示：用一个字节表示类型，一至五个字节表示编号偏移值。</p><h2><span id="读取方式">读取方式</span></h2><p>经过代码分析，我们了解了写入的过程，下面来了解读取过程。<br>我们还是来看 读取Field的例子，Field 会封装在TMessage 当中，所以，首先read会读取TMessage,读取TMessage的没有什么特殊的，就是将TMessage 按照writeMessage 的顺序读取出来，之前会有一个判断版本号的一个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line">    <span class="keyword">if</span> (type == TType.STOP) &#123;</span><br><span class="line">      <span class="keyword">return</span> TSTOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> fieldId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是计算field的id</span></span><br><span class="line">    <span class="comment">// 写入是以高4为未field id的偏移 所以需要将field 的偏移算出来</span></span><br><span class="line">    <span class="keyword">short</span> modifier = (<span class="keyword">short</span>)((type &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (modifier == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果否没有偏移 直接 读取16位的field id</span></span><br><span class="line">      fieldId = readI16();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则 偏移 + 组内编号得到 field整整的id</span></span><br><span class="line">      fieldId = (<span class="keyword">short</span>)(lastFieldId_ + modifier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为 type</span></span><br><span class="line">    TField field = <span class="keyword">new</span> TField(<span class="string">""</span>, getTType((<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>)), fieldId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this happens to be a boolean field, the value is encoded in the type</span></span><br><span class="line">    <span class="keyword">if</span> (isBoolType(type)) &#123;</span><br><span class="line">      <span class="comment">// save the boolean value in a special instance variable.</span></span><br><span class="line">      boolValue_ = (<span class="keyword">byte</span>)(type &amp; <span class="number">0x0f</span>) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录field</span></span><br><span class="line">    lastFieldId_ = field.id;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="read-方法举例">read 方法举例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">short</span>)zigzagToInt(readVarint32());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readVarint32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i32buf 是5个字节 也就是说 varint 最大字节为5 </span></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] buf = trans_.getBuffer();</span><br><span class="line">      <span class="keyword">int</span> pos = trans_.getBufferPosition();</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// varin32的读法，建议读一下上面的 varint32的写法 这里不再详解</span></span><br><span class="line">        <span class="keyword">byte</span> b = buf[pos+off];</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">        off++;</span><br><span class="line">      &#125;</span><br><span class="line">      trans_.consumeBuffer(off+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = readByte();</span><br><span class="line">        result |= (<span class="keyword">int</span>) (b &amp; <span class="number">0x7f</span>) &lt;&lt; shift;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>) <span class="keyword">break</span>;</span><br><span class="line">        shift += <span class="number">7</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2><span id="压缩测试">压缩测试</span></h2><p>本节我们来讨论压缩比，上面说了这么多，那么TCompactProtocol 的压缩比如何呢？<br>首先我们需要 <a href="https://github.com/zhang-xzhi/memoryutil" target="_blank" rel="noopener">MemeoryUtil</a> 这个工具</p><ul><li>1、 编写测试bean 并生成对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="number">1</span>: required string name,</span><br><span class="line">    <span class="number">2</span>: required i16 age = <span class="number">0</span>;</span><br><span class="line">    <span class="number">3</span>: required bool gender,</span><br><span class="line">    <span class="number">4</span>: required i32 No,</span><br><span class="line">    <span class="number">5</span>: required i64 createTime,</span><br><span class="line">    <span class="number">6</span>: required <span class="keyword">double</span> grade,</span><br><span class="line">    <span class="number">7</span>: required list&lt;Friends&gt; friends,</span><br><span class="line">    <span class="number">8</span>: optional map&lt;i32, Friends&gt; mapUser,</span><br><span class="line">    <span class="number">9</span>: optional set&lt;Friends&gt; setUser,</span><br><span class="line">    <span class="number">10</span>: required UserType userType = UserType.STUDENT,</span><br><span class="line">    <span class="number">11</span>: optional i32 number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、 编写测试方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">protected</span> TMemoryInputTransport memory ;</span><br><span class="line">    <span class="keyword">protected</span> TByteArrayOutputStream tByteArrayOutputStream ;</span><br><span class="line">    <span class="keyword">protected</span> TFramedTransport tFramedTransport;</span><br><span class="line">    <span class="keyword">protected</span> TCompactProtocol tcprotocol;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;? extends TFramedTransport&gt; aClass ;</span><br><span class="line">    Field writeBuffer_;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        memory = <span class="keyword">new</span> TMemoryInputTransport(buf);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          利用反射 将写如的对象转换成 TByteArrayOutputStream</span></span><br><span class="line"><span class="comment">          这样通过 TCompactProtocol 写入的就是   TByteArrayOutputStream 这个对象当中，方面我们统计</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        tByteArrayOutputStream = <span class="keyword">new</span> TByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        tFramedTransport = <span class="keyword">new</span> TFramedTransport(memory);</span><br><span class="line">        tcprotocol = <span class="keyword">new</span> TCompactProtocol(tFramedTransport);</span><br><span class="line">        aClass = tFramedTransport.getClass();</span><br><span class="line"></span><br><span class="line">        writeBuffer_ = aClass.getDeclaredField(<span class="string">"writeBuffer_"</span>);</span><br><span class="line">        writeBuffer_.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        writeBuffer_.set(tFramedTransport, tByteArrayOutputStream);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MemoryUtil 是classmexer 当中的方法</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTMessageCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] total = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                .mapToObj(CompressionTest::mockUser)</span><br><span class="line">                .forEach(user -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        user.write(tcprotocol);</span><br><span class="line">                        <span class="keyword">long</span> l = MemoryUtil.deepMemoryUsageOf(user, MemoryUtil.VisibilityFilter.ALL);</span><br><span class="line">                        total[<span class="number">0</span>] +=l;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = tByteArrayOutputStream.len();</span><br><span class="line">        <span class="comment">// 转换</span></span><br><span class="line">        <span class="keyword">double</span> userTotalDouble = (<span class="keyword">double</span>) total[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>) len / userTotalDouble;</span><br><span class="line">        String format = String.format(<span class="string">"%.4f"</span>, rate);</span><br><span class="line">        System.out.println(<span class="string">"total:"</span> + total[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"len:"</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"rate:"</span> + format);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inet 类型的测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntCompactTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            tcprotocol.writeI32(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = tByteArrayOutputStream.len();</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>) len / (<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"rate:"</span> + rate);</span><br><span class="line">        System.out.println(<span class="string">"len:"</span> + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成一个 测试对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">mockUser</span> <span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(Short.MAX_VALUE);</span><br><span class="line">        user.setCreateTime(System.currentTimeMillis());</span><br><span class="line">        user.setGender(<span class="keyword">true</span>);</span><br><span class="line">        user.setName(<span class="string">"name"</span> + no);</span><br><span class="line">        user.setNo(no);</span><br><span class="line">        Friends friends = <span class="keyword">new</span> Friends();</span><br><span class="line">        friends.setNo(Short.MAX_VALUE);</span><br><span class="line">        user.setFriends(Collections.singletonList(friends));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>3、 将  <a href="https://github.com/zhang-xzhi/memoryutil" target="_blank" rel="noopener">classmexer.jar</a>  添加到lib 当中去</li><li>4、 jvm 参数加上代理 参数： VM options:如下图所示</li></ul><p><img src="/article/java-thrift-4-2/java-thrift-4-2-184948.png" alt></p><p>最后得出结果<br>User 1000个的压缩结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total:<span class="number">815184</span></span><br><span class="line">len:<span class="number">42786</span></span><br><span class="line">rate:<span class="number">0.0525</span></span><br></pre></td></tr></table></figure><p>Int 类型压缩结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate:<span class="number">0.48425</span></span><br><span class="line">len:<span class="number">1937</span></span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://wikimore.github.io/2016/09/22/zig-zag-intro/" target="_blank" rel="noopener">varint和zigzag编码</a></li><li><a href="https://www.cnblogs.com/voipman/p/5163267.html" target="_blank" rel="noopener">Thrift的TCompactProtocol紧凑型二进制协议分析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（四）</title>
      <link href="/article/java-thrift-4/"/>
      <url>/article/java-thrift-4/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>本节来讨论thrift 的编解码器。</p><h2><span id="核心组件">核心组件</span></h2><h2><span id="整体架构">整体架构</span></h2><p><img src="/article/java-thrift-4/java-thrift-1-112101.png" alt></p><p><strong>Thrift的核心组件, 主要包含以下几个方面</strong></p><ul><li>IDL服务描述组件,负责完成跨平台和跨语言(针对不同语言完成了Server层和Client代码的生成)</li><li>TServer和Client，服务端和客户端组件的实现</li><li>TProtocal 协议和解编码组件</li><li>TTransport 传输组件</li><li>TProcessor 服务调用组件，完成对服务实现的调用</li></ul><p>协议和编解码是一个网络应用程序的核心问题之一，客户端和服务器通过约定的协议来传输消息(数据)，通过特定的格式来编解码字节流，并转化成业务消息，提供给上层框架调用。</p><p>本节主要主要针对<code>TProtocal</code> 协议组件来讨论。</p><h2><span id="编解码">编解码</span></h2><h2><span id="协议">协议</span></h2><p>thrift 做到很好的让用户在服务器端与客户端选择对应的传输协议，总体上一般为2种传输协议：<br><strong>二进制或者文本</strong>.</p><p>如果想要节省带宽可以采用二进制的协议，如果希望方便抓包、调试则可以选择文本协议，用户可用根据自己的项目需求选择对应的协议。</p><h3><span id="类图">类图</span></h3><p><img src="https://icefrozen.github.io/article/java-thrift-3/java-thrift-3-161213.png" alt></p><ul><li><strong>TCompactProtocol</strong> ： 紧凑的、高效的二进制传输协议；</li><li><strong>TBinaryProtocol</strong> ： 基于二进制传输的协议，使用方法与TCompactProtocol 相同</li><li><strong>TJSONProtocol</strong> ： 使用json格式编码传输协议</li><li>TSimpleJSONProtocol 使用简单json格式编码传输协议</li></ul><p>我们可以看到所有的</p><h3><span id="tprotocol-方法">TProtocol 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">protected</span> TTransport trans_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 写方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer buf)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="comment">// 读取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里面定义了一些抽象方法，用于<code>Thrift</code> 中各个消息的系列化入口，子类根基自身的提醒来实现这些方法，用于达到不同的类型，用不同的序列化协议。</p><p>我们以最基本的二级制协议格式来具体看一下，那么是究竟如何序列化的。</p><h3><span id="tbinaryprotocol-二进制">TBinaryProtocol （二进制）</span></h3><p>二级制序列化是每个序列化框架都应该具备基本序列化方法，虽然在网络上最终是以二进制的方法，但是这种而序列化方法能让我们决定具体的二级序列，避免了浪费带宽。<br>先看源码</p><h3><span id="源码">源码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TBinaryProtocol</span> <span class="keyword">extends</span> <span class="title">TProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TStruct ANONYMOUS_STRUCT = <span class="keyword">new</span> TStruct();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_MASK = <span class="number">0xffff0000</span>;     <span class="comment">// -65536</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_1 = <span class="number">0x80010000</span>;       <span class="comment">//2147418112</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> strictRead_ = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> strictWrite_ = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> readLength_;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> checkReadLength_ = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 协议工厂</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">TProtocolFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> strictRead_ = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> strictWrite_ = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> readLength_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(strictRead, strictWrite, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite, <span class="keyword">int</span> readLength)</span> </span>&#123;</span><br><span class="line">      strictRead_ = strictRead;</span><br><span class="line">      strictWrite_ = strictWrite;</span><br><span class="line">      readLength_ = readLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TProtocol <span class="title">getProtocol</span><span class="params">(TTransport trans)</span> </span>&#123;</span><br><span class="line">      TBinaryProtocol proto = <span class="keyword">new</span> TBinaryProtocol(trans, strictRead_, strictWrite_);</span><br><span class="line">      <span class="keyword">if</span> (readLength_ != <span class="number">0</span>) &#123;</span><br><span class="line">        proto.setReadLength(readLength_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> proto;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// factory  ... ... ... ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TBinaryProtocol</span><span class="params">(TTransport trans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(trans, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TBinaryProtocol</span><span class="params">(TTransport trans, <span class="keyword">boolean</span> strictRead, <span class="keyword">boolean</span> strictWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(trans);</span><br><span class="line">    strictRead_ = strictRead;</span><br><span class="line">    strictWrite_ = strictWrite;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入 message 相关信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageBegin</span><span class="params">(TMessage message)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strictWrite_) &#123;</span><br><span class="line">      <span class="keyword">int</span> version = VERSION_1 | message.type;</span><br><span class="line">      writeI32(version);</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeString(message.name);</span><br><span class="line">      writeByte(message.type);</span><br><span class="line">      writeI32(message.seqid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMessageEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructBegin</span><span class="params">(TStruct struct)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 写入 field </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldBegin</span><span class="params">(TField field)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(field.type);</span><br><span class="line">    writeI16(field.id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// field stop 表示</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldStop</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(TType.STOP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Map 写入开始</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapBegin</span><span class="params">(TMap map)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(map.keyType);</span><br><span class="line">    writeByte(map.valueType);</span><br><span class="line">    writeI32(map.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMapEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListBegin</span><span class="params">(TList list)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(list.elemType);</span><br><span class="line">    writeI32(list.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeListEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetBegin</span><span class="params">(TSet set)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(set.elemType);</span><br><span class="line">    writeI32(set.size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSetEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeByte(b ? (<span class="keyword">byte</span>)<span class="number">1</span> : (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span> [] bout = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 写入一个 byte 数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    bout[<span class="number">0</span>] = b;</span><br><span class="line">    trans_.write(bout, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i16out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI16</span><span class="params">(<span class="keyword">short</span> i16)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i16out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i16out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i16));</span><br><span class="line">    trans_.write(i16out, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i32out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI32</span><span class="params">(<span class="keyword">int</span> i32)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i32out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    i32out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    i32out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i32out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i32));</span><br><span class="line">    trans_.write(i32out, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    i64out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">    i64out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">    i64out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">    i64out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    i64out[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">    i64out[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    i64out[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    i64out[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">    trans_.write(i64out, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> dub)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    writeI64(Double.doubleToLongBits(dub));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">      writeI32(dat.length);</span><br><span class="line">      trans_.write(dat, <span class="number">0</span>, dat.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBinary</span><span class="params">(ByteBuffer bin)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = bin.limit() - bin.position();</span><br><span class="line">    writeI32(length);</span><br><span class="line">    trans_.write(bin.array(), bin.position() + bin.arrayOffset(), length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reading methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMessage <span class="title">readMessageBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> version = size &amp; VERSION_MASK;</span><br><span class="line">      <span class="keyword">if</span> (version != VERSION_1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class="string">"Bad version in readMessageBegin"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TMessage(readString(), (<span class="keyword">byte</span>)(size &amp; <span class="number">0x000000ff</span>), readI32());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (strictRead_) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TProtocolException(TProtocolException.BAD_VERSION, <span class="string">"Missing version in readMessageBegin, old client?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TMessage(readStringBody(size), readByte(), readI32());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMessageEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TStruct <span class="title">readStructBegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ANONYMOUS_STRUCT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStructEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TField <span class="title">readFieldBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> type = readByte();</span><br><span class="line">    <span class="keyword">short</span> id = type == TType.STOP ? <span class="number">0</span> : readI16();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TField(<span class="string">""</span>, type, id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TMap <span class="title">readMapBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TMap(readByte(), readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMapEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TList <span class="title">readListBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TList(readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readListEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TSet <span class="title">readSetBegin</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TSet(readByte(), readI32());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readSetEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (readByte() == <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] bin = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">byte</span> b = trans_.getBuffer()[trans_.getBufferPosition()];</span><br><span class="line">      trans_.consumeBuffer(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    readAll(bin, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bin[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i16rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readI16</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i16rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i16rd, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      (<span class="keyword">short</span>)</span><br><span class="line">      (((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">       ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i32rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readI32</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i32rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i32rd, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((buf[off] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] i64rd = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readI64</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = i64rd;</span><br><span class="line">    <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">      buf = trans_.getBuffer();</span><br><span class="line">      off = trans_.getBufferPosition();</span><br><span class="line">      trans_.consumeBuffer(<span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readAll(i64rd, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off]   &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>) |</span><br><span class="line">      ((<span class="keyword">long</span>)(buf[off+<span class="number">7</span>] &amp; <span class="number">0xff</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.longBitsToDouble(readI64());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(trans_.getBuffer(), trans_.getBufferPosition(), size, <span class="string">"UTF-8"</span>);</span><br><span class="line">        trans_.consumeBuffer(size);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readStringBody(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">readStringBody</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      checkReadLength(size);</span><br><span class="line">      <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">      trans_.readAll(buf, <span class="number">0</span>, size);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException uex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">readBinary</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = readI32();</span><br><span class="line">    checkReadLength(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trans_.getBytesRemainingInBuffer() &gt;= size) &#123;</span><br><span class="line">      ByteBuffer bb = ByteBuffer.wrap(trans_.getBuffer(), trans_.getBufferPosition(), size);</span><br><span class="line">      trans_.consumeBuffer(size);</span><br><span class="line">      <span class="keyword">return</span> bb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    trans_.readAll(buf, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.wrap(buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readAll</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    checkReadLength(len);</span><br><span class="line">    <span class="keyword">return</span> trans_.readAll(buf, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadLength</span><span class="params">(<span class="keyword">int</span> readLength)</span> </span>&#123;</span><br><span class="line">    readLength_ = readLength;</span><br><span class="line">    checkReadLength_ = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkReadLength</span><span class="params">(<span class="keyword">int</span> length)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"Negative length: "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkReadLength_) &#123;</span><br><span class="line">      readLength_ -= length;</span><br><span class="line">      <span class="keyword">if</span> (readLength_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"Message length exceeded: "</span> + length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="write数据">write数据</span></h3><p>二级制协议主要的核心代码 主要集中在序列化上， Thrift 对 封装好的</p><ul><li>TStruct</li><li>TMessage类型</li><li>TField 类型</li><li>TCollection 方法 TMap, TStruct, TSet</li><li>基础类型 i16， i32, i64 … binary, string 等</li></ul><p>类型都有特定的 写入begin和写入end 两种方法。Begin 都会将自己的id 和 type 写入到 byte 当中。所有的byte写入会调用，下面几种基础写入方法</p><ul><li>writeBool</li><li>writeByte</li><li>writeI16</li><li>writeI32</li><li>writeI64</li><li>writeDouble</li><li>writeString</li></ul><p>我们先来看一个方法 核心的序列化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 64位 需要8个字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] i64out = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeI64</span><span class="params">(<span class="keyword">long</span> i64)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">   i64out[<span class="number">0</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">56</span>));</span><br><span class="line">   i64out[<span class="number">1</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">48</span>));</span><br><span class="line">   i64out[<span class="number">2</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">40</span>));</span><br><span class="line">   i64out[<span class="number">3</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">32</span>));</span><br><span class="line">   i64out[<span class="number">4</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">24</span>));</span><br><span class="line">   i64out[<span class="number">5</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">16</span>));</span><br><span class="line">   i64out[<span class="number">6</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64 &gt;&gt; <span class="number">8</span>));</span><br><span class="line">   i64out[<span class="number">7</span>] = (<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (i64));</span><br><span class="line">   trans_.write(i64out, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>0xff 值为：<br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code></li><li>i64 是我们要序列化的数字 每个8bit是一个属于<br><code>10000000 01000000 00100000 00010000 00001000 00000100 00000010 00000001</code></li><li>“&gt;&gt;56” 相当于我们 让上面的数字想右边移动 56 位 ，取到 10000000</li></ul><p>然后和 0xff &amp; 一下 得到<br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 11111111</code><br><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 10000000</code><br>&amp;的计算方法 不在赘述最后得到了  10000000 这段 byte 数据。</p><p>其实以上的意思是 将 i64 最高的 一个byte 取出来 放到  i64out 的第一位<br>最后将 i64 的数字 变成<br><code>10000000 01000000 00100000 00010000 00001000 00000100 00000010 00000001</code><br>即：</p><ul><li><code>i64out[0] = 10000000</code></li><li><code>i64out[1] = 01000000</code></li><li><code>i64out[2] = 00100000</code></li><li><code>i64out[3] = 00010000</code></li><li><code>i64out[4] = 00001000</code></li><li><code>i64out[5] = 00000100</code></li><li><code>i64out[6] = 00000010</code></li><li><code>i64out[7] = 00000001</code></li></ul><h3><span id="read-数据">read 数据</span></h3><p>读数据其实本质上是要按照写的方法去读取数据，也就是说是写数据反向操作。 具体的方法可以参考以上源码，这里不再过多赘述。<br>这里要介绍一个概念。Transport<br>RPC作为一种特殊的网络编程，会封装一层传输层来支持底层的网络通信。Thrift使用了Transport来封装传输层，但Transport不仅仅是底层网络传输，它还是上层流的封装。<br>我们看到，无论TProtocal 如何处理数据，最终都会交给  Transport 去传输<br>Transport 如何传输，本章节不在讨论。请看下一个章节。</p><h3><span id="factory">Factory</span></h3><p>这是一个协议封装好的工厂，这个工厂是要向外提供出去，供Server 和 Client 使用的，所以这里没有引用。<br>具体看一下<a href="https://icefrozen.github.io/article/java-thrift-1/#-9" target="_blank" rel="noopener">Thrift框架详解（一)</a></p><h2><span id="参考">参考</span></h2><ul><li><a href="http://www.cpper.cn/2016/03/17/develop/Thrift-Reserch/" target="_blank" rel="noopener">Thrift框架调研</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构（一）</title>
      <link href="/article/architecture/"/>
      <url>/article/architecture/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>阿姆达尔定律</p><h2><span id="什么是阿姆达尔定律">什么是阿姆达尔定律</span></h2><p>阿姆达尔定律（英语：Amdahl’s law，Amdahl’s argument），一个计算机科学界的经验法则，因吉恩·阿姆达尔(Gene Amdahl)而得名。它代表了处理器平行运算之后效率提升的能力。<br>1967年计算机体系结构专家吉恩.阿姆达尔提出过一个定律阿姆达尔定律，说：<strong>在并行计算中用多处理器的应用加速受限于程序所需的串行时间百分比</strong>。<br>举两个例子说明这个问题：</p><ol><li><p><strong>譬如说，你的程序50%是串行的，其他一半可以并行，那么，最大的加速比就是2。不管你用多少处理器并行，这个加速比不可能提高。在这种情况下，改进串行算法可能比多核处理器并行更有效。</strong></p></li><li><p><strong>假设某一功能的处理时间为整体系统运行时间的60%，若使该功能的处理速度提高至原来的5倍，则根据阿姆达尔定律，整个系统的处理速度可提高至原来的多少倍</strong>？</p></li></ol><h2><span id="阿姆达尔定律规则">阿姆达尔定律规则</span></h2><h3><span id="加速比">加速比</span></h3><p>优化前系统总耗时To(old)，优化后系统总耗时Tn(new)，为加速比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S =To/Tn</span><br></pre></td></tr></table></figure><h3><span id="原系统中能够改进的部分占总部分的比例c">原系统中能够改进的部分占总部分的比例:C</span></h3><p>原系统中能够改进的部分占总部分的比例，也可以说能够改进部分运行时间占总系统运行时间的比例，比如上文所说的，加入的你程序100%是并行的，如果将50% 改成并行（或者其他能提高速度的方式），那么 <code>C = 50%</code></p><h3><span id="系统的提升比例st">系统的提升比例St</span></h3><p>比如 系统比原系统提升了5倍 这是个比例(St=5)</p><h3><span id="公式如下">公式如下</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = To/Tn = <span class="number">1</span> / ((<span class="number">1</span>-C) + C/St)</span><br></pre></td></tr></table></figure><h3><span id="计算">计算</span></h3><p>那么我们来回答第一个问题</p><blockquote><p>你的程序50%是串行的，其他一半可以并行，那么，最大的加速比就是2。不管你用多少处理器并行，这个加速比不可能提高。<br>根据公式得到</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当St 变的很大的时候 0.5/St 将会趋于 0，得到 </span><br><span class="line"></span><br><span class="line">```S = 1/(1 - 0.5 + 0) = 1 / 0.5 = 2</span><br></pre></td></tr></table></figure><p>也就是说你把另一半程序优化的比原来提升多少倍,那么加速比，也就是说 你能提升的性能最大可能是原来的 2倍。</p><blockquote><p><strong>假设某一功能的处理时间为整体系统运行时间的60%，若使该功能的处理速度提高至原来的5倍，则根据阿姆达尔定律，整个系统的处理速度可提高至原来的多少倍</strong>？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S   = <span class="number">1</span>/((<span class="number">1</span> - <span class="number">0.6</span> ）+ <span class="number">0.6</span> / <span class="number">5</span>) </span><br><span class="line">    = <span class="number">1</span> / (<span class="number">0.4</span> + <span class="number">0.12</span>)</span><br><span class="line">    = <span class="number">1</span> / <span class="number">0.52</span></span><br><span class="line">    ≈ <span class="number">1.923</span></span><br></pre></td></tr></table></figure><h2><span id="阿姆达尔定律原理">阿姆达尔定律原理</span></h2><p>为了更好地理解阿姆达尔定律，我会尝试演示这个定定律是如何诞生的。</p><p><strong>首先，一个程序可以被分割为两部分，一部分为不可并行部分B，一部分为可并行部分1 – B。如下图：</strong></p><p><img src="/article/architecture/architecture-110031.png" alt></p><p><strong>在顶部被带有分割线的那条直线代表总时间 T(1)。</strong></p><p><strong>下面你可以看到在并行因子为2的情况下的执行时间：</strong></p><p><img src="/article/architecture/architecture-110049.png" alt></p><p><strong>并行因子为3的情况：</strong></p><p><img src="/article/architecture/architecture-110106.png" alt></p><p>我们假设不考虑其他因素，并行因子越大， 那么1 - B 所占用的时间越短，也就是图中略色的部分也就越短。<br>当我们 并行因子（也就是我们 将 1 - B 运行的速度提升 n 倍 n → ∞）提升无穷大。那么绿色的面积会越来越小，最后约等于0<br>那么我们程序的总时间将约等于 B 的时间。<br>因此我们得出结论：<strong>在并行计算中用多处理器的应用加速受限于程序所需的串行时间百分比</strong>。</p><h2><span id="总结">总结</span></h2><p>虽然阿姆达尔定律允许你并行化一个算法的理论加速比，但是不要过度依赖这样的计算。在实际场景中，当你优化或并行化一个算法时，可以有很多的因子可以被考虑进来。</p><p>内存的速度，CPU缓存，磁盘，网卡等可能都是一个限制因子。如果一个算法的最新版本是并行化的，但是导致了大量的CPU缓存浪费，你可能不会再使用x N个CPU来获得x N的期望加速。如果你的内存总线（memory bus），磁盘，网卡或者网络连接都处于高负载状态，也是一样的情况。</p><p>我们的建议是，使用阿姆达尔定律定律来指导我们优化程序，而不是用来测量优化带来的实际加速比。记住，有时候一个高度串行化的算法胜过一个并行化的算法，因为串行化版本不需要进行协调管理（上下文切换），而且一个单个的CPU在底层硬件工作（CPU管道、CPU缓存等）上的一致性可能更好。</p><h2><span id="参考">参考</span></h2><ul><li><a href="http://ifeve.com/amdahls-law/" target="_blank" rel="noopener">阿姆达尔定律</a></li><li><a href="https://www.geek-share.com/detail/2783250020.html" target="_blank" rel="noopener">阿姆达尔Law对系统性能提升的定义</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（三）</title>
      <link href="/article/java-thrift-3/"/>
      <url>/article/java-thrift-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一节，我们已经详解了IDL详细的语法，Thrift 就是根据这个语法，替我们生成目标代码的。下面我们来具体分析一下，生成的代码究竟是什么作用。</p><h2><span id="准备">准备</span></h2><h2><span id="目录结构">目录结构</span></h2><p>我们来看一下代码结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── java</span><br><span class="line">│   └── learn</span><br><span class="line">│       └── thrift</span><br><span class="line">│           ├── bean</span><br><span class="line">│           ├── client</span><br><span class="line">│           │   └── Client.java</span><br><span class="line">│           ├── constant</span><br><span class="line">│           │   └── ServerConfig.java</span><br><span class="line">│           ├── gen_code.sh</span><br><span class="line">│           ├── idl</span><br><span class="line">│           │   ├── bean.thrift</span><br><span class="line">│           │   └── hello.thrift</span><br><span class="line">│           ├── idlcode</span><br><span class="line">│           │   ├── HelloWorldService.java</span><br><span class="line">│           │   └── UserService.java</span><br><span class="line">│           └── server</span><br><span class="line">│               ├── Server.java</span><br><span class="line">│               └── handler</span><br><span class="line">│                   ├── HelloWorldServiceImpl.java</span><br><span class="line">│                   └── UserServiceImpl.java</span><br></pre></td></tr></table></figure><h2><span id="代码生成">代码生成</span></h2><p>我们来看一下 gen_code.sh 的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">thrift_name=hello.thrift</span><br><span class="line">thrift_bean=bean.thrift</span><br><span class="line">pathroot=../..</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"gen code "</span></span><br><span class="line">thrift --gen java -out <span class="variable">$pathroot</span> ./idl/<span class="variable">$thrift_name</span></span><br><span class="line">thrift --gen java -out <span class="variable">$pathroot</span> ./idl/<span class="variable">$thrift_bean</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finsh"</span></span><br></pre></td></tr></table></figure><p>当我们执行这个脚本的时候 会将 idl 的两个文件生成对应的代码。<br>来看一下  bean.thrift 文件，这里主要是定义的 thrift struct 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namesapce 的用法   java 标识生成java 代码。 后边的标识报名，代码将会生成到那个包下。</span></span><br><span class="line"><span class="comment">// 就是上文提到的 bean 目录下。</span></span><br><span class="line">namespace java learn.thrift.bean</span><br><span class="line"></span><br><span class="line">struct Friends &#123;</span><br><span class="line">    <span class="number">1</span>: required i16 No</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行后发现在bean 下多了一个文件叫<code>Friends</code> 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── java</span><br><span class="line">│   └── learn</span><br><span class="line">│       └── thrift</span><br><span class="line">│           ├── bean</span><br><span class="line">                |-- Friends.java</span><br></pre></td></tr></table></figure><h2><span id="生成代码样例">生成代码样例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.thrift.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friends</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">Friends</span>, <span class="title">Friends</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TStruct STRUCT_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TStruct(<span class="string">"Friends"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TField NO_FIELD_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TField(<span class="string">"No"</span>, org.apache.thrift.protocol.TType.I16, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    schemes.put(StandardScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsStandardSchemeFactory</span>())</span>;</span><br><span class="line">    schemes.put(TupleScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsTupleSchemeFactory</span>())</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">short</span> No; <span class="comment">// required</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> _Fields implements org.apache.thrift.TFieldIdEnum &#123;</span><br><span class="line">    NO((<span class="keyword">short</span>)<span class="number">1</span>, <span class="string">"No"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, _Fields&gt; byName = <span class="keyword">new</span> HashMap&lt;String, _Fields&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (_Fields field : EnumSet.allOf(_Fields<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        byName.put(field.getFieldName(), field);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches fieldId, or null if its not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByThriftId</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span>(fieldId) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">          <span class="keyword">return</span> NO;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches fieldId, throwing an exception</span></span><br><span class="line"><span class="comment">     * if it is not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByThriftIdOrThrow</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">      _Fields fields = findByThriftId(fieldId);</span><br><span class="line">      <span class="keyword">if</span> (fields == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Field "</span> + fieldId + <span class="string">" doesn't exist!"</span>);</span><br><span class="line">      <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find the _Fields constant that matches name, or null if its not found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> _Fields <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> byName.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> _thriftId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String _fieldName;</span><br><span class="line"></span><br><span class="line">    _Fields(<span class="keyword">short</span> thriftId, String fieldName) &#123;</span><br><span class="line">      _thriftId = thriftId;</span><br><span class="line">      _fieldName = fieldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getThriftFieldId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _thriftId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFieldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _fieldName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isset id assignments</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> __NO_ISSET_ID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> BitSet __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; metaDataMap;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; tmpMap = <span class="keyword">new</span> EnumMap&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt;(_Fields<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    tmpMap.put(_Fields.NO, <span class="keyword">new</span> org.apache.thrift.meta_data.FieldMetaData(<span class="string">"No"</span>, org.apache.thrift.TFieldRequirementType.REQUIRED, </span><br><span class="line">        <span class="keyword">new</span> org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I16)));</span><br><span class="line">    metaDataMap = Collections.unmodifiableMap(tmpMap);</span><br><span class="line">    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Friends<span class="class">.<span class="keyword">class</span>, <span class="title">metaDataMap</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">short</span> No)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="keyword">this</span>.No = No;</span><br><span class="line">    setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Performs a deep copy on &lt;i&gt;other&lt;/i&gt;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(Friends other)</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.clear();</span><br><span class="line">    __isset_bit_vector.or(other.__isset_bit_vector);</span><br><span class="line">    <span class="keyword">this</span>.No = other.No;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Friends <span class="title">deepCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Friends(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setNoIsSet(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.No = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.No;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Friends <span class="title">setNo</span><span class="params">(<span class="keyword">short</span> No)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.No = No;</span><br><span class="line">    setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.clear(__NO_ISSET_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if field No is set (has been assigned a value) and false otherwise */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __isset_bit_vector.get(__NO_ISSET_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoIsSet</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    __isset_bit_vector.set(__NO_ISSET_ID, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(_Fields field, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unsetNo();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setNo((Short)value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getFieldValue</span><span class="params">(_Fields field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">return</span> Short.valueOf(getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(_Fields field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (field) &#123;</span><br><span class="line">    <span class="keyword">case</span> NO:</span><br><span class="line">      <span class="keyword">return</span> isSetNo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (that <span class="keyword">instanceof</span> Friends)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.equals((Friends)that);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Friends that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> this_present_No = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> that_present_No = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (this_present_No || that_present_No) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(this_present_No &amp;&amp; that_present_No))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.No != that.No)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Friends other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getClass().equals(other.getClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> getClass().getName().compareTo(other.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lastComparison = <span class="number">0</span>;</span><br><span class="line">    Friends typedOther = (Friends)other;</span><br><span class="line"></span><br><span class="line">    lastComparison = Boolean.valueOf(isSetNo()).compareTo(typedOther.isSetNo());</span><br><span class="line">    <span class="keyword">if</span> (lastComparison != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lastComparison;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSetNo()) &#123;</span><br><span class="line">      lastComparison = org.apache.thrift.TBaseHelper.compareTo(<span class="keyword">this</span>.No, typedOther.No);</span><br><span class="line">      <span class="keyword">if</span> (lastComparison != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lastComparison;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> _Fields <span class="title">fieldForId</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Fields.findByThriftId(fieldId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(iprot.getScheme()).getScheme().read(iprot, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(oprot.getScheme()).getScheme().write(oprot, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Friends("</span>);</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">"No:"</span>);</span><br><span class="line">    sb.append(<span class="keyword">this</span>.No);</span><br><span class="line">    first = <span class="keyword">false</span>;</span><br><span class="line">    sb.append(<span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    <span class="comment">// check for required fields</span></span><br><span class="line">    <span class="comment">// alas, we cannot check 'No' because it's a primitive and you chose the non-beans generator.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      write(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(out)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.</span></span><br><span class="line">      __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line">      read(<span class="keyword">new</span> org.apache.thrift.protocol.TCompactProtocol(<span class="keyword">new</span> org.apache.thrift.transport.TIOStreamTransport(in)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (org.apache.thrift.TException te) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> java.io.IOException(te);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsStandardScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsStandardScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">      iprot.readStructBegin();</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        schemeField = iprot.readFieldBegin();</span><br><span class="line">        <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">            <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.I16) &#123;</span><br><span class="line">              struct.No = iprot.readI16();</span><br><span class="line">              struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">        &#125;</span><br><span class="line">        iprot.readFieldEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">      <span class="keyword">if</span> (!struct.isSetNo()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'No' was not found in serialized data! Struct: "</span> + toString());</span><br><span class="line">      &#125;</span><br><span class="line">      struct.validate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      struct.validate();</span><br><span class="line"></span><br><span class="line">      oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">      oprot.writeFieldBegin(NO_FIELD_DESC);</span><br><span class="line">      oprot.writeI16(struct.No);</span><br><span class="line">      oprot.writeFieldEnd();</span><br><span class="line">      oprot.writeFieldStop();</span><br><span class="line">      oprot.writeStructEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsTupleScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsTupleScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleScheme</span> <span class="keyword">extends</span> <span class="title">TupleScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      TTupleProtocol oprot = (TTupleProtocol) prot;</span><br><span class="line">      oprot.writeI16(struct.No);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">      TTupleProtocol iprot = (TTupleProtocol) prot;</span><br><span class="line">      struct.No = iprot.readI16();</span><br><span class="line">      struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="代码详解">代码详解</span></h2><h2><span id="类图">类图</span></h2><p>下面我们会对上文的代码做详细分析。首先我们来看一下类图。<br><img src="/article/java-thrift-3/java-thrift-3-155727.png" alt></p><p>我们可以看到 <code>Friends</code> 是继承 <code>TBase</code> , <code>TBase</code> 又实现 <code>TFieldIdEnum</code>。<br>我们来看TBase 代码</p><h1><span id="基础数据结构">基础数据结构</span></h1><h2><span id="tbase">TBase</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TBase</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">TBase</span>&lt;?, ?&gt;, <span class="title">F</span> <span class="keyword">extends</span> <span class="title">TFieldIdEnum</span>&gt; <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">F <span class="title">fieldForId</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(F var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getFieldValue</span><span class="params">(F var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(F var1, Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TBase&lt;T, F&gt; <span class="title">deepCopy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  TFieldIdEnum</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFieldIdEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">getThriftFieldId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFieldName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TBase</code> 是 <code>Thrift</code> 的所有Type 类型的基类接口，其中定了几个比较重要的方法，比如说读写，克隆和清空。 而<code>TFieldIdEnum</code> 只是一个id 和名字的枚举。 从这里可以看到，实现 <code>TBase</code>的类具有可序列化的功能。</p><h2><span id="tstruct">TStruct</span></h2><p>接下来是 本 <code>Struct</code> 的一个描述， <code>TStruct</code> 只是对 <code>struct</code> 名字的一个描述的封装类，并没有什么特别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.thrift.protocol.TStruct STRUCT_DESC = <span class="keyword">new</span> org.apache.thrift.protocol.TStruct(<span class="string">"Friends"</span>);</span><br><span class="line"><span class="comment">// TStruct.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TStruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TStruct</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TStruct 类似的文件是 Thrift 协议层的一个定义，另外协议层还有一下方法<br><img src="/article/java-thrift-3/java-thrift-3-161213.png" alt></p><h2><span id="协议层">协议层</span></h2><p>这一层主要是用来定义如何序列化数据，属于协议层的一部分，将会在其他章节详细讨论，本节不在详细讲述。</p><ul><li><strong>TProtocol</strong></li><li><strong>TBinaryProtocol</strong></li><li><strong>TCompactProtocol</strong></li><li><strong>TJSONProtocol</strong></li><li><strong>TProtocolFactory</strong></li><li><strong>TProtocolUtil</strong></li><li><strong>TSimpleJSONProtocol</strong></li><li><strong>TTupleProtocol</strong></li><li><strong>TProtocolException</strong></li></ul><h2><span id="元数据">元数据</span></h2><p>这里定义的各种其他元数据的类声明</p><ul><li><strong>TBase64Utils</strong> :  Base64 数据的编解码工具</li><li><strong>TField</strong>: Field 字段的声明</li><li><strong>TList</strong>  : List 结构的声明</li><li><strong>TMap</strong>    : Map 结构的声明</li><li><strong>TMessage</strong> : Message 结构的声明</li><li><strong>TMessageType</strong>:  Message类型</li><li><strong>TSet</strong>    :  set类型的声明</li><li><strong>TStruct</strong>:   struct 类型的声明</li><li><strong>TType</strong> :   thrift 所有支持类型的枚举</li></ul><h2><span id="ttype">TType</span></h2><p>Thrift 所有支持的类型 都在 <code>TType</code> 里定义的，我们看一下TType的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STOP   = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> VOID   = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BOOL   = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE   = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DOUBLE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I16    = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I32    = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> I64    = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRING = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> STRUCT = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> MAP    = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SET    = <span class="number">14</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LIST   = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ENUM   = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tmessage">TMessage</span></h2><p>这个是 封装结构元数据的上层类, 当我们调用RPC 的时候， Thrift 会将我们要求我们按照他的格式封装元数据，然后在通过TMessage 封装元数据，然后通过网络发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMessageType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CALL  = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> REPLY = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> EXCEPTION = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ONEWAY = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TMessage 结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> seqid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">""</span>, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMessage</span><span class="params">(String n, <span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.type = t;</span><br><span class="line">        <span class="keyword">this</span>.seqid = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;TMessage name:'"</span> + <span class="keyword">this</span>.name + <span class="string">"' type: "</span> + <span class="keyword">this</span>.type + <span class="string">" seqid:"</span> + <span class="keyword">this</span>.seqid + <span class="string">"&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TMessage ? <span class="keyword">this</span>.equals((TMessage)other) : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TMessage other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(other.name) &amp;&amp; <span class="keyword">this</span>.type == other.type &amp;&amp; <span class="keyword">this</span>.seqid == other.seqid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tmap-结构">TMap 结构</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> keyType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> valueType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">byte</span>)<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TMap</span><span class="params">(<span class="keyword">byte</span> k, <span class="keyword">byte</span> v, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyType = k;</span><br><span class="line">        <span class="keyword">this</span>.valueType = v;</span><br><span class="line">        <span class="keyword">this</span>.size = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tset">TSet</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> elemType;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">byte</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">(<span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elemType = t;</span><br><span class="line">        <span class="keyword">this</span>.size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TSet</span><span class="params">(TList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(list.elemType, list.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tlist">TList</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(TType.STOP, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TList</span><span class="params">(<span class="keyword">byte</span> t, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    elemType = t;</span><br><span class="line">    size = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> elemType;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>  size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="tfield">TField</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TField</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>   type;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>  id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">""</span>, TType.STOP, (<span class="keyword">short</span>)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TField</span><span class="params">(String n, <span class="keyword">byte</span> t, <span class="keyword">short</span> i)</span> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    type = t;</span><br><span class="line">    id = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;TField name:'"</span> + name + <span class="string">"' type:"</span> + type + <span class="string">" field-id:"</span> + id + <span class="string">"&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TField otherField)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type == otherField.type &amp;&amp; id == otherField.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Friends</code> 中每个变量都会用 TField 来封装，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TField NO_FIELD_DESC = </span><br><span class="line"><span class="keyword">new</span> TField(<span class="string">"No"</span>, TType.I16, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>里面记录了 Field 的名字，类型，和FieldId , thrift 会给每一个Struct的成员变量增加一个Field封装类。</p><h1><span id="ischeme">IScheme</span></h1><h2><span id="ischeme-的作用">IScheme 的作用</span></h2><p>除了变量的定义之外 Friends 类当中还有一个概念 叫 Scheme</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt; schemes = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends IScheme&gt;, SchemeFactory&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    schemes.put(StandardScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsStandardSchemeFactory</span>())</span>;</span><br><span class="line">    schemes.put(TupleScheme<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">FriendsTupleSchemeFactory</span>())</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看一下继承关系</p><p><img src="/article/java-thrift-3/java-thrift-3-203051.png" alt></p><p><code>FriendsStandardSchemeFactory</code> 就是 <code>Scheme</code> 的工厂，意思就是新建一个 <code>FriendsStandardScheme</code>。  而 <code>FriendsStandardScheme</code> 又去实现了 <code>IScheme</code> 这个接口。 从而实现了 <code>read</code> 和 <code>write</code> 方法。</p><p>这个 <code>Scheme</code> 是干什么呢, 和 <code>FriendsStandardScheme</code>,  <code>Friends</code> 又是什么关系呢？</p><p><code>我们知道，Friends</code> 是继承 <code>TBase</code> 的 <code>TBase</code> 中有两个重要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(TProtocol var1)</span> <span class="keyword">throws</span> TException</span>;</span><br></pre></td></tr></table></figure><p>而 <code>Friends</code> 就是要实现这两个方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(iprot.getScheme()).getScheme().read(iprot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    schemes.get(oprot.getScheme()).getScheme().write(oprot, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Scheme</code> 其实就是一种序列化方式，标识该类的具体读写策略、</p></li><li><p><code>Friends</code> 序列化的时候，需要传递协议，也就是 <code>TProtocol</code> 的实现类，<code>TProtocol</code> 会根据自身支持的 序列化方式选择来选择 <code>Friends</code>  所支持的序列化方式，也就是的对应的具体 <code>Scheme</code>工厂。从而创建出具体的 <code>Scheme</code> 实现类。</p></li><li><p>上述代码中 <code>schemes.get(oprot.getScheme()).getScheme()</code>，第一个<code>oprot.getScheme()</code> 是选择对应的<code>Scheme</code> 方式，也就是 <code>StandardScheme</code> 还是 <code>TupleScheme</code>。 从 <code>Friends</code> 静态对象 schemes 中找到<code>Scheme</code> 工厂然后实例化具体的 <code>Scheme</code> 的实现类。</p></li></ul><p>本例中，<code>Friends</code> 一共实现类两种实现类 一种是 <code>FriendsStandardScheme</code>, 一种是·<code>FriendsTupleScheme</code></p><p>来看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsTupleScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsTupleScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardSchemeFactory</span> <span class="keyword">implements</span> <span class="title">SchemeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FriendsStandardScheme <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FriendsStandardScheme();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2><span id="ischeme-具体实现方式">IScheme 具体实现方式。</span></h2><p>下面我们具体来分析一下 <code>FriendsStandardScheme</code> 和  <code>FriendsTupleSchemeFactory</code> 具体的读写策略。</p><h3><span id="friendsstandardscheme">FriendsStandardScheme</span></h3><p>我们来具体分析一下 <code>FriendsStandardScheme</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsStandardScheme</span> <span class="keyword">extends</span> <span class="title">StandardScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol iprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     org.apache.thrift.protocol.TField schemeField;</span><br><span class="line">     iprot.readStructBegin();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       schemeField = iprot.readFieldBegin();</span><br><span class="line">       <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.STOP) &#123; </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">switch</span> (schemeField.id) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// NO</span></span><br><span class="line">           <span class="keyword">if</span> (schemeField.type == org.apache.thrift.protocol.TType.I16) &#123;</span><br><span class="line">             struct.No = iprot.readI16();</span><br><span class="line">             struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);</span><br><span class="line">       &#125;</span><br><span class="line">       iprot.readFieldEnd();</span><br><span class="line">     &#125;</span><br><span class="line">     iprot.readStructEnd();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// check for required fields of primitive type, which can't be checked in the validate method</span></span><br><span class="line">     <span class="keyword">if</span> (!struct.isSetNo()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> org.apache.thrift.protocol.TProtocolException(<span class="string">"Required field 'No' was not found in serialized data! Struct: "</span> + toString());</span><br><span class="line">     &#125;</span><br><span class="line">     struct.validate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol oprot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">     struct.validate();</span><br><span class="line"></span><br><span class="line">     oprot.writeStructBegin(STRUCT_DESC);</span><br><span class="line">     oprot.writeFieldBegin(NO_FIELD_DESC);</span><br><span class="line">     oprot.writeI16(struct.No);</span><br><span class="line">     oprot.writeFieldEnd();</span><br><span class="line">     oprot.writeFieldStop();</span><br><span class="line">     oprot.writeStructEnd();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Write 操作<br>从代码来分析  write 方法是写入规则，首先写入了 <code>STRUCT_DESC</code> 描述， 然后写入了 <code>NO_FIELD_DESC</code> 就是 No 这个字段，然后根据No 的大小吸入了No的具体的值，因为 No 是i16的类型，所以调用了 <code>writeI16</code> 的方法，然后 <code>writeFieldEnd</code> 标识该字段结束。<br><img src="/article/java-thrift-3/java-thrift-3-205443.png" alt></p></li><li><p>读操作<br>读取操作其实很写入操作相反， 需要注意一点是 读操作有个标记为 为 <code>schemeField.type == org.apache.thrift.protocol.TType.STOP</code><br>遇到这个标记为，则读取直接停止。那么这个 <code>STOP</code> 是什么作用呢？</p></li></ul><p>STOP 是 <code>writeFieldStop</code> 结束的标记为，标记该 <code>Struct</code> 的所有 <code>Field</code> 都已经读取完毕</p><p><img src="/article/java-thrift-3/java-thrift-3-114519.png" alt><br>从图中我们可以看到， 当Field 写入完毕后 <code>wirte</code> 会写入 <code>TType.STOP</code> <code>标记，代表所有的Field</code> 都已经图区完毕，这个时候 <code>read</code> 就可以退出了。</p><p>而在每个<code>Field</code>,<code>Struct</code> 协议的最后，又会写入结束的标记。<br>这个标记是由协议来实现的，目前不同的协议有不同的写入方法<br>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TBinaryProtocol.java  为空实现，什么也不写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TJSONProtocol.java 协议实现方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFieldEnd</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.writeJSONObjectEnd();<span class="comment">// 这里输入的是 “&#125;”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问，为什么 <code>TBinaryProtocol</code> 什么也不写呢？<br>问知道 <code>TField</code> 中有个 <code>type</code> 的字段， <code>type</code> 字段标明了 <code>value</code> 类型所占的长度，<br>所有我们用 往后读 <code>type</code> 所占的长度就可以获取 <code>value</code> 的值，所以 <code>Field</code> 的结束标记位可以什么都不用写。<br>那么又有读者会问，那么 <code>String</code> 类型呢，他没有固定长度。</p><p>二级制协议 <code>TBinaryProtocol</code> 中关于 写 <code>String</code> 写入的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] dat = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">this</span>.writeI32(dat.length);</span><br><span class="line">        <span class="keyword">this</span>.trans_.write(dat, <span class="number">0</span>, dat.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(<span class="string">"JVM DOES NOT SUPPORT UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看出， 写 <code>String</code> string 转成UTF8的编码，然后在value的地方前两个字节写入字符串的长度，然后在写入字符创的 byte 数据。<br>所以说，对于变长类型，写入的规则为 <strong>长度 + 数据</strong>的方式。</p><h3><span id="friendstuplescheme">FriendsTupleScheme</span></h3><p><code>FriendsTupleScheme</code> 重新定义了一种名为 <code>TTupleProtocol</code> 的协议，这个协议是一个<br><code>TCompactProtocol</code> 的子类， <code>TCompactProtocol</code> 我会在协议层分析。</p><p>简单说 <code>FriendsTupleScheme</code> 一种压缩的编码方式，将所有的指以固定长度压缩在一起。结构如下<br><img src="/article/java-thrift-3/java-thrift-3-120859.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendsTupleScheme</span> <span class="keyword">extends</span> <span class="title">TupleScheme</span>&lt;<span class="title">Friends</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    TTupleProtocol oprot = (TTupleProtocol) prot;</span><br><span class="line">    oprot.writeI16(struct.No);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(org.apache.thrift.protocol.TProtocol prot, Friends struct)</span> <span class="keyword">throws</span> org.apache.thrift.TException </span>&#123;</span><br><span class="line">    TTupleProtocol iprot = (TTupleProtocol) prot;</span><br><span class="line">    struct.No = iprot.readI16();</span><br><span class="line">    struct.setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="get-set-方法">GET SET 方法</span></h1><h2><span id="set-方法">SET 方法</span></h2><p><code>Friends</code> 为每一个Field 都生成了一个 set 方法 和一个 isSetXXX 的方法，标识该值是否被set。之所以有这个方式是因为 当我们在给 一个 i31的数 定义为 optional 的时候，i32 对应的是Java 语言的int 型 那么 这个值被初始化为 0，那么当rpc 过来的 这个值 就是0的时候，程序无法区分 这个0 是没有set 还是值就是0</p><blockquote><p>注意，在设计RPC 协议或者其他协议的时候，避免 0 这个值。</p></blockquote><p>Thrift 会给String 每个字段顶一个id, 名字为：<code>__{filed name}_ISSET_ID</code>,又会定义个bitSet 结构   bitSet 的大小为字段的个数。</p><p>当我们执行 setXX 这个方法的时候会调用 setXXIsSet(true) 方法。 来标明这个方法已经赋过值了。<br><code>setXXIsSet(true)</code> 本意就是讲 这个字段对应的BitSet 的位置控制成1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> __NO_ISSET_ID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> BitSet __isset_bit_vector = <span class="keyword">new</span> BitSet(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Friends</span><span class="params">(<span class="keyword">short</span> No)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  <span class="keyword">this</span>.No = No;</span><br><span class="line">  setNoIsSet(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们还可以判断这个指是否</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSetNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __isset_bit_vector.get(__NO_ISSET_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fieldmetadata-结构">FieldMetaData 结构</span></h2><p><code>Thrift</code> 对于每个生成的类会有一个 <code>FieldMetaData</code> 的结构<br>这个类会和 Field 一个名称的枚举类型来对应成一个map结构。<br><code>FieldMetaData</code> 主要是封装了 Field 值的一些元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; metaDataMap;</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">   Map&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt; tmpMap = <span class="keyword">new</span> EnumMap&lt;_Fields, org.apache.thrift.meta_data.FieldMetaData&gt;(_Fields<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   tmpMap.put(_Fields.NO, <span class="keyword">new</span> org.apache.thrift.meta_data.FieldMetaData(<span class="string">"No"</span>, org.apache.thrift.TFieldRequirementType.REQUIRED, </span><br><span class="line">       <span class="keyword">new</span> org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I16)));</span><br><span class="line">   metaDataMap = Collections.unmodifiableMap(tmpMap);</span><br><span class="line">   org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Friends<span class="class">.<span class="keyword">class</span>, <span class="title">metaDataMap</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先我们来看一下meta包下都有哪些字段</p><ul><li>EnumMetaData</li><li>FieldMetaData</li><li>FieldValueMetaData</li><li>ListMetaData</li><li>MapMetaData</li><li>SetMetaData</li><li>StructMetaData</li></ul><h3><span id="继承关系类图">继承关系类图</span></h3><p><img src="/article/java-thrift-3/java-thrift-3-100507.png" alt></p><h3><span id="fieldmetadata">FieldMetaData</span></h3><p>这个数据结构是<code>Friends</code> 用来说明其中涉及<code>Field</code>信息的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMetaData</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String fieldName;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> requirementType;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> FieldValueMetaData valueMetaData;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends TBase&gt;, Map&lt;? extends TFieldIdEnum, FieldMetaData&gt;&gt; structMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所有Meta的映射关系</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    structMap = <span class="keyword">new</span> HashMap&lt;Class&lt;? extends TBase&gt;, Map&lt;? extends TFieldIdEnum, FieldMetaData&gt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FieldMetaData</span><span class="params">(String name, <span class="keyword">byte</span> req, FieldValueMetaData vMetaData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fieldName = name;    <span class="comment">// Field 名字</span></span><br><span class="line">    <span class="keyword">this</span>.requirementType = req; <span class="comment">// 是否是必须的</span></span><br><span class="line">    <span class="keyword">this</span>.valueMetaData = vMetaData;  <span class="comment">// value 字段的元数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// .... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Friends</code> 或 <code>new</code> 一个这个出来，并传入了相应的信息，我们<code>struct</code>的中的<code>required</code> <code>optional</code> 的关键字 就是通过 这个常量类来定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TFieldRequirementType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> REQUIRED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> OPTIONAL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> DEFAULT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TFieldRequirementType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="fieldvaluemetadata">FieldValueMetaData</span></h3><p>既然大部分是继承 <code>FieldValueMetaData</code> 那么我们首先来看这个数据结构,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueMetaData</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> type;    <span class="comment">// Field 类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isTypedefType; <span class="comment">// 是否是 Thrift 预定义的类型（TType 预定义的类型）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String typedefName; <span class="comment">// Filed 名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBinary;   <span class="comment">// 是否二进制协议</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="获取filedmetadata">获取FiledMetaData</span></h3><ul><li>全局获取<br>当我们新建好了 FiledMetaData之后可以通过 FiledMetaData 静态类来获取，</li></ul><p><code>FiledMetaData.getStructMetaDataMap(Friends.class)</code></p><ul><li>Friend API获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Friends friends = <span class="keyword">new</span> Friends();</span><br><span class="line">friends.getFieldValue(Friends._Fields.NO);</span><br></pre></td></tr></table></figure><h1><span id="复杂符合类型">复杂符合类型</span></h1><p>我们的 Friends 这是简单定义了 Friends 一个i16的字段No<br>如果我们在Friends 里增加一些复杂类型，Java 文件又是什么情况呢？</p><p>这里还要还有一个问题，我们只是分析了Struct 的生成类，那么Service的生成类是怎样的呢？</p><p>由于篇幅问题，我们这个话题留在下期去讨论。</p><h2><span id="总结">总结</span></h2><p>本节主要是总结了通过struct 文件生成的代码，主要谈论了框架生成的一些特性。更有一些协议层的相关的方法，thrift 的Java 代码非常轻量级，分层也非常明确，那么这些东西将会如何组织，整个的分层又是什么呢？我们下一节在详细论述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（二）</title>
      <link href="/article/java-thrift-2/"/>
      <url>/article/java-thrift-2/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><a href="https://icefrozen.github.io/article/java-thrift-1/" target="_blank" rel="noopener">前一章节</a>，我们基本入门，了解了 <code>Thrift</code> 的基本用法，这一节继续来分析 <code>Thrift</code> IDL的内容。<br><code>Thrift</code> 采用IDL（<code>Interface Definition Language</code>）来定义通用的服务接口，然后通过 <code>Thrift</code> 提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p><h2><span id="idl定义的规范">IDL定义的规范</span></h2><h2><span id="idl-结构规范">IDL 结构规范</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document   ::= Header* Definition*</span><br><span class="line">Header     ::= Include | CppInclude | Namespace</span><br><span class="line">Definition ::= Const | Typedef | Enum | Senum | Struct | Union | Exception | Service</span><br></pre></td></tr></table></figure><p>IDL的结构分为Header，Definition两个部分。<br>Head 只是的是协议头，主要包含三个关键字</p><ul><li>Include</li><li>CppInclude</li><li>Namespace<br>Thrift IDL 的 Definition为定义部分。</li></ul><h2><span id="idl-语法规范">IDL 语法规范</span></h2><h3><span id="identifier">Identifier</span></h3><p>官方文档中的定义如下：<br><code>Identifier ::= ( Letter | '_' ) ( Letter | Digit | '.' | '_' )*</code></p><p>复制代码即合法的标识符满足以下条件：</p><p>1、标识符只能由字母，数字，<em>（under score）, .（dot）组成<br>2、只能以字母，</em> 开头</p><h2><span id="idl-definition-部分">IDL Definition 部分</span></h2><p>语法组成</p><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## IDL （Field）基本类型</span><br><span class="line">+ 基本类型的语法格式</span><br><span class="line">```java</span><br><span class="line">FieldID? FieldReq? FieldType Identifier (&apos;=&apos; ConstValue)? XsdFieldOptions ListSeparator?</span><br></pre></td></tr></table></figure><h3><span id="fieldid-为类型的展位符号-通常用int">FieldID 为类型的展位符号 通常用int</span></h3><h3><span id="fieldtype">FieldType</span></h3><table><thead><tr><th>关键字</th><th>类型</th><th>对应Java中的类型</th></tr></thead><tbody><tr><td>bool</td><td>布尔值</td><td>对应Java中的boolean</td></tr><tr><td>byte</td><td>有符号字节</td><td>对应Java中的byte</td></tr><tr><td>i16</td><td>16位有符号整型</td><td>对应Java中的short</td></tr><tr><td>i32</td><td>32位有符号整型</td><td>对应Java中的int</td></tr><tr><td>i64</td><td>64位有符号整型</td><td>对应Java中的long</td></tr><tr><td>double</td><td>64位浮点型</td><td>对应Java中的double</td></tr><tr><td>string</td><td>字符串</td><td>对应Java中的String</td></tr><tr><td>binary</td><td>Blob 类型</td><td>对应Java中的byte[]</td></tr><tr><td>slist</td><td></td><td></td></tr></tbody></table><blockquote><p>可以是基础类型，容器类型或者合法标识符，这里的合法标识符就是下文中通过 typedef, enum, struct 等关键中声明的类型。</p></blockquote><h3><span id="filedreq">FiledReq</span></h3><ul><li><p><strong>required</strong>:</p><ol><li>写：必须字段始终写入，并且应该设置这些字段。</li><li>读：必须字段始终读取，并且它们将包含在输入流中</li><li>默认值：始终写入</li></ol><blockquote><p>注意：如果一个必须字段在读的时候丢失，则会抛出异常或返回错误，所以在版本控制的时候，要严格控制字段的必选和可选，必须字段如果被删或者改为可选，那将会造成版本不兼容。</p></blockquote></li><li><p><strong>optional</strong>:<br>1、写：可选字段仅在设置时写入<br>2、读：可选字段可能是也可能不是输入流的一部分<br>3、默认值：在设置了isset标志时写入</p><blockquote><p>Thrift使用所谓的“isset”标志来指示是否设置了特定的可选字段， 仅设置了此标志的字段会写入，相反，仅在从输入流中读取字段值时才设置该标志。</p></blockquote></li><li><p><strong>default</strong>:<br>1、写：理论上总是写入，但是有一些特例<br>2、读：跟optional一样<br>3、默认值：可能不会写入</p><blockquote><p>默认类型是required和optional的结合，可选输入（读），必须输出（写）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 例子</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    1: required string name,         </span><br><span class="line">    2: required i16 age = 0;</span><br></pre></td></tr></table></figure></p></blockquote></li></ul><h2><span id="container-容器">Container (容器)</span></h2><h3><span id="有3种可用容器类型">有3种可用容器类型：</span></h3><ul><li><p><strong>list<t></t></strong>: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或者其他语言的数组</p></li><li><p><strong>set<t></t></strong>: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了</p></li><li><p><strong>map&lt;t, t&gt;</strong>: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary</p></li></ul><h3><span id="例子">例子：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>: required list&lt;User&gt; friends,</span><br><span class="line"><span class="number">8</span>: optional map&lt;i32, User&gt; mapUser;</span><br><span class="line"><span class="number">9</span>: optional set&lt;User&gt; setUser;</span><br></pre></td></tr></table></figure><h2><span id="struct结构体">struct结构体</span></h2><h3><span id="struct语法">struct语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct     ::= <span class="string">'struct'</span> Identifier <span class="string">'xsd_all'</span>? <span class="string">'&#123;'</span> Field* <span class="string">'&#125;'</span></span><br><span class="line">Field      ::=  FieldID? FieldReq? <span class="function">FieldType <span class="title">Identifier</span> <span class="params">(<span class="string">'='</span> ConstValue)</span>? XsdFieldOptions ListSeparator?</span></span><br><span class="line"><span class="function">FieldID    ::</span>=  IntConstant <span class="string">':'</span></span><br><span class="line">FieldReq   ::=  <span class="string">'required'</span> | <span class="string">'optional'</span></span><br></pre></td></tr></table></figure><blockquote><p>xsd_all 是 Facebook 内部的字段，直接忽略，就算你写了，也不会有啥影响 Field 中的 XsdFeildOptions 也是 Facebook 内部字段，直接忽略</p></blockquote><p>从语法定义看，一个 Struct 定义的核心是 <code>Field</code> 字段，而且每个字段的名字在一个 <code>Struct</code> <code>内要确保是唯一的，Struct</code> 不能继承，但是可以嵌套使用，即可以作为 <code>struct</code> 字段的类型。<br>接下来就仔细看下 <code>Field</code> 的定义，一个合法的 <code>Field</code> 只需要哟 <code>FieldType</code> 和对应的 <code>Identifier</code> 就可以了，但是通常我们都会加上 <code>FieldId</code> 和 <code>ListSeparator</code>, 而 FieldReq 则视情况而定。<br><code>FieldId</code> 必须是整型常量加 : 组成。</p><h3><span id="struct约束">struct约束：</span></h3><ol><li>struct不能继承，但是可以嵌套，不能嵌套自己。</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li><li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li><li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li><li>每个字段可以设置默认值</li><li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li></ol><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Friends &#123;</span><br><span class="line">    <span class="number">1</span>: required i32 No,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    <span class="number">1</span>: required string name,         </span><br><span class="line">    <span class="number">2</span>: required i16 age = <span class="number">0</span>;            </span><br><span class="line">    <span class="number">3</span>: required bool gender,</span><br><span class="line">    <span class="number">4</span>: required i32 No,</span><br><span class="line">    <span class="number">5</span>: required i64 createTime,</span><br><span class="line">    <span class="number">6</span>: required <span class="keyword">double</span> grade,</span><br><span class="line">    <span class="number">7</span>: required list&lt;Friends&gt; friends,</span><br><span class="line">    <span class="number">8</span>: optional map&lt;i32, Friends&gt; mapUser;</span><br><span class="line">    <span class="number">9</span>: optional set&lt;Friends&gt; setUser;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="union">Union</span></h2><h3><span id="语法格式">语法格式</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Union` 语法定义除了关键字不一样外，基本与 `Struct` 相同，只不过语义上是有很大差别的，`Union` 可以定义这样一个结构体，结构体中的字段只要有要给被赋予合法值，就可以被 thrift 传输，而且 `Union` 结构中的字段默认就是 `optional` 的，不能使用 `required` 声明，写了也没意义，其语法定义如下：</span><br><span class="line"></span><br><span class="line">可以想象这么一个场景，我们收集用户的信息，只要用户填写了手机号或者邮箱中的一个就可以了，这时候我们就可以使用 `Union` 结构来标识这个类型</span><br><span class="line">```java</span><br><span class="line">union UserInfo &#123;</span><br><span class="line">  1: string phone,</span><br><span class="line">  2: string email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="常量类型">常量类型</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Const          ::= <span class="string">'const'</span> FieldType Identifier <span class="string">'='</span> ConstValue ListSeparator?</span><br><span class="line">ConstValue     ::= IntConstant | DoubleConstant | Literal | Identifier | ConstList | ConstMap</span><br><span class="line">IntConstant    ::= (<span class="string">'+'</span> | <span class="string">'-'</span>)? Digit+</span><br><span class="line">DoubleConstant ::= (<span class="string">'+'</span> | <span class="string">'-'</span>)? Digit* (<span class="string">'.'</span> Digit+)? ( (<span class="string">'E'</span> | <span class="string">'e'</span>) IntConstant )?</span><br><span class="line">ConstList      ::= <span class="string">'['</span> (ConstValue ListSeparator?)* <span class="string">']'</span></span><br><span class="line">ConstMap       ::= <span class="string">'&#123;'</span> (ConstValue <span class="string">':'</span> ConstValue ListSeparator?)* <span class="string">'&#125;'</span></span><br><span class="line">ListSeparator  ::= <span class="string">','</span> | <span class="string">';'</span></span><br></pre></td></tr></table></figure><h3><span id="例子">例子</span></h3><p>先说明下 <code>ListSeparator</code>, 这个分隔符就好比 Java 中一句话结束后的 ;，在 IDL 中分隔符可以是 , 或者 ; 而且大部分情况下可以忽略不写</p><p>IDL 中通过 const 关键字进行声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string testConst = <span class="string">'hello,thrift'</span>; <span class="comment">// `;` 可以替换为 `,` 也可以不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制代码常量声明语句中 = 后面的内容就是常量值，IDL 中的合法常量值如下：</span></span><br><span class="line"><span class="comment">// int 类型常量，和 js 中的 number 字面量是一个意思</span></span><br><span class="line"><span class="keyword">const</span> i8 count = <span class="number">100</span>  <span class="comment">// 可以是正数，负数（如：-2）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doubule 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> money = <span class="string">'13.14'</span>   <span class="comment">// 同样可正可负</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> rate = <span class="number">1.2e-5</span>     <span class="comment">// 可以使用科学计数法，表示 0.000012</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> salary = <span class="number">3.5e8</span>    <span class="comment">// 表示 350000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 list, 类似 js 中的数组字面量</span></span><br><span class="line"><span class="keyword">const</span> list&lt;string&gt; names = [ <span class="string">'tom'</span>, <span class="string">'joney'</span>, <span class="string">'catiy'</span> ]  <span class="comment">// 当然 `,` 可以替换成 ';', 也可以不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量 map, 类似 js 中的对象字面量</span></span><br><span class="line"><span class="keyword">const</span> map&lt;string, string&gt; = &#123; <span class="string">'name'</span>: <span class="string">'johnson'</span>, <span class="string">'age'</span>: <span class="string">'20'</span> &#125;</span><br></pre></td></tr></table></figure><h2><span id="异常类型">异常类型</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">Exception 语法定义与 Struct 相似，但是这个类型通常适合目标语言的异常处理机制配合使用的</span><br><span class="line">```java</span><br><span class="line">exception Error &#123;</span><br><span class="line">  1: required i8 Code,</span><br><span class="line">  2: string Msg,</span><br><span class="line">&#125;</span><br><span class="line">service ExampleService &#123;</span><br><span class="line">  string GetName() throws (1: Error err),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="枚举类型">枚举类型</span></h2><h3><span id="语法">语法：</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">```java</span><br><span class="line">enum fb_status &#123;</span><br><span class="line">  DEAD = 0,</span><br><span class="line">  STARTING = 1,</span><br><span class="line">  ALIVE = 2,</span><br><span class="line">  STOPPING = 3,</span><br><span class="line">  STOPPED = 4,</span><br><span class="line">  WARNING = 5,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码从语法定义来看，(’=’ IntConstant)? 是一个可选项，也就是说我们可以不用指定值，默认就是从 0 开始递增，如果要指定，那就必须是一个整型常量，如果后续没有再指定，则从第一个指定的整型值开始进行递增. 所以上述示例中的枚举值，也可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> fb_status &#123;</span><br><span class="line">  DEAD,</span><br><span class="line">  STARTING,</span><br><span class="line">  ALIVE,</span><br><span class="line">  STOPPING,</span><br><span class="line">  STOPPED,</span><br><span class="line">  WARNING,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="typedef">Typedef</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 例子</span><br><span class="line">```java</span><br><span class="line">typedef i8 int8  // 这里把 i8 去个别名 int8, 在后面的定义中就可以使用了</span><br><span class="line">const int8 count = 100 // 等价于 const i8 count = 100</span><br></pre></td></tr></table></figure><h2><span id="services类型">Services类型</span></h2><h3><span id="语法">语法</span></h3><p>上面的小节中介绍的所有内容都是用来服务 <code>Service</code> <code>的，Service</code> 提供了我们要暴露的接口，而且，<code>Service</code> 是可以被继承的，<code>Service A</code>继承了 <code>Service B</code>, A 除了提供自己定义的接口外，他还提供了从 B 继承来的接口。语法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service      ::= <span class="string">'service'</span> Identifier ( <span class="string">'extends'</span> Identifier )? <span class="string">'&#123;'</span> Function* <span class="string">'&#125;'</span></span><br><span class="line">Function     ::= <span class="string">'oneway'</span>? FunctionType Identifier <span class="string">'('</span> Field* <span class="string">')'</span> Throws? ListSeparator?</span><br><span class="line">FunctionType ::= FieldType | <span class="string">'void'</span></span><br><span class="line">Throws       ::= <span class="string">'throws'</span> <span class="string">'('</span> Field* <span class="string">')'</span></span><br></pre></td></tr></table></figure><p>复制代码从语法定义，我们可以看到 Service 的核心就是 <code>Function</code> 的定义</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service ExampleService &#123;</span><br><span class="line">  <span class="function">oneway <span class="keyword">void</span> <span class="title">GetName</span><span class="params">(<span class="number">1</span>: string UserId)</span>,</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">GetAge</span><span class="params">(<span class="number">1</span>: string UserId)</span> <span class="title">throws</span> <span class="params">(<span class="number">1</span>: Error err)</span>,</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><code>oneway</code> 是一个关键字，从字面上，我们就可以了解到，他是单向的，怎么理解呢？非 <code>oneway</code> 修饰的 function 是应答式，即 <code>req-resp</code>, 客户端发请求，服务端返回响应，被 <code>oneway</code> 修饰后的函数，则意味着，客户端只是会发起，无须关注返回，服务端也不会响应，与 <code>void</code> 的区别是 <code>void</code> 类型的方法还可以返回异常。<br><code>FunctionType</code> 是任何合法的 <code>FieldType</code> 或者 <code>void</code> 关键字，表示无返回类型<br><code>Throws</code> 顾名思义，参考上述示例即可。</p><h2><span id="idl-head-部分">IDL Head 部分</span></h2><p>从语法定义看，Header 可以是 <code>Include</code>, <code>CppInclude</code>, <code>Namespace</code>, 接下来，我们依次进行介绍。</p><h2><span id="include-语法定义">Include 语法定义</span></h2><h3><span id="语法">语法</span></h3><figure class="highlight plain"><figcaption><span>::</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">复制代码从语法规则上看，Include 由 include 关键字 + thrift 文件路径组成。</span><br><span class="line">在真正的业务开发中，我们不可能把所有的服务都定义到一个文件中，通常会根据业务模块进行拆分，然后将这些服务 include 到一个入口文件中，然后在最终服务发布上线的时候，thrift 编译器只需要编译入口文件，就能将所有引入的文件都生成对应的代码，而且 include 进来的文件中定义的内容都是可见的</span><br><span class="line"></span><br><span class="line">### 例子</span><br><span class="line">+ base.thrift</span><br><span class="line">```java</span><br><span class="line">namespace go base</span><br><span class="line"></span><br><span class="line">struct Base &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>example.thrift</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">'base.thrift'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时，我们就可以引用从 base.thrift 导入的内容了</span></span><br><span class="line">struct Example &#123;</span><br><span class="line">  <span class="number">1</span>: base.Base ExampleBase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="cppinclude">CppInclude</span></h2><h3><span id="语法">语法</span></h3><p>复制代码CppInclude 语法定义<br>CppInclude ::= ‘cpp_include’ Literal<br>复制代码CppInclude 主要是用来为当前的 thrift 文件生成的代码中添加一个自定义的 C++ 引入声明 目前没有使用场景，不做过多陈述</p><h3><span id="namespace">Namespace</span></h3><h3><span id="语法">语法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Namespace ::= ( <span class="string">'namespace'</span> ( NamespaceScope Identifier ) )</span><br><span class="line">NamespaceScope  ::=  <span class="string">'*'</span> | <span class="string">'c_glib'</span> | <span class="string">'cpp'</span> | <span class="string">'csharp'</span> | <span class="string">'delphi'</span> | <span class="string">'go'</span> | <span class="string">'java'</span> | <span class="string">'js'</span> | <span class="string">'lua'</span> | <span class="string">'netcore'</span> | <span class="string">'perl'</span> | <span class="string">'php'</span> | <span class="string">'py'</span> | <span class="string">'py.twisted'</span> | <span class="string">'rb'</span> | <span class="string">'st'</span> | <span class="string">'xsd'</span></span><br></pre></td></tr></table></figure><p>复制代码 <code>Namespace</code> 用来声明使用哪种语言来处理当前 <code>thrift</code> <code>文件中定义的各种类型，NamespaceScope</code> 就是各种语言的标识，也可以指定为通配符 * 标识，标识 thrift 文件中的定义适用于所有的语言。除此之外 Namespace 还有一个作用就是避免不同 <code>Identifier</code> 定义的命名冲突。</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace java com.facebook.fb303</span><br></pre></td></tr></table></figure><p>上述示例中 <code>Namespace</code> 声明语句，标识当前的 thrift 文件适用于 java<br>NamespaceScope 后面紧跟着的 Identifier 在不同语言中会有不一样的表现.</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/u011642663/article/details/56015576" target="_blank" rel="noopener">Thrift IDL基本语法</a></li><li><a href="https://juejin.im/post/5de8e38ef265da33d7441913" target="_blank" rel="noopener">Thrift &amp; IDL 介绍</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift框架详解（一）</title>
      <link href="/article/java-thrift-1/"/>
      <url>/article/java-thrift-1/</url>
      
        <content type="html"><![CDATA[<h2><span id="thrift-简介">Thrift 简介</span></h2><p>Thrift是一个轻量级、跨语言的远程服务调用框架，最初由Facebook开发，后面进入Apache开源项目。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端/客户端模板代码。<br>Thrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等，本系列主要讲述基于Java语言的Thrift的配置方式和具体使用。</p><p>Thrift的主要特点有：</p><ol><li>基于二进制的高性能的编解码框架</li><li>基于NIO的底层通信</li><li>相对简单的服务调用模型</li><li>使用IDL支持跨平台调用</li></ol><h2><span id="thrift-安装">Thrift 安装</span></h2><p>具体的安装不做介绍，可以去官网查询，本系列主要使用的是0.8.0， 截止到目前，最新版本是0.13.0， 由于目前就职的公司普遍使用的是0.8.0，则就以这个为准，后边会单独开一片0.8.0和0.13.0的区别。</p><h2><span id="thrift-设计">Thrift 设计</span></h2><h2><span id="设计架构">设计架构</span></h2><div align="center"><p><img src="/article/java-thrift-1/java-thrift-1-112101.png" alt></p></div><p>Thrift软件栈分层从下向上分别为：</p><ul><li><p><strong>传输层(Transport Layer)</strong>：传输层负责直接从网络中读取和写入数据，它定义了具体的网络传输协议；比如说TCP/IP传输等。</p></li><li><p><strong>协议层(Protocol Layer)</strong>：协议层定义了数据传输格式，负责网络传输数据的序列化和反序列化；比如说JSON、XML、二进制数据等。</p></li><li><p><strong>处理层(Processor Layer)</strong>：处理层是由具体的IDL（接口描述语言）生成的，封装了具体的底层网络传输和序列化方式，并委托给用户实现的Handler进行处理。</p></li><li><p><strong>服务层(Server Layer)</strong>：整合上述组件，提供具体的网络线程/IO服务模型，形成最终的服务。</p></li></ul><h2><span id="特性">特性</span></h2><h3><span id="一-开发速度快">(一) 开发速度快</span></h3><p>通过编写RPC接口<strong>Thrift IDL</strong>文件，利用编译生成器自动生成服务端骨架(<code>Skeletons</code>)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p><p>服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(<code>Handler</code>)即实现类即可。<br>客户端：只需要拷贝IDL定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。</p><h3><span id="二-接口维护简单">(二) 接口维护简单</span></h3><p>通过维护<code>Thrift格</code>式的IDL（接口描述语言）文件（注意写好注释），即可作为给Client使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且Thrift协议可灵活支持接口的可扩展性。</p><h3><span id="三-学习成本低">(三) 学习成本低</span></h3><p>因为其来自Google Protobuf开发团队，所以其IDL文件风格类似Google Protobuf，且更加易读易懂；特别是RPC服务接口的风格就像写一个面向对象的Class一样简单。<br>初学者只需参照：<a href="thrift.apache.org"></a>，一个多小时就可以理解Thrift IDL文件的语法使用。</p><h3><span id="四-多语言跨语言支持">(四) 多语言/跨语言支持</span></h3><p>Thrift支持<code>C++、 Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk</code>等多种语言，即可生成上述语言的服务器端和客户端程序。<br>对于我们经常使用的<code>Java、PHP、Python、C++</code>支持良好。</p><h3><span id="五-稳定广泛使用">(五) 稳定/广泛使用</span></h3><p>Thrift在很多开源项目中已经被验证是稳定和高效的，例如<code>Cassandra、Hadoop、HBase</code>等；国外在Facebook中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><h2><span id="thrift-快速入门">Thrift 快速入门</span></h2><h3><span id="项目包路径">项目包路径</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com.thrift</span><br><span class="line">    |- client</span><br><span class="line">        |- client.java          <span class="comment">//主要存放 client的代码</span></span><br><span class="line">    |- constant</span><br><span class="line">        | - ServerConfig.java  <span class="comment">// 主要存放服务器配置等关键信息</span></span><br><span class="line">    |- idl</span><br><span class="line">        |- hello.thrift         <span class="comment">// IDL描述文件</span></span><br><span class="line">    |- idlcode</span><br><span class="line">        | - HelloWorldService.java <span class="comment">// 主要存放根据IDL自动生成的文件</span></span><br><span class="line">    | -server   </span><br><span class="line">        |- handler              <span class="comment">// rpc 接口的具体实现</span></span><br><span class="line">            |- HelloWorldServiceImpl.java</span><br><span class="line">        server.java             <span class="comment">// 服务器测试代码</span></span><br><span class="line">    gen_code.sh                 <span class="comment">// IDL生成命令</span></span><br></pre></td></tr></table></figure><h3><span id="具体实现">具体实现</span></h3><ul><li>（1） 编写IDL 文件,命名为 <code>hello.thrift</code>放到<code>com.thrift.idl</code> 这个包名下。如果需要提示，在Idea上安装 <code>Thrift</code> 编辑插件，具体可以搜索 <code>ThirftSupport</code> 这个插件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  string say(<span class="number">1</span>: string username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 运行gen_code.sh 用于生成 <code>thrift</code> 的各种代码块。<br>我们来看一下 gen_code.sh 的代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">path_root=`<span class="built_in">pwd</span>`</span><br><span class="line">idlDir=<span class="variable">$path_root</span>/idl</span><br><span class="line">idlCode=<span class="variable">$path_root</span>/idlCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> `ls <span class="variable">$idlDir</span>/*.thrift`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   thrift --gen java -out <span class="variable">$idlCode</span> <span class="variable">$f</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行完成或，我们会在 <code>idlcode</code> 生成一个<code>HelloWorldService.java</code> 文件，这个就是上文中服务器和客户端交互的核心代码。</p><p>我们来简单看一下这个java文件的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 同步接口定义</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步接口定义</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncIface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String username, org.apache.thrift.async.AsyncMethodCallback&lt;AsyncClient.say_call&gt; resultHandler)</span> <span class="keyword">throws</span> org.apache.thrift.TException</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 客户端</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TServiceClient</span> <span class="keyword">implements</span> <span class="title">Iface</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">  <span class="comment">// 异步客户端</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncClient</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">async</span>.<span class="title">TAsyncClient</span> <span class="keyword">implements</span> <span class="title">AsyncIface</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">  <span class="comment">// Processor 组件</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span>&lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">Iface</span>&gt; <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBaseProcessor</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TProcessor</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">say_args</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">say_args</span>, <span class="title">say_args</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">say_result</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">thrift</span>.<span class="title">TBase</span>&lt;<span class="title">say_result</span>, <span class="title">say_result</span>.<span class="title">_Fields</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span>  </span>&#123;<span class="comment">/** ...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于开发人员而言，使用原生的Thrift框架，仅需要关注以下四个核心内部接口/类：<code>Iface, AsyncIface, Client和AsyncClient</code>。</p><ul><li>Iface：服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的同步业务逻辑。</li><li>AsyncIface：服务端通过实现HelloWorldService.Iface接口，向客户端的提供具体的异步业务逻辑。</li><li>Client：客户端通过HelloWorldService.Client的实例对象，以同步的方式访问服务端提供的服务方法。</li><li>AsyncClient：客户端通过HelloWorldService.AsyncClient的实例对象，以异步的方式访问服务端提供的服务方法。</li></ul><p>这里的结构不做详细分析，等到下一章节在做分析。</p><ul><li>（3） 安装thrift插件，我这里用的是0.8.0版本，所以在pom.xml 文件添加如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(4) 编写RPC的实现类<br>首先 我们要对 <code>HelloWorldService</code> 服务做实现，也就是我们要提供更多具体的RPC 方法<br>在 <code>server.handler</code> 包下创建 <code>HelloWorldServiceImpl.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String username)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello ==&gt; "</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（5） 编写服务器代码</li><li>Thrift的服务端类型<ol><li><strong>TSimpleServer</strong> ：单线程服务器端，使用标准的阻塞式I/O</li><li><strong>TThreadPoolServer</strong> ：多线程服务器端，使用标准的阻塞式I/O</li><li><strong>TNonblockingServer</strong> ：单线程服务器端，使用非阻塞式I/O</li><li><strong>THsHaServer</strong> ：半同步半异步服务器端，基于非阻塞式IO读写和多线程工作任务处理</li><li><strong>TThreadedSelectorServer</strong> ：多线程选择器服务器端，对THsHaServer在异步IO模型上进行增强</li></ol></li></ul><p>这里我们使用<code>TSimpleServer</code>，在 server包下新建 <code>server.java</code>以及定义 <code>ServerConfig</code> 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SimpleServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleServer</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(ServerConfig.SERVER_PORT);</span><br><span class="line">        <span class="comment">// 转换层</span></span><br><span class="line">        TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(serverSocket);</span><br><span class="line">        <span class="comment">// processor 层</span></span><br><span class="line">        HelloWorldService.Processor processor =</span><br><span class="line">                <span class="keyword">new</span> HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(<span class="keyword">new</span> HelloWorldServiceImpl());</span><br><span class="line">        <span class="comment">// 协议工厂</span></span><br><span class="line">        TBinaryProtocol.Factory protocolFactory = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">        TSimpleServer.Args tArgs = <span class="keyword">new</span> TSimpleServer.Args(serverTransport);</span><br><span class="line">        tArgs.processor(processor);</span><br><span class="line">        tArgs.protocolFactory(protocolFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的单线程服务模型 一般用于测试</span></span><br><span class="line">        TServer tServer = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">        System.out.println(<span class="string">"Running Simple Server"</span>);</span><br><span class="line">        tServer.serve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerConfig.java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">9988</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（6） client 代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport = <span class="keyword">new</span> TSocket(ServerConfig.SERVER_IP, ServerConfig.SERVER_PORT, ServerConfig.TIMEOUT);</span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            HelloWorldService.Client client = <span class="keyword">new</span> HelloWorldService.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line">            String result = client.say(<span class="string">"Leo"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Result =: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(7) 运行server<br>server控制台输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Running Simple Server</span><br></pre></td></tr></table></figure><p>client 输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result =: hello ==&gt; Leo</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>Thrift是一个RPC框架，内部实现的机制和概念还有很多，更重要的留下几个问题。、<br>1、Thrift如何做服务发现？ 这个留着下次再分析。<br>2、生成的java文件起着什么样的作用。<br>3、Rpc的流程是什么。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5b290dbf6fb9a00e5c5f7aaa" target="_blank" rel="noopener">Apache Thrift系列详解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Thrift </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(3)</title>
      <link href="/article/java-AQS3-read-write-lock/"/>
      <url>/article/java-AQS3-read-write-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="基础">基础</span></h2><p>所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为：如果对资源加了<strong>写锁</strong>，其他线程无法再获得<strong>写锁与读锁</strong>，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。本文主要分析JDK(1.8+)JCU包中读写锁接口(<strong>ReadWriteLock</strong>)的重要实现类<strong>ReentrantReadWriteLock</strong>的细节，来阐述AQS的应用。</p><h2><span id="样例">样例</span></h2><p>我们来看一段例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">double</span> data=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">readClass</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">readClass</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        System.out.println(i + <span class="string">" --&gt;读数据："</span>+data);</span><br><span class="line">        rwl.readLock().unlock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">writeClass</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">writeClass</span><span class="params">(<span class="keyword">double</span> i)</span> </span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      data=i;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"写数据： "</span>+data);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">"sleep: ..."</span>);</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.printf(<span class="string">"wake up ... "</span>);</span><br><span class="line">      rwl.writeLock().unlock();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        readClass readClass = <span class="keyword">new</span> readClass(i);</span><br><span class="line">        callList.add(readClass);</span><br><span class="line">    &#125;</span><br><span class="line">    callList.add(<span class="keyword">new</span> writeClass(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      readClass readClass = <span class="keyword">new</span> readClass(i);</span><br><span class="line">      callList.add(readClass);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futures = executor.invokeAll(callList);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 --&gt;读数据：0.0</span><br><span class="line">2 --&gt;读数据：0.0</span><br><span class="line">0 --&gt;读数据：0.0</span><br><span class="line">4 --&gt;读数据：0.0</span><br><span class="line">3 --&gt;读数据：0.0</span><br><span class="line">6 --&gt;读数据：0.0</span><br><span class="line">5 --&gt;读数据：0.0</span><br><span class="line">7 --&gt;读数据：0.0</span><br><span class="line">8 --&gt;读数据：0.0</span><br><span class="line">9 --&gt;读数据：0.0</span><br><span class="line">写数据： 10.0</span><br><span class="line">sleep: ...wake up ... 10 --&gt;读数据：10.0</span><br><span class="line">11 --&gt;读数据：10.0</span><br><span class="line">12 --&gt;读数据：10.0</span><br><span class="line">13 --&gt;读数据：10.0</span><br><span class="line">14 --&gt;读数据：10.0</span><br><span class="line">15 --&gt;读数据：10.0</span><br><span class="line">17 --&gt;读数据：10.0</span><br><span class="line">19 --&gt;读数据：10.0</span><br><span class="line">16 --&gt;读数据：10.0</span><br><span class="line">18 --&gt;读数据：10.0</span><br></pre></td></tr></table></figure><p>结论，我们可以看到，读写锁互斥的，当有写锁锁住资源的时候，无法进行读取，同理，当有数据加了读锁，无法进行写入。</p><h2><span id="源码分析">源码分析</span></h2><h2><span id="类图">类图</span></h2><ul><li><p>看一下<code>ReentrantReadWriteLock</code>的继承类图</p><p><img src="/article/java-AQS3-read-write-lock/1569557796298java-read-write-lock_.png" alt></p></li></ul><p>我们可以发现 <code>ReentrantReadWriteLock</code>类继承了读写锁 <code>ReadWriteLock</code> 的接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们来看整体的类图</li></ul><p><img src="/article/java-AQS3-read-write-lock/1569586591335java-read-write-lock_.png" alt></p><h2><span id="reentrantreadwritelock-构造函数">ReentrantReadWriteLock 构造函数</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>中提供了两把锁分别是 <code>ReadLock</code> （读锁）和  <code>WriterLock</code>（写锁），这两个锁都是以内部类的形式存在的。这两个内部类当中有都有一个 <code>Sync</code>的对象，这个对象正是<code>AbstractQueuedSynchronizer</code> (AQS)的实现类。锁中的 <code>Sync</code> 的对象和 <code>ReentrantReadWriteLock</code> 对象中的<code>Sync</code>是同一个对象。 在<code>ReentrantReadWriteLock</code>的构造函数中，这个对象对根据我们锁填参数分为 <code>FairSync</code> (公平锁)和 <code>NonfairSync</code> (非公平锁)。其中 <code>FairSync</code> 和  <code>NonfairSync</code> 都有各自的实现，下文会分析。</p><h2><span id="锁readlock-和-writelock之间的关系">锁（ReadLock 和 WriteLock）之间的关系</span></h2><p>读锁和写锁有以下特点：</p><ul><li><p>1)<code>writeLock</code> 是排他的 <code>exclusive</code>, <code>readLock</code> 是共享的 <code>sahred</code>。</p></li><li><ol start="2"><li>同一个线程可以拥有 <code>writeLock</code> 与 <code>readLock</code> (但必须先获取 <code>writeLock</code> 再获取 <code>readLock</code>, 反过来进行获取会导致死锁)。<code>writeLock</code> 与 <code>readLock</code> 是互斥的(就像 <code>Mysql</code> 的 <code>X S</code> 锁)。（死锁的问题后面会具体分析）</li></ol></li><li><ol start="3"><li>在获取 <code>writeLock</code> 时监测到有线程获取了 <code>readLock</code> , 则获取<code>writeLock</code>是线程会一直在 <code>AQS</code> 的 <code>sync queue</code> 里面等待<code>readLock</code>被完全释放, 而若获取 <code>readLock</code> 的时候，若这个线程以前获取过 <code>readLock</code>, 则还能继续重入 (<code>reentrant</code>), 而没有获取 <code>readLock</code> 的线程因为 <code>AQS Sync Queue</code> 里面有想要获取 <code>writeLock</code> 的 线程创建的 <code>Node</code> 节点存在， 会存放在 <code>AQS Sync Queue</code> 队列里面 一直 <code>block</code>。</li></ol></li></ul><p>如果线程想要获取<code>readLock</code>,并且成功获取，那么前提是aqs队列中没有<code>writeLock</code>对应的<code>Node</code>, 如果线程想要获取<code>writeLock</code>,并且成功获取，那么前提是aqs队列中没有<code>readLock</code>对应的<code>Node</code>,</p><blockquote><p>如果你不知道什么是<code>Node</code>和 <code>AQS Sync Queue</code> 队列，可以参考我的另外两篇博文：<a href="https://icefrozen.github.io/article/java-AQS/" target="_blank" rel="noopener">JAVA多线程之AQS分析(1)</a>,<a href="https://icefrozen.github.io/article/Java-AQS2/" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)</a></p></blockquote><h2><span id="sync-类详解">Sync 类详解</span></h2><p><code>ReentrantReadWriterLock</code> 同样使用自己的内部类 <code>Sync</code>（继承 <code>AbstractQueuedSynchronizer</code> ）实现<code>CLH</code>算法。为了方便对读写锁获取机制的了解，先介绍一下<code>Sync</code>内部类中几个属性。</p><p>对于CLH 锁，这里就不在展开，有兴趣的小伙伴可以自行查阅。</p><blockquote><p>CLH lock is Craig, Landin, and Hagersten (CLH) locks, CLH lock is a spin lock, can ensure no hunger, provide fairness first come first service.<br>The CLH lock is a scalable, high performance, fairness and spin lock based on the list, the application thread spin only on a local variable, it constantly polling &gt; the precursor state, if it is found that the pre release lock end spin.</p></blockquote><h3><span id="sync-属性">Sync 属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);      <span class="comment">// 000000000 00000001 00000000 00000000</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  <span class="comment">// 000000000 00000000 11111111 11111111</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 计算 readLock 的获取次数(包含 reentrant 的次数) */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>       </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">// 将字节向右移动 16位, 只剩下 原来的 高 16 位</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** 计算 writeLock 的获取的次数(包括 reentrant的次数) */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">// 与 EXCLUSIVE_MASK 与一下</span></span><br><span class="line"><span class="comment">// ...略</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>ReentrantReadWriterLock</code>使用一个32位的int类型来表示锁被占用的线程数（<code>state</code> 这个字段在<code>ReentrantLock</code>中代表同一个线程的加锁次数，采取的办法是，高16位用来表示<strong>读锁占有的线程数量</strong>，用低16位表示<strong>写锁被同一个线程申请的次数</strong>。这里留一个疑问，<strong>就是为什么要保存同一个线程的申请次数</strong></li></ul><h3><span id="sync-状态静态变量的含义">Sync 状态(静态变量的含义)</span></h3><ul><li><p><code>state</code>： 这个是在<code>AQS</code>的类中定义的，并没有在<code>ReentrantReadWriteLock</code>类的 <code>Sync</code>单独实现，表示了当前锁的状态。</p></li><li><p><code>SHARED_SHIFT</code>: 对32位的int进行分割 (对半 16) <code>SHARED_SHIFT</code>，表示读锁占用的位数，常量16, 也就是对上文的status字段表示分割。</p></li><li><p><code>SHARED_UNIT</code>: 如果增加一个读锁，按照上述设计，就相当于增加 <code>SHARED_UNIT</code>，其中的值为<code>000000000 00000001 00000000 00000000</code>。我们可以看到他的含义就是 将int的高16位作为一个单元，然后在这个单元上加上这个单元的1。</p></li><li><p><code>MAX_COUNT</code> : 表示申请读锁最大的线程数量，为65535。例：<code>000000000 00000000 11111111 11111111</code>。</p></li><li><p><code>EXCLUSIVE_MASK</code> :表示计算写锁的值使用的掩码，该值为15个1,用 <code>getState()</code> &amp; <code>EXCLUSIVE_MASK</code> 算出写锁的线程数。</p></li><li><p>举例说明</p><blockquote><p>现在当前，申请读锁的线程数为13个，写锁一个，那<code>state</code>怎么表示？<br>用一个32位的int类型的高16位表示读锁线程数，13的二进制为 <code>1101</code>,那<code>state</code>的二进制表示为<code>00000000 00001101 00000000 00000001</code>十进制数为 <code>851969</code>, 接下来要得到读锁和写锁的数量时，需要根据这个<code>851968</code>这个值得出上文中的 13 与 1。要算成13，只需要将<code>state</code> 无符号向左移位16位置，得出00000000 00001101，就出13，根据851969要算成低16位置，只需要用该<code>00000000 00001101 00000000 00000001</code> &amp; <code>111111111111111</code>（15位），就可以得出<code>00000001</code>,就是利用了1&amp;1得1,1&amp;0得0这个技巧。</p></blockquote></li></ul><h2><span id="readlock">ReadLock</span></h2><p>我们来看一下读锁的源码</p><h3><span id="核心代码">核心代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">      sync = lock.sync;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.acquireShared(<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;sync.releaseShared(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="加锁的方法为获取">加锁的方法为获取</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync 的获取共享锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 这里表示 是否有写锁在，如果有且不是当前线程， 则加锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 获得当前线程</span></span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获得读锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 这里表示 读锁是否应该阻塞 这里的方法是根据 公平和非公平的锁来实现的</span></span><br><span class="line">    <span class="comment">// 公平锁 是直接调用 hasQueuedPredecessors() </span></span><br><span class="line">    <span class="comment">// 非公平锁 直接调用的是  apparentlyFirstQueuedIsExclusive(); 方法</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        <span class="comment">// 读锁的数量 + 1</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 加锁之前 没有读锁 本线程是第一个</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录第一个读锁的线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果读锁 再次重入，那么读锁可重入的数量 ++</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的条件路径都失败，那么会继续调用fullTryAcquireShared方法。  </span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这段代码有几个问题：</p><ul><li>第一：为什么要记录第一把读锁 <code>firstReader</code>？</li><li>第二:<code>cachedHoldCounter</code> 是干什么用的？</li><li>第三:排队的阻塞策略是什么？</li><li>第四:<code>fullTryAcquireShared</code> 这个方法是干什么用的，为什么保底要执行这个方法？</li><li>第五:加锁之前为什么要 <code>tryAcquireShared</code> 为什么不能直接加锁么，之后 <code>doAcquireShared</code> 方法是做什么，为什么要有这一步？</li></ul><p>带着这几个问题，我们往下看</p><h3><span id="readholds-类cachedholdcounter-作用">readHolds 类（cachedHoldCounter 作用）</span></h3><ul><li>首先来解决第二个问题 <code>cachedHoldCounter</code> 是干什么用的？</li></ul><p>在Sync类当中有这么几个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br></pre></td></tr></table></figure><p>读写锁是要给多个线程调用的，也就是说，多个线程会同事操作同一个对象，每个线程如果读锁重入，就要记住没个线程对应重入了多少读锁。<code>HoldCounter</code> 相当于一个计数器。一次共享锁的操作就相当于在该计数器的操作。获取共享锁，则该计数器 + 1，释放共享锁，该计数器 - 1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以 <code>HoldCounter</code> 的作用就是当前线程持有共享锁的数量，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p><p><code>HoldCounter</code> 定义非常简单，就是一个计数器 <code>count</code> 和线程 <code>tid</code>两个变量。按照这个意思我们看到 <code>HoldCounter</code> 是需要和某给线程进行绑定了，我们知道如果要将一个对象和线程绑定仅仅有 <code>tid</code> 是不够的，而且从上面的代码我们可以看到 <code>HoldCounter</code> 仅仅只是记录了tid，根本起不到绑定线程的作用。那么怎么实现呢？答案是 <code>ThreadLocal</code>， 定义如下：</p><ul><li>ThradLocalHoldCounter 计数器</li></ul><p><code>ThradLocalHoldCounter</code> 继承了<code>ThreadLocal</code>,将 <code>HoldCounter</code> 绑定到当前线程上，同时 <code>HoldCounter</code> 也持有线程Id，这样在释放锁的时候才能知道 <code>ReadWriteLock</code> 里面缓存的上一个读取线程（<code>cachedHoldCounter</code>） 是否是当前线程。这样做的好处是可以减少 <code>ThreadLocal.get()</code>的次数，因为这也是一个耗时操作。需要说明的是这样 <code>HoldCounter</code> 绑定线程id而不绑定线程对象的原因是避免<code>HoldCounter</code> 和 <code>ThreadLocal</code>互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p><ul><li>为什么要记录第一把读锁 <code>firstReader</code> ？</li></ul><p>其实这个很好理解，有了上面 <code>cachedHoldCounter</code> 的解释，这里的 <code>firstReader</code> 第一个获取锁的线程也就好理解，一个是最后一个获取锁的线程，一个是第一个获取读锁的线程，这样做的目的就是为了性能考虑，实际上就是缓存。因为第一个和最后一个读锁在整个互斥链上有着比较重要的作用，在后边的代码中，我们可以看到他们的实际作用。</p><h3><span id="fulltryacquireshared-自旋效应">fullTryAcquireShared 自旋效应</span></h3><p>齐次，<code>fullTryAcquireShared</code> 这个方法是干什么用的，为什么保底要执行这个方法？？</p><p>我们来看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">  HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">/* 如果当前持有写锁的是本线程，那么应该让继续去获取读锁，否则一旦返回，改线程睡眠，则会导致死锁 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">      <span class="comment">// 这里的 firstReader 的作用就出来了，这里firstReader的缓存可以有效的帮助</span></span><br><span class="line">      <span class="comment">// 快速的判断 读线程是否需要阻塞</span></span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          这里的代码是本线程应该排队的情况，如果最后一个获取读锁的线程不是本线程</span></span><br><span class="line"><span class="comment">          意味着，这个读线程应该排队。</span></span><br><span class="line"><span class="comment">          如果该线程的数量读锁的数量为0 证明没有以前并没有获取过，那么本线程应该睡眠</span></span><br><span class="line"><span class="comment">          否则一旦发现 本线程确实有获取过读锁，那么不能睡眠（不能返回-1），重入锁要走的自选逻辑。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个读锁的线程</span></span><br><span class="line">            rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果没有人获取过读锁，或者上一个获取读锁的不是本线程</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                <span class="comment">// 拿到当前线程的计数器</span></span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">                <span class="comment">// 如果计数器 ==0 证明 该读锁已经没有获取过任何锁了，直接可以进入阻塞逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">// 如果计数器 ==0 证明 该读锁已经没有获取过任何锁了，直接可以进入阻塞逻辑</span></span><br><span class="line">          <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一下是正常的加锁逻辑，共享锁首锁缓存，数量+1 计数器+1 等等</span></span><br><span class="line">      <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">            cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码发现，这段代码和 <code>tryAcquireShared</code> 特别相似，相对于其，多加了一些额外的判断和一个for循环。从<code>tryAcquireShared</code> 中可以看到，调用到该方法的前提是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">    compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>1、<code>readerShouldBlock</code>失败，证明当前有写锁，失败。</li><li>2、<code>compareAndSetState</code> 失败，证明当前可能有读锁被抢占。</li></ul><p>有读写锁的特性可以得到，读锁之间是可以重入的。那么如果这两个有任意一个调用失败，我们都可以进行再次的尝试.如果再次尝试，写锁释放，我们既可以得到锁。<code>compareAndSetState</code>  失败，我们也可以再次尝试。当有上面两个条件任意一个失败的时候，我们让这个方法进入自旋状态，确保读锁可以有效的获取锁。</p><h3><span id="锁降级">锁降级</span></h3><p>在这段代码之前 我们还可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码的含义是，如果当前线程拥有写锁，但是又要去申请写锁，是允许的当写锁被持有时，</span></span><br><span class="line"><span class="comment">// 如果持有该锁的线程不是当前线程，就返回 “获取锁失败”，反之就会继续获取读锁。称之为锁降级。</span></span><br><span class="line"><span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>锁降级定义</strong>：重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</p></li><li><p><strong>锁降级的必要性</strong></p><p>我们来看一下这样的情景， 如果读锁不在写锁之后 进行降级 那么情况1 中的 线程获取和修改的值就会出现类脏读的问题</p><p>线程1 命名修改了 data = 1 但是由于 写锁后没有降级成读锁，导致data 被线程2 改成了 2</p></li></ul><table><thead><tr><th>时间序列</th><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td></td><td>获取写锁</td><td></td></tr><tr><td></td><td>更改数据 data = 1</td><td></td></tr><tr><td></td><td>释放写锁</td><td>获取写锁</td></tr><tr><td></td><td></td><td>data =2</td></tr><tr><td></td><td>处理数据</td><td></td></tr><tr><td></td><td></td><td>释放写锁</td></tr><tr><td></td><td>处理完毕</td><td></td></tr><tr><td></td><td>打印data = 2</td><td></td></tr><tr><td></td><td></td><td>打印data = 2</td></tr></tbody></table><p>读锁降级为写锁</p><table><thead><tr><th>时间序列</th><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td></td><td>获取写锁</td><td></td></tr><tr><td></td><td>获得读锁</td><td></td></tr><tr><td></td><td>更改数据 data = 1</td><td></td></tr><tr><td></td><td>释放写锁</td><td></td></tr><tr><td></td><td></td><td>获取写锁失败 阻塞</td></tr><tr><td></td><td>处理数据</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>处理完毕</td><td></td></tr><tr><td></td><td>打印data = 2</td><td></td></tr><tr><td></td><td>释放读锁</td><td>获取写锁 成功</td></tr></tbody></table><h3><span id="doacquireshared-正式加锁">doAcquireShared 正式加锁</span></h3><p>若发现当前的线程应该排队的时候，那么会正式进入以下代码，用于加锁。代码 和 <code>acquireQueued</code> 比较相似，可以参考 <a href="https://icefrozen.github.io/article/Java-AQS2/#sync-doacquiresharedinterruptibly-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)-Sync doAcquireSharedInterruptibly </a></p><p>这里只贴一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">              <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">              <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  setHeadAndPropagate(node, r);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  <span class="keyword">if</span> (interrupted)</span><br><span class="line">                      selfInterrupt();</span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 阻塞</span></span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">              parkAndCheckInterrupt())</span><br><span class="line">              interrupted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">          cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="readlockunlock-解锁流程">ReadLockUnlock 解锁流程</span></h3><h3><span id="核心代码">核心代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 首个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">// 读锁数量 -1 如果没有清空</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码我们知道，其实就只是做了状态的更改，更改statue 和每个线程的holder的数量，具体的解锁流程代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      Node h = head;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 如果头结点 是等待信号状态，那么意味着head 节点是阻塞的</span></span><br><span class="line">              <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              unparkSuccessor(h);     <span class="comment">// 唤醒线程</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">              <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doReleaseShared</code> 的方法 在<a href="https://icefrozen.github.io/article/Java-AQS2/#sync-doreleaseshared-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">JAVA多线程之AQS分析(2)-sync-doReleaseshared</a> 有详细的介绍<br>这里再次强调一下</p><ul><li><p>这里为什么要 拿到head？：因为共享锁是可以传播的，意思是如果某一个共享锁阻塞的线程被唤醒了，那么意味着排队链上的所有被共享节点阻塞的线程都应该被唤醒。</p></li><li><p>如果当前线程是排队链的第n个，那么当被唤醒的时候，我们要找到头部节点，如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功，将head链唤醒，当head被唤醒的时候，会执行 <code>setHeadAndPropagate</code> 这个方法，然后唤醒下一个被共享锁阻塞的线程。</p></li><li><p>如果头结点是当前线程，那就意味着头结点已经被唤醒了或者已经持有锁了，那么意味着已经做过唤醒其他的(<code>setHeadAndPropagate</code>)操作了。如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功</p></li></ul><p>至此，我们已经完整了解了读写锁的加锁流程。 那么我们剩下一个问题，就是：排队的策略是什么样子的？ 这就涉及到我们的写锁流程</p><h2><span id="writelock">WriteLock</span></h2><p>按照我们的传统，来看一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">      selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看到，加锁的流程会降级为普通排它锁，之所以可以这么做，完全可以无视上面的读写锁的互斥规则的原因就是，读锁的重入基本上是不会对阻塞链造成什么改变的，原因如下 在读锁<code>tryAcquireShared</code> 的方法有个<br><code>readerShouldBlock</code> 方法，这个方法是由公平锁和非公平锁的类实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">      * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">      * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">      * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">      * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">      * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="排队的策略">排队的策略</span></h3><ul><li>公平锁的 <code>readerShouldBlock</code> / <code>writerShouldBlock</code></li></ul><p>首先来看公平锁的 block 判定都是 <code>hasQueuedPredecessors</code> 这个方法。 这个方法的判断标准我们以前讨论过，就是看排队链有没有节点，也就是说，只有写锁<code>tryAcquire</code>失败了（注意，tryAcquire ！= 0 证明 有读锁占据高位置） 才会加入到队列当中，那么意味着，一旦加入排队，往后的读锁就要执行 <code>hasQueuedPredecessors</code> 方法的时候，就要排队了。</p><p><code>writerShouldBlock</code>也是一样，写锁要排到队列后边，两个写锁有先后关系。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(read)  -&gt; wl1(写锁1)  -&gt; rl1（读锁1） ... -&gt; wl2(写锁2)  ---&gt; other</span><br></pre></td></tr></table></figure><ul><li><p>非公平锁的 <code>readerShouldBlock</code>/ <code>writerShouldBlock</code>: 非公平锁的排队策略 在注释生已经说的很清楚了，我们来看一下这两段注释</p><blockquote><p>As a heuristic to avoid indefinite writer starvation,<br>block if the thread that momentarily appears to be head<br>of queue, if one exists, is a waiting writer.  This is<br>only a probabilistic effect since a new reader will not<br>block if there is a waiting writer behind other enabled<br>readers that have not yet drained from the queue.</p></blockquote></li></ul><blockquote><p>Returns {@code true} if the apparent first queued thread, if one<br>exists, is waiting in exclusive mode.  If this method returns<br>{@code true}, and the current thread is attempting to acquire in<br>shared mode (that is, this method is invoked from {@link<br>tryAcquireShared}) then it is guaranteed that the current thread<br>is not the first queued thread.  Used only as a heuristic in<br>ReentrantReadWriteLock.</p></blockquote><p>简单的来说就是，当代队里中的第一个节点（head 后的第一个节点 ）不是共享锁的时候，需要排序。换句话说，当队列中（head 后第一个元素）是写锁的时候，且写锁被阻塞了，那么这个时候，读锁就要排队，因为读锁必须要排在写锁侯彪，看代码已经很清晰了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node h, s;</span><br><span class="line">  <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      !s.isShared()         &amp;&amp;</span><br><span class="line">      s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>致辞，AQS的核心已经全部分享完毕了。总结如下</p><ol><li>AQS的排最节点氛围 共享和排他两种模式，共享锁的唤醒是由前一个节点来唤醒。</li><li>排它锁的阻塞由阻塞线程完成，但是前一个排他锁的阻塞状态是由阻塞线程完成的。</li><li>statue 不仅保存了读锁的数量，还保存了写锁的数量。</li><li>读锁可重入，一旦有写锁加入等待队列，意味着后面想要获取锁的操作（未获取过锁的）操作都需要排队。一旦写锁释放，后边的写锁就都会被唤醒。</li></ol><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/6923c126e762" target="_blank" rel="noopener">ReentrantReadWriteLock 源码分析(基于Java 8)</a></li><li><a href="https://www.jianshu.com/p/d47fe1ec1bb3" target="_blank" rel="noopener">【死磕Java并发】-----J.U.C之读写锁：ReentrantReadWriteLock</a></li><li><a href="https://www.cnblogs.com/stateis0/p/9062062.html" target="_blank" rel="noopener">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇（3）</title>
      <link href="/article/databases-lock/"/>
      <url>/article/databases-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="innodb-介绍">InnoDB 介绍</span></h2><h2><span id="innodb-中的锁">InnoDB 中的锁</span></h2><p>你可能听过各种各样的 InnoDB 的数据库锁，Gap 锁，共享锁，排它锁，读锁，写锁等等。但是 InnoDB 的标准实现的锁只有 2 类，<strong>一种是行级锁，一种是意向锁</strong>。</p><h3><span id="innodb的行级锁">InnoDB的行级锁：</span></h3><ul><li><strong>共享锁(读锁 S Lock)</strong>，允许事务读一行数据。</li><li><strong>排它锁(写锁 X Lock)</strong>，允许事务删除一行数据或者更新一行数据。<br>行级锁中，除了 S 和 S 兼容，其他都不兼容。</li></ul><h3><span id="innodb-支持两种意向锁即为表级别的锁">InnoDB 支持两种意向锁(即为表级别的锁)：</span></h3><ul><li><strong>意向共享锁(读锁 IS Lock)</strong>，事务想要获取一张表的几行数据的共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁(写锁 IX Lock)</strong>，事务想要获取一张表中几行数据的排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。</li></ul><p>首先解释一下意向锁，意向锁为了表明某个事务正在锁定一行或者将要锁定一行数据。<br>首先申请意向锁的动作是 InnoDB 完成的，怎么理解意向锁呢?</p><blockquote><p>例如：事务 A 要对一行记录 R 进行上 X 锁，那么 InnoDB 会先申请表的 IX 锁，再锁定记录 R 的 X 锁。在事务 A 完成之前，事务 B 想要来个全表操作，此时直接在表级别的 IX 就告诉事务 B 需要等待而不需要在表上判断每一行是否有锁。<br>意向排它锁存在的价值在于节约 InnoDB 对于锁的定位和处理性能。另外注意了，除了全表扫描以外意向锁都不会阻塞。</p></blockquote><h3><span id="意向锁的存在意义">意向锁的存在意义</span></h3><p>如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p><p>假设 我们有一张users表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td></tr><tr><td>2</td><td>lisi</td></tr></tbody></table><p>当事务A 想要更新id=2的user 的时候，会做以下操作</p><ol><li>DB引擎给表增加一个意向排它锁</li><li>事务A给id=2的行增加一个排它锁</li></ol><blockquote><p>这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！！</p></blockquote><p>此时若有事务B想获取 User表的共享锁（注意，这里是表级别的锁） 这个时候，因为是要锁表，所以意味着表中的所有数据都不能修改，但是此时A 已经对2 加了锁，所有如果没有意向锁，事务B 必须在获取表级别的共享锁的时候，检测每一行是否有排他锁。</p><p>但是一旦有了意向共享锁，所以事务B 因此不用每一行都扫描。</p><p>因此此时事务 B 检测事务 A 持有 users 表的意向排他锁，就可以得知事务 A 必然持有该表中某些数据行的排他锁，那么事务 B 对 users 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p><p>我们可以根据下表来看一下各个锁的兼容性</p><h3><span id="锁的兼容互斥性">锁的兼容互斥性</span></h3><p>看一下意向锁的排斥性</p><table><thead><tr><th></th><th><strong>意向共享锁（IS）</strong></th><th><strong>意向排他锁（IX</strong>）</th></tr></thead><tbody><tr><td><strong>意向共享锁（IS）</strong></td><td>兼容</td><td>兼容</td></tr><tr><td><strong>意向排他锁（IX）</strong></td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意义： 意向锁不会跟对意向锁产生排斥，这设计到表的并发。<br>举个例子：还是刚才的User 表<br>事务A 要对id = 2 的表进行更新，那么事务A 会产生两个效果</p><ol><li>表级别的意向排它锁</li><li>行级别的排他锁。<br>此时B 事务想更新 id = 1 的行,</li><li>首要获取User 的意向排它锁，</li><li>发现User 表已经有意向排它锁</li><li>但是意向排他锁是互相兼容的，因此，事务B 加锁成功</li><li>id = 1的数据行上不存在任何排他锁，最终事务 B 成功获取到了该数据行上的排他锁。</li></ol><p>意向锁对共享和排他锁的互斥性</p><table><thead><tr><th></th><th><strong>意向共享锁（IS）</strong></th><th><strong>意向排他锁（IX）</strong></th></tr></thead><tbody><tr><td><strong>共享锁（IS）</strong></td><td>兼容</td><td>互斥</td></tr><tr><td><strong>排他锁（IX）</strong></td><td>互斥</td><td>互斥</td></tr></tbody></table><h3><span id="锁的算法">锁的算法</span></h3><p>InnoDB 有 3 种行锁的算法：</p><ul><li><strong>Record Lock</strong>： 单个行记录上的锁。</li><li><strong>Gap Lock</strong>：    间隙锁，锁定一个范围，而非记录本身。</li><li><strong>Next-Key Lock</strong>：结合 Gap Lock 和 Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是 RR 隔离级别下的幻读。</li></ul><p><code>Next-Key Lock</code> 和 <code>Gap Lock</code> 的区别就是：会首先对索引（如果我们的查询语句命中索引记录的话）记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。<br>如果没有命中索引记录，则直接退化成 <code>Gap Lock</code></p><h4><span id="gap-lock-和-next-key-lock">Gap Lock 和 Next-Key Lock</span></h4><ul><li>产生间隙锁的条件（RR事务隔离级别下；）：<ul><li>使用普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引锁定多行记录。</li><li>不使用索引则加全局锁</li></ul></li><li>举例说明，假若我们有如下表</li></ul><table><thead><tr><th>id（主键）</th><th>v1（索引）</th><th>v2（无索引）</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>3</td><td>1</td></tr><tr><td>3</td><td>4</td><td>2</td></tr><tr><td>5</td><td>5</td><td>9</td></tr><tr><td>7</td><td>7</td><td>4</td></tr><tr><td>10</td><td>9</td><td>5</td></tr></tbody></table><p>间隙锁（Gap Lock）一般是针对非唯一索引而言的，test表中的v1（非唯一索引）字段值可以划分的区间为：<br><code>-∞,1）（1,3）（3,4）（4,5）（5,7）（7,9）（9, +∞）</code></p><p>假如要更新<code>v1=7</code>的数据行，锁定的区间是（5,7）和（7,9）。同时找到,v1=7的数据行的主键索引和非唯一索引，对key加上锁。</p><ul><li><p>插入锁</p><table><thead><tr><th>事物1</th><th>事物2</th></tr></thead><tbody><tr><td>UPDATE test set v2=10 where v1=7（加锁范围（5，9））</td><td></td></tr><tr><td></td><td>insert into test values(15,6,3)（阻塞））</td></tr><tr><td></td><td>insert into test values(9,9,3)（阻塞））</td></tr><tr><td></td><td>insert into test values(11,9,3)（成功））</td></tr><tr><td></td><td>insert into test values(4,5,3)（成功））</td></tr></tbody></table><p>看一下 插入图<br><img src="/article/databases-lock/1577760232986distributed-transaction_.png" alt></p></li><li><p>更新锁</p><table><thead><tr><th>事物1</th><th>事物2</th></tr></thead><tbody><tr><td>UPDATE test set v2=10 where v1=7（加锁范围（5，9））</td><td></td></tr><tr><td></td><td>update test set v1=6 where v1=5（阻塞））</td></tr><tr><td></td><td>update test set v1=9 where v1=7（阻塞））</td></tr><tr><td></td><td>update test set v1=10 where v1=9（成功））</td></tr></tbody></table><p>v1 = 6 相当于在 5 7 范围内加入</p></li></ul><h4><span id="锁选择">锁选择</span></h4><ul><li>1）、如果更新条件没有走索引，此时会进行全表扫描，扫表的时候，要阻止其<br>他任何的更新操作，所以上升为表锁。</li><li>2）如果更新条件为索引字段，但是并非唯一索引（包括主键索引）那么此时<br>更新会使用Next-Key Lock。使用Next-Key Lock的原因：<br>a）、首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；<br>b）、还要保证锁定的区间不能插入新的数据。</li><li>3）、如果更新条件为唯一索引，则使用Record Lock（记录锁）。</li></ul><h4><span id="锁应用">锁应用</span></h4><ul><li>在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。</li><li>InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。</li><li>由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。</li><li>当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。</li><li>InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。</li><li>InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5c0fc472e51d451ac27c47eb" target="_blank" rel="noopener">MySQL探秘(七):InnoDB行锁算法</a></li><li><a href="https://www.gaoyaxuan.net/blog/296.html" target="_blank" rel="noopener">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://cloud.tencent.com/developer/article/1100494" target="_blank" rel="noopener">扫盲贴-分布式数据一致性：两阶段提交，三阶段提交</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li><li><a href="https://my.oschina.net/tridays/blog/791124" target="_blank" rel="noopener">事务并发的可能问题与其解决方案 </a></li><li><a href="https://juejin.im/post/5c9040e95188252d92095a9e" target="_blank" rel="noopener">MySQL的可重复读级别能解决幻读吗</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">MySQL的InnoDB的幻读问题</a></li><li><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></li><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjE5NDQyOA==&amp;mid=2247483782&amp;idx=1&amp;sn=b5548efc354a04cf986709af4b7efdd8&amp;source=41#wechat_redirect" target="_blank" rel="noopener">MySQL探秘(六):InnoDB一致性非锁定读</a></li><li><a href="https://database.51cto.com/art/201904/594446.htm" target="_blank" rel="noopener">一文快速搞懂MySQL InnoDB事务ACID实现原理</a></li><li><a href="https://www.jianshu.com/p/1573c4dcecd6" target="_blank" rel="noopener">InnoDB逻辑存储结构</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483678&amp;idx=1&amp;sn=913780d42e7a81fd3f9b747da4fba8ec&amp;chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB数据页结构</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇(2)</title>
      <link href="/article/distributed-transaction-innodb/"/>
      <url>/article/distributed-transaction-innodb/</url>
      
        <content type="html"><![CDATA[<h2><span id="innobd-的数据结构">InnoBD 的数据结构</span></h2><h2><span id="innobd-中的数据结构概览">InnoBD 中的数据结构概览</span></h2><p>先来看一下 InnoDB 中的整体存贮逻辑<br><img src="/article/distributed-transaction-innodb/1575793726712distributed-transaction_.png" alt></p><p>MySQL 使用 InnoDB 存储表时，会将<strong>表的定义</strong>和<strong>数据索引</strong>等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。</p><h3><span id="frm-文件">.frm 文件</span></h3><p>无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。</p><h3><span id="ibd-文件">.ibd 文件</span></h3><p>InnoDB 中用于存储数据的文件总共有两个部分，一是<strong>系统表空间文件</strong>，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。<br>当打开 <code>innodb_file_per_table</code> 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p><h3><span id="数据结构分类">数据结构分类</span></h3><ul><li><p><strong>表空间Tablespace（ibd文件）</strong></p><p>新建一个数据库时，innodb存储引擎会初始化一个名为<code>ibdata1</code>的表空间文件，默认情况下，这个文件会存储所有表的数据，以及我们所熟知但看不到的系统表 sys_tables、sys_columns、sys_indexes 、sys_fields等。此外，还会存储<strong>用来保证数据完整性的回滚段数据</strong>，当然这部分数据在新版本的MySQL中，已经可以通过参数来设置回滚段的存储位置了；</p></li><li><p><strong>段Segment（一个索引2个段）</strong></p><p>段是表空间文件中的主要组织结构，它是一个逻辑概念，用来管理物理文件，是构成索引、表、回滚段的基本元素。<br>常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），<strong>因此数据即索引，索引即数据</strong>。那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。</p><p>创建一个索引（B+树）时会同时创建两个段，分别是内节点段和叶子段，内节点段用来管理（存储）B+树非叶子（页面）的数据，叶子段用来管理（存储）B+树叶子节点的数据；也就是说，在索引数据量一直增长的过程中，所有新的存储空间的申请，都是从“段”这个概念中申请的。</p></li><li><p><strong>簇(区)Extent（1MB）：64个Page</strong></p><p>簇是由64个连续的页组成的，<strong>每个页大小为16KB</strong>，<strong>即每个簇的大小为1MB</strong>。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</p><p>一个B+树节点就是一个页16KB,页的编号可以映射到物理文件偏移,B+树叶子节点前后形成双向链表,如下图</p><p><img src="/article/distributed-transaction-innodb/1575794673983distributed-transaction_.png" alt></p></li><li><p><strong>页Page（16KB）</strong>：</p><p>磁盘管理的最小单位,可以理解为簇的细化。页是InnoDB磁盘管理的最小单位。</p><p>页的本质就是一块16KB大小的存储空间，InnoDB为了不同的目的而把页分为不同的类型，其中用于存放记录的页也称为数据页</p><p>常见的页类型有：</p><ul><li>数据页（B-tree Node）。</li><li>Undo页（Undo Log Page）。</li><li>系统页（System Page）。</li><li>事务数据页（Transaction system Page）。</li><li>插入缓冲位图页（Insert Buffer Bitmap）。</li><li>插入缓冲空闲列表页（Insert Buffer Free List）。</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）。</li><li>压缩的二进制大对象页（Compressed BLOB Page）。<br>在逻辑上（页面号都是从小到大连续的）及物理上都是连续的。在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用；</li></ul></li></ul><h2><span id="innobd-page详解">InnoBD Page详解</span></h2><h3><span id="page和行结构结构">Page和行结构结构</span></h3><p><img src="/article/distributed-transaction-innodb/1575794929155distributed-transaction_.png" alt><br>为了更好的理解Page页的具体作用，我们先来看行记录格式<br>行记录格式 存放在 <code>UserRecords</code> 中，是从 <code>Free Space</code> 分配而来的</p><h4><span id="行记录格式">行记录格式</span></h4><ul><li><strong>行记录格式（Compact 格式）</strong></li></ul><p>想要了解 Page的结构，还需要从 行格式来说起。行记录记录在5.1版本的情况下，有 <code>Compact</code> 和 <code>Redundant</code> 格式两种情况,<code>Compact</code> 则是在5.0 的时候引入的。</p><p>另外还有其他两种结构 具体的请移步<a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483670&amp;idx=1&amp;sn=751d84d0ce50d64934d636014abe2023&amp;chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&amp;mpshare=1&amp;scene=23&amp;srcid=1210jEAAUuWPRLJ9u61XjZLl&amp;sharer_sharetime=1575964590022&amp;sharer_shareid=224e201559d0f0f2cae21cbf8a695c55%23rd" target="_blank" rel="noopener">InnoDB记录存储结构</a></p><p>下面我们主要是讲解 <code>Compact</code> 格式的行记录，结构如下：</p><p><img src="/article/distributed-transaction-innodb/1575875953139distributed-transaction_.png" alt></p><p>我们可以用 <code>show table status like 'sth'\G;</code> 来查看行结构</p><ul><li><p><strong>变长字段长度列表：</strong>  如果列的长度小于255字节，用1字节表示；如果大于255个字节，用2字节表示，也就是说，innodb 中的 <code>varchar</code> 不能超过 <code>65535</code> 个字节，因为有其他的字段，所以实际创建的 <code>varchar</code> 的具体只要比 <code>65535</code> 个字节少</p></li><li><p><strong>NULL标志位</strong>：表明该行数据是否有NULL值。占一个字节。该行明确定义了哪些列可以为空，一个字节</p></li><li><p><strong>记录头信息</strong>：固定占用5字节,每位的含义见下表：</p></li></ul><table><thead><tr><th>字段名</th><th>大小</th><th>字段含义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>标记该记录是否为B+树的非叶子节点中的最小记录</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前槽管理的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><strong>事务id</strong>  占6个字节</li><li><strong>回滚指针</strong> 占7 个字节</li><li><strong>row_id</strong> 如果没有置顶主键， 则会默认生成一个这个列 占6个字节</li></ul><p>我们下面里创建一张表：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>这个新创建的 <code>page_demo</code> 表有3个列，其中 c1 和 c2 列是用来存储整数的，c3 列是用来存储字符串的。</p><p>需要注意的是，我们把 c1 列指定为主键，所以在具体的行格式中MySQL就没必要为我们去创建那个所谓的 <code>row_id</code> 隐藏列了。而且我们为这个表指定了ascii字符集以及 <code>Compact</code> 的行格式。所以这个表中记录的行格式示意图就是这样的：</p><p><img src="/article/distributed-transaction-innodb/1575876493352distributed-transaction_.png" alt></p><p>我们插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>插入之后的结果如下：</p><p><img src="/article/distributed-transaction-innodb/1575887545816distributed-transaction-innodb_.png" alt></p><p>下面我们具体来分析一下 记录头信息 信息相关内容</p><ul><li><p><code>delete_mask</code> 表示是否删除，行记录可能被其他覆盖</p></li><li><p><code>min_rec_mask</code> 标记该记录是否为B+树的非叶子节点中的最小记录</p></li><li><p><code>n_owned</code>:   该记录管理的槽数量，见页目录章节</p></li><li><p><code>heap_no</code> ：<br>这个属性表示当前记录在本页中的位置，从图中可以看出来，我们插入的4条记录在本页中的位置分别是 2、3、4、5<br>而0和1 表示两条虚拟记录，最大的和最小的，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录</p><p>这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的</p><p><img src="/article/distributed-transaction-innodb/1575878951094distributed-transaction_.png" alt></p><p>由于这两条记录不是我们自己定义的记录，所以它们并不存放在页的<code>User Records</code>部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分，如图所示：</p><p><img src="/article/distributed-transaction-innodb/1575880203017distributed-transaction_.png" alt></p></li><li><p><code>record_type</code></p><p>这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 <code>record_type</code> 值都是0，而最小记录和最大记录的 <code>record_type</code> 值分别为2和3。</p><p>至于 <code>record_type</code> 为1的情况，我们之后在说索引的时候会重点强调的。</p></li><li><p><code>next_record</code><br>它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的<code>next_record</code>值为36，意味着从第一条记录的真实数据的地址处向后找36个字节便是下一条记录的真实数据。</p><p>如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 最小记录 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 最大记录 ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：</p></li></ul><p><img src="/article/distributed-transaction-innodb/1575880301031distributed-transaction_.png" alt></p><p>图中可以看出来，我们的记录按照从小到大的顺序形成了一个单链表。最大记录的next_record的值为0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM page_demo WHERE c1 = 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>删掉第2条记录后的示意图就是：</p><p><img src="/article/distributed-transaction-innodb/1575882481097distributed-transaction_.png" alt></p><p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：<br>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li><li>第2条记录的 <code>next_record</code> 值变为了0，意味着该记录没有下一条记录了。</li><li>第1条记录的 <code>next_record</code> 指向了第3条记录。还有一点你可能忽略了，就是最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。</li></ul><p>再来看一个有意思的事情，因为主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中, 那么2这个数据 就会复用原来的空间。</p><ul><li><p><strong>行溢出</strong></p><p>即使我们能存放65 532个字节了，但是有没有想过，InnoDB存储引擎的页为16KB，即16 384个字节，怎么能存放65 532个字节呢？一般情况下，数据都是存放在B-tree Node的页类型中，但是当发生行溢处时，则这个存放行溢处的页类型为Uncompress BLOB Page。</p></li></ul><p>我们来看个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (a <span class="built_in">varchar</span> (<span class="number">65532</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="keyword">repeat</span> (<span class="string">'a'</span>,<span class="number">65532</span>);</span><br></pre></td></tr></table></figure><p>下面的表空间文件:<br><img src="/article/distributed-transaction-innodb/1575895093171distributed-transaction-innodb_.png" alt></p><p>可以看到一个B-tree Node页类型，另外有4个为Uncompressed BLOB Page，这些页中才是真正存放了65 532个字节的数据。既然实际存放的数据都放到BLOB页中，那数据页中又存放了些什么东西呢？同样，通过之前的hexdump来读取表空间文件,可以看到，从0x0000c093到0x0000c392数据页面其实只保存了varchar（65 532）的前768个字节的前缀（prefix）数据（这里都是a），之后跟的是偏移量，指向行溢出页，也就是前面我们看到的Uncompressed BLOB Page。因此，对于行溢出数据，其存放方式下图4所示：<br><img src="/article/distributed-transaction-innodb/1575895129375distributed-transaction-innodb_.png" alt></p><p>CHAR很明确地被视为了变长类型，对于未能占满长度的字符还是填充0x20。</p><ul><li><strong>页目录</strong></li></ul><p>上边我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p><p><code>SELECT * FROM page_demo WHERE c1 = 3;</code></p><p><strong>顺序查找：</strong></p><p>从最小记录开始，沿着链表一直往后找，在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。<br>但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的。</p><p><strong>基于slot的查找</strong><br>因此基于目录的思想，innodBD 设计了如下的数据结构：</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的<strong>最后一条记录</strong>的头信息中的n_owned属性表示该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（英文名：Slot）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为<code>Page Directory</code>。</li></ul><p>比方说现在的 <code>page_demo</code> 表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：<br><img src="/article/distributed-transaction-innodb/1575884533564distributed-transaction_.png" alt></p><p>从这个图中我们需要注意这么几点：<br>现在Page Directory部分中有两个槽，也就意味着我们的记录被分成了两个组，槽0中的值是112，代表最大记录的地址偏移量；槽1中的值是99，代表最小记录的地址偏移量。</p><ul><li>注意最小和最大记录的头信息中的n_owned属性</li><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul><p>99和112这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：</p><p><img src="/article/distributed-transaction-innodb/1575884564248distributed-transaction_.png" alt></p><p>单纯从逻辑上看一下这些记录和页目录的关系，如下图<br><img src="/article/distributed-transaction-innodb/1575884591930distributed-transaction_.png" alt></p><p>设计InnoDB的设计师个分组中的记录条数是有规定的，对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。所以分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个。</li><li>在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到该组中了。</li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(5, 500, 'eeee'), </span><br><span class="line">(6, 600, 'ffff'), (7, 700, 'gggg'), </span><br><span class="line">(8, 800, 'hhhh'), (9, 900, 'iiii'), </span><br><span class="line">(10, 1000, 'jjjj'), (11, 1100, 'kkkk'), </span><br><span class="line">(12, 1200, 'llll'), (13, 1300, 'mmmm'), </span><br><span class="line">(14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');</span><br><span class="line">Query OK, 12 rows affected (0.00 sec)</span><br><span class="line">Records: 12  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>往表中添加了12条记录，现在就一共有16条正常的记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：<br><img src="/article/distributed-transaction-innodb/1575884726338distributed-transaction_.png" alt></p><p><strong>查找过程</strong></p><p>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。4个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为5的记录，过程是这样的：</p><ul><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 5，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4。所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为5的记录在槽1和槽2之间，接下来就是遍历链表的查找了。</li><li>所以在一个数据页中查找指定主键值的记录的过程分为两步：<br>通过二分法确定该记录所在的槽。<br>通过记录的 <code>next_record</code> 属性组成的链表遍历查找该槽中的各个记录。</li></ul><h3><span id="page结构的详细说明">Page结构的详细说明</span></h3><p>本章开始 我们已经介绍过了Page的信息，下面我们在来看一下每一页的具体细节。</p><p><img src="/article/distributed-transaction-innodb/1575794929155distributed-transaction_.png" alt></p><h4><span id="page-header">Page Header</span></h4><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>PAGE_N_DIR_SLOTS</code></td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td><code>PAGE_HEAP_TOP</code></td><td>2字节</td><td>第一个记录的地址</td></tr><tr><td><code>PAGE_N_HEAP</code></td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td><code>PAGE_FREE</code></td><td>2字节</td><td>指向可重用空间的地址（就是标记为删除的记录地址）</td></tr><tr><td><code>PAGE_GARBAGE</code></td><td>2字节</td><td>已删除的字节数，行记录结构中delete_flag为1的记录大小总数</td></tr><tr><td><code>PAGE_LAST_INSERT</code></td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td><code>PAGE_DIRECTION</code></td><td>2字节</td><td>最后插入的方向</td></tr><tr><td><code>PAGE_N_DIRECTION</code></td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td><code>PAGE_N_RECS</code></td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td><code>PAGE_MAX_TRX_ID</code></td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td><code>PAGE_LEVEL</code></td><td>2字节</td><td>当前页在索引树中的位置，高度</td></tr><tr><td><code>PAGE_INDEX_ID</code></td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td><code>PAGE_BTR</code></td><td>10字节</td><td>非叶节点所在段的segment header，仅在B+树的Root页定义</td></tr><tr><td><code>PAGE_LEVEL</code></td><td>10字节</td><td>B+树所在段的segment header，仅在B+树的Root页定义</td></tr></tbody></table><h4><span id="file-header">File Header</span></h4><p><img src="/article/distributed-transaction-innodb/1575966669980distributed-transaction-innodb_.png" alt></p><ul><li>FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p><ul><li>FIL_PAGE_OFFSET</li></ul><p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。</p><ul><li>FIL_PAGE_TYPE</li></ul><p>这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，本集中介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><p><img src="/article/distributed-transaction-innodb/1575966710639distributed-transaction-innodb_.png" alt></p><ul><li>FIL_PAGE_PREV和FIL_PAGE_NEXT</li></ul><p>一张表中可以有成千上万条记录，一个页只有16KB，所以可能需要好多页来存放数据，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的数据页是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：<br><img src="/article/distributed-transaction-innodb/1575966768836distributed-transaction-innodb_.png" alt></p><h4><span id="freespace">FreeSpace</span></h4><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下</p><p><img src="/article/distributed-transaction-innodb/1575875117094distributed-transaction_.png" alt></p><h3><span id="file-header">File Header</span></h3><p>对于这个部分，我的理解比较简单，我们知道InnoDB 会把数据从内存刷新到磁盘，中间交互的单位是页 ，但是我们想想，假如再刷新到磁盘的时候出现了问题，这样的话怎么办呢？<br>​这就是File Trailer 作用，这个部分由8个字节组成，可以分成2个小部分：</p><ul><li>前四个字节代表页的检验和：</li></ul><p>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错；</p><ul><li>后四个字节代表日志序列位置（LSN）这个部分也是为了校验页的完整性的，可以先不用管这个属性。</li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.gaoyaxuan.net/blog/296.html" target="_blank" rel="noopener">快速理解脏读、不可重复读、幻读</a></li><li><a href="https://cloud.tencent.com/developer/article/1100494" target="_blank" rel="noopener">扫盲贴-分布式数据一致性：两阶段提交，三阶段提交</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">常用的分布式事务解决方案</a></li><li><a href="https://my.oschina.net/tridays/blog/791124" target="_blank" rel="noopener">事务并发的可能问题与其解决方案 </a></li><li><a href="https://juejin.im/post/5c9040e95188252d92095a9e" target="_blank" rel="noopener">MySQL的可重复读级别能解决幻读吗</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">MySQL的InnoDB的幻读问题</a></li><li><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></li><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://database.51cto.com/art/201904/594446.htm" target="_blank" rel="noopener">一文快速搞懂MySQL InnoDB事务ACID实现原理</a></li><li><a href="https://www.jianshu.com/p/1573c4dcecd6" target="_blank" rel="noopener">InnoDB逻辑存储结构</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483678&amp;idx=1&amp;sn=913780d42e7a81fd3f9b747da4fba8ec&amp;chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB数据页结构</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MYSQL </tag>
            
            <tag> 事物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka系列</title>
      <link href="/article/kafka/"/>
      <url>/article/kafka/</url>
      
        <content type="html"><![CDATA[<h2><span id="kafka概述">Kafka概述</span></h2><h2><span id="kafka-定义">Kafka 定义</span></h2><p>Kafka 是一个分布式的基于发布/订阅模式的消息队列(Message Queue)，主要应用于 大数据实时处理领域。</p><h2><span id="消息队列好处">消息队列好处</span></h2><p>可以参考我的另一篇博文<a href="https://icefrozen.github.io/article/why-mq/" target="_blank" rel="noopener">MQ可以解决哪些实际问题</a></p><h2><span id="优缺点">优缺点</span></h2><ul><li><p>优点：</p><ul><li>可扩展。Kafka集群可以透明的扩展，增加新的服务器进集群。</li><li>高性能。Kafka性能远超过传统的ActiveMQ、RabbitMQ等，Kafka支持Batch操作。</li><li>容错性。Kafka每个Partition数据会复制到几台服务器，当某个Broker失效时，Zookeeper将通知生产者和消费者从而使用其他的Broker。</li></ul></li><li><p>缺点：</p><ul><li>重复消息。Kafka保证每条消息至少送达一次，虽然几率很小，但一条消息可能被送达多次。</li><li>消息乱序。Kafka某一个固定的Partition内部的消息是保证有序的，如果一个Topic有多个Partition，partition之间的消息送达不保证有序。</li><li>复杂性。Kafka需要Zookeeper的支持，Topic一般需要人工创建，部署和维护比一般MQ成本更高。</li></ul></li></ul><h2><span id="kafka应用场景">Kafka应用场景</span></h2><p>Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。在大数据领域的数据采集。离线数据采集等日志收集方面，Kafka几乎是规范。<br>两个作用：</p><ul><li><p>降低系统组网复杂度。<br>降低编程复杂度，各个子系统不在是相互协商接口，各个子系统类似插口插在插座上，Kafka承担高速数据总线的作用。</p></li><li><p>Kafka主要特点：</p><ol><li>同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。</li><li>可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。</li><li>分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。</li><li>消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。</li><li>支持online和offline的场景。</li></ol></li><li><p>Kafka的设计要点：</p><ol><li>直接使用linux 文件系统的cache，来高效缓存数据。</li><li>采用linux Zero-Copy提高发送性能。传统的数据发送需要发送4次上下文切换，采用sendfile系统调用之后，数据直接在内核态交换，系统上下文切换减少 为2次。根据测试结果，可以提高60%的数据发送性能。</li><li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="noopener">Zero-Copy详细的技术</a></li></ol></li></ul><h2><span id="kafka架构">Kafka架构</span></h2><h2><span id="kafka架构图">Kafka架构图</span></h2><p><img src="/article/kafka/1568778317608kafka_.png" alt></p><ol><li><strong>Producer</strong> :消息生产者，就是向 kafka broker 发消息的客户端;</li><li><strong>Consumer</strong> :消息消费者，向 kafka broker 取消息的客户端;</li><li><strong>Consumer Group (CG)</strong>:消费者组，由多个 consumer 组成。消费者组内每个消费者负 责消费不同分区的数据，一个分区只能由一个组内消费者消费;消费者组之间互不影响。所 有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker</strong> :一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li><li><strong>Topic</strong> :可以理解为一个队列，生产者和消费者面向的都是一个 topic;</li><li><strong>Partition</strong>:为了实现扩展性，一个非常大的 topic 可以分布到多个 broker(即服务器)上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列;</li><li><strong>Replica</strong>:副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本， 一个 leader 和若干个 follower。</li><li><strong>leader</strong>:每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对 象都是 leader。</li><li><strong>follower</strong>:每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据 的同步。leader 发生故障时，某个 follower 会成为新的 follower。</li></ol><h2><span id="kafka深入理解">Kafka深入理解</span></h2><h2><span id="kafka-生产者">Kafka 生产者</span></h2><h3><span id="kafka-工作流程及文件存储机制">Kafka 工作流程及文件存储机制</span></h3><p><img src="/article/kafka/1568778701466kafka_.png" alt><br>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。</p><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><h3><span id="kafka的日志存贮">Kafka的日志存贮</span></h3><p>在kafka的配置文件当中有个名叫<code>log.dirs=/opt/module/kafka/logs</code> 的配置文件，主要是存放的是 partition 用于存放日志文件<br>来看一下日志文件的分布图<br><img src="/article/kafka/1568963295967kafka_.png" alt></p><h4><span id="partiton的分布">partiton的分布</span></h4><p>下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：</p><p><img src="/article/kafka/1568948547101kafka_.png" alt></p><ul><li>(1)指明 <code>partition</code> 的情况下，直接将指明的值直接作为 <code>partiton</code> 值;</li><li>(2)没有指明 <code>partition</code> 值但有 key 的情况下，将 key 的 hash 值与 topic 的 <code>partition</code> 数进行取余得到 <code>partition</code> 值;</li><li>(3)既没有 <code>partition</code> 值又没有 key 值的情况下，第一次调用时随机生成一个整数(后 面每次调用在这个整数上自增)，将这个值与 topic 可用的 <code>partition</code> 总数取余得到 <code>partition</code> 值，也就是常说的<code>round-robin</code> 算法。</li></ul><h4><span id="ptopic中partition存储分布">ptopic中partition存储分布</span></h4><p>下面示意图形象说明了partition中文件存储方式:<br><img src="/article/kafka/1568953593516kafka_.png" alt></p><p>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</p><p>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</p><ul><li><p><strong>partiton中segment文件存储结构</strong></p><ul><li><p>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.</p></li><li><p>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</p></li></ul><p>建一个topicXXX包含1 partition，设置每个segment大小为500MB,并启动producer向Kafka broker写入大量数据,如下图2所示segment文件列表形象说明了上述2个规则：</p><p><img src="/article/kafka/1568953760884kafka_.png" alt></p><p>接下来我们看一下 kafka segment 文件的详解：<br><img src="/article/kafka/1568953908892kafka_.png" alt></p><p>上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。 其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。</p><p>从上述图3了解到segment data file由许多message组成，下面详细说明message物理结构如下：<br><img src="/article/kafka/1568954000231kafka_.png" alt></p><table><thead><tr><th>关键字</th><th>解释说明</th></tr></thead><tbody><tr><td>8 byte offset</td><td>在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td></tr><tr><td>4 byte message size</td><td>message大小</td></tr><tr><td>4 byte CRC32</td><td>用crc32校验message</td></tr><tr><td>1 byte “magic”</td><td>表示本次发布Kafka服务程序协议版本号</td></tr><tr><td>1 byte “attributes”</td><td>表示为独立版本、或标识压缩类型、或编码类型。</td></tr><tr><td>4 byte key length</td><td>表示key的长度,当key为-1时，K byte key字段不填</td></tr><tr><td>K byte key</td><td>可选</td></tr><tr><td>value bytes payload</td><td>表示实际消息数据。</td></tr></tbody></table></li></ul><h4><span id="在partition中如何通过offset查找message"><strong>在partition中如何通过offset查找message</strong></span></h4><p>例如读取offset=368776的message，需要通过下面2个步骤查找。</p><ul><li><p>第一步查找segment file 上述图2为例，其中00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1.同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset <strong>二分查找</strong>文件列表，就可以快速定位到具体文件。 当offset=368776时定位到00000000000000368769.index|log</p></li><li><p>第二步通过segment file查找message 通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</p></li></ul><p>这样做的优点，segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p><h3><span id="数据可靠性保证">数据可靠性保证</span></h3><ul><li><strong>副本数据同步策略以及</strong></li></ul><p>为了提高消息的可靠性，Kafka每个topic的partition有N个副本（replicas），其中N(大于等于1)是topic的复制因子（replica fator）的个数。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个broker失效情况下仍然保证服务可用。</p><p>在Kafka中发生复制时确保partition的日志能有序地写到其他节点上，N个replicas中，其中一个replica为leader，其他都为follower, leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。</p><p>假设我们有3个border, id 分别为 0,1,2,分别将信息放在 border0, border1, border2 目录下。此时我们创建一个 my-replicated-topic主题 我们将topic 分为3个分区和3个副本执行</p><blockquote><p>bin/kafka-topics.sh --create --bootstrap-server localhost:9000 --replication-factor 3 --partitions 3 --topic my-replicated-topic<br>然后我们查看一下 topic 的分布情况</p></blockquote><blockquote><p>bin/kafka-topics.sh --describe --bootstrap-server localhost:9000 --topic my-replicated-topic</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Topic:my-replicated-topicPartitionCount:3ReplicationFactor:3Configs:segment.bytes=536870912</span><br><span class="line">Topic: my-replicated-topicPartition: 0Leader: 2Replicas: 2,1,0Isr: 0,1,2</span><br><span class="line">Topic: my-replicated-topicPartition: 1Leader: 1Replicas: 1,0,2Isr: 0,1,2</span><br><span class="line">Topic: my-replicated-topicPartition: 2Leader: 0Replicas: 0,2,1Isr: 0,1,2</span><br></pre></td></tr></table></figure><blockquote><p>我来解释一下 Partition 0 ,代表0号分区，由于我们有3个分区和3个副本，所以Replicas中为 0号分区所在的border 分别为 2，1，0 而leader :2 代表2 好分区负责读写 至于这里头个ISR 后面在继续分析</p></blockquote><ul><li><strong>ACK应答机制</strong></li></ul><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack(acknowledgement 确认收到)，如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="/article/kafka/1568964462017kafka_.png" alt></p><p>kafka 提供了三种ACK机制</p><ul><li><p>0:producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据;</p></li><li><p>1:producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据;</p></li><li><p>-1(all):producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p></li><li><p><strong>ISR机制</strong><br>上述过程有个问题，即当ack设置为all的时候，leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢?</p><p>在zk中会保存AR（Assigned Replicas）列表，其中包含了分区所有的副本，其中 AR = ISR+OSR</p><p><strong>ISR（in sync replica）</strong>：</p><p>是kafka动态维护的一组同步副本，在ISR中有成员存活时，只有这个组的成员才可以成为leader，内部保存的为每次提交信息时必须同步的副本（acks = all时），每当leader挂掉时，在ISR集合中选举出一个follower作为leader提供服务，当ISR中的副本被认为坏掉的时候，会被踢出ISR，当重新跟上leader的消息数据时，重新进入ISR。</p><p>当然 ISR 在这里可以认为是活跃度border节点，当ack=all 的时候，只要保证所有isr中的节点同步完毕之后，就可以回复ACK消息。</p><p>kafka 会自己维护ISR里面border节点。kafka会根据中zk中的数据对border的活跃性做一个判断</p><ul><li>第一点：一个节点必须维持和zk的会话，通过zk的心跳检测实现</li><li>第二点：如果节点是一个slave也就是复制节点，那么他必须复制leader节点不能太落后。这里的落后可以指两种情况<ul><li>1：数据复制落后，slave节点和leader节点的数据相差较大，这种情况有一个缺点，在生产者突然发送大量消息导致网络堵塞后，大量的slav复制受阻，导致数据复制落后被大量的踢出ISR。</li><li>2：时间相差过大，指的是slave向leader请求复制的时间距离上次请求相隔时间过大。通过配置replica.lag.time.max就可以配置这个时间参数。这种方式解决了上述第一种方式导致的问题。</li></ul></li></ul></li></ul><blockquote><p>注意：最新的版本的kafka 已经干掉了 第一个中情况，采用了第二种时间的延迟的方式来维护ISR列表，原因是当kafka分批次发送消息，恰好这批消息是的 leader offset 大于ISR的临界值，那么kafka就会将所有的ISR 节点提出ISR列表，当同步完成之后，所有的follow 又和leader的值相等，这样就会将所有的节点加入ISR 这样一来，kafka 就会频繁的删减ISR列表</p></blockquote><p><strong>OSR（out sync replica）</strong>: 保存的副本不必保证必须同步完成才进行确认，OSR内的副本是否同步了leader的数据，不影响数据的提交，OSR内的follower尽力的去同步leader，可能数据版本会落后。</p><ul><li><strong>如果ISR内的全部副本挂掉怎么办？</strong><ul><li><p>服务直接不可用一段时间等待ISR中副本恢复</p><p>服务不可用方式这种适用在不允许消息丢失的情况下使用，适用于一致性大于可用性，可以有两种做法：</p><ul><li>设置ISR最小同步副本数量，如果ISR的当前数量大于设置的最小同步值，那么该分区才会接受写入，避免了ISR同步副本过少。如果小于最小值那么该分区将不接收写入。这个最小值设置只有在acks = all的时候才会生效。</li></ul></li><li><p>禁用unclean-leader选举，当isr中的所有副本全部不可用时，不可以使用OSR 中的副本作为leader，直接使服务不可用，直到等到ISR 中副本恢复再进行选举leader。</p></li></ul></li></ul><p>直接选择第一个副本作为leader的方式，适用于可用性大于一致性的场景，这也是kafka在isr中所有副本都死亡了的情况采用的默认处理方式，我们可以通过配置参数<code>unclean.leader.election.enable</code>来禁止这种行为，采用第一种方法。</p><ul><li><strong>ISR同步机制</strong></li></ul><p><img src="/article/kafka/1568966813187kafka_.png" alt></p><ul><li><p><strong>base offset</strong>：起始位移，replica中第一天消息的offset</p></li><li><p><strong>HW</strong>：replica高水印值，副本中最新一条已提交消息的位移。leader 的HW值也就是实际已提交消息的范围，每个replica都有HW值，但仅仅leader中的HW才能作为标示信息。什么意思呢，就是说当按照参数标准成功完成消息备份（成功同步给follower replica后）才会更新HW的值，代表消息理论上已经不会丢失，可以认为“已提交”。(也可以理解为指的是消费者能见到的最大的 offset)</p></li><li><p><strong>LEO</strong>：日志末端位移，也就是replica中下一条待写入消息的offset，注意哈，是下一条并且是待写入的，并不是最后一条。</p></li></ul><p>所以HW代表已经完成同步的数据的位置，LEO代表已经写入的最新位置，只有HW位置之前的才是可以被外界访问的数据。<br>现在就来看一下之前，broker从收到消息到返回响应这个黑盒子里发生了什么。<br><img src="/article/kafka/1568967144894kafka_.png" alt></p><ul><li><p>(1)follower 故障<br>follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。</p></li><li><p>(2)leader 故障<br>leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的 更多数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。<br><strong>注意:这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p></li></ul><h3><span id="exactly-once-语义">Exactly Once 语义</span></h3><ul><li><p><strong>At Least Once and At Most Once</strong></p><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。</p></li><li><p><strong>At Least Once</strong></p><p>可以保证数据不丢失，但是不能保证数据不重复;相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p></li></ul><p>0.11 版本的 Kafka，引入了一项重大特性:幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即:<br><strong>At Least Once + 幂等性 = Exactly Once</strong></p><p>要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka<br>的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。</p><p>开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。</p><p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。</p><ul><li><strong>Exactly Once</strong></li></ul><h2><span id="kafka-生产者">Kafka 生产者</span></h2><h3><span id="消费方式">消费方式</span></h3><p>consumer 采用 pull(拉)模式从 broker 中读取数据。</p><p>pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数 据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有 数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><h3><span id="消费者组">消费者组</span></h3><p>Kafka 存在 <code>Consumer Group</code>的概念，也就是 <code>group.id</code> 一样的 Consumer，这些 Consumer 属于同一个<code>Consumer Group</code>，组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。<br>当然，每个分区只能由同一个消费组内的一个consumer来消费。那么问题来了，同一个 Consumer Group 里面的 Consumer 是如何知道该消费哪些分区里面的数据呢？<br><img src="/article/kafka/1569295480813kafka_.png" alt></p><h3><span id="分区分配策略">分区分配策略</span></h3><p>在 Kafka 内部存在两种默认的分区分配策略：Range 和 RoundRobin。当以下事件发生时，Kafka 将会进行一次分区分配：</p><ul><li>同一个 Consumer Group 内新增消费者</li><li>消费者离开当前所属的Consumer Group，包括shuts down 或 crashes</li><li>订阅的主题新增分区</li><li>将分区的所有权从一个消费者移到另一个消费者称为重新平衡（rebalance），如何rebalance就涉及到本文提到的分区分配策略。</li></ul><p>下面我们将详细介绍 Kafka 内置的两种分区分配策略。本文假设我们有个名为 T1 的主题，其包含了10个分区，然后我们有两个消费者（C1，C2）来消费这10个分区里面的数据，而且 C1 的 num.streams = 1，C2 的 num.streams = 2。</p><p>Kafka 有两种分配策略，一是 <code>RoundRobin</code>，一是 <code>Range</code></p><ul><li>RoundRobin</li></ul><p><strong>使用RoundRobin策略有两个前提条件必须满足：</strong></p><ul><li>同一个Consumer Group里面的所有消费者的num.streams必须相等；</li><li>每个消费者订阅的主题必须相同。</li></ul><p>RoundRobin策略的工作原理：将<strong>所有主题</strong>的分区组成 TopicAndPartition 列表，然后对 TopicAndPartition 列表按照 hashCode 进行排序，然后按照轮询的方式进行分配</p><p><img src="/article/kafka/1569384344801kafka_.png" alt></p><ul><li>Range</li></ul><p><strong>Range策略是对每个主题而言的</strong></p><ul><li>首先对同一个主题里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。</li><li>在我们的例子里面，排完序的分区将会是0, 1, 2, 3, 4, 5, 6, 7, 8, 9；消费者线程排完序将会是C1-0, C2-0, C2-1。</li><li>然后将partitions的个数除于消费者线程的总数来决定每个消费者线程消费几个分区。</li><li>如果除不尽，那么前面几个消费者线程将会多消费一个分区。</li></ul><p>在我们的例子里面，我们有10个分区，3个消费者线程， 10 / 3 = 3，而且除不尽，那么消费者线程 C1-0 将会多消费一个分区，所以最后分区分配的结果看起来是这样的：</p><blockquote><p>C1-0 将消费 0, 1, 2, 3 分区</p></blockquote><blockquote><p>C2-0 将消费 4, 5, 6 分区</p></blockquote><blockquote><p>C2-1 将消费 7, 8, 9 分区</p></blockquote><p>假如我们有2个主题(T1和T2)，分别有10个分区，那么最后分区分配的结果看起来是这样的：</p><blockquote><p>C1-0 将消费 T1主题的 0, 1, 2, 3 分区以及 T2主题的 0, 1, 2, 3分区</p></blockquote><blockquote><p>C2-0 将消费 T1主题的 4, 5, 6 分区以及 T2主题的 4, 5, 6分区</p></blockquote><blockquote><p>C2-1 将消费 T1主题的 7, 8, 9 分区以及 T2主题的 7, 8, 9分区</p></blockquote><p>可以看出，C1-0 消费者线程比其他消费者线程多消费了2个分区，这就是Range strategy的一个很明显的弊端。</p><p><img src="/article/kafka/1569384264366kafka_.png" alt></p><h3><span id="offset">Offset</span></h3><h4><span id="offset-存贮">Offset 存贮</span></h4><p>在kafka 0.9版本之后，kafka为了降低zookeeper的io读写，减少network data transfer，也自己实现了在kafka server上存储consumer，topic，partitions，offset信息将消费的 offset 迁入到了 Kafka 一个名为 __consumer_offsets 的Topic中。<br>offset提交消息会根据消费组的key(消费组名称)进行分区. 对于一个给定的消费组,它的所有消息都会发送到唯一的broker,<br>这对offset的抓取请求会更加容易,因为不需要以分散-收集的方式对多个brokers发送请求并收集结果(只针对一个broker).</p><h4><span id="offset-提交方式">Offset 提交方式</span></h4><ul><li><p>自动提交</p><p>Kafka中偏移量的自动提交是由参数<code>enable_auto_commit</code>和<code>auto_commit_interval_ms</code>控制的，当<code>enable_auto_commit=True</code>时，Kafka在消费的过程中会以频率为<code>auto_commit_interval_ms</code>向Kafka自带的topic(__consumer_offsets)进行偏移量提交，具体提交到哪个Partation是以算法：<code>partation=hash(group_id)%50</code>来计算的。</p><blockquote><p>如：group_id=test_group_1，则partation=hash(“test_group_1”)%50=28</p></blockquote></li><li><p>手动提交</p><p>对于自动提交偏移量，如果auto_commit_interval_ms的值设置的过大，当消费者在自动提交偏移量之前异常退出，将导致kafka未提交偏移量，进而出现重复消费的问题，所以建议auto_commit_interval_ms的值越小越好。</p><p>鉴于Kafka自动提交offset的不灵活性和不精确性(只能是按指定频率的提交)，Kafka提供了手动提交offset策略。手动提交能对偏移量更加灵活精准地控制，以保证消息不被重复消费以及消息不被丢失。</p><p>对于手动提交offset主要有3种方式：</p><ol><li><p>同步提交 (consumer.commitSync())</p><p>虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞<br>吐量会收到很大的影响。因此更多的情况下，会选用异步提交 offset 的方式。</p></li><li><p>异步提交   consumer.commitAsync()</p></li></ol></li></ul><p>无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先<br>提交 offset 后消费，有可能造成数据的漏消费;而先消费后提交 offset，有可能会造成数据 的重复消费。</p><ul><li><p>自动管理</p><p>Kafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的 topic 中。除此之外，Kafka 还可以选择自定义存储 offset。<br>offset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace。</p><ul><li><p>当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发 生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance。</p></li><li><p>消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费</p></li></ul><p>kafka 提供了ConsumerRebalanceListener 类来监控 rebanlace</p><ul><li>当我们发生rebanlace 的时候需要将将offset 从落地库中取出来，最典型的应用就是将消息的落地和offset的提交做成一个事物。</li></ul></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/lizhitao/article/details/41778193" target="_blank" rel="noopener">Kafka集群partitions/replicas默认分配解析</a></li><li><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html" target="_blank" rel="noopener">Kafka文件存储机制那些事</a></li><li><a href="https://juejin.im/post/5c46e729e51d452c8e6d5679" target="_blank" rel="noopener">kafka-如何保证消息的可靠性与一致性</a></li><li><a href="https://juejin.im/post/5ccffe886fb9a03239689e5c" target="_blank" rel="noopener">kafka副本同步机制</a></li><li><a href="https://blog.csdn.net/lizhitao/article/details/23744675" target="_blank" rel="noopener">apache kafka系列之在zookeeper中存储结构</a></li><li><a href="https://zqhxuyuan.github.io/2016/02/18/Kafka-Consumer-Offset-Manager/" target="_blank" rel="noopener">译：Kafka消费者的Offset管理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理篇(1)</title>
      <link href="/article/database-clustered-index/"/>
      <url>/article/database-clustered-index/</url>
      
        <content type="html"><![CDATA[<h2><span id="索引概诉">索引概诉</span></h2><p><img src="/article/database-clustered-index/1575439752430database-clustered-index_.png" alt></p><h2><span id="索引详解">索引详解</span></h2><h2><span id="常见的索引算法">常见的索引算法</span></h2><p><img src="/article/database-clustered-index/1575459371999database-clustered-index_.png" alt></p><h3><span id="平衡二叉树索引">平衡二叉树索引</span></h3><p>二叉树的查找的时间复杂度是O(log2N)，其查找效率与深度有关，而普通的二叉树可能由于内部节点排列问题退化成链表，这样查找效率就会很低。因此平衡二叉树是更好的选择，因为它保持平衡，即通过旋转调整结构保持最小的深度。其查找的时间复杂度也是O(log2N)。</p><p>但实际上，数据库中索引的结构也并非AVL树或更优秀的红黑树，尽管它的查询的时间复杂度很低。</p><h3><span id="那为什么平衡二叉树不适合作为索引呢">那为什么平衡二叉树不适合作为索引呢？</span></h3><p>索引是存在于索引文件中，是存在于磁盘中的。因为索引通常是很大的，因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页的数据到内存中。而这个磁盘的读取的速度较内存中的读取速度而言是差了好几个级别。</p><p>注意，我们说的平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组。然后<strong>由于在逻辑结构上相近的节点在物理结构上可能会差很远</strong>。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。</p><p>而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。</p><h3><span id="为什么-二叉树物理结构上可能相差很远">为什么 二叉树物理结构上可能相差很远？</span></h3><p>举个例子：</p><p><img src="/article/database-clustered-index/1575457059710database-clustered-index_.png" alt></p><p>二叉树就物理结构来分可以分成：<strong>顺序存储</strong>结构和<strong>链式存储</strong>结构。</p><ul><li><p><strong>1. 顺序存储结构</strong>：</p><p>顺序存储结构，顾名思义就是二叉树的数据元素存放在一组连续的存储单元中。其主要有一下几个特点：</p><ul><li><p>① 逻辑上相邻的两个元素在物理位置上也是相邻的；</p></li><li><p>② 操作删除和插入的时候，需要整体移动元素；</p></li><li><p>③ 需要预先分配空间，不能动态增长；</p><p>例如：</p></li></ul></li></ul><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>下标</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td></tr></tbody></table><ul><li><p><strong>1. 链式存储结构：</strong></p><p>链式存储结构中二叉树的每个结点至少包含三个域：数据域、左指针域和右指针域。其二叉树是通过指针实现，链式存储结构有以下几个特点：</p><ul><li><p>① 逻辑上相邻的两个元素在物理位置上不一定是相邻的；</p></li><li><p>② 操作删除和插入的时候，不需要整体移动元素；只需要修改相应的指针即可；</p></li><li><p>③ 不需要预先分配空间；</p></li><li><p>④ 存储指针本身会消耗一定的存储的空间；</p><p>基本数据如下：</p></li></ul></li></ul><table><thead><tr><th>下标</th><th>左孩子</th><th>数据</th><th>右孩子</th></tr></thead><tbody><tr><td></td><td>left_child</td><td>data</td><td>right_child</td></tr></tbody></table><p>树的保存如下：</p><p><img src="/article/database-clustered-index/1575457965850database-clustered-index_.png" alt></p><p>由于索引是有序的， 所有我们可以假定 左子树小于右子树<br>即 <code>B &lt; A &lt; C ， D &lt; B &lt; E</code></p><p>如果也强制用数组表示的话：如下（0 表示为空）</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td>(2,A,3)</td><td>(4,B,5)</td><td>(6,C,7)</td><td>(8,D,9)</td><td>(10,E,0)</td><td>(0,F,0)</td><td>(0,G,0)</td><td>(0,H,0)</td><td>(0,I,0)</td><td>(0,J,0)</td></tr></tbody></table><p>所有,如果我要查找H 这个字符，当我们判断到到 <code>H &lt; D</code> 的时候，因为H D相差不是很大， 但是在数组存贮相差甚远。</p><p>所以当我们加载 1 - 6 的数据块的时候，H所在的 7 - 10 数据库就无法加载到内存当中。 所以，当找到D 的时候，我们需要再次进行一次io 将7 - 10 的数据块加载到内存当中。额外消耗了一次io。</p><h3><span id="b树索引">B树索引</span></h3><p>B树是平衡多叉树，解决了查找深度的问题。红黑树（平衡二叉树）没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。</p><p>局部性原理与磁盘预读：</p><blockquote><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<br>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><blockquote><p>程序运行期间所需要的数据通常比较集中。<br>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p></blockquote><p>B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p><p>B 树的索引结构：</p><p><img src="/article/database-clustered-index/1575516048252database-clustered-index_.png" alt></p><h3><span id="b树的索引">B+树的索引</span></h3><p>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据</p><p>B+树索引结构</p><p><img src="/article/database-clustered-index/1575516240587database-clustered-index_.png" alt></p><h3><span id="b树索引-vs-b树索引">B+树索引 VS B树索引</span></h3><ul><li>B树必须用中序遍历的方法按序扫库。</li><li>而B+树直接从叶子结点挨个扫一遍就完了，</li><li>B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</li><li>B+树非叶子节点不存数据，这样可以使得每一页能存贮更多的索引，是的树高减少。</li></ul><p>数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p><h2><span id="索引的种类">索引的种类</span></h2><p>按照索数据的组织方式，我们可以分<strong>聚簇索引，非聚簇索引（辅助索引）</strong><br>按照索引的作用 可以分为 <strong>主键索引，唯一索引，单建索引，复合索引，全文索</strong>引等。</p><h3><span id="主键索引">主键索引</span></h3><ul><li>概念：主键索引是唯一的，通常以表的ID设置为主键索引,一个表只能有一个主键索引，这是他跟唯一索引的区别。</li></ul><p>在 InnoDB 内部，表数据是优化主键快速查询而排列分布的，其查找速度是最快的，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。即使表中没有适合做主键的列，也推荐采用一个自动增长的整数主键(代理键)，那么这个表在增加数据的时候是顺序存放的，而且后续在别的表参考该外键查询的时候也会得到优化。</p><ul><li><p>主键的选择：</p><ul><li>显示的定义主键</li><li>如果没有，则非空的唯一索引（Unique NOT NULL</li><li>InnoDB 存储引擎自动创建一个 6 个字节大小的指针，用户不能查看或访问。</li></ul></li><li><p>主键的插入：<br>主键的推荐是使用自增的ID, 自增 ID 在插入的时候可以保证相邻的两条记录可能在同一个数据块,在插入的时候，由于要维持id的有序性，当自增的ID在物理上也连续，那么可以有效的减少磁盘块的加载次数。</p></li></ul><p><img src="/article/database-clustered-index/1575601089292database-clustered-index_.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="唯一索引">唯一索引</span></h3><ul><li>概念：唯一索引主要用于业务上的唯一约束</li><li>和主键的区别：他跟主键索引的区别是，一个表可以有多个唯一索引</li><li>创建语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="单键索">单键索</span></h3><ul><li>概念：以某一个字段为索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3><span id="联合索引">联合索引</span></h3><ul><li>概念：两个或两个以上字段联合组成一个索引</li><li>比如我们有表 如下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">unique</span> <span class="keyword">key</span>(<span class="string">`uid`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/article/database-clustered-index/1575611856923database-clustered-index_.png" alt></p><p>我们可以看到， 联合索引的结构依然是一个B+ 数的结构，只不过每一个节点存放的值并不是单个值，而是多个值。 节点的排序是先按照第一个索引的顺存放，然后再按照第二个索引大小的值存放，因此在叶子节点的排列应该是</p><pre><code>&gt; (1,1) (1, 2) (2, 1) (2, 4) (3,1) (3,2)</code></pre><ul><li><p>最左前缀</p><p>因此 对于查询</p><p><code>SELECT * FROM USER where a=xxx and b=xxx</code></p><p>我们当然可以通过索引查找对应的数值，因为 a最左边的索引，如果我们想要查<br><code>SELECT * FROM USER where b=xxx</code> 的时候，我们发现 b 在两个叶子节点数据分别为  1 2 1  和 4 1 3  完全无序， 那么因此，就不可以索引查询。因此这句话的查询索引就失效了。</p><p>这就是最左匹配原则。</p></li><li><p>上述的联合索引还有什么好处。因为我们的a b 是联合有序，那么在a 已经确定的情况下，我们可以直接利用索引，返回b的有序结合，不需要额外的二次排序。<br>比如如下语句</p><p><code>SELECT * FROM USER where a=xxx order by b desc limit 3</code></p><p>在a确定的情况下 b 已经是有序的了，所以不需要回表查询。</p></li></ul><h3><span id="全文索引">全文索引</span></h3><p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。<br>开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况<br>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；<br>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;<br>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。<br>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p><h3><span id="索引的使用场景">索引的使用场景</span></h3><ol><li>当数据多且字段值有相同的值得时候用普通索引。</li><li>当字段多且字段值没有重复的时候用唯一索引。</li><li>当有多个字段名都经常被查询的话用复合索引。</li><li>普通索引不支持空值，唯一索引支持空值。</li><li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li><li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li><li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li><li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li><li>所以，会对增删改的执行减缓速度，</li><li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li><li>更新太频繁地字段不适合创建索引。</li><li>不会出现在where条件中的字段不该建立索引。</li></ol><h3><span id="索引组织方式">索引组织方式：</span></h3><ul><li>聚簇索引</li></ul><p>InnoDB 可以看做是聚集索引，因为它的 B+ 树的叶结点包含了完整的数据记录。InnoDB 的数据文件本身就是索引文件，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，<strong>InnoDB 的所有辅助索引都引用主键作为 data 域</strong>。</p><ul><li>非聚簇索引（辅助索引）</li></ul><p>而 MyISAM 方式 B+ 树的叶结点只是存储了数据的地址，故称为非聚集索引。MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址；在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。</p><h3><span id="区别和用法">区别和用法</span></h3><p><img src="/article/database-clustered-index/1575614217485database-clustered-index_.png" alt></p><p>聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，根据主键查询可以直接利用聚簇索引定位到所在记录。</p><p>而普通索引根据申明这个索引时候的列来构建，<strong>叶子节点存放的是这一行记录对应的主键的值，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。</strong> 如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/weixin_30531261/article/details/79312676" target="_blank" rel="noopener">一步步分析为什么B+树适合作为索引的结构</a></li><li><a href="https://juejin.im/post/5cf3d550f265da1b76388a34" target="_blank" rel="noopener">MySQL 索引的原理与应用：索引类型，存储结构与锁</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MYSQL </tag>
            
            <tag> 事物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(3)</title>
      <link href="/article/tcpip-tcpstatus/"/>
      <url>/article/tcpip-tcpstatus/</url>
      
        <content type="html"><![CDATA[<h2><span id="tcp-状态">TCP 状态</span></h2><p>一个TCP连接在它的生命周期内会有不同的状态。<br><img src="/article/tcpip-tcpstatus/1567651608053tcpip-tcpstatus_.png" alt></p><h3><span id="tcp状态图">TCP状态图</span></h3><p><img src="/article/tcpip-tcpstatus/1567653467803tcpip-tcpstatus_.png" alt></p><table>    <thead>        <tr>            <th>状态</th>            <th>描述</th>        </tr>    </thead>    <tbody>        <tr>            <td>LISTEN</td>            <td>等待来自远程TCP应用程序的请求</td>        </tr>        <tr>            <td>SYN_SENT</td>            <td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td>        </tr>        <tr>            <td>SYN-RECEIVED</td>            <td>该端点已经接收到连接请求并发送确认。                <br>该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td>        </tr>        <tr>            <td>ESTABLISHED</td>            <td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td>        </tr>        <tr>            <td>FIN_WAIT_1</td>            <td>等待来自远程TCP的终止连接请求或终止请求的确认</td>        </tr>        <tr>            <td>FIN_WAIT_2</td>            <td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td>        </tr>        <tr>            <td>CLOSE_WAIT</td>            <td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td>        </tr>        <tr>            <td>CLOSING</td>            <td>等待来自远程TCP的连接终止请求确认</td>        </tr>        <tr>            <td>LAST_ACK</td>            <td>等待先前发送到远程TCP的连接终止请求的确认</td>        </tr>        <tr>            <td>TIME_WAIT</td>            <td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td>        </tr>    </tbody></table><h3><span id="三次握手状态">三次握手状态</span></h3><h4><span id="closed">CLOSED：</span></h4><ul><li>起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。</li></ul><h4><span id="listen">LISTEN：</span></h4><ul><li>服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。</li></ul><h4><span id="syn_sent">SYN_SENT：</span></h4><ul><li>第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。</li></ul><h4><span id="syn_rcvd">SYN_RCVD：</span></h4><ul><li>第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即 SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。</li></ul><h4><span id="established">ESTABLISHED：</span></h4><ul><li>第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP 需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是 ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。</li></ul><h3><span id="四次回收状态">四次回收状态</span></h3><h4><span id="fin_wait_1">FIN_WAIT_1：</span></h4><ul><li>第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回 ACK 。调用 close() 第一次挥手就进入此状态。</li></ul><h4><span id="close_wait">CLOSE_WAIT：</span></h4><ul><li>接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送 ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。前面已经说过，TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入 LAST_ACK 状态。</li></ul><h4><span id="fin_wait_2">FIN_WAIT_2：</span></h4><ul><li>主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK 后进入此状态。</li></ul><h4><span id="last_ack">LAST_ACK：</span></h4><ul><li>被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。</li></ul><h4><span id="closing">CLOSING：</span></h4><ul><li>两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。</li></ul><h4><span id="time_wait">TIME_WAIT：</span></h4><ul><li>从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。主动关闭方在接收到被动关闭方的FIN请求后，发送成功给对方一个ACK后,将自己的状态由FIN_WAIT2修改为TIME_WAIT，而必须再等2倍 的MSL(Maximum Segment Lifetime,MSL是一个数据报在internetwork中能存在的时间)时间之后双方才能把状态 都改为CLOSED以关闭连接。目前RHEL里保持TIME_WAIT状态的时间为60秒。当然上述很多TCP状态在系统里都有对应的解释或设置,可见man tcp</li></ul><h3><span id="为什么建立连接协议是三次握手而关闭连接却是四次握手呢">为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</span></h3><ul><li>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><h3><span id="为什么time_wait状态还需要等2msl后才能返回到closed状态">为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</span></h3><ul><li>虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</li></ul><h2><span id="常用tcpip抓包命令">常用TCP/IP抓包命令</span></h2><table><thead><tr><th>命令</th><th>命令说明</th><th>命令返回结果</th></tr></thead><tbody><tr><td><code>netstat -an</code></td><td>查看哪些IP连接本机</td><td></td></tr><tr><td><code>netstat -nat|grep -i &quot;xx&quot;|wc -l</code></td><td>统计xx端口连接数</td><td></td></tr><tr><td><code>ps -ef|grep httpd|wc -l</code></td><td>统计httpd协议连接数</td><td></td></tr><tr><td><code>netstat -na|grep ESTABLISHED|wc -l</code></td><td>统计已连接上的，状态为established</td><td></td></tr><tr><td><code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</code></td><td>查看TCP网络连接情况</td><td></td></tr></tbody></table><h2><span id="tcp常见问题排查和解决">TCP常见问题排查和解决</span></h2><h3><span id="tcp的time_wait问题">TCP的TIME_WAIT问题</span></h3><ul><li><p>问题产生原因<br>由于主动关闭的一方在发送最后一个ACK后就会进入TIME_WAIT状态，并停留2MSL（Max Segment LifeTime）时间。所以，频繁的重复链接相同的IP地址，可能会导致大量的TIME_WAIT 状态。</p></li><li><p>五元组</p><p>网络中每个通信实体的 <code>socket</code> 是用一个三元组标识的。<strong>三元组指的是：协议族（地址族），网络地址、和传输层端口 （本文目前只介绍 Ipv4 ）。</strong></p><p>通信双方的一个连接是用网络五元组来标识的，它是由双方相同协议族的两个本地三元组合成的。**网络五元组指的是：协议族（地址族）、本地网络地址、本地端口、远程网络地址和远程端口。**上述五元组往往称为全相关。而三元组往往称为半相关</p><p>在监听的时候，协议 / 本地 IP/ 本地端口（监听端口）都是确定的，当收到客户端的报文时，远方 IP 就是报文的源 IP 地址，远方端口就是报文的源端口，这样一来五元组就确定了。</p><p>然后服务器进入处理阶段，需要开启一个新的线程与客户端交互，当然就需要确定一个新的五元组，这时候协议 / 本地 IP/ 远方 IP/ 远方端口都来自监听阶段确定的五元组，而本地端口会在 1024 以上随机选取 （不再使用监听端口，以便监听其他客户端的请求）。</p><p>客户端的话正好相反，在发送请求时采用随机的本地端口 ，而接受响应时采用服务器的源端口作为远方端口。</p><p><strong>如果占用本地端口过多，大量的新链接失败。</strong></p></li><li><p>查看TIME_WAIT的数量<br><code>netstat -n | awk '/^tcp/ {++S[$NF]} END { for(a in S) print(a,S[a])}'</code></p></li><li><p>短连接最大的缺点是将占用大量的系统资源，例如：本地端口、socket句柄。导致这个问题的原因其实很简单：<strong>tcp协议层并没有长短连接的概念，因此不管长连接还是短连接，连接建立-&gt;数据传输-&gt;连接关闭的流程和处理都是一样的</strong>。</p></li><li><p>TIME_WAIT的状态，持续的时间一般在1~4分钟，对于连接数不高的场景，1~4分钟其实并不长，对系统也不会有什么影响，但如果短时间内（例如1s内）进行大量的短连接</p></li><li><p>问题的调优</p></li></ul><ul><li>1）修改<strong>ipv4.ip_local_port_range</strong>，增大可用端口范围，但只能缓解问题，不能根本解决问题；</li><li>2）客户端程序中设置socket的SO_LINGER选项；</li><li>3）客户端机器打开tcp_tw_recycle和tcp_timestamps选项；<ul><li><strong>tcp_tw_reuse</strong>:让TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒- <strong>tcp_tw_recycle</strong>: 让TIME_WAIT尽快回收</li></ul></li><li>4）客户端机器设置tcp_max_tw_buckets为一个很小的值；</li><li><ol start="5"><li>客户端利用  shutdown() 替换 close()</li></ol></li></ul><h3><span id="tcp的close_wait问题">TCP的CLOSE_WAIT问题</span></h3><h3><span id="tcp-rst-复位报文">TCP RST 复位报文</span></h3><h4><span id="rst-复位">RST 复位</span></h4><p>RST表示复位，用来异常的关闭连接。发送RST包关闭连接时，不必等缓冲区的包都发出去（FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。TCP处理程序会在自己认为的异常时刻发送RST包。<br>举2种情况：</p><ul><li>a）C向S发起连接，但S之上并未监听相应的端口，这时S操作系统上的TCP处理程序会发RST包。（UDP没有连接，没有RST）</li><li>b）C和S已经正常建立连接，正在通讯时，C向S发送了FIN包要求关连接，S发送ACK后，C网断了，C通过若干原因放弃了这个连接（例如进程重启）。网络恢复之后，S又开始或重发数据包，C不知道这连接哪来的，就发RST包强制把连接关闭，S收到后会出现connect reset by peer错误。</li></ul><p>RST 出现的三种情况 TCP在下列三种情况下产生RST复位报文段。</p><ul><li><p>1.到不存在的端口的连接请求<br>　　产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在监听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息；而TCP则使用复位。</p></li><li><p>2.异常终止一个连接<br>　　终止一个连接的正常方式是一方发送FIN，这也称为有序释放，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是FIN来中途释放一个连接，这也称为异常释放。异常终止一个连接对应用程序来说有两个优点：（1）丢弃任何待发数据并立即发送复位报文段；（2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。</p></li><li><p>3.检测半关闭连接<br>　　如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。</p></li></ul><h4><span id="rst-复位攻击">RST 复位攻击</span></h4><p>A和服务器B之间建立了TCP连接，如果此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击。<br>伪造这样的TCP包能造成什么后果？</p><ul><li>1、假定C伪装成A发过去的包，这个包如果是RST包，冲区上所有数据B将会丢弃与A的缓，强制关掉连接。</li><li>2、如果发过去的包是SYN包，那么，B会表示A已经是正常连接却又来建新连接，B主动向A发个RST包，并在自己这端强制关掉连接。<br><strong>如何伪造成A发给B的包？</strong></li></ul><p>这里有两个关键因素，源端口和序列号。</p><p><strong>一个TCP连接都是四元组，由源IP、源端口、目标IP、目标端口唯一确定一个连接</strong>。所以，如果C要伪造A发给B的包，要在上面提到的IP头和TCP头，把源IP、源端口、目标IP、目标端口都填对。</p><ul><li><p>1）这里B作为服务器，IP和端口是公开的；</p></li><li><p>2）A是我们要下手的目标，IP当然知道，但A的源端口就不清楚了，因为这可能是A随机生成的。当然，如果能够对常见的OS如windows和linux找出生成source port规律的话，还是可以进行碰撞。</p></li><li><p>3）序列号问题是与滑动窗口对应的，伪造的TCP包里需要填序列号，如果序列号的值不在A之前向B发送时B的滑动窗口内，B是会主动丢弃的。所以我们要找到能落到当时的AB间滑动窗口的序列号。这个可以暴力解决，因为一个sequence长度是32位，取值范围0-4294967296，如果窗口大小像上图中我抓到的windows下的65535的话，只需要相除，就知道最多只需要发65537（4294967296/65535=65537）个包就能有一个序列号落到滑动窗口内。RST包是很小，IP头＋TCP头才40字节，算算我们的带宽就知道这实在只需要几秒钟就能搞定。</p></li><li><p>那么，序列号不是问题，源端口会麻烦点，如果各个操作系统不能完全随机的生成源端口，或者黑客们能通过其他方式获取到source port，RST攻击存在可能。</p></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://blog.csdn.net/hguisu/article/details/38700899" target="_blank" rel="noopener">TCP连接的状态详解以及故障排查</a></li><li><a href="https://www.cnblogs.com/cslunatic/p/3783281.html" target="_blank" rel="noopener">TCP/IP详解–TCP/IP连接各个状态转换分析</a></li><li><a href="https://blog.csdn.net/wenqian1991/article/details/40110703" target="_blank" rel="noopener">【Unix 网络编程】TCP状态转换图详解</a></li><li><a href="https://blog.csdn.net/yunhua_lee/article/details/8146830_" target="_blank" rel="noopener">tcp短连接TIME_WAIT问题解决方法大全（1）</a></li><li><a href="https://www.superltx.com/archives/56" target="_blank" rel="noopener">TCP安全——RST复位攻击简析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之深入分析synchronized原理和锁膨胀过程</title>
      <link href="/article/java-synchronized/"/>
      <url>/article/java-synchronized/</url>
      
        <content type="html"><![CDATA[<h2><span id="synchronized概述">synchronized概述</span></h2><p>synchronized 是锁同步的一个关键字，这里主要讲解这个关键的概念性的东西，不做扫盲。</p><h2><span id="特性">特性</span></h2><ul><li>可见性</li><li>有序性</li><li>可见性</li><li>原子性</li></ul><h2><span id="synchronized-优化历史">synchronized 优化历史</span></h2><h2><span id="锁膨胀详解">锁膨胀详解</span></h2><h2><span id="前言">前言</span></h2><p>上一篇文章介绍了多线程的概念及<code>synchronized</code>的使用方法<a href="https://link.juejin.im?target=https%3A%2F%2Fddnd.cn%2F2019%2F03%2F21%2Fjava-synchronized%2F" target="_blank" rel="noopener">《synchronized的使用（一）》</a>，但是仅仅会用还是不够的，只有了解其底层实现才能在开发过程中运筹帷幄，所以本篇探讨<code>synchronized</code>的实现原理及锁升级(膨胀)的过程。</p><h2><span id="synchronized实现原理">synchronized实现原理</span></h2><p><code>synchronized</code>是依赖于<code>JVM</code>来实现同步的，在同步方法和代码块的原理有点区别。</p><h3><span id="同步代码块">同步代码块</span></h3><p>我们在代码块加上<code>synchronized</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: getfield      #2                  // Field object:Ljava/lang/String;</span><br><span class="line">        <span class="number">4</span>: dup</span><br><span class="line">        <span class="number">5</span>: astore_1</span><br><span class="line">        <span class="number">6</span>: monitorenter</span><br><span class="line">        7: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       10: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">13</span>: dup</span><br><span class="line">       14: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       17: ldc           #6                  // String synSay----</span><br><span class="line">       19: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       22: invokestatic  #8                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       25: invokevirtual #9                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       31: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       34: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">37</span>: aload_1</span><br><span class="line">       <span class="number">38</span>: monitorexit</span><br><span class="line">       <span class="number">39</span>: goto          <span class="number">47</span></span><br><span class="line">       <span class="number">42</span>: astore_2</span><br><span class="line">       <span class="number">43</span>: aload_1</span><br><span class="line">       <span class="number">44</span>: monitorexit</span><br><span class="line">       <span class="number">45</span>: aload_2</span><br><span class="line">       <span class="number">46</span>: athrow</span><br><span class="line">       <span class="number">47</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">7</span>    <span class="number">39</span>    <span class="number">42</span>   any</span><br><span class="line">           <span class="number">42</span>    <span class="number">45</span>    <span class="number">42</span>   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">22</span>: <span class="number">7</span></span><br><span class="line">       line <span class="number">23</span>: <span class="number">37</span></span><br><span class="line">       line <span class="number">24</span>: <span class="number">47</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">48</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br><span class="line">     StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">       frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">         offset_delta = <span class="number">42</span></span><br><span class="line">         locals = [ class cn/T1, class java/lang/Object ]</span><br><span class="line">         stack = [ class java/lang/Throwable ]</span><br><span class="line">       frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">         offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现<code>synchronized</code>同步代码块是通过加<code>monitorenter</code>和<code>monitorexit</code>指令实现的。</p><p>每个对象都有个**监视器锁(<code>monitor</code>) **，当<code>monitor</code>被占用的时候就代表对象处于锁定状态，而<code>monitorenter</code>指令的作用就是获取<code>monitor</code>的所有权，<code>monitorexit</code>的作用是释放<code>monitor</code>的所有权，这两者的工作流程如下：</p><p><strong>monitorenter</strong>：</p><ol><li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li><li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li><li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，知道<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li></ol><p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p><h3><span id="同步方法">同步方法</span></h3><p>在方法上加上<code>synchronized</code>关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">6</span>: dup</span><br><span class="line">        7: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       10: ldc           #5                  // String synSay----</span><br><span class="line">       12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       15: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       18: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">       21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">       24: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">       27: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">21</span>: <span class="number">30</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br></pre></td></tr></table></figure><p>从字节码上看，加有<code>synchronized</code>关键字的方法，常量池中比普通的方法多了个<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>就是根据这个标识来实现方法的同步。</p><p>当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p><h3><span id="两种同步方式区别">两种同步方式区别</span></h3><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong>。</p><p>而 <code>synchronized</code> 同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。</p><p><strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong></p><p>线程获取、释放<code>monitor</code>的过程如下：</p><p><img src="/article/java-synchronized/1578390033012java-synchronized_.png" alt></p><p>线程尝试获取<code>monitor</code>的所有权，如果获取失败说明<code>monitor</code>被其他线程占用，则将线程加入到的<strong>同步队列</strong>中，等待其他线程释放<code>monitor</code>，<strong>当其他线程释放<code>monitor</code>后，有可能刚好有线程来获取<code>monitor</code>的所有权，那么系统会将<code>monitor</code>的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以<code>synchronized</code>是非公平锁</strong>。如果线程获取<code>monitor</code>成功则进入到<code>monitor</code>中，并且将其进入数<code>+1</code>。</p><blockquote><p>关于什么是公平锁、非公平锁可以参考一下美团技术团队写的<a href="https://link.juejin.im?target=https%3A%2F%2Ftech.meituan.com%2F2018%2F11%2F15%2Fjava-lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a></p></blockquote><p>到这里我们也清楚了<code>synchronized</code>的语义底层是通过一个<code>monitor</code>的对象完成，其实<code>wait</code>、<code>notiyf</code>和<code>notifyAll</code>等方法也是依赖于<code>monitor</code>对象来完成的，<strong>这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常</strong></p><h2><span id="java对象的组成">Java对象的组成</span></h2><p>我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？</p><p>为了解开这个疑问，我们需要进入<strong>Java虚拟机(JVM)</strong> 的世界。在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p><p><img src="/article/java-synchronized/1578390964423java-synchronized_.png" alt></p><h3><span id="对象头">对象头</span></h3><p>对象头的数据长度在<code>32</code>位和<code>64</code>位(未开启压缩指针)的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。对象头由以下三个部分组成：<br><img src="/article/java-synchronized/1578391080054java-synchronized_.png" alt></p><ul><li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li><li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li></ul><p>在<code>32</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>5</code>种中的一种。</p><p><img src="/article/java-synchronized/1578391108895java-synchronized_.png" alt></p><p>在<code>64</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>2</code>种中的一种。</p><p><img src="/article/java-synchronized/1578391116559java-synchronized_.png" alt></p><p>这里重点注意<strong>是否偏向锁</strong>和<strong>锁标志位</strong>，这两个标识和<code>synchronized</code>的锁膨胀息息相关。</p><h3><span id="实例数据">实例数据</span></h3><p>储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。</p><h3><span id="对齐填充">对齐填充</span></h3><p><code>HotSpot</code>虚拟机的对齐方式为<code>8</code>字节对齐，即一个对象必须为<code>8</code>字节的整数倍，如果不是，则通过这个对齐填充来占位填充。</p><h2><span id="synchronized锁膨胀过程">synchronized锁膨胀过程</span></h2><p>上文介绍的 “<code>synchronized</code>实现原理” 实际是synchronized实现<strong>重量级锁的原理</strong>，那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？</p><p><strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>，如图：</p><p><img src="/article/java-synchronized/1578391201137java-synchronized_.png" alt></p><p><img src="/article/java-synchronized/1578391213485java-synchronized_.png" alt></p><p>那锁的状态为其它状态的时候是不是就没用上<code>monitor</code>对象？答案:是的。</p><p>这也是<code>JVM</code>对<code>synchronized</code>的优化，我们知道重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以<code>JVM</code>对<code>synchronized</code>做了优化，<code>JVM</code>先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用<code>monitor</code>对象。当然<code>JVM</code>对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p><p>那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。</p><h3><span id="锁的优化">锁的优化</span></h3><h4><span id="自旋锁和自适应性自旋锁">自旋锁和自适应性自旋锁</span></h4><p><strong>自旋</strong>：当有个线程<code>A</code>去请求某个锁的时候，这个锁正在被其它线程占用，但是线程<code>A</code>并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程<code>A</code>可以尝试一直请求锁，没必要被挂起放弃<code>CPU</code>时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程<code>A</code>自旋指定的时间还没有获得锁，仍然会被挂起。</p><p><strong>自适应性自旋</strong>：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。</p><p>反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p><h4><span id="锁消除">锁消除</span></h4><p>锁消除是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p><h4><span id="锁粗化">锁粗化</span></h4><p>在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是<strong>为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁</strong>。</p><h4><span id="轻量级锁">轻量级锁</span></h4><p>所谓<strong>轻量级锁</strong>是相对于使用底层操作系统<code>mutex</code>互斥原语实现同步的<strong>重量级锁</strong>而言的，因为轻量级锁同步的<strong>实现是基于对象头的Mark Word</strong>。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。</p><p><strong>获取锁过程</strong>：</p><ol><li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为&quot;01&quot;状态，是否为偏向锁为&quot;0&quot;)</strong>，虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li></ol><p><img src="/article/java-synchronized/1578391357996java-synchronized_.png" alt></p><ol><li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li><li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li><li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为&quot;00&quot;，即表示此对象处于轻量级锁的状态。</strong>。</li></ol><p><img src="/article/java-synchronized/1578391371386java-synchronized_.png" alt></p><ol><li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为&quot;10&quot;，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li></ol><p><img src="/article/java-synchronized/1578391379352java-synchronized_.png" alt></p><p><strong>释放锁的过程</strong>：</p><ol><li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li><li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h4><span id="偏向锁">偏向锁</span></h4><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，<strong>进一步提高程序的运行性能</strong>。如果说轻量级锁是在无竞争的情况下使用<code>CAS</code>操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不用做了。<strong>偏向锁默认是开启的，也可以关闭</strong>。</p><p>偏向锁&quot;偏&quot;，就是&quot;偏心&quot;的&quot;偏&quot;，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p><strong>获取锁的过程</strong>：</p><ol><li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li><li>如果是可偏向锁，则<strong>检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code></strong>，如果是则执行同步块，否则执行步骤<code>3</code>。</li><li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li><li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li></ol><p><strong>锁释放的过程</strong>：</p><ol><li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li><li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li><li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)</strong>，以允许其他线程竞争，如果<strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁<strong>升级为轻量级锁状态(00)</strong>。</li></ol><p><img src="/article/java-synchronized/1578391391238java-synchronized_.png" alt></p><h3><span id="锁的转换过程">锁的转换过程</span></h3><p>锁主要存在<code>4</code>种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。<strong>需要注意锁可以升级，但是不可以降级。</strong></p><p><img src="/article/java-synchronized/1578391399369java-synchronized_.png" alt></p><p>这里盗个图，这个图总结的挺好的！(图被压缩过了 看不清，可以打开这个地址查看高清图<a href="https://link.juejin.im?target=http%3A%2F%2Fwx2.sinaimg.cn%2Flarge%2Fe0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg" target="_blank" rel="noopener">&gt;&gt;高清图&lt;&lt;</a>)</p><p><img src="/article/java-synchronized/java-synchronized-1598413598005.png" alt></p><h3><span id="三种锁的优缺点比较">三种锁的优缺点比较</span></h3><p><img src="/article/java-synchronized/java-synchronized-1598413582085.png" alt></p><h2><span id="参考">参考</span></h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Flkforce%2Farticle%2Fdetails%2F81128115%23%25E4%25B8%2580%25EF%25BC%258C%25E5%25AF%25B9%25E8%25B1%25A1%25E5%25A4%25B4" target="_blank" rel="noopener">Java的对象头和对象组成详解</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fliupeifeng3514%2Farticle%2Fdetails%2F79111565" target="_blank" rel="noopener">JVM（三）JVM中对象的内存布局详解</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fzhengbin%2Fp%2F6490953.html" target="_blank" rel="noopener">JVM——深入分析对象的内存布局</a></li><li><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f#heading-16" target="_blank" rel="noopener">啃碎并发（七）：深入分析Synchronized原理</a><br><a href="https://link.juejin.im?target=http%3A%2F%2Fbigdatadecode.club%2FJavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(2)</title>
      <link href="/article/Java-AQS2/"/>
      <url>/article/Java-AQS2/</url>
      
        <content type="html"><![CDATA[<h2><span id="aqs-共享功能的实现">AQS 共享功能的实现</span></h2><h2><span id="countdownlatch-的用法">CountDownLatch 的用法</span></h2><p>CountDownLatch，CountDownLatch 为 <code>java.util.concurrent</code>包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减 1 操作，并在计数器为 0 后调用 <code>await</code> 方法的线程被唤醒，从而实现多线程间的协作。它在多线程环境下的基本使用方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main thread 新建一个 CountDownLatch，并指制定一个初始大小 </span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 调用 await 方法后，main 线程将阻塞在这里，直到 countDownLatch 中的计数为 0 </span></span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"over"</span>);</span><br><span class="line"><span class="comment">//thread1</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread3</span></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line"><span class="comment">// 调用 countDown 方法，将计数减 1</span></span><br><span class="line">  countDownLatch.countDown();</span><br></pre></td></tr></table></figure><p>注意，线程 thread 1,2,3 各自调用 <code>countDown</code> 后，<code>countDownLatch</code>的计数为 <code>0，await</code> 方法返回，控制台输入“over”, 在此之前 main thread 会一直沉睡。<br>可以看到 <code>CountDownLatch</code> 的作用类似于一个“栏栅”，在 <code>CountDownLatch</code> 的计数为 0 前，调用 await 方法的线程将一直阻塞，直到 <code>CountDownLatch</code> 计数为 0，await 方法才会返回，<br>而 <code>CountDownLatch</code> 的 <code>countDown()</code> 方法则一般由各个线程调用，实现 <code>CountDownLatch</code> 计数的减 1。</p><h2><span id="countdownlatch-的实现">CountDownLatch 的实现</span></h2><h3><span id="构造函数">构造函数</span></h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和 <code>ReentrantLock</code> <code>类似，CountDownLatch</code> 内部也有一个叫做 <code>Sync</code> 的内部类，同样也是用它继承了 AQS。</p><h3><span id="await">await</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      <span class="comment">// 同理  tryAcquireShared 是实现类实现的 这一点和读写锁一样</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sync-共享锁">Sync 共享锁</span></h3><p>从方法名上看，这个方法的调用是响应线程的打断的，所以在前两行会检查下线程是否被打断。接着，尝试着获取共享锁，小于 0，表示获取失败，通过本系列的上半部分的解读， 我们知道 AQS 在获取锁的思路是，先尝试直接获取锁，如果失败会将当前线程放在队列中，按照 FIFO 的原则等待锁。而对于共享锁也是这个思路，如果和独占锁一致，这里的 <code>tryAcquireShared</code> 应该是个空方法，留给子类去判断，我们来看 <code>Sync</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123; setState(count);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState();&#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 state 变成 0 了，则返回 1，表示获取成功，否则返回 -1 则表示获取失败。</span></span><br><span class="line"><span class="comment">     * 看到这里，读者可能会发现， await 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 tryAcquireShared 呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，读者可能会发现， <code>await</code> 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 <code>tryAcquireShared</code> 呢？</p><p>回想下 <code>CountDownLatch</code> 的 <code>await</code> 方法是不是只能在主线程中调用？答案是否定的，<code>CountDownLatch</code> 的 <code>await</code> 方法可以在多个线程中调用，当 <code>CountDownLatch</code> 的计数器为 <code>0</code> 后，调用 <code>await</code> 的方法都会依次返回。 也就是说可以多个线程同时在等待 <code>await</code> 方法返回，所以它被设计成了实现 <code>tryAcquireShared</code> 方法，获取的是一个共享锁，锁在所有调用 <code>await</code> 方法的线程间共享，所以叫共享锁。</p><p>如果获取共享锁失败（返回了 -1，说明 <code>state</code> 不为 0，也就是 <code>CountDownLatch</code> 的计数器还不为 0），进入调用 <code>doAcquireSharedInterruptibly</code> 方法中，按照我们上述的猜想，应该是要将当前线程放入到队列中去。</p><p>在这之前，我们再回顾一下 AQS 队列的数据结构：AQS 是一个双向链表，通过节点中的 next，pre 变量分别指向当前节点后一个节点和前一个节点。其中，每个节点中都包含了一个线程和一个类型变量：表示当前节点是独占节点还是共享节点，头节点中的线程为正在占有锁的线程，而后的所有节点的线程表示为正在等待获取锁的线程。</p><p><img src="/article/Java-AQS2/1563765045994java-AQS_.png" alt></p><p>黄色节点为头节点，表示正在获取锁的节点，剩下的蓝色节点（Node1、Node2、Node3）为正在等待锁的节点，他们通过各自的 next、pre 变量分别指向前后节点，形成了 AQS 中的双向链表。每个线程被加上类型（共享还是独占）后便是一个 Node， 也就是本文中说的节点。<br>我再来看 <code>doAcquireSharedInterruptibly</code> 方法</p><h3><span id="sync-doacquiresharedinterruptibly-方法">Sync doAcquireSharedInterruptibly 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); </span><br><span class="line"><span class="comment">// 将当前线程包装为类型为 Node.SHARED 的节点，标示这是一个共享节点。</span></span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="comment">// 如果新建节点的前一个节点，就是 Head，说明当前节点是 AQS 队列中等待获取锁的第一个节点，</span></span><br><span class="line">            <span class="comment">// 按照 FIFO 的原则，可以直接尝试获取锁。</span></span><br><span class="line">              <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">              <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  setHeadAndPropagate(node, r); </span><br><span class="line">              <span class="comment">// 获取成功，需要将当前节点设置为 AQS 队列中的第一个节点，这是 AQS 的规则</span></span><br><span class="line">              <span class="comment">// 队列的头节点表示正在获取锁的节点 </span></span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 检查下是否需要将当前节点挂起 </span></span><br><span class="line">              parkAndCheckInterrupt()) </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">          cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几点需要说明的：</p><ol><li>setHeadAndPropagate 方法：<br>调用 setHeadAndPropagate 的方法的前提是 当前线程已经获取到了锁，且是第一个排队的节点，意味着和他的head 为空节点，<br>当第一个排队的线程获取到了 锁之后， 首要的任务就是<br>1、将自己弄成头结点，然后清空自己的节点为null<br>2、然后判断排队自己后边排队的节点，如果是共享模式的，那么唤醒这个节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);  <span class="comment">//将自己弄成头结点，然后清空自己的节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sync-doreleaseshared-方法">Sync doReleaseShared 方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 这里为什么要 拿到head 因为共享锁是可以传播的，意思是如果某一个共享锁阻塞的线程被唤醒了</span></span><br><span class="line">      <span class="comment">// 那么意味着 排队链上的所有线程都应该被唤醒</span></span><br><span class="line">      <span class="comment">// 加入 当前线程是在 排队链的第n 个那么当唤醒的时候，我们要找到头部链</span></span><br><span class="line">      <span class="comment">// 如果 然后将head 链 唤醒，然后在 一次传播 </span></span><br><span class="line">      <span class="comment">// 如果 头结点是当前线程，那就意味着头结点已经被唤醒了或者已经持有锁了，那么意味着已经做过</span></span><br><span class="line">      <span class="comment">// 唤醒其他的操作了 详情看上面的代码 所有退出</span></span><br><span class="line">      <span class="comment">// 如果头结点是阻塞状态，那么自旋的去获取 ，知道解锁成功</span></span><br><span class="line">      Node h = head;</span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; </span><br><span class="line">              <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) </span><br><span class="line">            <span class="comment">// 如果当前节点是 SIGNAL 意味着，它正在等待一个信号 可以理解为在已经是阻塞状态了，  </span></span><br><span class="line">              <span class="comment">// 或者说，它在等待被唤醒，因此做两件事，1 是重置 waitStatus 标志位，2 是重置成功后, 唤醒下一个节点。</span></span><br><span class="line">                  <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                  !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))  </span><br><span class="line"><span class="comment">// 如果本身头节点的 waitStatus 是出于重置状态（waitStatus==0）的，将其设置为“传播”状态。</span></span><br><span class="line"><span class="comment">// 意味着需要将状态向后一个节点传播。</span></span><br><span class="line">              <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要这么做呢？这就是共享功能和独占功能最不一样的地方，对于独占功能来说，有且只有一个线程（通常只对应一个节点，拿 ReentantLock 举例，如果当前持有锁的线程重复调用 lock() 方法，那根据本系列上半部分我们的介绍，我们知道，会被包装成多个节点在 AQS 的队列中，所以用一个线程来描述更准确），能够获取锁，但是对于共享功能来说。<br>共享的状态是可以被共享的，也就是意味着其他 AQS 队列中的其他节点也应能第一时间知道状态的变化。因此，一个节点获取到共享状态流程图是这样的：</p><p>例如，当多个线程调用了<code>await</code> 方法的时候，这时候在Sycn 中会有一个等队列如下图：<br><img src="/article/Java-AQS2/1564037960989Java-AQS2_.png" alt></p><p>Node1 变成了头节点然后调用 <code>unparkSuccessor</code>() 方法唤醒了 Node2、Node2 中持有的线程 A 出于上面流程图的 park node 的位置， 还记得 <code>doAcquireSharedInterruptibly</code> 里面的for循环吗，当Node2唤醒之后 会计入这个for循环当中，然后会判断当前node的 父节点，并唤醒。</p><p>线程 A 被唤醒后，重复黄色线条的流程，重新检查调用 <code>tryAcquireShared</code> 方法，看能否成功，如果成功，则又更改头节点，重复以上步骤，以实现节点自身获取共享锁成功后，唤醒下一个共享类型节点的操作，实现共享状态的向后传递。</p><ol><li>其实对于 doAcquireShared 方法，AQS 还提供了集中类似的实现：<br><img src="/article/Java-AQS2/1564041186249Java-AQS2_.png" alt><br>分别对应了：</li></ol><ul><li>带参数请求共享锁。 （忽略中断）</li><li>带参数请求共享锁，且响应中断。（每次循环时，会检查当前线程的中断状态，以实现对线程中断的响应）</li><li>带参数请求共享锁但是限制等待时间。（第二个参数设置超时时间，超出时间后，方法返回。）</li></ul><p><img src="/article/Java-AQS2/1564454733915Java-AQS2_.png" alt></p><h3><span id="sync-doacquiresharednanos方法">Sync doAcquireSharedNanos方法</span></h3><p>比较特别的为最后一个 doAcquireSharedNanos 方法，我们一起看下它怎么实现超时时间的控制的。<br>因为该方法和其余获取共享锁的方法逻辑是类似的，我用红色框圈出了它所不一样的地方，也就是实现超时时间控制的地方。<br>可以看到，其实就是在进入方法时，计算出了一个“deadline”，每次循环的时候用当前时间和“deadline”比较，大于“dealine”说明超时时间已到，直接返回方法。</p><p>注意，最后一个红框中的这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nanosTimeout &gt; spinForTimeoutThreshold</span><br></pre></td></tr></table></figure><p>从变量的字面意思可知，这是拿超时时间和超时自旋的最小作比较，在这里 Doug Lea 把超时自旋的阈值设置成了 1000ns, 即只有超时时间大于 1000ns 才会去挂起线程，否则，再次循环，以实现“自旋”操作。这是“自旋”在 AQS 中的应用之处。</p><h3><span id="countdown-方法">countDown 方法</span></h3><p>看完 await 方法，我们再来看下 countDown() 方法：</p><ul><li>countDown() 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Sync </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  同样先尝试去释放锁，tryReleaseShared 同样为空方法，留给子类自己去实现，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="tryreleaseshared-方法">tryReleaseShared 方法</span></h3><p>看一下  <code>tryReleaseShared</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">          <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>本文从 CountDownLatch 入手，深入分析了 AQS 关于共享锁方面的实现方式：</p><blockquote><p>如果获取共享锁失败后，将请求共享锁的线程封装成 Node 对象放入 AQS 的队列中，并挂起 Node 对象对应的线程，实现请求锁线程的等待操作。<br>待共享锁可以被获取后，从头节点开始，依次唤醒头节点及其以后的所有共享类型的节点。实现共享状态的传播。</p></blockquote><p>这里有几点值得注意：</p><ul><li>与 AQS 的独占功能一样，共享锁是否可以被获取的判断为空方法，交由子类去实现。</li><li>与 AQS 的独占功能不同，当锁被头节点获取后，独占功能是只有头节点获取锁，其余节点的线程继续沉睡，等待锁被释放后，才会唤醒下一个节点的线程，而共享功能是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒 AQS 队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li></ul><p><strong>以上的分析都是从 AQS 子类的角度去看待 AQS 的部分功能的，而如果直接看待 AQS，或许可以这么去解读：</strong></p><ul><li><p>首先，AQS 并不关心“是什么锁”，对于 AQS 来说它只是实现了一系列的用于判断“资源”是否可以访问的 API, 并且封装了在“访问资源”受限时将请求访问的线程的加入队列、挂起、唤醒等操作， AQS 只关心“资源不可以访问时，怎么处理？”、“资源是可以被同时访问，还是在同一时间只能被一个线程访问？”、“如果有线程等不及资源了，怎么从 AQS 的队列中退出？”等一系列围绕资源访问的问题，而至于“资源是否可以被访问？”这个问题则交给 AQS 的子类去实现。</p></li><li><p>当 AQS 的子类是实现独占功能时，例如 <code>ReentrantLock</code>，“资源是否可以被访问”被定义为只要 AQS 的 <code>state</code> 变量不为 0，并且持有锁的线程不是当前线程，则代表资源不能访问。</p></li><li><p>当 AQS 的子类是实现共享功能时，例如：CountDownLatch，“资源是否可以被访问”被定义为只要 AQS 的 <code>state</code> 变量不为 0，说明资源不能访问。</p></li></ul><p><strong>这是典型的将规则和操作分开的设计思路：规则子类定义，操作逻辑因为具有公用性，放在父类中去封装。</strong></p><p>当然，正式因为 AQS 只是关心“资源在什么条件下可被访问”，所以子类还可以同时使用 AQS 的共享功能和独占功能的 API 以实现更为复杂的功能。</p><p>比如：<code>ReentrantReadWriteLock</code>，我们知道 <code>ReentrantReadWriteLock</code> 的中也有一个叫 <code>Sync</code>的内部类继承了 <code>AQS</code>，而 <code>AQS</code> 的队列可以同时存放共享锁和独占锁，对于 <code>ReentrantReadWriteLock</code> 来说分别代表读锁和写锁，当队列中的头节点为读锁时，代表读操作可以执行，而写操作不能执行，因此请求写操作的线程会被挂起，当读操作依次推出后，写锁成为头节点，请求写操作的线程被唤醒，可以执行写操作，而此时的读请求将被封装成 Node 放入 AQS 的队列中。如此往复，实现读写锁的读写交替进行。</p><p>而本系列文章上半部分提到的 <code>FutureTask</code>，其实思路也是：封装一个存放线程执行结果的变量 A, 使用 AQS 的独占 API 实现线程对变量 A 的独占访问，判断规则是，线程没有执行完毕：call() 方法没有返回前，不能访问变量 A，或者是超时时间没到前不能访问变量 A(这就是 FutureTask 的 get 方法可以实现获取线程执行结果时，设置超时时间的原因)。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（上)</a></li><li><a href="https://www.infoq.cn/article/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下)</a></li><li><a href="https://www.jianshu.com/p/279baac48960" target="_blank" rel="noopener">java AQS的实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">深入学习java同步器AQS</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="http://codingdict.com/blog/article/2019/4/26/934.html" target="_blank" rel="noopener">http://codingdict.com/blog/article/2019/4/26/934.html</a></li><li><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86192135" target="_blank" rel="noopener">https://blog.csdn.net/Viscu/article/details/86192135</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程篇之锁的介绍</title>
      <link href="/article/java-lock-show/"/>
      <url>/article/java-lock-show/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>这篇文章介绍各种锁的分类。介绍的内容如下：</p><ol><li>公平锁 / 非公平锁</li><li>可重入锁 / 不可重入锁</li><li>独享锁 / 共享锁</li><li>互斥锁 / 读写锁</li><li>乐观锁 / 悲观锁</li><li>分段锁</li><li>偏向锁 / 轻量级锁 / 重量级锁</li><li>自旋锁</li></ol><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2><span id="锁的种类详解">锁的种类详解</span></h2><h2><span id="公平锁-非公平锁">公平锁 / 非公平锁</span></h2><ul><li>公平锁<br>公平锁是指多个线程按照申请锁的顺序来获取锁。</li><li>非公平锁<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</li><li>有可能，会造成优先级反转或者饥饿现象。</li><li>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。</li><li>非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</li></ul><p>具体可以参考<a href="https://icefrozen.github.io/article/java-AQS/" target="_blank" rel="noopener">JAVA多线程之AQS分析(1)</a></p><h2><span id="可重入锁-不可重入锁">可重入锁 / 不可重入锁</span></h2><ul><li>不可重入锁：只判断这个锁有没有被锁上，只要被锁上申请锁的线程都会被要求等待。实现简单</li><li>可重入锁：不仅判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上的时候，那么他依旧可以再次访问临界资源，并把加锁次数加一。</li></ul><p><code>synchronized</code>和<code>ReentrantLock</code>都是可重入锁。</p><ul><li><code>ReentrantLock</code>与<code>synchronized</code>比较：<ul><li>1.前者使用灵活，但是必须手动开启和释放锁</li><li>2.前者扩展性好，有时间锁等候（tryLock()可中断锁等候（lockInterruptibly()），锁投票等，适合用于高度竞争锁和多个条件变量的地方</li><li>3.前者提供了可轮询的锁请求，可以尝试去获取锁（tryLock( )），如果失败，则会释放已经获得的锁。有完善的错误恢复机制，可以避免死锁的发生。</li></ul></li></ul><h2><span id="乐观锁-悲观锁">乐观锁 / 悲观锁</span></h2><ul><li><p>悲观锁 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p></li><li><p>乐观锁 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式(CAS实现的)</p></li><li><p>使用场景<br>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。<br>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p></li><li><p>CAS算法：</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li><p>CAS 算法ABA的问题</p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &quot;ABA&quot;问题。</p><blockquote><p>JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就提供了此种能力，其中的 <code>compareAndSet</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></blockquote></li></ul><h2><span id="独享锁-共享锁">独享锁 / 共享锁</span></h2><ul><li>独享锁 是指该锁一次只能被一个线程所持有。</li><li>共享锁 是指该锁可被多个线程所持有。<br>对于<code>ReentrantLock</code>而言，其是独享锁。<br>但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。<br>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li></ul><h2><span id="互斥锁-读写锁">互斥锁 / 读写锁</span></h2><ul><li>互斥锁<br>一次只能一个线程拥有互斥锁，其他线程只有等待</li></ul><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。</p><ul><li><p>读写锁<br>读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。</p></li><li><p>java中的读写锁 <code>ReentrantReadWriteLock</code></p></li></ul><h2><span id="自旋锁">自旋锁</span></h2><ul><li>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。</li></ul><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，&quot;自旋&quot;一词就是因此而得名。</p><ul><li>存在问题<ul><li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li><li>自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li></ul></li><li>优点：<ul><li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li><li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li></ul></li></ul><h2><span id="偏向锁-轻量级锁-重量级锁">偏向锁 / 轻量级锁 / 重量级锁</span></h2><p>一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁,只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试失败,则分为两种情况：</p><ul><li>1，对象的偏向锁标志位为0（当前不是偏向锁），说明发生了竞争，已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁</li><li>2，偏向锁标志位为1，说明还是偏向锁不过请求的线程不是原来那个了。这时只需要使用CAS尝试把对象头偏向锁从原来那个线程指向目前求锁的线程。</li></ul><ul><li><p>本质：使用CAS取代<code>互斥同步</code>。</p></li><li><p>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。</p></li><li><p>锁膨胀</p></li><li><p>轻量级锁与重量级锁的比较：</p><ul><li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用<code>互斥同步</code>来保证线程的安全；</li><li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用<code>互斥同步</code>，而是使用CAS操作来获得锁，这样能减少<code>互斥同步</code>所使用的『互斥量』带来的性能开销。</li></ul></li><li><p>实现原理：<br>对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。Mark Word中有个标志位用来表示当前对象所处的状态。</p></li><li><p>偏向锁作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</p><ul><li><p>与轻量级锁的区别：</p><ul><li>轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；</li><li>而偏向锁是在无竞争的情况下完全取消同步。</li></ul></li><li><p>与轻量级锁的相同点：</p><ul><li>它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。</li></ul><blockquote><p>原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。<br>但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。<br>+ 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。偏向锁可以通过虚拟机的参数来控制它是否开启。</p></blockquote><blockquote><p>具体请参考<a href="https://icefrozen.github.io/article/java-synchronized/" target="_blank" rel="noopener">深入分析synchronized原理和锁膨胀过程</a></p></blockquote></li><li><p>三种对比<br><img src="/article/java-lock-show/1565944754578java-lock-show_.png" alt></p></li></ul></li></ul><h2><span id="参考">参考</span></h2><ul><li><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">面试必备之乐观锁与悲观锁</a></li><li><a href="https://zhuanlan.zhihu.com/p/40729293" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></li><li><a href="https://blog.csdn.net/qyp199312/article/details/70598480" target="_blank" rel="noopener">Java中的公平锁和非公平锁实现详解</a></li><li><a href="https://maimai.cn/article/detail?fid=1231504957&amp;efid=TgPEQCFJ6KSa6rBIAyLHNg" target="_blank" rel="noopener">Java中15种锁的介绍！</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86252371" target="_blank" rel="noopener">JDK源码系列 ReentrantLock 公平锁和非公平锁的实现原理</a></li><li><a href="https://www.zhihu.com/question/55075763/answer/246516866" target="_blank" rel="noopener">Java 的偏向锁是怎么实现的？</a></li><li><a href="https://www.zhihu.com/question/39009953/answer/240514586" target="_blank" rel="noopener">jvm从轻量级锁膨胀到重量级锁是在什么时候发生的？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之 高性能IO浅析</title>
      <link href="/article/operating-system-io/"/>
      <url>/article/operating-system-io/</url>
      
        <content type="html"><![CDATA[<h2><span id="io模型分类">IO模型分类</span></h2><ul><li><strong>（1）同步阻塞IO（Blocking IO）</strong>：即传统的IO模型。</li><li><strong>（2）同步非阻塞IO（Non-blocking IO）</strong>：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li><li><strong>（3）IO多路复用（IO Multiplexing）</strong>：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。 有兴趣可以看一下<a href="https://icefrozen.github.io/article/operating-system-epoll/" target="_blank" rel="noopener">Epoll的原理</a>。</li><li><strong>（4）异步IO（Asynchronous IO）</strong>：即经典的Proactor设计模式，也称为异步非阻塞IO。</li></ul><h3><span id="同步和异步">同步和异步</span></h3><p>同步和异步的概念描述的是用户线程与内核的交互方式：</p><ul><li>同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；</li><li>而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li></ul><h3><span id="阻塞和非阻塞">阻塞和非阻塞</span></h3><p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：</p><ul><li>阻塞是指IO操作需要彻底完成后才返回到用户空间；</li><li>而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</li></ul><h2><span id="同步阻塞io">同步阻塞IO</span></h2><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p><p><img src="/article/operating-system-io/1563243388124operating-system-io_.png" alt></p><p>如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。<br>用户线程使用同步阻塞IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  read(socket, buffer);</span><br><span class="line">  process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p><h2><span id="同步非阻塞io">同步非阻塞IO</span></h2><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。<br><img src="/article/operating-system-io/1563243655861operating-system-io_.png" alt></p><p>如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。<br>用户线程使用同步非阻塞IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(read(socket, buffer) != SUCCESS);</span><br><span class="line">    process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><h2><span id="io多路复用">IO多路复用</span></h2><h3><span id="什么是io多路复用">什么是IO多路复用</span></h3><p>关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。写操作类似。</p><p>操作系统的这个功能通过<code>select/poll/epoll/kqueue</code>之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程。</p><h3><span id="select-函数">select 函数</span></h3><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p><p><img src="/article/operating-system-io/1563243505125operating-system-io_.png" alt></p><p>如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。<br>当数据到达时，socket被激活(用户线程被唤起)，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p>用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    select(socket);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">                read(socket, buffer);</span><br><span class="line">                process(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</p><h4><span id="select-函数的缺点">select 函数的缺点：</span></h4><ol><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>select支持的文件描述符数量太小了，默认是1024</li></ol><h3><span id="poll">poll</span></h3><ul><li>poll 的方式和select 很大，但是没有1024的限制，我们可以简单的理解为select  向内核态传递数据的时候是通过数组的方式，这样一来就有限制，而poll 则是使用了 链表的方式，如此就可以避免了突破了1024的限制</li></ul><h3><span id="epoll">epoll</span></h3><ul><li>epoll的原理我已经在<a href="https://icefrozen.github.io/article/operating-system-epoll/" target="_blank" rel="noopener">Epoll的原理</a>这篇文章分析过了，这里组要讲一下epoll是如何解决select的三个问题的。</li></ul><h4><span id="epoll优点">epoll优点</span></h4><ul><li>epoll既然是对 <code>select</code> 和 <code>poll</code> 的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？<ul><li><p>我们先看一下 <code>epoll</code> 和 <code>select</code> 和poll的调用接口上的不同，<code>select</code>和<code>poll</code>都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，<code>epoll_create,epoll_ctl和epoll_wait</code>，<code>epoll_create</code>是创建一个 <code>epoll</code> 句柄；<code>epoll_ctl</code> 是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。</p></li><li><p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p></li><li><p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait 的工作实际上就是在这个就绪链表中查看有没有就绪的fd。</p></li><li><p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p></li></ul></li></ul><p>IO多路复用模型使用了Reactor设计模式实现了这一机制。</p><h2><span id="reactor设计模式">Reactor设计模式</span></h2><h3><span id="rector解决了什么">Rector解决了什么</span></h3><p>它要解决什么问题呢？线程在真正处理请求之前首先需要从 socket 中读取网络请求，而在读取完成之前，线程本身被阻塞，不能做任何事，这就导致线程资源被占用，而线程资源本身是很珍贵的，尤其是在处理高并发请求时。</p><p>而 Reactor 模式指出，在等待 IO 时，线程可以先退出，这样就不会因为有线程在等待 IO 而占用资源。但是这样原先的执行流程就没法还原了，因此，我们可以利用<code>事件驱动的方式</code>，要求线程在退出之前向 event loop 注册回调函数，这样 IO 完成时 event loop 就可以调用回调函数完成剩余的操作。</p><p>所以说，Reactor 模式通过减少服务器的资源消耗，提高了并发的能力。</p><h3><span id="rector-实现">Rector 实现</span></h3><h4><span id="rector-设计理念">Rector 设计理念</span></h4><p><img src="/article/operating-system-io/1563244009489operating-system-io_.png" alt></p><p>EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle，我们可以简单理解为拥有 socket 这个对象</p><p>继承于EventHandler的子类可以对事件处理器的行为进行定制就是我们的具体的hander。</p><p>Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。 有些简单的世界中 Rector 处理时间循环的可以具体为一个Acceptor 类，用于accept接受 socket 链接。 而Rector 可以负责分发 具体相当于一个 dispatch 类似的组件。</p><p><img src="/article/operating-system-io/1563508418230operating-system-io_.png" alt></p><p>由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。<br>一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p><h4><span id="单线程-reactor-模式">单线程 Reactor 模式</span></h4><p><img src="/article/operating-system-io/1578539455022operating-system-io_.png" alt></p><p>在该种模式下我们使用的是一个单线程的 Reactor，acceptor() 处理器注册了 ACCEPT 事件，即连接事件，当有连接请求时 Reactor 会将其分发给 acceptor() 处理。</p><p>但在这种模式下，Reactor 线程不但要处理 accept()、read()、send()，连非IO业务也要处理，如果业务逻辑复杂，这可能会使 Reactor 线程无法处理其它事件的响应。</p><p>为了避免这种事情发生，我们需要把非IO业务逻辑处理交给子线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//阻塞等待事件</span></span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="comment">// 事件列表</span></span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        System.out.println(<span class="string">"select invoke:"</span> + select);</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            <span class="comment">//分发事件</span></span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dispatch"</span>);</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">//新链接建立，注册</span></span><br><span class="line">                register(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//读事件处理</span></span><br><span class="line">                read(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                <span class="comment">//写事件处理</span></span><br><span class="line">                wirte(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            clientChannel.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"data:"</span>+ Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wirte</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"register"</span>);</span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) key</span><br><span class="line">                    .channel();</span><br><span class="line">            <span class="comment">// 获得和客户端连接的通道</span></span><br><span class="line">            SocketChannel channel = server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//客户端通道注册到selector 上</span></span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="单线程-reactor-模式-线程池">单线程 Reactor 模式 + 线程池</span></h4><p><img src="/article/operating-system-io/1578539472242operating-system-io_.png" alt></p><p>通过加入工作线程池，把具体的逻辑操作交由子线程，提高了 Reactor 线程的IO响应时间，但是这样的模式还是存在着缺陷。</p><p>就是Reactor 线程要处理包括I/O的accept()、read()、write()以及connect()操作，当同时有大量的连接建立时，单线程的 Reactor性能会下降，然后可能会使大量客户端连接超时，最终使大量消息积压和连接超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            register.attach(<span class="keyword">new</span> Acceptor(register, selector));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Runnable runnable = (Runnable) (key.attachment());</span><br><span class="line">            <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        SelectionKey key;</span><br><span class="line">        Selector selector;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(SelectionKey key, Selector selector)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"register"</span>);</span><br><span class="line">                ServerSocketChannel server = (ServerSocketChannel) key</span><br><span class="line">                        .channel();</span><br><span class="line">                <span class="comment">// 获得和客户端连接的通道</span></span><br><span class="line">                SocketChannel c = server.accept();</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">new</span> MultiThreadHandler(c, selector);</span><br><span class="line">                    <span class="comment">//new Handler(c, selector);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run errro"</span>);</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读写业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READING = <span class="number">0</span>, WRITING = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> state;</span><br><span class="line">        <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(SocketChannel socket, Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = READING;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            sk.attach(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (state == READING) &#123;</span><br><span class="line">                    read();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == WRITING) &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            process();</span><br><span class="line">            <span class="comment">//下一步处理写事件</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            <span class="keyword">this</span>.state = WRITING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            process();</span><br><span class="line">            <span class="comment">//下一步处理读事件</span></span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            <span class="keyword">this</span>.state = READING;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * task 业务处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadHandler</span><span class="params">(SocketChannel socket, Selector selector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(socket, selector);</span><br><span class="line">            <span class="comment">//多线程处理业务逻辑</span></span><br><span class="line">            executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">                    <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="多线程的-reactor-模式">多线程的 Reactor 模式</span></h4><p>在多线程的 Reactor 模式中，我们分为 mainReactor 和 subReactor，每一个 Reactor 线程都会有自己的 Selector 与不同的事件循环逻辑。</p><p>其中 mainReactor 主要负责接受客户的连接请求，然后将建立的 ScoketChannel 传递给 subReactor，由 subReactor 来完成和客户端的通信。</p><p>而 subReactor 一般会有多个，这可以很好的解决单线程 Reactor 模式下的瓶颈。</p><p><img src="/article/operating-system-io/1578539637647operating-system-io_.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIORector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Thread app;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIORector</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Selector selector;</span><br><span class="line">        ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">        NIOServer() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            register.attach(<span class="keyword">new</span> MultiWorkThreadAcceptor(serverSocket));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                    <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set selected = selector.selectedKeys();</span><br><span class="line">                        Iterator it = selected.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                            dispatch((SelectionKey) (it.next()));</span><br><span class="line">                            it.remove();</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个是事件分发器，相当于Reactor 里的分发器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Runnable runnable = (Runnable) (key.attachment());</span><br><span class="line">            <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的Acceptor 相当于时间 接收器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiWorkThreadAcceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">        <span class="comment">// cpu线程数相同多work线程</span></span><br><span class="line">        <span class="keyword">int</span> workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        SubReactor[] workThreadHandlers = <span class="keyword">new</span> SubReactor[workCount];</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> nextHandler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiWorkThreadAcceptor</span><span class="params">(ServerSocketChannel serverSocket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.server = serverSocket;</span><br><span class="line">            nextHandler = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workThreadHandlers.length; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workThreadHandlers[i] = <span class="keyword">new</span> SubReactor();</span><br><span class="line">                    <span class="keyword">new</span> Thread(workThreadHandlers[i]).start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"MultiWorkThreadAcceptor error"</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"register"</span>);</span><br><span class="line">                <span class="comment">// 有socket 链接上来</span></span><br><span class="line">                SocketChannel c = server.accept();</span><br><span class="line">                <span class="comment">// 注册读写</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (c) &#123;</span><br><span class="line">                        <span class="comment">// 顺序获取SubReactor，然后注册channel</span></span><br><span class="line">                        SubReactor work = workThreadHandlers[nextHandler];</span><br><span class="line">                        <span class="comment">// 这里注册</span></span><br><span class="line">                        work.registerChannel(c);</span><br><span class="line">                        nextHandler++;</span><br><span class="line">                        <span class="keyword">if</span> (nextHandler &gt;= workThreadHandlers.length) &#123;</span><br><span class="line">                            nextHandler = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"run errro"</span>);</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Selector mySelector;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(workCount);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 每个SubReactor 一个selector</span></span><br><span class="line">            <span class="keyword">this</span>.mySelector = SelectorProvider.provider().openSelector();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(SocketChannel c)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            registerChannel(c, <span class="keyword">new</span> MultiThreadHandler());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(SocketChannel c, Handler hander)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey register = c.register(mySelector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT);</span><br><span class="line">            register.attach(hander);</span><br><span class="line">            System.out.println(<span class="string">"registerChannel success!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每个SubReactor 自己做事件分派处理读写事件</span></span><br><span class="line">                    <span class="keyword">int</span> select = mySelector.selectNow();</span><br><span class="line">                    <span class="keyword">if</span> (select == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = mySelector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        MultiThreadHandler handler = (MultiThreadHandler) key.attachment();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        handler.hander(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"sub running error:"</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hander</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hander</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                read(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                write(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//下一步处理写事件</span></span><br><span class="line">            System.out.println(<span class="string">"read"</span>);</span><br><span class="line">            SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = socket.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"data:"</span> + Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        app = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer());</span><br><span class="line">        app.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="总结">总结</span></h4><p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p><h2><span id="异步io">异步IO</span></h2><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。</p><p>而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。<br>异步IO模型使用了Proactor设计模式实现了这一机制。</p><p><img src="/article/operating-system-io/1563627346572operating-system-io_.png" alt></p><p>如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。</p><p>AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。</p><p>虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p><p><img src="/article/operating-system-io/1563627447724operating-system-io_.png" alt></p><p>如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。<br>用户线程使用异步IO模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserCompletionHandler::handle_event(buffer) &#123;</span><br><span class="line">        process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    aio_read(socket, <span class="keyword">new</span> UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.zhihu.com/question/28594409/answer/52763082" target="_blank" rel="noopener">I/O多路复用技术（multiplexing）是什么？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之Epoll原理</title>
      <link href="/article/operating-system-epoll/"/>
      <url>/article/operating-system-epoll/</url>
      
        <content type="html"><![CDATA[<p>Epoll 很重要，但是 Epoll 与 Select 的区别是什么呢?Epoll 高效的原因是什么?</p><h2><span id="从网卡接收数据说起">从网卡接收数据说起</span></h2><h3><span id="网卡接收数据的过程">网卡接收数据的过程</span></h3><p>下边是一个典型的计算机结构图，计算机由 CPU、存储器(内存)与网络接口等部件组成，了解 <code>Epoll</code> 本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><p><img src="/article/operating-system-epoll/1562727855783operating-system-epoll_.png" alt><br>下图展示了网卡接收数据的过程：</p><ul><li>在 1 阶段，网卡收到网线传来的数据。</li><li>经过 2 阶段的硬件电路的传输。</li><li>最终 3 阶段将数据写入到内存中的某个地址上。</li><li>这个过程涉及到 DMA 传输、IO 通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。</li></ul><h3><span id="中断机制">中断机制</span></h3><p>通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。</p><p>如何知道接收了数据?了解 Epoll 本质的第二步，要从 CPU 的角度来看数据接收。理解这个问题，要先了解一个概念：中断。</p><p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级(电容可以保存少许电量，供 CPU 运行很短的一小段时间)。</p><p>一般而言，由硬件产生的信号需要 CPU 立马做出回应，不然数据可能就丢失了，所以它的优先级很高。</p><p>CPU 理应中断掉正在执行的程序，去做出响应;当 CPU 完成对硬件的响应后，再重新执行用户程序。</p><p>中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><p><img src="/article/operating-system-epoll/1562727999511operating-system-epoll_.png" alt></p><p>以键盘为例，当用户按下键盘某个按键时，键盘会给 CPU 的中断引脚发出一个高电平，CPU 能够捕获这个信号，然后执行键盘中断程序。</p><p>下图展示了各种硬件通过中断与 CPU 交互的过程：</p><p><img src="/article/operating-system-epoll/1562728030652operating-system-epoll_.png" alt></p><p>现在可以回答“如何知道接收了数据?”这个问题了：当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><h3><span id="进程阻塞不占用-cpu-资源">进程阻塞不占用 CPU 资源</span></h3><p>了解 Epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件(如接收到网络数据)发生之前的等待状态，Recv、Select 和 Epoll 都是阻塞方法。</p><p>下边分析一下进程阻塞为什么不占用 CPU 资源?为简单起见，我们从普通的 Recv 接收开始分析，先看看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket </span></span><br><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line"><span class="comment">//绑定 </span></span><br><span class="line">bind(s, ...) </span><br><span class="line"><span class="comment">//监听 </span></span><br><span class="line">listen(s, ...) </span><br><span class="line"><span class="comment">//接受客户端连接 </span></span><br><span class="line"><span class="keyword">int</span> c = accept(s, ...) </span><br><span class="line"><span class="comment">//接收客户端数据 </span></span><br><span class="line">recv(c, ...); </span><br><span class="line"><span class="comment">//将数据打印出来 </span></span><br><span class="line"><span class="built_in">printf</span>(...)</span><br></pre></td></tr></table></figure><p>这是一段最基础的网络编程代码，先新建 Socket 对象，依次调用 Bind、Listen 与 Accept，最后调用 Recv 接收数据。</p><p>Recv 是个阻塞方法，当程序运行到 Recv 时，它会一直等待，直到接收到数据才往下执行。那么阻塞的原理是什么?</p><h3><span id="工作队列">工作队列</span></h3><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。</p><p>运行状态是进程获得 CPU 使用权，正在执行代码的状态;等待状态是阻塞状态，比如上述程序运行到 Recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。</p><p>操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><p><img src="/article/operating-system-epoll/1562729083970operating-system-epoll_.png" alt></p><h3><span id="等待队列">等待队列</span></h3><p>当进程 A 执行到创建 Socket 的语句时，操作系统会创建一个由文件系统管理的 Socket 对象(如下图)。<br><img src="/article/operating-system-epoll/1562729110268operating-system-epoll_.png" alt></p><ul><li><p>创建 Socket</p><p>这个 Socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 Socket 事件的进程。</p><p>当程序执行到 Recv 时，操作系统会将进程 A 从工作队列移动到该 Socket 的等待队列中(如下图)。</p><p><img src="/article/operating-system-epoll/1562729170077operating-system-epoll_.png" alt></p></li><li><p>Socket 的等待队列</p><p>由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。</p><blockquote><p>注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p></blockquote></li></ul><h3><span id="唤醒进程">唤醒进程</span></h3><p>当 Socket 接收到数据后，操作系统将该 Socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。</p><p>同时由于 Socket 的接收缓冲区已经有了数据，Recv 可以返回接收到的数据。</p><ul><li><p>内核接收网络数据全过程<br>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞 Recv 下，内核接收数据的全过程。</p><p><img src="/article/operating-system-epoll/1562729363577operating-system-epoll_.png" alt></p><p>如上图所示，进程在 Recv 阻塞期间：</p><ul><li>计算机收到了对端传送的数据(步骤 ①)</li><li>数据经由网卡传送到内存(步骤 ②)</li><li>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序(步骤 ③)</li><li>此处的中断程序主要有两项功能，先将网络数据写入到对应 Socket 的接收缓冲区里面(步骤 ④)，再唤醒进程 A(步骤 ⑤)，重新将进程 A 放入工作队列中。</li></ul></li><li><p>唤醒进程的过程如下图所示：<br><img src="/article/operating-system-epoll/1562729427475operating-system-epoll_.png" alt></p></li></ul><h3><span id="唤醒进程">唤醒进程</span></h3><p>以上是内核接收数据全过程，这里我们可能会思考两个问题：</p><ul><li>操作系统如何知道网络数据对应于哪个 Socket?</li><li>如何同时监视多个 Socket 的数据?</li></ul><ul><li>操作系统如何知道网络数据对应于哪个 Socket?</li></ul><p>因为一个 Socket 对应着一个端口号，而网络数据包中包含了 IP 和端口的信息，内核可以通过端口号找到对应的 Socket。当然，为了提高处理速度，操作系统会维护端口号到 Socket 的索引结构，以快速读取。</p><ul><li>如何同时监视多个 Socket 的数据?</li></ul><h2><span id="同时监视多个-socket-方法">同时监视多个 Socket 方法</span></h2><p>服务端需要管理多个客户端连接，而 Recv 只能监视单个 Socket，这种矛盾下，人们开始寻找监视多个 Socket 的方法。Epoll 的要义就是高效地监视多个 Socket。</p><p>从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如 Select 之于 Epoll。先理解不太高效的 Select，才能够更好地理解 Epoll 的本质。</p><p>假如能够预先传入一个 Socket 列表，如果列表中的 Socket 都没有数据，挂起进程，直到有一个 Socket 收到数据，唤醒进程。这种方法很直接，也是 Select 的设计思想。</p><p>为方便理解，我们先复习 Select 的用法。在下边的代码中，先准备一个数组 FDS，让 FDS 存放着所有需要监视的 Socket。</p><p>然后调用 Select，如果 FDS 中的所有 Socket 都没有数据，Select 会阻塞，直到有一个 Socket 接收到数据，Select 返回，唤醒进程。</p><p>用户可以遍历 FDS，通过 FD_ISSET 判断具体哪个 Socket 收到数据，然后做出处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123; </span><br><span class="line">            <span class="comment">//fds[i]的数据处理 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Select 的流程</li></ul><p>Select 的实现思路很直接，假如程序同时监视如下图的 Sock1、Sock2 和 Sock3 三个 Socket，那么在调用 Select 之后，操作系统把进程 A 分别加入这三个 Socket 的等待队列中。</p><p><img src="/article/operating-system-epoll/1562729629174operating-system-epoll_.png" alt></p><p>操作系统把进程 A 分别加入这三个 Socket 的等待队列中</p><p>当任何一个 Socket 收到数据后，中断程序将唤起进程。下图展示了 Sock2 接收到了数据的处理流程：</p><p><img src="/article/operating-system-epoll/1562729661910operating-system-epoll_.png" alt></p><p>Sock2 接收到了数据，中断程序唤起进程 A</p><p>注：Recv 和 Select 的中断回调可以设置成不同的内容。</p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：</p><p><img src="/article/operating-system-epoll/1562729681601operating-system-epoll_.png" alt></p><p>将进程 A 从所有等待队列中移除，再加入到工作队列里面</p><p>经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 Socket 接收了数据。程序只需遍历一遍 Socket 列表，就可以得到就绪的 Socket。</p><p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><ul><li>每次调用 Select 都需要将进程加入到所有监视 Socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。</li></ul><p>正是因为遍历操作开销大，出于效率的考量，才会规定 Select 的最大监视数量，默认只能监视 1024 个 Socket。</p><ul><li>进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次。<br>那么，有没有减少遍历的方法?有没有保存就绪 Socket 的方法?这两个问题便是 Epoll 技术要解决的。</li></ul><blockquote><p>补充说明：本节只解释了 Select 的一种情形。当程序调用 Select 时，内核会先遍历一遍 Socket，如果有一个以上的 Socket 接收缓冲区有数据，那么 Select 直接返回，不会阻塞。</p></blockquote><p>这也是为什么 Select 的返回值有可能大于 1 的原因之一。如果没有 Socket 有数据，进程才会阻塞。</p><h2><span id="epoll-的设计思路">Epoll 的设计思路</span></h2><p>Epoll 是在 Select 出现 N 多年后才被发明的，是 Select 和 Poll(Poll 和 Select 基本一样，有少量改进)的增强版本。Epoll 通过以下一些措施来改进效率：</p><h3><span id="措施一功能分离">措施一：功能分离</span></h3><p>Select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一<br><img src="/article/operating-system-epoll/1562729825016operating-system-epoll_.png" alt></p><p>相比 Select，Epoll 拆分了功能</p><p>如上图所示，每次调用 Select 都需要这两步操作，然而大多数应用场景中，需要监视的 Socket 相对固定，并不需要每次都修改。</p><p>Epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。</p><p>为方便理解后续的内容，我们先了解一下 Epoll 的用法。如下的代码中，先用 epoll_create 创建一个 Epoll 对象 Epfd，再通过 epoll_ctl 将需要监视的 Socket 添加到 Epfd 中，最后调用 epoll_wait 等待数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(...); </span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(...) </span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123; </span><br><span class="line">        <span class="comment">//处理 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="措施二就绪列表">措施二：就绪列表</span></h3><p>Select 低效的另一个原因在于程序不知道哪些 Socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 Socket，就能避免遍历。</p><p><img src="/article/operating-system-epoll/1562729924745operating-system-epoll_.png" alt></p><p>就绪列表示意图</p><p>如上图所示，计算机共有三个 Socket，收到数据的 Sock2 和 Sock3 被就绪列表 Rdlist 所引用。</p><p>当进程被唤醒后，只要获取 Rdlist 的内容，就能够知道哪些 Socket 收到数据。</p><h3><span id="epoll-的原理与工作流程">Epoll 的原理与工作流程</span></h3><p>本节会以示例和图表来讲解 Epoll 的原理和工作流程。</p><ul><li><p>创建 Epoll 对象</p><p>如下图所示，当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象(也就是程序中 Epfd 所代表的对象)。</p><p><img src="/article/operating-system-epoll/1562729950856operating-system-epoll_.png" alt></p><p>内核创建 eventpoll 对象</p><p>eventpoll 对象也是文件系统中的一员，和 Socket 一样，它也会有等待队列。</p><p>创建一个代表该 Epoll 的 eventpoll 对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</p></li><li><p>维护监视列表</p><p>创建 Epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 Socket。以添加 Socket 为例。</p><p><img src="/article/operating-system-epoll/1562730099033operating-system-epoll_.png" alt></p><p>添加所要监听的 Socket</p><p>如上图，如果通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll 添加到这三个 Socket 的等待队列中。</p><p>当 Socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</p></li><li><p>接收数据</p><p>当 Socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 Socket 引用。<br><img src="/article/operating-system-epoll/1562730158957operating-system-epoll_.png" alt></p><p>给就绪列表添加引用</p><p>如上图展示的是 Sock2 和 Sock3 收到数据后，中断程序让 Rdlist 引用这两个 Socket。</p><p>eventpoll 对象相当于 Socket 和进程之间的中介，Socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p><p>当程序执行到 epoll_wait 时，如果 Rdlist 已经引用了 Socket，那么 epoll_wait 直接返回，如果 Rdlist 为空，阻塞进程。</p></li><li><p>阻塞和唤醒进程</p><p>假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。</p><p><img src="/article/operating-system-epoll/1562730841047operating-system-epoll_.png" alt></p></li><li><p>epoll_wait 阻塞进程</p><p>如上图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</p><p>当 Socket 接收到数据，中断程序一方面修改 Rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态(如下图)。</p><p><img src="/article/operating-system-epoll/1562730871184operating-system-epoll_.png" alt></p></li><li><p>Epoll 唤醒进程</p><p>也因为 Rdlist 的存在，进程 A 可以知道哪些 Socket 发生了变化。</p><p>Epoll 的实现细节<br>至此，相信读者对 Epoll 的本质已经有一定的了解。但我们还需要知道 eventpoll 的数据结构是什么样子?</p><p>此外，就绪队列应该使用什么数据结构?eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 Socket?</p><p><img src="/article/operating-system-epoll/1562730925725operating-system-epoll_.png" alt></p></li></ul><p>如上图所示，eventpoll 包含了 Lock、MTX、WQ(等待队列)与 Rdlist 等成员，其中 Rdlist 和 RBR 是我们所关心的。</p><h3><span id="就绪列表的数据结构">就绪列表的数据结构</span></h3><p>就绪列表引用着就绪的 Socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视 Socket，也可能随时删除。</p><p>当删除时，若该 Socket 已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</p><p>双向链表就是这样一种数据结构，Epoll 使用双向链表来实现就绪队列(对应上图的 Rdlist)。</p><h3><span id="索引结构">索引结构</span></h3><p>既然 Epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 Socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。</p><p>红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是 O(log(N))，效率较好，Epoll 使用了红黑树作为索引结构(对应上图的 RBR)。</p><blockquote><p>注：因为操作系统要兼顾多种功能，以及有更多需要保存的数据，Rdlist 并非直接引用 Socket，而是通过 Epitem 间接引用，红黑树的节点也是 Epitem 对象。</p></blockquote><p>同样，文件系统也并非直接引用着 Socket。为方便理解，本文中省略了一些间接结构。</p><h2><span id="总结">总结</span></h2><p>Epoll 在 Select 和 Poll 的基础上引入了 eventpoll 作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。</p><p>这里也以表格形式简单对比一下 Select、Poll 与 Epoll，结束此文。希望读者能有所收获。</p><h2><span id="参考链接">参考链接</span></h2><p><a href="http://developer.51cto.com/art/201906/597307.htm" target="_blank" rel="noopener">查看原文</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(1)</title>
      <link href="/article/java-memory-model/"/>
      <url>/article/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2><span id="为什么要有内存模型">为什么要有内存模型</span></h2><h2><span id="cpu缓存">CPU缓存</span></h2><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（<code>L1</code>），二级缓存（<code>L3</code>），部分高端CPU还具有三级缓存（<code>L3</code>），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：<strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong>。单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><p>下图为一个单CPU双核的缓存结构。</p><p><img src="/article/java-memory-model/1562587586971java-memory-model_.png" alt></p><h2><span id="多线程下缓存一致性问题">多线程下缓存一致性问题</span></h2><ul><li><p>单线程</p><blockquote><p>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p></blockquote></li><li><p>单核CPU，多线程。</p><blockquote><p>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p></blockquote></li><li><p>多核CPU, 多线程。</p><blockquote><p>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。在CPU和主存之间增加缓存，在多线程场景下就可能存在。缓存一致性问题**，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p></blockquote><p><img src="/article/java-memory-model/1562587658569java-memory-model_.png" alt></p></li></ul><h2><span id="处理器优化和指令重排">处理器优化和指令重排</span></h2><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p><h3><span id="编译器重排">编译器重排</span></h3><p>下面我们简单看一个编译器重排的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>             线程 <span class="number">2</span></span><br><span class="line"><span class="number">1</span>： x2 = a ;      <span class="number">3</span>: x1 = b ;</span><br><span class="line"><span class="number">2</span>: b = <span class="number">1</span>;         <span class="number">4</span>: a = <span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>两个线程同时执行，分别有1、2、3、4四段执行代码，其中1、2属于线程1 ， 3、4属于线程2 ，从程序的执行顺序上看，似乎不太可能出现x1 = 1 和x2 = 2 的情况，但实际上这种情况是有可能发现的，因为如果编译器对这段程序代码执行重排优化后，可能出现下列情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span>              线程 <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: b = <span class="number">1</span>;          <span class="number">4</span>: a = <span class="number">2</span> ; </span><br><span class="line"><span class="number">1</span>：x2 = a ;        <span class="number">3</span>: x1 = b ;</span><br></pre></td></tr></table></figure><p>这种执行顺序下就有可能出现x1 = 1 和x2 = 2 的情况，这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。</p><h3><span id="处理器指令重排">处理器指令重排</span></h3><p>处理器重排其实氛围了两方面，一方面叫做指令重排，一方面叫做CPU缓存重排序，其两者都是伟重排。什么叫做伪重排？是因为，其本身并没有发生真正意义上的重排序，cpu依旧是按照顺序执行指令，只不过完成的时间或者其他原因导致某个后面的指令先完成。所以，处理器重排序事实上并没有对输入的指令做调整。只有编译器重排序，才会对指令进行重排序。</p><p>处理器重拍一共有两种</p><ul><li>流水线指令重排序</li><li>CPU缓存一致性导致的重排序。</li></ul><p>这里只介绍<strong>流水线指令重排序</strong>，以下的指令重排均是指流水线指令重排序。想要了解<strong>CPU缓存一致性导致的重排序</strong>请参考我的另一篇博文<a href="https://icefrozen.github.io/article/why-memory-barriers-1/" target="_blank" rel="noopener">CPU缓存一致性协议-深入理解内存屏障</a>.</p><p>先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下</p><ul><li>取指 IF</li><li>译码和取寄存器操作数 ID</li><li>执行或者有效地址计算 EX</li><li>存储器访问 MEM</li><li>写回 WB</li></ul><p>CPU在工作时，需要将上述指令分为多个步骤依次执行(注意硬件不同有可能不一样),由于每一个步会使用到不同的硬件操作，比如取指时会只有PC寄存器和存储器，译码时会执行到指令寄存器组，执行时会执行ALU(算术逻辑单元)、写回时使用到寄存器组。为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下：</p><p><img src="/article/java-memory-model/1562642803915java-memory-model_.png" alt></p><p>从图中可以看出当指令1还未执行完成时，第2条指令便利用空闲的硬件开始执行，这样做是有好处的，如果每个步骤花费1ms，那么如果第2条指令需要等待第1条指令执行完成后再执行的话，则需要等待5ms，但如果使用流水线技术的话，指令2只需等待1ms就可以开始执行了，这样就能大大提升CPU的执行性能。</p><p>虽然流水线技术可以大大提升CPU的性能，但不幸的是一旦出现流水中断，所有硬件设备将会进入一轮停顿期，当再次弥补中断点可能需要几个周期，这样性能损失也会很大，就好比工厂组装手机的流水线，一旦某个零件组装中断，那么该零件往后的工人都有可能进入一轮或者几轮等待组装零件的过程。</p><p>因此我们需要尽量阻止指令中断的情况，指令重排就是其中一种优化中断的手段，我们通过一个例子来阐明指令重排是如何阻止流水线技术中断的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c ;</span><br><span class="line">d = e + f ;</span><br></pre></td></tr></table></figure><p>下面通过汇编指令展示了上述代码在CPU执行的处理过程</p><p><img src="https://img-blog.csdn.net/20170611002708717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><ul><li><p>LW指令 表示 load，其中LW R1,b表示把b的值加载到寄存器R1中</p></li><li><p>LW R2,c 表示把c的值加载到寄存器R2中</p></li><li><p>ADD 指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。</p></li><li><p>SW 表示 store 即将 R3寄存器的值保持到变量a中</p></li><li><p>LW R4,e 表示把e的值加载到寄存器R4中</p></li><li><p>LW R5,f 表示把f的值加载到寄存器R5中</p></li><li><p>SUB 指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。</p></li><li><p>SW d,R6 表示将R6寄存器的值保持到变量d中</p></li></ul><p>上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？</p><p>这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。</p><p>前面阐述过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把LW R4,e 和 LW R5,f 移动到前面执行，毕竟LW R4,e 和 LW R5,f执行并没有数据依赖关系，对他们有数据依赖关系的SUB R6,R5,R4指令在R4,R5加载完成后才执行的，没有影响，过程如下：</p><p><img src="/article/java-memory-model/1562642816423java-memory-model_.png" alt></p><p>正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。关于编译器重排以及指令重排(这两种重排我们后面统一称为指令重排)相关内容已阐述清晰了，我们必须意识到对于单线程而已指令重排几乎不会带来任何影响，比竟重排的前提是保证串行语义执行的一致性，但对于多线程环境而已，指令重排就可能导致严重的程序轮序执行问题，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，同时存在线程A和线程B对该实例对象进行操作，其中A线程调用写入方法，而B线程调用读取方法，由于指令重排等原因，可能导致程序执行顺序变为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A                    线程B</span><br><span class="line">writer：                 read：</span><br><span class="line">1:flag = true;           1:flag = true;</span><br><span class="line">2:a = 1;                 2: a = 0 ; //误读</span><br></pre></td></tr></table></figure><p>由于指令重排的原因，线程A的flag置为true被提前执行了，而a赋值为1的程序还未执行完，此时线程B，恰好读取flag的值为true，直接获取a的值（此时B线程并不知道a为0）并执行i赋值操作，结果i的值为1，而不是预期的2，这就是多线程环境下，指令重排导致的程序乱序执行的结果。因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性。</p><h2><span id="java内存模型即java-memory-model简称jmm">Java内存模型(即Java Memory Model，简称JMM)</span></h2><h2><span id="简介">简介</span></h2><p>本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>简单说：Java 为了能在不同架构的 CPU 上运行，提炼出一套自己的内存模型，定义出来 Java 程序该怎么样和这个抽象的内存模型进行交互，定义出来程序的运行过程，什么样的指令可以重排，什么样的不行，指令之间可见性如何等。相当于是规范出来了 Java 程序运行的基本规范。</p><p>这个模型定义会很不容易，它要有足够弹性，以适应各种不同的硬件架构，让这些硬件在支持 JVM 时候都能满足运行规范；它又要足够严谨，让应用层代码编写者能依靠这套规范，知道程序怎么写才能在各种系统上运行都不会有歧义，不会有并发问题。</p><p>综上所述：<strong>JMM（java Memory Model）屏蔽掉各种操作系统和硬件的内存访问差异，使得 java 程序在各种操作系统和硬件环境下，达到一致的内存访问效果。JMM 是一种在多样环境下对内存统一访问的模型</strong>。</p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">PDF文档</a></p><h2><span id="jvm-运行时基本的线程模型">JVM 运行时基本的线程模型</span></h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图</p><p><img src="/article/java-memory-model/1562642839101java-memory-model_.png" alt></p><h2><span id="并发编程的问题">并发编程的问题</span></h2><ul><li><p>JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。</p></li><li><p>JMM是围绕<strong>原子性，有序性、可见性</strong>展开的。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下</p></li></ul><ul><li><p>主内存</p><p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p></li><li><p>工作内存</p><p>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p></li></ul><p>对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（<code>boolean,byte,short,char,int,long,float,double</code>），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。</p><p>但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。</p><p>简单示意图如下所示：<br><img src="/article/java-memory-model/1562642879150java-memory-model_.png" alt></p><h2><span id="jmm存在的必要性">JMM存在的必要性</span></h2><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。</p><p>如下图，主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？</p><p>答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。</p><p><img src="/article/java-memory-model/1562642895574java-memory-model_.png" alt></p><h2><span id="java内存模型的承诺">Java内存模型的承诺</span></h2><ul><li><p><strong>原子性</strong>：原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p><p>比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。</p><p>有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量。</p></li><li><p><strong>可见性</strong>：理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值</p></li><li><p><strong>有序性</strong>  有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p></li></ul><h2><span id="java内存模型与缓存一致性的联系">Java内存模型与缓存一致性的联系</span></h2><p>缓存一致性问题其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的，<strong>指令重排</strong>即会导致有<strong>序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2><span id="jmm解决缓存一致性问题的方案">JMM解决缓存一致性问题的方案</span></h2><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。<strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</strong> 它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用.</p><ul><li><p>原子性问题，除了JVM自身提供的对<strong>基本数据类型读写操作的原子性</strong>外，对于方法级别或者代码块级别的原子性操作，可以使用<strong>synchronized</strong>关键字或者重入锁(<strong>ReentrantLock</strong>)保证程序执行的原子性。关于<code>synchronized</code>的详解，看博主另外一篇文章( 深入理解Java并发之synchronized实现原理)。</p></li><li><p>而工作内存与主内存同步延迟现象导致的可见性问题，可以使用<code>synchronized</code>关键字或者<code>volatile</code>关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。</p></li><li><p>对于指令重排导致的可见性问题和有序性问题，则可以利用<code>volatile</code>关键字解决，因为<code>volatile</code>的另外一个作用就是禁止重排序优化，关于<code>volatile</code>稍后会进一步分析。</p></li></ul><p>除了靠<code>sychronized</code>和<code>volatile</code>关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套<code>as-if-serial, happens-before</code> 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。</p><h3><span id="as-if-serial">as-if-serial</span></h3><p>as-if-serial 语义的意思是：<strong>所有的操作均可以为了优化而被重排序，但是你必须要保证重排序后执行的结果不能被改变，编译器、runtime、处理器都必须遵守 as-if-serial 语义。注意，as-if-serial 只保证单线程环境，多线程环境下无效。</strong></p><p>下面我们用一个简单的示例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;      <span class="comment">// A</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> ;      <span class="comment">// B</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;   <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>A、B、C 三个操作存在如下关系：A、B 不存在数据依赖关系，A和C、B和C存在数据依赖关系，因此在进行重排序的时候，A、B 可以随意排序，但是必须位于 C 的前面，执行顺序可以是 A –&gt; B –&gt; C 或者 B –&gt; A –&gt; C 。但是无论是何种执行顺序最终的结果 C 总是等于 3 。</p><p>as-if-serail 语义把单线程程序保护起来了，它可以保证在重排序的前提下程序的最终结果始终都是一致的。</p><p>当然，上述关系还存在着 happens-before 的原则</p><h3><span id="happens-before-原则">happens-before 原则</span></h3><p>根据happens-before的程序顺序规则，上面计算圆的面积的示例代码存在3个happens-before关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>） A happens-before B。</span><br><span class="line"><span class="number">2</span>） B happens-before C。</span><br><span class="line"><span class="number">3</span>） A happens-before C。</span><br></pre></td></tr></table></figure><p>而这里的第3个happens-before关系，是根据happens-before的传递性推导出来的。</p><p>注意：</p><p><strong>这里A happens-before B，但实际执行时B却可以排在A之前执行</strong>，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作(执行的结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见，而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens-before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法，JMM允许这种重排序。</p><p>倘若在程序开发中，仅靠<code>sychronized</code>和<code>volatile</code>关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下</p><ul><li><p><strong>程序顺序原则</strong>，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p></li><li><p><strong>锁规则</strong></p></li></ul><p>解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p><ul><li><strong>volatile规则</strong></li></ul><p>volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</p><ul><li><strong>线程启动规则</strong></li></ul><p>线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</p><ul><li><p><strong>传递性 A先于B ，B先于C 那么A必然先于C</strong></p></li><li><p><strong>线程终止规则</strong></p></li></ul><p>线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><ul><li><strong>线程中断规则</strong></li></ul><p>对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><ul><li>**对象终结规则 **</li></ul><p>对象的构造函数执行，结束先于finalize()方法</p><p>上述8条原则无需手动添加任何同步手段(synchronized|volatile)即可达到效果，下面我们结合前面的案例演示这8条原则如何判断线程是否安全，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的道理，存在两条线程A和B，线程A调用实例对象的writer()方法，而线程B调用实例对象的read()方法，线程A先启动而线程B后启动，那么线程B读取到的i值是多少呢？</p><p>现在依据8条原则，由于存在两条线程同时调用，因此程序次序原则不合适。writer()方法和read()方法都没有使用同步手段，锁规则也不合适。没有使用volatile关键字，volatile变量原则不适应。</p><p>线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性和本次测试案例也不合适。线程A和线程B的启动时间虽然有先后，但线程B执行结果却是不确定，也是说上述代码没有适合8条原则中的任意一条，也没有使用任何同步手段，所以上述的操作是线程不安全的，因此线程B读取的值自然也是不确定的。修复这个问题的方式很简单，要么给writer()方法和read()方法添加同步手段，如synchronized或者给变量flag添加volatile关键字，确保线程A修改的值对线程B总是可见。</p><h3><span id="volatile内存语义">volatile内存语义</span></h3><p>i变量的任何改变都会立马反应到其他线程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="volatile禁止重排优化">volatile禁止重排优化</span></h3><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(<code>Memory Barrier</code>）。</p><p>关于<code>Memory Barrier</code> 我会在写一篇博文详细探讨他的实现方式。只需要知道，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p><p><code>Memory Barrier</code>的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的<code>instance</code>不为<code>null</code>时，<code>instance</code>的引用对象可能没有完成初始化。因为<code>instance = new DoubleCheckLock()</code>;可以分为以下3步完成(伪代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null</span></span><br></pre></td></tr></table></figure><p>由于步骤1和步骤2间可能会重排序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象</span></span><br></pre></td></tr></table></figure><p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问<code>instance</code>不为<code>null</code>时，由于<code>instance</code>实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用<code>volatile</code>禁止<code>instance</code>变量被执行指令重排优化即可。</p><p>关于指令重排序，我们已经讨论了cpu流水线的重排序，接下来没问会讨论另外两种重排序，编译器重排序和缓存引起的重排序。</p><h2><span id="参考">参考:</span></h2><ul><li><a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">全面理解Java内存模型(JMM)及volatile关键字</a></li><li><a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf" target="_blank" rel="noopener">JSR133中文版1.pdf</a></li><li><a href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html" target="_blank" rel="noopener">Why Memory Barriers</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP系列(1)</title>
      <link href="/article/tcpip-overview/"/>
      <url>/article/tcpip-overview/</url>
      
        <content type="html"><![CDATA[<h1><span id="一-计算机网络体系结构分层">一、 计算机网络体系结构分层</span></h1><p><img src="/article/tcpip-overview/1561949241852tcpip-overview_.png" alt></p><p>七层网络模型是一个理想的模型，而TCP/IP 则是从中演变而来</p><h1><span id="二-tcpip-基础">二、 TCP/IP 基础</span></h1><h2><span id="1tcpip-模型">1.TCP/IP 模型</span></h2><p><img src="/article/tcpip-overview/1561949339710tcpip-overview_.png" alt></p><h2><span id="2-tcpip-的具体含义">2. TCP/IP 的具体含义</span></h2><p>TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><h2><span id="3-数据包">3. 数据包</span></h2><p>包、帧、数据包、段、消息<br>以上五个术语都用来表述数据的单位，大致区分如下：</p><ul><li>包可以说是全能性术语；</li><li>帧用于表示数据链路层中包的单位；</li><li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li><li>段则表示 TCP 数据流中的信息；</li><li>消息是指应用协议中数据的单位。</li></ul><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="/article/tcpip-overview/1561949470260tcpip-overview_.png" alt></p><h2><span id="4-数据处理流程">4. 数据处理流程</span></h2><p>下图以用户 a 向用户 b 发送邮件为例子：<br><img src="/article/tcpip-overview/1561949594954tcpip-overview_.png" alt></p><p>数据处理流程</p><ul><li><p>① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p></li><li><p>② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p></li><li><p>③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p></li><li><p>④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p></li><li><p>⑤ 网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p></li><li><p>⑥ IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p></li><li><p>⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p></li><li><p>⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p></li></ul><h1><span id="三-传输层中的-tcp-和-udp">三、传输层中的 TCP 和 UDP</span></h1><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><ul><li><p>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“<strong>流控制（流量控制）</strong>”、“<strong>拥塞控制</strong>”、<strong>提高网络利用率</strong>等众多功能。</p></li><li><p>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p></li></ul><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p><h2><span id="1-端口号">1. 端口号</span></h2><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><h3><span id="11-根据端口号识别应用">1.1 根据端口号识别应用</span></h3><p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p><p><img src="/article/tcpip-overview/1561949956557tcpip-overview_.png" alt="通过端口号识别应用"></p><h3><span id="12-通过-ip-地址-端口号-协议号进行通信识别">1.2 通过 IP 地址、端口号、协议号进行通信识别</span></h3><p>通过端口号、IP地址、协议号进行通信识别</p><ul><li><p>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</p></li><li><p>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p></li></ul><h3><span id="13-端口号的确定">1.3 端口号的确定</span></h3><p>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p><p><strong>时序分配法</strong>：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</p><h3><span id="14-端口号与协议">1.4 端口号与协议</span></h3><p>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。<br>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p><h2><span id="2-udp">2. UDP</span></h2><ul><li><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</p></li><li><p>出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</p></li><li><p>此外，传输途中出现丢包，UDP 也不负责重发。</p></li><li><p>甚至当包的到达顺序出现乱序时也没有纠正的功能。<br>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p></li></ul><p>UDP 常用于一下几个方面：</p><ul><li>1.包总量较少的通信（DNS、SNMP等）；</li><li>2.视频、音频等多媒体通信（即时通信）；</li><li>3.限定于 LAN 等特定网络中的应用通信；</li><li>4.广播通信（广播、多播）。</li></ul><h2><span id="3-tcp">3. TCP</span></h2><p>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能。</p><ul><li><p>进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</p></li><li><p>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p></li><li><p>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过<code>检验和、序列号、确认应答、重发控制、连接管理以及窗口控制</code>等机制实现）。</p></li></ul><h3><span id="31-三次握手重点">3.1 三次握手（重点）</span></h3><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p><p><img src="/article/tcpip-overview/1561951414718tcpip-overview_.png" alt></p><ul><li><p><strong>第一次握手</strong>：客户端将标志位<code>SYN</code>置为1，随机产生一个值<code>seq=J</code>，并将该数据包发送给服务器端，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p></li><li><p><strong>第二次握手</strong>：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将标志位<code>SYN</code>和<code>ACK</code>都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p></li><li><p><strong>第三次握手</strong>：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p></li></ul><h4><span id="几点问题">几点问题</span></h4><ul><li><p>seq=J 随机号</p><blockquote><p>TCP握手采用随机序列号（不完全随机，而是随着时间流逝而线性增长，到了2^32尽头再回滚），为的就是让攻击者更难以猜测sequence number，因为伪造的sequence number不在合法范围内，而被接收方丢弃，增加安全性。</p></blockquote></li><li><p>ack=J+1 确认机制</p><blockquote><p>报文不一定会按发送的时序到达目标，所以要加一</p></blockquote></li><li><p>SYN 攻击</p><blockquote><p>SYN攻击。client伪造大量随机ip，向server发送SYN=1，seq=X的第一步的连接请求，server给不存在的ip发送SYN=1，ACK=1，ack=X+1,seq=Y响应，由于client的ip不是实际存在的，所以server发出的消息不能到达，server不断的重试直到超时，那么server的连接队列会被占满，正常的TCP握手请求就无法到达server，影响了正常的连接请求，导致网络阻塞或者server系统瘫痪。这种SYN攻击通过命令netstat -nap | grep SYN_RECV可以查出来.</p></blockquote><blockquote><p>于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p></blockquote><blockquote><p>请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</p></blockquote></li></ul><h3><span id="32-四次挥手重点">3.2 四次挥手（重点）</span></h3><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p><img src="/article/tcpip-overview/1561952951862tcpip-overview_.png" alt></p><p>四次挥手</p><p>中断连接端可以是客户端，也可以是服务器端。</p><ul><li><p><strong>第一次挥手</strong>: 客户端发送一个<code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入<code>FIN_WAIT_1</code>状态。意思是说&quot;我客户端没有数据要发给你了&quot;，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p></li><li><p><strong>第二次挥手</strong>: 服务器端收到FIN后，先发送<code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入<code>FIN_WAIT_2</code> 状态，继续等待服务器端的FIN报文。</p></li><li><p><strong>第三次挥手</strong> :当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入<code>LAST_ACK</code>状态。</p></li><li><p><strong>第四次挥手</strong>: 客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送<code>ack=N+1</code>后进入<code>TIME_WAIT</code>状态，如果Server端没有收到<code>ACK</code>则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</p></li></ul><h3><span id="33-tcp超时与重传机制">3.3 TCP超时与重传机制</span></h3><p><img src="/article/tcpip-overview/1562118945313tcpip-overview_.png" alt></p><p>TCP协议是一种面向连接的可靠的传输层协议，它保证了数据的可靠传输，对于一些出错，超时丢包等问题TCP设计的超时与重传机制。</p><p><strong>其基本原理</strong>：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><p>这里比较重要的是重传超时时间，怎样设置这个定时器的时间（RTO），从而保证对网络资源最小的浪费。因为若RTO太小，可能有些报文只是遇到拥堵或网络不好延迟较大而已，这样就会造成不必要的重传。太大的话，使发送端需要等待过长的时间才能发现数据丢失，影响网络传输效率。</p><p>由于不同的网络情况不一样，不可能设置一样的RTO，实际中RTO是根据网络中的 <code>RTT</code>（传输往返时间）来自适应调整的。 这里就不展开了。</p><h3><span id="34-tcp流量控制">3.4 TCP流量控制</span></h3><p>图解：</p><p><img src="/article/tcpip-overview/1562037078236tcpip-overview_.png" alt></p><ul><li>滑动窗口协议</li></ul><p>TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。</p><p><img src="/article/tcpip-overview/1562039919707tcpip-overview_.png" alt></p><p>TCP消息确认机制如上图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备B定期发送给A一条发送限制参数，制约设备A一次能发送的消息最大数量。设备B可以对该参数进行调整，以控制设备A的数据流。</p><p>为了提高速度，TCP并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用message ID字段，而是使用的片段内最后一个字节的sequence number。因此一次可以处理不同的字节数，这一数量即为片段内的sequence number。</p><ul><li><ol><li>TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；</li></ol></li><li><ol start="2"><li>发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；</li></ol></li><li><ol start="3"><li>发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</li></ol></li><li><ol start="4"><li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；</li></ol></li></ul><p>我们来看一个例子：</p><ul><li><strong>TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为<code>20</code></strong>：</li></ul><p><img src="/article/tcpip-overview/1562040200219tcpip-overview_.png" alt></p><ul><li><strong>A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组</strong>：</li></ul><p><img src="/article/tcpip-overview/1562040234614tcpip-overview_.png" alt></p><ul><li><strong>只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递</strong></li></ul><p><img src="/article/tcpip-overview/1562041418982tcpip-overview_.png" alt></p><ul><li><p>回退协议</p><ul><li>TCP片段重传计时器以及重传队列:<br>检测丢失片段并对之重传的方法概念上是很简单的。每一次发送一个片段，就开启一个重传计时器。计时器有一个初始值并随时间递减。如果在片段接收到确认之前计时器超时，就重传片段。TCP使用了这一基本技术，但实现方式稍有不同。原因在于为了提高效率需要一次处理多个未被确认的片段，以保证每一个在恰当的时间重传。TCP按照以下特定顺序工作：</li></ul></li><li><p>比特滑动窗口协议</p><p>滑动窗口协议的理论，实际应用中又有不同。首先就是停等协议(stop－and－wait)，这时接受方的窗口和发送方的窗口大小都是1，1个比特就够表示了，所以也叫1比特滑动窗口协议。发送方这时自然发送每次只能发送一个，并且必须等待这个数据包的ACK，才能发送下一个。虽然在效率上比较低，带宽利用率明显较低，不过在网络环境较差，或是带宽本身很低的情况下，还是适用的。看下面的流程图：</p></li><li><p>退后N帧协议</p><p>停等协议虽然实现简单，也能较好的适用恶劣的网络环境，但是显然效率太低。所以有了后退n协议，这也是滑动窗口协议真正的用处，这里发送的窗口大小为n，接受方的窗口仍然为1。具体看下面的图，这里假设n=9：      首先发送方一口气发送10个数据帧，前面两个帧正确返回了，数据帧2出现了错误，这时发送方被迫重新发送2-8这7个帧，接受方也必须丢弃之前接受的3-8这几个帧。      后退n协议的好处无疑是提高了效率，但是一旦网络情况糟糕，则会导致大量数据重发，反而不如上面的停等协议，实际上这是很常见的，<br><img src="/article/tcpip-overview/1562119313949tcpip-overview_.png" alt></p></li><li><p>选择重传协议（Fast Retransmit）</p><p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p><p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p><p><img src="/article/tcpip-overview/1562043567516tcpip-overview_.png" alt></p><p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p></li></ul><ul><li><p>SACK 方法</p><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p><p><img src="/article/tcpip-overview/1562119794860tcpip-overview_.png" alt></p><p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p><p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p><p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》</p></li></ul><h3><span id="35-tcp拥塞控制">3.5 TCP拥塞控制</span></h3><ol><li>慢开始（slow start）<br>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</li></ol><p>慢启动的算法如下(cwnd全称Congestion Window)：</p><ul><li><p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p></li><li><p>2）每当收到一个ACK，cwnd++; 呈线性上升</p></li><li><p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p></li><li><p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p></li></ul><p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p><p><img src="/article/tcpip-overview/1562120996693tcpip-overview_.png" alt></p><ol start="2"><li>拥塞避免（Congestion Avoidance）</li></ol><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p><ul><li><p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p></li><li><p>2）当每过一个RTT时，cwnd = cwnd + 1</p></li></ul><p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p><ol start="3"><li><p>快速重传（fast retransmit）<br>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认</p><p><img src="/article/tcpip-overview/1562121439564tcpip-overview_.png" alt></p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%</p></li></ol><ol start="4"><li><p>快速回复（fast recovery）</p><ul><li><p>1:当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p></li><li><p>2:由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p></li><li><p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p></li></ul><p><img src="/article/tcpip-overview/1562121516316tcpip-overview_.png" alt></p><p>实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用,采用这样的拥塞控制方法使得TCP的性能有明显的改进</p></li></ol><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之数据结构篇——树（2）</title>
      <link href="/article/data-structure-tree-b-puls/"/>
      <url>/article/data-structure-tree-b-puls/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><span style="font-family: 方正姚体; font-size: large;">概诉 </span></p><hr><h2><span id="b-树的定义">B+ 树的定义</span></h2><p><img src="/article/data-structure-tree-b-puls/1577764304776data-structure-tree-b-puls_.png" alt></p><p>关于B树的阶数和度数已经在上一篇<a href="https://icefrozen.github.io/article/B-Tree-And-B-Tree/" target="_blank" rel="noopener">算法探秘系列之数据结构篇——树（1）</a></p><p><span style="font-family: 仿宋; font-size: large;">除此之外B+树还有以下的要求。</span></p><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</span></p></li></ul><p> </p><h2><span id="b-树的操作">B+ 树的操作</span></h2><h1><span id="一-b树的插入操作"><span style="font-family: 黑体; font-size: x-large;">一、B+树的插入操作</span></span></h1><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</span></p></li></ul><p><span style="font-family: 仿宋; font-size: large;">下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">a）空树中插入5</span></p><p><img src="/article/data-structure-tree-b-puls/1577764324380data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">b）依次插入8，10，15</span></p><p><img src="/article/data-structure-tree-b-puls/1577764335394data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">c）插入16</span></p><p><img src="/article/data-structure-tree-b-puls/1577764346561data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764357872data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">d）插入17</span></p><p><img src="/article/data-structure-tree-b-puls/1577764368991data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">e）插入18，插入后如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764378857data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764389302data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数满足条件，插入结束。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">f）插入若干数据后</span></p><p><img src="/article/data-structure-tree-b-puls/1577764399238data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">g）在上图中插入7，结果如下图所示 </span></p><p><img src="/article/data-structure-tree-b-puls/1577764406347data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764418069data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764428601data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">当前结点的关键字个数满足条件，插入结束。</span></p><p> </p><h1><span id="二-b树的删除操作"><span style="font-family: 黑体;"><span style="font-size: x-large;">二、B+树的删除操作</span></span></span></h1><p><span style="font-family: 仿宋; font-size: large;">如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</span></p><ul><li><p><span style="font-family: 仿宋; font-size: large;">1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</span></p></li><li><p><span style="font-family: 仿宋; font-size: large;">6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</span></p></li></ul><p><span style="font-family: 仿宋; font-size: large;">注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</span></p><p><span style="font-family: 仿宋; font-size: large;">下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">a）初始状态</span></p><p><img src="/article/data-structure-tree-b-puls/1577764441677data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">b）删除22,删除后结果如下图</span></p><p><img src="/article/data-structure-tree-b-puls/1577764449973data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">删除后叶子结点中key的个数大于等于2，删除结束</span></p><hr><p><span style="font-family: 仿宋; font-size: large;">c）删除15，删除后的结果如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764460004data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764479201data-structure-tree-b-puls_.png" alt></p><hr><p><span style="font-family: 仿宋; font-size: large;">d）删除7，删除后的结果如下图所示</span></p><p><img src="/article/data-structure-tree-b-puls/1577764487719data-structure-tree-b-puls_.png" alt><br><span style="font-family: 仿宋; font-size: large;">当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764500392data-structure-tree-b-puls_.png" alt></p><p><span style="font-family: 仿宋; font-size: large;">此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。</span></p><p><img src="/article/data-structure-tree-b-puls/1577764509124data-structure-tree-b-puls_.png" alt></p><h4><span id> </span></h4><h4><span id="3参考内容"><span style="font-family: 黑体; font-size: large; font-weight: normal;">3.参考内容</span></span></h4><p>[1] <a href="https://www.cnblogs.com/wade-luffy/p/6292784.html" target="_blank" rel="noopener">B+树介绍</a><br>[2] <a href="http://hedengcheng.com/?p=525" target="_blank" rel="noopener">从MySQL Bug#67718浅谈B+树索引的分裂优化</a><br>[3] <a href="https://www.jianshu.com/p/6f68d3c118d6" target="_blank" rel="noopener">B+树的几点总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之概率随机算法(1)</title>
      <link href="/article/bloomfilter/"/>
      <url>/article/bloomfilter/</url>
      
        <content type="html"><![CDATA[<h2><span id="什么是布隆过滤器">什么是布隆过滤器</span></h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h2><span id="实现原理">实现原理</span></h2><h3><span id="hashmap-的问题">HashMap 的问题</span></h3><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p><h3><span id="布隆过滤器数据结构">布隆过滤器数据结构</span></h3><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br><img src="/article/bloomfilter/1561976816306bloomfilter_.png" alt></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：<br><img src="/article/bloomfilter/1561977049305bloomfilter_.png" alt></p><p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/article/bloomfilter/1561977074282bloomfilter_.png" alt></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><h4><span id="支持删除么">支持删除么</span></h4><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。</p><p>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。</p><h4><span id="false-positives-概率推导">False positives 概率推导</span></h4><p>假设 Hash 函数以等概率条件选择并设置 Bit Array 中的某一位，<code>m</code> 是该位数组的大小，<code>k</code> 是 <code>Hash</code> 函数的个数，那么位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是:</p><div align="center"><p><img src="/article/bloomfilter/1561977732449bloomfilter_.png" alt></p></div><p>那么在所有 k 次 Hash 操作后该位都没有被置 “1” 的概率是：</p><div align="center"><p><img src="/article/bloomfilter/1561977826148bloomfilter_.png" alt></p></div><p>如果我们插入了 n 个元素，那么某一位仍然为 “0” 的概率是</p><div align="center"><p><img src="/article/bloomfilter/1561977842227bloomfilter_.png" alt></p></div><p>因而该位为 &quot;1&quot;的概率是：</p><div align="center"><p><img src="/article/bloomfilter/1561977861881bloomfilter_.png" alt></p></div><p>现在检测某一元素是否在该集合中。标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 “1”，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定：</p><div align="center"><p><img src="/article/bloomfilter/1561977925870bloomfilter_.png" alt></p></div>其中：<div align="center"><p><img src="/article/bloomfilter/1561979531108bloomfilter_.png" alt></p></div><p>其实上述结果是在假定由每个 Hash 计算出需要设置的位（bit） 的位置是相互独立为前提计算出来的，不难看出，随着 m （位数组大小）的增加，假正例（False Positives）的概率会下降，同时随着插入元素个数 n 的增加，False Positives的概率又会上升，对于给定的m，n，如何选择Hash函数个数 k 由以下公式确定：</p><div align="center"><p><img src="/article/bloomfilter/1561979719773bloomfilter_.png" alt></p></div><h4><span id="k-值的估算">K 值的估算</span></h4><div align="center"><p><img src="/article/bloomfilter/1561981022666bloomfilter_.png" alt></p></div><h4><span id="bloom-filter内存占用">Bloom Filter内存占用</span></h4><p><img src="/article/bloomfilter/1561982659598bloomfilter_.png" alt></p><h4><span id="结论">结论</span></h4><p>当 K 为一下值的时候 误差率最小</p><div align="center"><p><img src="/article/bloomfilter/1561979719773bloomfilter_.png" alt></p></div>此时的误差为：<div align="center"><p><img src="/article/bloomfilter/1561979726393bloomfilter_.png" alt></p></div><p>此时的 M 即空间消耗为：</p><div align="center"><p><img src="/article/bloomfilter/1561979739269bloomfilter_.png" alt></p></div><h2><span id="布隆过滤器的应用场景">布隆过滤器的应用场景</span></h2><ul><li>大数据去重</li><li>网页爬虫对URL的去重，避免爬取相同的URL地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li><li>缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Redis </tag>
            
            <tag> 概率随机算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之数据结构篇——树（1）</title>
      <link href="/article/B-Tree-And-B-Tree/"/>
      <url>/article/B-Tree-And-B-Tree/</url>
      
        <content type="html"><![CDATA[<p><strong><em>注意：首先需要说明的一点是：B-树就是B树，没有所谓的B减树</em></strong></p><h1><span id="引言">引言</span></h1><p>我们都知道二叉查找树的查找的时间复杂度是Ｏ(log N)，其查找效率已经足够高了，那为什么还有Ｂ树和Ｂ＋树的出现呢？难道它两的时间复杂度比二叉查找树还小吗？</p><p>答案当然不是，Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是磁盘ＩＯ，众所周知ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。<br>　　所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是：</p><ul><li>(1)、<strong>每个节点存储多个元素</strong></li><li>(2)、<strong>摒弃二叉树结构，采用多叉树</strong></li></ul><p>这样就引出来了一个新的查找树结构 ——多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B~树)自然可以使得数据的查找效率保证在O(logN)这样的对数级别上。即多路平衡查找树</p><p>下面来具体介绍一下<code>B树（Balance Tree）</code>，</p><h1><span id="b树">Ｂ树</span></h1><h3><span id="b树的定义">B树的定义</span></h3><p>一个m阶的B树具有如下几个<strong>特征</strong>：B树中所有结点的孩子结点最大值称为B树的阶，通常用m表示。一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集。<br>这里 k 表示为度，而m 表示为阶数</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含<code>k-1</code>个元素和<code>k</code>个孩子，其中 <code>ceil（m/2） ≤ k ≤ m</code></li><li>每一个叶子节点都包含<code>k-1</code>个元素，其中 <code>ceil（m/2） ≤ k ≤ m</code></li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中<code>k-1</code>个元素正好是k个孩子包含的元素的值域划分</li><li>每个结点的结构为：<code>（n，A0，K1，A1，K2，A2，… ，Kn，An）</code>其中，<code>Ki(1≤i≤n)</code>为关键字，且<code>Ki&lt;Ki+1(1≤i≤n-1)</code>。<br><code>Ai(0≤i≤n)</code>为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于<code>Ki+1</code>。<code>n</code>为结点中关键字的个数，满足<code>ceil(m/2)-1≤n≤m-1</code>。</li></ol><h3><span id="示例三阶b树">示例：三阶B树</span></h3><p><img src="/article/B-Tree-And-B-Tree/1559615879973B-Tree-And-B-Tree_.png" alt></p><h3><span id="b树的两种定义">B树的两种定义</span></h3><p>B树的两种定义，一种是算法导论中的度数说；另一种是维基百科的阶数说。</p><p><strong>度数</strong>：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。<br><strong>阶数</strong>：（Order）阶定义为一个节点的子节点数目的最大值。（自带最大值属性）<br>然后再结合B树来理解具体含义：</p><h3><span id="度数与阶数的区别">度数与阶数的区别</span></h3><p>每个节点（结点）所包含的关键字个数有上界和下界。用一个被称为B树的<code>最小度数（minmum degree</code>）的固定整数<code>t&gt;=2</code>来表示这些界。</p><p><strong>a . 除根节点外每个节点至少包含 t-1 个关键字；至少有t个孩子。</strong><br><strong>b . 每个节点至多可包含 2t-1 个关键字，至多 2t 个孩子节点。</strong></p><p>比如当t=2时，每个内部节点可以有2，3，4个孩子。此时该B树的阶为4。</p><p><strong>至于这两种定义的差别请参考知乎<a href="https://www.zhihu.com/question/19836260" target="_blank" rel="noopener">为什么 B-tree 在不同著作中度的定义有一定差别？</a></strong></p><p>我这里只做简单的介绍，度的定义用来优化阶的定义，主要却别在于，阶数只能定义一个节点满和不满的情况，而度则是在基础上对应了 不满，半满，和全满的情况。 半满对应阶数的满情况，当节点达到全满的情况下才去分裂节点，这样既能满足b树的平衡，用能减少分裂带来的需要找到父节点所带来的开销，毕竟b树的应用场景还是数据库的索引。</p><h2><span id="查询">查询</span></h2><p>以上图为例：若查询的数值为５：</p><ul><li><strong>第一次磁盘ＩＯ</strong>：在内存中定位（与17、35比较），比17小，左子树；</li><li><strong>第二次磁盘ＩＯ</strong>：在内存中定位（与８、12比较），比８小，左子树；</li><li><strong>第三次磁盘ＩＯ</strong>：在内存中定位（与3、5比较），找到5，终止。</li></ul><p>整个过程中，我们可以看出：比较的次数并不比二叉查找树少，尤其适当某一节点中的数据很多时，但是磁盘IO的次数却是大大减少。比较是在内存中进行的，相比于磁盘IO的速度，比较的耗时几乎可以忽略。所以当树的高度足够低的话，就可以极大的提高效率。相比之下，节点中的元素多点也没关系，仅仅是多了几次内存交互而已，只要不超过磁盘页的大小即可。</p><h2><span id="插入">插入</span></h2><h3><span id="插入逻辑">插入逻辑</span></h3><p>对度数为<code>ｋ</code>的<code>m</code>阶B树，新结点一般是插在叶子层。通过检索可以确定关键码应插入的结点位置。然后分两种情况讨论：</p><ol><li>如果根节点的关键字 等于 <code>2k - 1</code> 则根节点分裂（）</li><li>循环找到B树要插入的叶节点（因为插入总发生在叶子节点）<br>在插入过程中会遇到节点数 满足 <code>2k - 1</code>的节点，遇到这样的节点就要分裂（以度数<code>k</code>为中心点分裂）。当分裂完成之后，必然会产生<code>t</code> 和 <code>t - 1</code> 关键字的两个节点，而分裂的节点又会上升到父节点当中去，所以，父节点的关键字数不能等于 <code>2k - 1</code>否则将不匹配B数的定义</li><li>当经过第二步完成的时候，必然会找到一个叶子节点，其关键字 小于等于 <code>2k - 1</code>，然后插入改节点。注意这里面的关键字可以是 小于，也可以是等于。</li></ol><p>注意：  为什么没有用阶数m用于区分原因就是，当<code>m</code> 数是一个固定的数字，没有缓冲边界。所以，一定<code>m</code> 满足了某种特定的条件，则必须要要分裂，分裂导致的父节点关键字+1 可能会引起父节点的分裂。一次类推，导致这种分裂将会一直想上直到根节点，在索引中目的就是要减少内存页的置换次数，如果一直分裂到父节点，意味着内存页面的置换需要一直进行到父节点。因此，为了减少这次的置换调用，算法导论中用了度数来替代阶数的定义，这样就是的每个非叶子节点的关键字个数从放宽了一个限制，在每次插入的时候，在进行分裂，这样就避免了上述多余一次的调用。</p><h3><span id="插入举例">插入举例</span></h3><p>例如：<br>我们以<code>[13, 3, 17, 10, 4, 12, 19, 9, 15, 18, 8, 2, 0, 6, 1, 16, 7, 11, 5, 14]</code> 序列来插入</p><p>例如：<br><img src="/article/B-Tree-And-B-Tree/1561375198045B-Tree-And-B-Tree_.png" alt></p><h4><span id="插入">插入</span></h4><p>插入逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,key)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(self.root) == self.degree * <span class="number">2</span> - <span class="number">1</span>:</span><br><span class="line">        <span class="comment">## 分裂根节点</span></span><br><span class="line">        self.root = self.root.split(node(isLeaf=<span class="literal">False</span>),self.degree)</span><br><span class="line">        self.nodeNum +=<span class="number">2</span></span><br><span class="line">    nd = self.root</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        idx = nd.findKey(key) <span class="comment"># 找到key 的位置</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt; len(nd) <span class="keyword">and</span> nd[idx] == key:<span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 插入操作总在叶子节点发生</span></span><br><span class="line">        <span class="keyword">if</span> nd.isLeafNode():</span><br><span class="line">            nd.insert(idx,key)</span><br><span class="line">            self.keyNum+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chd = nd.getChd(idx)</span><br><span class="line">            <span class="comment"># 当节点分裂只会，chd 就已经在树中被阻断了，因此这边要记下来，应为chd的child 毕竟</span></span><br><span class="line">            <span class="keyword">if</span> len(chd) == self.degree*<span class="number">2</span><span class="number">-1</span>: </span><br><span class="line">                <span class="comment"># split 返回的其实是chd 的parent_node 很为在split 就已经处理过了parent</span></span><br><span class="line">                <span class="comment"># 所以下次插入的key的寻找节点还要在这里开始</span></span><br><span class="line">                nd = chd.split(nd,self.degree)</span><br><span class="line">                self.nodeNum +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nd = chd</span><br></pre></td></tr></table></figure><h4><span id="分裂">分裂</span></h4><p>我们来看分裂的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self,prt,t)</span>:</span></span><br><span class="line">    <span class="comment"># 度数 可以用来分割节点   prt 为parent_node</span></span><br><span class="line">    k = self[t<span class="number">-1</span>]</span><br><span class="line">    nd1 = node()</span><br><span class="line">    nd2 = node()</span><br><span class="line">    nd1.keys,nd2.keys = self[:t<span class="number">-1</span>], self[t:] <span class="comment"># note that t is 1 bigger than  key index</span></span><br><span class="line">    nd1.isLeaf = nd2.isLeaf = self.isLeaf</span><br><span class="line">    <span class="comment"># 非叶子节点的分裂</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.isLeaf: </span><br><span class="line">        <span class="comment"># note that  children index is one bigger than key index, and all children included</span></span><br><span class="line">        nd1.children, nd2.children = self.children[<span class="number">0</span>:t], self.children[t:] </span><br><span class="line">    <span class="comment"># connect them to parent</span></span><br><span class="line">    idx = prt.findKey(k)</span><br><span class="line">    <span class="keyword">if</span> prt.children !=[]: prt.children.remove(self) <span class="comment"># remove the original node</span></span><br><span class="line">    prt.insert(idx,k,nd2)</span><br><span class="line">    prt.insert(idx,nd = nd1)</span><br><span class="line">    <span class="keyword">return</span> prt</span><br></pre></td></tr></table></figure><h4><span id="最后结果">最后结果</span></h4><p>最后的树结构如下<br><img src="/article/B-Tree-And-B-Tree/1561375618993B-Tree-And-B-Tree_.png" alt></p><h2><span id="删除">删除</span></h2><p>Ｂ树中关键字的删除比插入更复杂，在这里，只介绍其中的一种方法：</p><p>在B树上删除关键字k的过程分两步完成： <strong>找出该关键字所在的结点。然后根据 <code>k</code>所在结点是否为叶子结点有不同的处理方法。</strong></p><h4><span id="第一步-找出删除节点">第一步 找出删除节点</span></h4><ul><li><strong>若该结点为<code>非叶结点</code></strong>，<ol><li>找到被删除的<code>key</code>所在的节点。</li><li>在<code>key</code>节点所在的子树找到叶节点,并找出改叶节点的最大的关键字<code>Y</code>,并记录下查找的节点的路径。</li><li>替换这个<code>Y</code>,当前<code>key</code></li><li>然后依次从后往前遍历节点路径中不满足定义的节点，然后根据情况左选右选或者合并，用来保持b树的平衡。</li></ol></li></ul><h4><span id="第一步-由小到大自平衡">第一步 由小到大自平衡</span></h4><ul><li><p>如果被删关键字所在结点的原关键字个数小于<code>k - 1</code>，说明删去该关键字后该结点不满足B树的定义。</p></li><li><p>自平衡的过程就是想兄弟或者父母借节点，使得父兄组成的树中是自平衡的，这个时候会有如下几种情况</p><ul><li>兄弟关键字个数大于 <code>k</code></li><li>左边和右边关键字个数都小于等于 <code>k</code></li></ul></li><li><p><strong>兄弟关键字个数大于 <code>k</code></strong><br>则可将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在结点中。然后将上升的左右节点根据情况连接到改节点的左右孩子上</p></li></ul><p>例如： 删除<code>3</code> 这个节点</p><p><img src="/article/B-Tree-And-B-Tree/1561377183013B-Tree-And-B-Tree_.png" alt></p><ul><li><p><strong>左边和右边关键字个数都小于等于 <code>k</code></strong></p><p>1、 将兄弟节点合并成一个节点<br>2、 将父节点拿下一个来放到这个新节点当中<br>3、 删除父节点拿下来的这个<code>key</code><br>4、 然后父节点在自平衡一下</p></li></ul><p>例子： 我们来看一下 删除<code>3</code>后在接近这删除<code>2</code></p><ul><li>第一步：删除节点 这个时候我们路保存了路径<br><img src="/article/B-Tree-And-B-Tree/1561379292282B-Tree-And-B-Tree_.png" alt></li><li>第二部，兄弟节点过少，无法满足平衡，合并兄弟节点，将父节点拿下来</li><li>第三部（左旋转），这个父节点（1,2的父节点） 再次自平衡，将root 的4 拿下来，root节点的下一个孩子的最小值拿上来8，然后，然后8的左孩子给到 1，2 父节点的右孩子<br><img src="/article/B-Tree-And-B-Tree/1561379255788B-Tree-And-B-Tree_.png" alt></li></ul><p>总之，设所删关键字为非终端结点中的Ki，则可以指针Ai所指子树中的最小关键字Y代替Ki，然后在相应结点中删除Y。对任意关键字的删除都可以转化为对最下层关键字的删除。</p><p>我们来看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebalance</span><span class="params">(self,fathers)</span>:</span></span><br><span class="line">    <span class="comment"># fatners 表示 这个节点，key 节点位置 父节点的指针</span></span><br><span class="line">    nd,keyIdx,chdIdx = fathers.pop()</span><br><span class="line">    <span class="keyword">while</span> len(nd)&lt;self.degree - <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 当节点已经不平衡的时候 找到他的父节点</span></span><br><span class="line">        prt,keyIdx,chdIdx = fathers[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 左边兄弟</span></span><br><span class="line">        lbro = [] <span class="keyword">if</span> chdIdx==<span class="number">0</span> <span class="keyword">else</span> prt.getChd(chdIdx<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右边的兄弟</span></span><br><span class="line">        rbro = [] <span class="keyword">if</span> chdIdx==len(prt) <span class="keyword">else</span> prt.getChd(chdIdx+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果左右兄弟都没有到 degree 则两个兄弟合并</span></span><br><span class="line">        <span class="keyword">if</span> len(lbro) &lt; self.degree <span class="keyword">and</span> len(rbro) &lt; self.degree:  <span class="comment"># merge two deficient nodes </span></span><br><span class="line">            beforeNode,afterNode = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">            <span class="comment"># 把父亲的 keyindex 拿下来，然后在想左边兄弟借一个key</span></span><br><span class="line">            <span class="keyword">if</span> lbro ==[]:</span><br><span class="line">                keyIdx = chdIdx</span><br><span class="line">                beforeNode,afterNode = nd,rbro</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果左边的兄弟为空 则把这个节点和右边的节点合并</span></span><br><span class="line">                beforeNode,afterNode = lbro,nd</span><br><span class="line">                keyIdx = chdIdx<span class="number">-1</span>      <span class="comment"># important, when choosing </span></span><br><span class="line">            keys = beforeNode[:]+[prt[keyIdx]]+afterNode[:]</span><br><span class="line">            <span class="comment"># 合并节点的孩子</span></span><br><span class="line">            children = beforeNode.getChildren() + afterNode.getChildren()</span><br><span class="line">            isLeaf = beforeNode.isLeafNode()</span><br><span class="line">            prt.delChd(keyIdx+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">del</span> prt[keyIdx]</span><br><span class="line">            nd.update(keys,isLeaf,children)</span><br><span class="line">            prt.children[keyIdx]=nd</span><br><span class="line">            self.nodeNum -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> len(lbro)&gt;=self.degree:  <span class="comment"># rotate  when only one sibling is deficient</span></span><br><span class="line">            <span class="comment"># 右旋转</span></span><br><span class="line">            keyIdx = chdIdx<span class="number">-1</span></span><br><span class="line">            nd.insert(<span class="number">0</span>,prt[keyIdx])    <span class="comment"># rotate keys</span></span><br><span class="line">            prt[keyIdx] =  lbro[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">del</span> lbro[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nd.isLeafNode():     <span class="comment"># if not leaf, move children</span></span><br><span class="line">                nd.insert(<span class="number">0</span>,nd=lbro.getChd(<span class="number">-1</span>))</span><br><span class="line">                lbro.delChd(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 左旋转 父节点拿下一个key 父节点右边第一个子树的根节点上升一个节点</span></span><br><span class="line">            <span class="comment"># 上升的一个节点左孩子链接到当前孩子的右子树当中去</span></span><br><span class="line">            keyIdx = chdIdx</span><br><span class="line">            nd.insert(len(nd),prt[keyIdx])    <span class="comment"># rotate keys</span></span><br><span class="line">            prt[keyIdx] =  rbro[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">del</span> rbro[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nd.isLeafNode():     <span class="comment"># if not leaf, move children</span></span><br><span class="line">                <span class="comment">#note that insert(-1,ele) will make the ele be the last second one</span></span><br><span class="line">                nd.insert(len(nd),nd=rbro.getChd(<span class="number">0</span>))</span><br><span class="line">                rbro.delChd(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> len(fathers)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.root)==<span class="number">0</span>: </span><br><span class="line">                self.root = nd</span><br><span class="line">                self.nodeNum -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nd,i,j = fathers.pop()</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>①、B树主要用于文件系统以及部分数据库索引，例如： MongoDB。而大部分关系数据库则使用B+树做索引，例如：mysql数据库；<br>　　②、从查找效率考虑一般要求B树的阶数m &gt;= 3;<br>　　③、B-树上算法的执行时间主要由读、写磁盘的次数来决定，故一次I/O操作应读写尽可能多的信息。因此B-树的结点规模一般以一个磁盘页为单位。一个结点包含的关键字及其孩子个数取决于磁盘页的大小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之分布式锁实现</title>
      <link href="/article/distributed-redis-lock/"/>
      <url>/article/distributed-redis-lock/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>在大多数的情况下，我们需要对一个共享资源进行写操作，在分布式的环境下，对于资源的写操作的互斥性就显得尤为重要。由于生产环境对redis有很多依赖，所以最近在分布式锁的实现上进行了一些调研。</p><p>对于锁的安全性，一直是分布式领域不可逃避的话题，一个分布式锁的实现在网上所以下，就会发现，这些文章的思路大体相近，给出的实现算法也看似合乎逻辑，但当我们着手去实现它们的时候，却发现如果你越是仔细推敲，疑虑也就越来越多。</p><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者antirez之间就发生过一场争论。由于对这个问题一直以来比较关注，所以我前些日子仔细阅读了与这场争论相关的资料。这场争论的大概过程是这样的：为了规范各家对基于Redis的分布式锁的实现，Redis的作者提出了一个更安全的实现，叫做<code>Redlock</code>。有一天，Martin Kleppmann写了一篇<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">blog</a>，分析了Redlock在安全性上存在的一些问题。</p><p>本文结合redsiion 的对分布式锁的单点的实现机制，在结合集群下的Redlock的实现机制，分析一下分布式锁在现阶段出现的问题。</p><h2><span id="基于单redis节点的分布式锁">基于单Redis节点的分布式锁</span></h2><h2><span id="一-redisson的简单应用">一、Redisson的简单应用</span></h2><p>Redisson的官网，看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。下面给大家看一段简单的使用代码片段，先直观的感受一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br><span class="line">lock.lock()</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><h2><span id="二-redisson实现redis分布式锁的底层原理">二、Redisson实现Redis分布式锁的底层原理</span></h2><p>好的，接下来就通过一张手绘图，给大家说说Redisson这个开源框架对Redis分布式锁的实现原理。</p><p><img src="/article/distributed-redis-lock/1561904661761distributed-redis-lock_.png" alt></p><h3><span id="1加锁机制">（1）加锁机制</span></h3><p>如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。这里注意，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段lua脚本到redis上，因为可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。那段lua脚本如下所示：</p><p><img src="/article/distributed-redis-lock/1561904682972distributed-redis-lock_.png" alt></p><p>那么，这段lua脚本是什么意思呢？这里KEYS[1]代表的是你加锁的那个key，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(&quot;myLock&quot;);</span><br></pre></td></tr></table></figure><p>这里你自己设置了加锁的那个锁key就是<code>myLock</code>。<br><code>ARGV[1]</code>代表的就是锁key的默认生存时间，默认30秒。<br><code>ARGV[2]</code>代表的是加锁的客户端的ID，类似于下面这样：<br><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：hset myLock</p><p><code>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylock:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span>:<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p><p>这里一定要增加一个myLock的生存时间。否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。</p><h3><span id="2锁互斥机制">（2）锁互斥机制</span></h3><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h3><span id="3watch-dog自动延期机制">（3）watch dog自动延期机制</span></h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h3><span id="4可重入加锁机制">（4）可重入加锁机制</span></h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？比如下面这种代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br><span class="line">lock.lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// coding</span></span><br><span class="line">lock.lock()</span><br><span class="line"><span class="comment">// coding</span></span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="comment">//codeing</span></span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><p>这时我们来分析一下上面那段lua脚本。第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</p><p>此时就会执行可重入加锁的逻辑，他会用：</p><p>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1  ，通过这个命令，对客户端1的加锁次数，累加1。此时myLock数据结构变为下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylock:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"8743c9c0-0795-4907-87fd-6c719a6b4586:1"</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p><h3><span id="5释放锁机制">（5）释放锁机制</span></h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：“del myLock”命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的分布式锁的开源Redisson框架的实现机制。</p><p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p><h3><span id="6上述redis分布式锁的缺点">（6）上述Redis分布式锁的缺点</span></h3><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。</p><p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p><p>所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</p><h2><span id="基于分布式redis的redlock-的分布式锁的实现机制">基于分布式redis的RedLock 的分布式锁的实现机制</span></h2><p>由于前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此提出了新的分布式锁的算法<code>Redlock</code>，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><h4><span id="加锁过程">加锁过程</span></h4><ul><li>获取当前时间（毫秒数）。</li><li>按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同, 为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</li></ul><ul><li><p>计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p></li><li><p>如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p></li><li><p>如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即<strong>向所有</strong>Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p></li></ul><blockquote><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p></blockquote><h4><span id="redlock-出现的问题">Redlock 出现的问题</span></h4><h5><span id="崩溃重启">崩溃重启</span></h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><ul><li>客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</li><li>节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</li><li>节点C重启后，客户端2锁住了C, D, E，获取锁成功。</li></ul><p>这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p><strong>延迟重启(delayed restarts)</strong> 的概念。</p><p>也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5><span id="客户端长期阻塞导致锁过期">客户端长期阻塞导致锁过期</span></h5><p>假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。</p><p>客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p><p><img src="/article/distributed-redis-lock/1561904900083distributed-redis-lock_.png" alt></p><p>系统环境太复杂，仍然有很多原因导致进程的pause，比如虚存造成的缺页故障(page fault)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果, 即客户端进程卡死的问题。</p><p><strong>fencing token</strong> 解决方案</p><p>fencing token是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图</p><p><img src="/article/distributed-redis-lock/1561904882527distributed-redis-lock_.png" alt><br>在上图中，客户端1先获取到的锁，因此有一个较小的fencing token，等于33，而客户端2后获取到的锁，有一个较大的fencing token，等于34。客户端1从GC pause中恢复过来之后，依然是向存储服务发送访问请求，但是带了fencing token = 33。存储服务发现它之前已经处理过34的请求，所以会拒绝掉这次33的请求。这样就避免了冲突。</p><h5><span id="时钟跳转以及网络延迟">时钟跳转以及网络延迟</span></h5><p>对于时钟的过分依赖也将会导致redlock分布式锁的一些问题，首先给出了下面的两个例子（还是假设有5个Redis节点A, B, C, D, E）：</p><ul><li><p><strong>时钟跳转</strong></p><ul><li>客户端1从Redis节点A, B, C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。</li><li>节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。</li><li>客户端2从Redis节点C, D, E成功获取了同一个资源的锁（多数节点）。</li><li>客户端1和客户端2现在都认为自己持有了锁。</li></ul></li><li><p><strong>网络延迟</strong></p><ul><li>客户端1向Redis节点A, B, C, D, E发起锁请求。</li><li>各个Redis节点已经把请求结果返回给了客户端1，但客户端1在收到请求结果之前进入了长时间的GC pause。</li><li>在所有的Redis节点上，锁过期了。</li><li>客户端2在A, B, C, D, E上获取到了锁。</li><li>客户端1从GC pause从恢复，收到了前面第2步来自各个Redis节点的请求结果。客户端1认为自己成功获取到了锁。<br>+客户端1和客户端2现在都认为自己持有了锁。</li></ul></li></ul><p>时钟跳跃的时候，举了两个可能造成时钟跳跃的具体例子：</p><ul><li>系统管理员手动修改了时钟。</li><li>从NTP服务收到了一个大的时钟更新事件。</li></ul><p>对于这个方面的解决是：</p><ul><li>手动修改时钟这种人为原因，不要那么做就是了。否则的话，如果有人手动修改Raft协议的持久化日志，那么就算是Raft协议它也没法正常工作了。</li><li>使用一个不会进行“跳跃”式调整系统时钟的ntpd程序（可能是通过恰当的配置），对于时钟的修改通过多次微小的调整来完成。</li></ul><p>另外一个是个网络延迟，网络延迟目前在分布式锁中没有较好的解决方案，即所有的分布式系统当中都将面临这个问题，而redlock的作者也明确表示过。</p><h2><span id="分布式锁的结论">分布式锁的结论</span></h2><p>在Martin的文章中，还有一个很有见地的观点，就是对锁的用途的区分。他把锁的用途分为两种：</p><ul><li><p>为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的email。</p></li><li><p>为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其它严重的问题。<br>最后，Martin得出了如下的结论：</p></li><li><p>如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock则是个过重的实现(heavyweight)。</p></li><li><p>如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。而且，它没有一个机制能够提供fencing token。那应该使用什么技术呢？Martin认为，应该考虑类似Zookeeper的方案，或者支持事务的数据库。</p></li></ul><h2><span id="参考链接">参考链接</span></h2><ul><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（上）？</a></li><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（下）？</a></li><li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">how to do distributed lockin</a></li><li><a href="https://carlosbecker.com/posts/distributed-locks-redis" target="_blank" rel="noopener">Distributed Locking with Redis</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之动态规划（2）</title>
      <link href="/article/knapsack-problem/"/>
      <url>/article/knapsack-problem/</url>
      
        <content type="html"><![CDATA[<h2><span id="背包问题">背包问题</span></h2><p>有N件物品和一个容量为V的背包。第i件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可使价值总和最大。</p><h3><span id="问题分类">问题分类</span></h3><ul><li>01背包问题  如果<code>N</code>个物品每个物品只能使用一次，则成为01背包问题</li><li>完全背包问题 如果N<code>N</code>个物品每个物品可以使用无限次，则为完全背包问题</li></ul><h3><span id="问题的解法">问题的解法</span></h3><ul><li>暴力搜索解法（递归解法）</li><li>动态规划解法</li><li>优化后的动态规划（滚动数组，自下而上）</li></ul><h2><span id="01背包问题">01背包问题</span></h2><blockquote><p>有N件物品和一个容量为V的背包。第i件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可使价值总和最大。 每件物品只能使用1次</p></blockquote><p><img src="/article/knapsack-problem/1559184539388knapsack-problem_.png" alt></p><h3><span id="问题分析">问题分析</span></h3><ul><li>设 C(i,w) 为 当物品有<code>i</code>个的时候, 且背包重量在 w 的情况下 取得的最大值。那么考虑第 <code>i</code> 个物品，无外乎两种可能：选，或者不选。<ul><li>不选的话，背包的容量不变，改变为问题 <code>C(i -1, w)</code>；</li><li>选的话，背包的容量变小，改变为问题 <code>C(i -1, w- w[i])</code> 。<br>最优方案就是比较这两种方案，哪个会更好些：<br>我们来看状态方程</li></ul></li></ul><p><img src="/article/knapsack-problem/1559191080552knapsack-problem_.png" alt></p><ul><li><p>如何理解这个方程：</p><p>假设 我们有 <code>c[3,4]</code> 和 w <code>[5,10]</code> ,<code>i[0,1] i</code> 我们放每个元素的名称。</p><p>首先对于<code>0</code> 这个元素 重量为<code>5</code> 价值为<code>3</code>。<br>假设<br>我们要求 <code>C(1,5)</code> 代表  在背包重量为<code>5</code> 的情况下 从 <code>0,1</code>中选择价值最大的。 直观的结果当让是<code>3</code>了。</p></li><li><p>分析过程<br>按照上述公式 当我要求 <code>C(1,5)</code> 的时候，对于<code>1</code>这个元素有两种求法</p><ul><li><code>1</code> 这个元素被选中</li><li><code>1</code> 这个元素没有被选中</li></ul><p>如果<code>1</code> 被选中了，则背包的重量要减去<code>1</code>的重量<code>10</code>那么在接下来的问题就变成 在 <code>C(0,5 - 10) + 4</code>（4 是用于1已经被选中了，所以原问题就变成了在子问题基础上 加上 已经选中的价值）  但是 <code>C(0, -5)</code> 不可能存在，所以 <code>1</code> 不能选 所以 有了 <code>C(0,5)</code> 的子问题</p></li><li><p>我们在看一个更复杂的例子：</p><p><code>ps = [12,3,1,3,6]</code></p><p><code>ws = [5,4,7,2,6]</code></p><p><code>i = [0,1,2,3,4]</code>   （物品的代号）</p><p><code>W = 10</code></p><p>我们依旧定义问题 <code>C(4, 10)</code><br>根据公式，我们来公式<br><img src="/article/knapsack-problem/1559211607230knapsack-problem_.png" alt></p><p>下面是具体的分析过程<br><code>4</code> 被选中<br><img src="/article/knapsack-problem/1559277486742knapsack-problem_.png" alt></p><p><code>4</code> 没有被选中<br><img src="/article/knapsack-problem/1559277542327knapsack-problem_.png" alt></p><p>求<code>C(4, 10)</code></p><ul><li>如果<code>4</code> 号元素被选中了，则进入子问题构成的问题<br><code>C(4 -1, 10 - ws[4]) + ps[4]</code></li><li>如果<code>4</code> 号元素 没有被选中，则进入第个子问题<code>C(4 -1, 10</code></li><li>这两个我们要取得最大的结果 才符合要求</li><li>处理边界 当<code>i</code> 和<code>v</code> 有一个小于<code>0</code> 的时候 这个问题都是不存在的</li></ul></li></ul><h3><span id="代码实现">代码实现</span></h3><h4><span id="递归写法">递归写法</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 -1 背包问题 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> v &gt;= w:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> idx &gt; len(ps) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>       </span><br><span class="line">    <span class="comment"># 如果选中该物品 太大 则放弃选中 原因就是 如果返回0 则会参与下边的运算max 会使得 ps[idx] + 0 会直接返回 ps[idx] 的值导致问题错误</span></span><br><span class="line">    <span class="keyword">if</span> ws[idx] + v &gt; w:</span><br><span class="line">        <span class="keyword">return</span> package0_1(idx+<span class="number">1</span>, v, w, ws, ps)</span><br><span class="line">    <span class="keyword">return</span>  max(ps[idx] + package0_1(idx+<span class="number">1</span>, v + ws[idx], w, ws, ps), package0_1(idx+<span class="number">1</span>, v, w, ws, ps))</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret = package0_1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, ws, ps) </span><br><span class="line">ret = <span class="number">15</span></span><br></pre></td></tr></table></figure><h4><span id="动态规划写法">动态规划写法</span></h4><ul><li><p>中间结果的保存</p><p>由于我们的问题是<code>C(i,w)</code> <code>i</code> 和<code>w</code> 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   由于我们的问题是`C(i,w)` `i` 和`w` 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    max_idx = len(ps)</span><br><span class="line">    ret_mid = [[ <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(w + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(max_idx)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">package0_1_inner_1</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> v &gt;= w:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> idx &gt; max_idx - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret_mid[idx][v] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ret_mid[idx][v]</span><br><span class="line">        ret_tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> ws[idx] + v &gt; w:</span><br><span class="line">            ret_tmp = package0_1_inner_1(idx + <span class="number">1</span>,v, w, ws, ps)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret_tmp = max(ps[idx] + package0_1_inner_1(idx+<span class="number">1</span>,v + ws[idx], w, ws, ps),package0_1_inner_1(idx+<span class="number">1</span>,v, w, ws, ps))</span><br><span class="line">        ret_mid[idx][v] = ret_tmp</span><br><span class="line">        <span class="keyword">return</span> ret_mid[idx][v]</span><br><span class="line">    </span><br><span class="line">    ret = package0_1_inner_1(idx, v, w, ws, ps)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret = package0_1_dynamic_1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, ws, ps) </span><br><span class="line">ret = <span class="number">15</span></span><br></pre></td></tr></table></figure><ul><li>优化分析<br>如果我们打印 ret_mid</li></ul><table><thead><tr><th>v/i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>15</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td></tr><tr><td>1</td><td>9</td><td>None</td><td>None</td><td>None</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td></tr><tr><td>2</td><td>9</td><td>None</td><td>None</td><td>None</td><td>6</td><td>3</td><td>None</td><td>None</td><td>None</td><td>0</td><td>None</td></tr><tr><td>3</td><td>9</td><td>None</td><td>None</td><td>None</td><td>6</td><td>3</td><td>None</td><td>3</td><td>None</td><td>0</td><td>None</td></tr><tr><td>4</td><td>6</td><td>None</td><td>6</td><td>None</td><td>6</td><td>0</td><td>0</td><td>0</td><td>None</td><td>0</td><td>None</td></tr></tbody></table><p>这个表格的意思是，当我们选中 背包选中<code>0</code> 的时候 且这个时候背包的总量为 <code>0</code>的时候 最大的价值 为<code>15</code> 既<code>C（0，0）</code>的含义<br>同理<code>C(1,0)</code>的意思是 没有选中 <code>0</code>  且 选中 <code>1</code>和 不选 <code>1</code>的价值最大的值</p><p>我们分析一下 如果我要求 <code>C(i,w)</code> 但是需要依赖于 <code>C(i+1,?)</code> 这里用<code>?</code> 表示只需要行数据。 那么需要上面数组 <code>C(i+1,?)</code> 的结果<br>也就是说 我们的 ret_mid[i] 要依赖于 ret_mid[i+1] 的结果 这个时候 我们的 <code>ret_mid[i+1]</code>  还没有被算出来<br>如果我们反转一下， 是否能计算将这个顺序 倒置一下，比如说让<code>ret_mid[i]</code> 依赖于 <code>ret_mid[i - 1]</code> 这样依赖，我们算到了<code>ret_mid[0]</code> 的时候，就可以被 <code>ret_mid[1]</code> 复用结果了。</p><p>我们来看一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   由于我们的问题是`C(i,w)` `i` 和`w` 会有各种不同的取值 那么我们申请一个二维数组来保存中间计算的结果</span></span><br><span class="line"><span class="comment">#   idx 变成了 物品数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_2</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">    <span class="comment"># 刚开始为 物品的数量</span></span><br><span class="line">    ret_mid = [[ <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(v)] <span class="keyword">for</span> j <span class="keyword">in</span> range(idx + <span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">package0_1_inner_2</span><span class="params">(idx, v, w, ws, ps)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt; <span class="number">0</span> <span class="keyword">or</span> v &lt; <span class="number">0</span>:           <span class="comment"># 这里我们做了处理 如果为0 则证明还有东西没有选的 因为 0 也是一个物品</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        print(idx,v)</span><br><span class="line">        <span class="keyword">if</span> ret_mid[idx][v - <span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:       <span class="comment"># v 的长度要减一 因为你传递过来的是 背包上线 当背包上线是10 的时候 对应 9号位置</span></span><br><span class="line">            <span class="keyword">return</span> ret_mid[idx][v - <span class="number">1</span>]</span><br><span class="line">        ret_tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span>  v - ws[idx] &lt; <span class="number">0</span>:        <span class="comment"># 表示剩下的已经不足装下现在的东西了</span></span><br><span class="line">            ret_tmp = package0_1_inner_2(idx - <span class="number">1</span>,v, w, ws, ps)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret_tmp = max(ps[idx] + package0_1_inner_2(idx - <span class="number">1</span>,v - ws[idx], w, ws, ps),package0_1_inner_2(idx - <span class="number">1</span>,v, w, ws, ps))</span><br><span class="line">        ret_mid[idx][v<span class="number">-1</span>] = ret_tmp</span><br><span class="line">        <span class="keyword">return</span> ret_mid[idx][v<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    ret = package0_1_inner_2(idx, v, w, ws, ps)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret3 = package0_1_dynamic_2(<span class="number">4</span>, <span class="number">10</span>, <span class="number">10</span>, ws, ps)</span><br><span class="line"><span class="comment"># ret = 15</span></span><br></pre></td></tr></table></figure><p>我们看到下面的ret_mid 数据</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>None</td><td>12</td><td>None</td><td>12</td><td>None</td><td>12</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>None</td><td>None</td><td>None</td><td>12</td><td>None</td><td>15</td></tr><tr><td>2</td><td>None</td><td>0</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>12</td><td>None</td><td>15</td></tr><tr><td>3</td><td>None</td><td>None</td><td>None</td><td>3</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>15</td></tr><tr><td>4</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>None</td><td>15</td></tr></tbody></table><p>看一下依赖关系</p><p><img src="/article/knapsack-problem/1559276755945knapsack-problem_.png" alt></p><p>我们根据这个图发现<br>第<code>4</code>行的图依赖于 <code>3</code>行的图数据 而第<code>3</code>行的数据依赖于第<code>2</code>行的数据 如果这样的话那么我们是不是可只用 两行数据来算出结果<br>级 <code>i</code> 行数据依赖于 <code>i -1</code> 行 ， 我们可以利用<code>滚动数组</code>的方法优化空间，也可以用<code>自下而上</code>的优化方法来优化</p><p>滚动数组的方式 好优化 只需要 将<code>idx % 2</code>就可以了</p><p>下面我来用自下而上的</p><p>来看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package0_1_dynamic_3</span><span class="params">(v, ws, ps)</span>:</span></span><br><span class="line">    max_idx = len(ws)       <span class="comment"># 物品数量</span></span><br><span class="line">    ret_mid = []</span><br><span class="line">    <span class="comment"># 初始化0 0 节点</span></span><br><span class="line">    ret_zero = [<span class="number">0</span>  <span class="keyword">for</span> i <span class="keyword">in</span> range(v + <span class="number">1</span>)]</span><br><span class="line">    ret_mid.insert(<span class="number">0</span>, ret_zero)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,max_idx + <span class="number">1</span>):     </span><br><span class="line">        ret_item = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(v + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> vi <span class="keyword">in</span> range(<span class="number">0</span>, v + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ws[i<span class="number">-1</span>] &gt; vi:</span><br><span class="line">                ret_item[vi] = ret_mid[i - <span class="number">1</span>][vi]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret_item[vi]= max(ret_mid[i - <span class="number">1</span>][vi - ws[i - <span class="number">1</span>]] + ps[i - <span class="number">1</span>], ret_mid[i - <span class="number">1</span>][vi])</span><br><span class="line">        ret_mid.insert(i,ret_item)</span><br><span class="line">    print(ret_mid)</span><br><span class="line">    <span class="keyword">return</span> ret_mid[max_idx][v]</span><br></pre></td></tr></table></figure><p>运行如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">ws = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">ret3 = package0_1_dynamic_3(<span class="number">10</span>, ws, ps)</span><br><span class="line">print(ret3)</span><br></pre></td></tr></table></figure><p>来看中间结果</p><table><thead><tr><th>i/v</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>12</td><td>12</td><td>12</td><td>12</td><td>12</td><td>12</td></tr><tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>12</td><td>12</td><td>12</td><td>12</td><td>15</td><td>15</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>12</td><td>12</td><td>12</td><td>12</td><td>15</td><td>15</td></tr><tr><td>4</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td>15</td></tr><tr><td>5</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>12</td><td>12</td><td>15</td><td>15</td><td>15</td><td>15</td></tr></tbody></table><h4><span id="总结">总结</span></h4><p>动态规划的主要难点就是如何划分问题，将大问题拆解为子问题之后，分析子问题和原问题的最优解，然后根据问题描述拆分通项公式，最后在分析计算的冗余度。对于逻辑分析能力是个很好的锻炼。</p><h2><span id="完全背包问题">完全背包问题</span></h2><pre><code>敬请期待</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法探秘系列之动态规划（1）</title>
      <link href="/article/dynamic-programming/"/>
      <url>/article/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><p>动态规划一般可分为</p><ul><li><p>线性动规</p></li><li><p>区域动规</p></li><li><p>树形动规</p></li><li><p>背包动规四类。</p></li><li><p>举例：</p><blockquote><p><code>线性动规</code>：拦截导弹(最大递减数列)，合唱队形，挖地雷，建学校，剑客决斗等；</p></blockquote><blockquote><p><code>区域动规</code>：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</p></blockquote><blockquote><p><code>树形动规</code>：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</p></blockquote><blockquote><p><code>背包问题</code>：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶等；</p></blockquote></li></ul><h2><span id="基本概念">基本概念</span></h2><h3><span id="动态规划过程">动态规划过程</span></h3><p><strong>每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</strong></p><p>动态规划算法与分治法类似，<code>其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</code>。</p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，<code>有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</code>。</p><p>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><p>态规划经常常使用于解决最优化问题，这些问题多表现为<code>多阶段决策</code>。</p><h3><span id="关于多阶段决策">关于多阶段决策：</span></h3><p>在实际中，人们经常遇到这样一类决策问题，即因为过程的特殊性，能够将决策的全过程根据时间或空间划分若干个联系的阶段。而在各阶段中。人们都须要作出方案的选择。我们称之为<code>决策</code>。</p><p>而且当一个阶段的决策之后，经常影响到下一个阶段的决策，从而影响整个过程的活动。这样，各个阶段所确定的决策就构成一个决策序列，常称之为<code>策略</code>。</p><p>因为各个阶段可供选择的决策往往不止一个。因而就可能有很多决策以供选择，这些可供选择的策略构成一个集合，我们称之为同意<code>策略集合</code>（简称策略集合）。每一个策略都对应地确定一种活动的效果。我们假定这个效果能够用数量来衡量。</p><p>因为不同的策略经常导致不同的效果，因此，怎样在同意策略集合中选择一个策略，使其在预定的标准下达到最好的效果。经常是人们所关心的问题。我们称这种策略为最优策略，这类问题就称为<strong>多阶段决策问题</strong>。</p><ul><li><strong>多阶段决策问题举例：机器负荷分配问题</strong></li></ul><p>某种机器能够在高低两种不同的负荷下进行生产。在高负荷下生产时。产品的年产量g和投入生产的机器数量x的关系为g=g(x)，这时的年完善率为a，即假设年初完善机器数为x，到年终时完善的机器数为a*x(0&lt;a&lt;1)；在低负荷下生产时，产品的年产量h和投入生产的机器数量y的关系为h=h(y)。对应的完善率为b(0&lt;b&lt;0)。且a&lt;b。</p><p>假定開始生产时完善的机器熟练度为s1。要制定一个五年计划，确定每年投入高、低两种负荷生产的完善机器数量，使5年内产品的总产量达到最大。这是一个多阶段决策问题。</p><p>显然能够将全过程划分为5个阶段（一年一个阶段），每一个阶段開始时要确定投入高、低两种负荷下生产的完善机器数，并且上一个阶段的决策必定影响到下一个阶段的生产状态。决策的目标是使产品的总产量达到最大。这个问题常常使用数学方法建模，结合线性规划等知识来进行解决。</p><h2><span id="动态规划的适用条件">动态规划的适用条件</span></h2><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足<code>最优化原理</code>和<code>无后效性</code>。</p><ol><li><p><strong>最优化原理（最优子结构性质）</strong> ：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有<code>最优子结构性质</code>。</p></li><li><p><strong>无后效性</strong>：无后效性将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为<code>无后效性</code>。</p></li><li><p><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ol><h2><span id="求解的基本步骤">求解的基本步骤</span></h2><p></p><ol><li><p><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p>**确定状态和状态变量：**将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p></li><li><p><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p></li></ol><p>实际应用中可以按以下几个简化的步骤进行设计：</p><ul><li><strong>(1) 分析最优解的性质，并刻画其结构特征。</strong></li><li><strong>(2) 递归的定义最优解。</strong></li><li><strong>(3) 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。</strong></li><li><strong>(4) 根据计算优值时得到的信息，构造问题的最优解。</strong></li></ul><h2><span id="实战分析">实战分析</span></h2><h3><span id="1-斐波那契数列">1. 斐波那契数列</span></h3><ul><li><p>问题描述</p><blockquote><p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。<br>数列的前两项为 0 和 1  指的是这样一个数列：0、1、1、2、3、5 … 我们要求<br>(每一项为 前两项的和)</p></blockquote></li><li><p>递归写法（直观的解法）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_recursion</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib_recursion(n<span class="number">-1</span>)+fib_recursion(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure></li><li><p>分析问题<br>因为通项公式为 <code>f(n) = f(n-1) + f(n-2)</code></p><p>我们看适用条件</p><ul><li><strong>最优子结构性质</strong>：<code>f(n)</code> 问问题<code>f(n-1)</code> 为子问题，所以一个<code>n</code> 的问题可以拆解成两个子问题<code>n-1</code> 和<code>n-2</code> 当子问题得到最优，那么原问题的最优解也得出。</li><li><strong>无后效性</strong>：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li><li><strong>子问题的重叠性</strong> 我们根据一张图来看一下重复计算的问题<br><img src="/article/dynamic-programming/1558927988639dynamic-programming_.png" alt></li></ul><p>这张图详细讲解了利用递归思想的求解<code>fib(5)</code> 的过程,我们需要先知道<code>fib(4)</code> 和 <code>fib(3)</code>；而<code>fib(4)</code> 需要知道<code>fib(3)</code> 和<code>fib(2)</code>；<code>fib(3)</code> 则需要知道<code>fib(2)</code> 和 <code>fib (1)</code>；<code>fib(3)</code> 则需要…<br>我们可以看到 <code>fib(3)</code> <code>fib(2)</code> 被计算了多次，浪费了很多时间。</p></li><li><p>时间优化<br>我们一个中间结果，保存已经计算过的结果</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中间结果的方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_mid_result</span><span class="params">(n)</span>:</span></span><br><span class="line">    mid_ret = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        mid_ret.append(<span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mid_ret[n] != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> mid_ret[n]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        mid_ret[n] = fib_recursion(n<span class="number">-1</span>)+fib_recursion(n<span class="number">-2</span>)</span><br><span class="line">        <span class="keyword">return</span> mid_ret[n]</span><br><span class="line">    <span class="keyword">return</span> fib(n)</span><br></pre></td></tr></table></figure></li><li><p>空间优化</p><ul><li><p>中间队列优化</p><p>我们来看中间队列，由于我们的每一项是根据前两项得到的，换句话说，我们<code>n</code> 只依赖于前两项，这样依赖，我们的中间结果就不在需要那么多的空间来存贮。所以我们只需要两个数来，分别是 <code>n-1</code> 和<code>n -2</code> 就能得出结论。</p></li><li><p>字底向上：</p><p>我们上面的实现方式都是自顶向下的实现方式，如果考虑自定向上的方式，我们就可以避免是用递归。<br>例如，我们可以先算 <code>f(0)</code>和 <code>f(1)</code> 然后<code>f(2)</code> 就可以用 <code>f(0) + f(1)</code> 来得到结果 在根据 <code>f(1) + f(2)</code>得到f(3)</p><p>来看代码。</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_bottom_up</span><span class="params">(n)</span>:</span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        pre , next = next, pre + next</span><br><span class="line">        n-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></li></ul><h3><span id="2-剪绳子">2. 剪绳子</span></h3><ul><li><p>问题描述</p><blockquote><p>把一根长度为 n 的绳子剪成 m 段，并且使得每段的长度的乘积最大（n, m 均为整数）</p></blockquote></li><li><p>分析问题</p><p>假设我们剪一刀，使得一根长度为<code>i</code>，一个长度为 <code>n-1</code>,他们的乘积 <code>i * n-1</code>如果这个时候，乘积结果是最大的，则直接返回。</p><p>当时实际上往往 将<code>i</code>这段绳子还能拆分，拆分的结果乘积 i 这个数本身还要大<br>所以我们的要解决的问题就变成了<br>求<code>F(n) = max(F(i) * F(n - 1))</code>，要使得  <code>f(n)</code> 最大 那必须要让 <code>f(i)</code> 和 <code>f(n-i)</code>得到最大值</p><p>我们用列举:</p><table><thead><tr><th>n</th><th>分段序列</th><th>最大乘积</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>不需要拆分</td></tr><tr><td>2</td><td>1,1</td><td>2</td><td>不需要拆分</td></tr><tr><td>3</td><td>1,2</td><td>3</td><td>不需要拆分</td></tr><tr><td>4</td><td>[1,3] [2,2]</td><td>4</td><td></td></tr><tr><td>5</td><td>[1,4] [2,3]</td><td>6</td><td></td></tr></tbody></table></li></ul><p>按着这个思路 当<code>n &lt;= 3</code> 的时候 不用切,当<code>n &gt; 4</code>的时候 才需要切割</p><ul><li><strong>一般写法(递归写法)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment">### 不用切割，返回的是自身长度</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 切割几次</span></span><br><span class="line">    split_number = n//<span class="number">2</span></span><br><span class="line">    max_ret = n;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,split_number+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        max_ret = max(ecursive(i)*ecursive(n-i),max_ret)</span><br><span class="line">    <span class="keyword">return</span> max_ret</span><br></pre></td></tr></table></figure><ul><li><p>优化分析<br>这个优化分如同第一题的分析一样，只不过第一题的加法改成了乘法，本质上是一样的。<br>接下来我们来看加了中间结果的优化方法</p><ul><li><strong>动态优化写法：时间优化，保留计算结果</strong></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 优化后的 递归算法 保留已经计算过的结果</span></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive2</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> result.get(l) != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result[l]</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    split_number = l//<span class="number">2</span></span><br><span class="line">    max_ret = l;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,split_number+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        max_ret = max(ecursive2(i)*ecursive2(l-i),max_ret)</span><br><span class="line">    result[l] = max_ret</span><br><span class="line">    <span class="keyword">return</span> max_ret</span><br></pre></td></tr></table></figure><ul><li><strong>字底向上写法</strong></li></ul><p><img src="/article/dynamic-programming/1559027638643dynamic-programming_.png" alt><br>假如入我们要计算<br><code>e(6)</code>那么我们首先要计算 <code>e(1)</code> 和  <code>e(5)</code></p><ol><li>因为 1，2，3 比较特殊 是不需要剪的 所以我们从 第4个开始</li><li>首先我们得到一个初始化数组 里面的元素为 [0,1,2,3]</li><li>计算 e(4)  拆分得到  <code>e(4) = e(1) * e(3) ... e(2) * e(2)</code>，找出最大的赋值给第四个元素 这个时候 数组就变成了 [0,1,2,3,4]  这个数组的概念为 [e(1),e(2),e(3),e(4)]</li><li>这个时候 计算<code>e(5)</code> 重复上述过程</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecursive3</span><span class="params">(l)</span>:</span></span><br><span class="line">    ret_mid = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> ret_mid[l]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,l + <span class="number">1</span>):</span><br><span class="line">        max_mid_ret = i</span><br><span class="line">        ret_mid.append(max_mid_ret)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,i//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            max_mid_ret = max(ret_mid[n] * ret_mid[i - n],max_mid_ret)</span><br><span class="line">        ret_mid[i] = max_mid_ret</span><br><span class="line">    <span class="keyword">return</span> ret_mid[l]</span><br></pre></td></tr></table></figure><ul><li><strong>贪婪算法写法</strong><br>当<code>n</code>大于等于5时，我们尽可能多的剪长度为<code>3</code>的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 为什么选<code>2，3</code>为最小的子问题？因为2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。 为什么选长度为<code>3</code>？因为当<code>n≥5</code>时，3(n−3)≥2(n−2)</li></ul><p>其实为什么要选2和3,来看证明<br><strong>证明</strong>： <code>n&lt;4</code>的情况不必说，我们假设<code>n&gt;=5</code>。这里的思想是把剪绳子划归为若干个子问题，每一剪就划分为两个子问题。当<code>n&gt;=</code>5时，若剪为长度为<code>a</code>与<code>n-a</code>的两段更优，即<code>a(n-a)&gt;n</code>，其中<code>1&lt;=a&lt;n</code></p><p>推导如下：</p><p><img src="/article/dynamic-programming/1559028801966dynamic-programming_.png" alt></p><p>令<code>f(n)=(a-1)n-a^2</code>  由于<code>a-1&gt;=0</code>，<code>f(n)</code>单调递增。当<code>n=5</code>时，<code>f(n)</code>取得最小值为<code>f(5)=(a-1)*5-a^2</code>。要使最小值大于0，接下来求<code>a</code>的取值范围，令方程<code>(a-1)*5-a^2=0</code>，可用求根公式解得<code>a</code>为<code>2,3</code>（取整）。<br>换句话说 当解中出现2，3 的时候 总能让函数递增，也就是是剪出来的数 大于本身长度。</p><p><img src="/article/dynamic-programming/1559029025348dynamic-programming_.png" alt></p><p><strong>来看实现</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span> <span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 3出现的次数</span></span><br><span class="line">    time_3  = l // <span class="number">3</span> </span><br><span class="line">    <span class="keyword">if</span> l % <span class="number">3</span> == <span class="number">1</span>:      <span class="comment">#如果剩下4 则4分为 2 2</span></span><br><span class="line">        time_3 -= <span class="number">1</span></span><br><span class="line">    time_2 = (l - time_3 * <span class="number">3</span>) // <span class="number">2</span></span><br><span class="line">    print(time_2,time_3)</span><br><span class="line">    ret = math.pow(<span class="number">3</span>,time_3)</span><br><span class="line">    <span class="keyword">if</span> time_2 != <span class="number">0</span>:</span><br><span class="line">        ret + math.pow(<span class="number">2</span>, time_2)</span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></li></ul><h3><span id="3-背包问题">3. 背包问题</span></h3><pre><code>由于篇幅问题</code></pre><h3><span id="4-抢劫问题">4. 抢劫问题</span></h3><h3><span id="5-小兵向前冲">5. 小兵向前冲</span></h3><h3><span id="6-最大递减数列">6. 最大递减数列</span></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(3)</title>
      <link href="/article/distributed-redis-data-structure-skip-zip-list/"/>
      <url>/article/distributed-redis-data-structure-skip-zip-list/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h1><span id="跳表">跳表</span></h1><p>–</p><h2><span id="跳表的结构">跳表的结构</span></h2><p>跳跃表（skiplist）是一种随机化的数据， 跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在对数期望时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多。</p><p>以下是个典型的跳跃表例子（图片来自维基百科）：<br><img src="/article/distributed-redis-data-structure-skip-zip-list/1561702628780distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>从图中可以看到， 跳跃表主要由以下部分构成：</p><ul><li><code>表头（head）：负责维护跳跃表的节点指针。</code></li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li></ul><p>为了满足自身的功能需要， <code>Redis</code> 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p><ul><li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的 score 值可以相同。</li><li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查 <code>member</code> ：当 <code>score</code> 值可以重复时，单靠 <code>score</code> 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。</li><li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 <code>ZREVRANGE</code> 或 <code>ZREVRANGEBYSCORE</code> 这类以逆序处理有序集的命令时，就会用到这个属性。</li></ul><p>跳表的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h2><span id="跳表的应用">跳表的应用</span></h2><p>和字典、链表或者字符串这几种在 Redis 中大量使用的数据结构不同， 跳跃表在 Redis 的唯一作用， 就是实现有序集数据类型。<br>跳跃表将指向有序集的 score 值和 member 域的指针作为元素， 并以 score 值为索引， 对有序集元素进行排序。<br>举个例子， 以下代码创建了一个带有 3 个元素的有序集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD s 6 x 10 y 15 z</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE s 0 -1 WITHSCORES</span></span><br><span class="line">1) "x"</span><br><span class="line">2) "6"</span><br><span class="line">3) "y"</span><br><span class="line">4) "10"</span><br><span class="line">5) "z"</span><br><span class="line">6) "15"</span><br></pre></td></tr></table></figure><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561702897381distributed-redis-data-structure-skip-zip-list_.png" alt></p><p><strong>为了方便展示， 在图片中我们直接将 member 和 score 值包含在表节点中， 但是在实际的定义中， 因为跳跃表要和另一个实现有序集的结构（字典）分享 member 和 score 值， 所以跳跃表只保存指向 member 和 score 的指针。</strong></p><h1><span id="压缩表">压缩表</span></h1><h2><span id="简介">简介</span></h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p><h2><span id="结构">结构</span></h2><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p><p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703120380distributed-redis-data-structure-skip-zip-list_.png" alt></p><table border="1" class="docutils"><colgroup><col width="11%"><col width="13%"><col width="11%"><col width="65%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">属性</th><th class="head">类型</th><th class="head">长度</th><th class="head">用途</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">zlbytes</span></code></td><td><code class="docutils literal"><span class="pre">uint32_t</span></code></td><td><code class="docutils literal"><span class="pre">4</span></code> 字节</td><td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 <code class="docutils literal"><span class="pre">zlend</span></code> 的位置时使用。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">zltail</span></code></td><td><code class="docutils literal"><span class="pre">uint32_t</span></code></td><td><code class="docutils literal"><span class="pre">4</span></code> 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">zllen</span></code></td><td><code class="docutils literal"><span class="pre">uint16_t</span></code></td><td><code class="docutils literal"><span class="pre">2</span></code> 字节</td><td>记录了压缩列表包含的节点数量：当这个属性的值小于 <code class="docutils literal"><span class="pre">UINT16_MAX</span></code> （<code class="docutils literal"><span class="pre">65535</span></code>）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 <code class="docutils literal"><span class="pre">UINT16_MAX</span></code> 时，节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">entryX</span></code></td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">zlend</span></code></td><td><code class="docutils literal"><span class="pre">uint8_t</span></code></td><td><code class="docutils literal"><span class="pre">1</span></code> 字节</td><td>特殊值 <code class="docutils literal"><span class="pre">0xFF</span></code> （十进制 <code class="docutils literal"><span class="pre">255</span></code> ），用于标记压缩列表的末端。</td></tr></tbody></table><p>图 7-2 展示了一个压缩列表示例：</p><ul><li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li><li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列+ 表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li><li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703205387distributed-redis-data-structure-skip-zip-list_.png" alt></p><h2><span id="压缩列表节点的构成">压缩列表节点的构成</span></h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li><li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li><li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li>4 位长，介于 0 至 12 之间的无符号整数；</li><li>1 字节长的有符号整数；</li><li>3 字节长的有符号整数；</li><li>int16_t 类型整数；</li><li>int32_t 类型整数；</li><li>int64_t 类型整数。</li></ul><p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成， 如图 7-4 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703498906distributed-redis-data-structure-skip-zip-list_.png" alt></p><h3><span id="previous_entry_length">previous_entry_length</span></h3><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p><p><code>previous_entry_length</code> 属性的长度可以是 1 字节或者 5 字节：</p><ul><li><p>如果前一节点的长度小于 254 字节， 那么 <code>previous_entry_length</code> 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</p></li><li><p>如果前一节点的长度大于等于 254 字节， 那么 <code>previous_entry_length</code> 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</p></li></ul><p>图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703612934distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703626097distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 <code>previous_entry_length</code> 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p><h3><span id="encoding">encoding</span></h3><p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p><ul><li><p>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</p></li><li><p>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 <code>content</code> 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</p></li></ul><p>表 7-2 记录了所有可用的字节数组编码， 而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703731706distributed-redis-data-structure-skip-zip-list_.png" alt></p><h3><span id="content">content</span></h3><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p><p>图 7-9 展示了一个保存字节数组的节点示例：</p><ul><li>编码的最高两位 00 表示节点保存的是一个字节数组；</li><li>编码的后六位 001011 记录了字节数组的长度 11 ；</li><li>content 属性保存着节点的值 “hello world” 。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703790975distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>图 7-10 展示了一个保存整数值的节点示例：</p><ul><li>编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</li><li>content 属性保存着节点的值 10086 。</li></ul><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703826960distributed-redis-data-structure-skip-zip-list_.png" alt></p><h2><span id="连锁更新">连锁更新</span></h2><p>前面说过， 每个节点的 previous_entry_length 属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。</li></ul><p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN ， 如图 7-11 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703296154distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>因为 e1 至 eN 的所有节点的长度都小于 254 字节， 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性， 换句话说， e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的。</p><p>这时， 如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点， 那么 new 将成为 e1 的前置节点， 如图 7-12 所示。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703910904distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p><p>现在， 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间， 在为 previous_entry_length 属性新增四个字节的空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间， 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p><p>因此， 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 e2 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p><p>正如扩展 e1 引发了对 e2 的扩展一样， 扩展 e2 也会引发对 e3 的扩展， 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 eN 为止。</p><p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。</p><p><img src="/article/distributed-redis-data-structure-skip-zip-list/1561703978763distributed-redis-data-structure-skip-zip-list_.png" alt></p><p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p><p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p><ul><li><p>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</p></li><li><p>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</p></li></ul><p>因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法之空间亚线性算法（二）</title>
      <link href="/article/most-frequent-number-in-stream/"/>
      <url>/article/most-frequent-number-in-stream/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p><a href="https://icefrozen.github.io/article/reservoir-sampling/" target="_blank" rel="noopener">水库抽样算法</a> 样算法虽然是抽样算法却不是近似算法。本节分享一下有限内存利用近似解求数据流中最频繁的元素。</p><p>Misra-Gries算法是频繁项挖掘中一个著名的算法。频繁项就是那些在数据流中出现频率最高的数据项。频繁项挖掘，这个看似简单的任务却是很多复杂算法的基础，同时也有着广泛的应用。</p><p>对于频繁项挖掘而言，一个简单的想法是，为所有的数据项分配计数器，当一个数据项到达，我们即增加相应计数器的值。但当数据流的规模较大时，出于内存的限制，我们往往不可能为每个数据项分配计数器。而Misra-Gries算法则是以一种清奇的思路解决了这个问题，实现了在内存受限的情况下，以较小的错误率统计数据流中的频繁项。</p><h5><span id="问题描述">问题描述</span></h5><ul><li><p>先讲解一下大数据的数据流模型特点：</p><ul><li>数据只能扫描1次或几次；</li><li>能够使用的内存是有限的（内存&lt;&lt;数据规模）；</li><li>希望通过维护一个内存结果（数据流概要）来给出相关性质的一个评估；</li></ul></li></ul><p>总结来说：<strong>数据要快速处理；空间亚线性。</strong></p><ul><li><p>问题描述</p><ul><li>输入：大数据流序列&lt;x1,x2,x3… …&gt;。</li><li>输出：找出数据流中当前扫描的元素序列中出现最频繁的元素的信息。</li></ul></li><li><p>问题定义</p><p><strong><em>对于流<img src="/article/most-frequent-number-in-stream/1560856790132most-frequent-number-in-stream_.png" alt> 隐式地定义了一个频率向量f=(f1,…,fn)。注意f1+…+fn=m。</em></strong></p><p><strong><em>对于一个参数k，输出集合<img src="/article/most-frequent-number-in-stream/1560856883155most-frequent-number-in-stream_.png" alt></em></strong></p></li></ul><pre><code>频繁元素问题有广泛的应用。在网络当中找到“elephant flow”、ip地址等，在搜索引擎中找到频繁查询，可以给这些最频繁的查询做一些优化。在应用当中求频繁元素时有一个假设，即**Zipf原则:典型的频率分布是高度偏斜的，只有少数频繁元素，大多数元素是非常不频繁的**。这个假设是合法的，根据统计一般最多10%的元素占元素总个数的90%。</code></pre><h2><span id="问题分析">问题分析</span></h2><ul><li><p>举个简单的例子，例如<br>输入 ： <code>&lt;32,12,14,32,7,12,32,7,6,12,4&gt;</code> 其中 <code>n=6，k=3，m=11</code></p><ul><li>算法如下：<ol><li>对于接收到的元素x，如果已经为其分配计数器，则把相应计数器加1；</li><li>如果没有相应计数器，但计数器个数少于k,就为其分配计数器，并设为1，意味着内存中还有空间；</li><li>如果当前计数器的个数为k，说明内存已经满了，则把所有计数器减1，然后删除取值为0的计数器，这样内存就又有空间了，再依次处理下一个。</li></ol></li></ul></li><li><p>计算过程如下</p><ul><li><ol><li>接收<code>32</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="2"><li>接收<code>12</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;</code>，<code>&lt;12,1&gt;</code>。</li></ol></li><li><ol start="3"><li>接收<code>14</code>，内存有空间，为其分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;,&lt;14,1&gt;</code>。</li></ol></li><li><ol start="4"><li>接收<code>32，32</code>对应计数器加<code>1</code>，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;,&lt;14,1&gt;</code>。</li></ol></li><li><ol start="5"><li>接收<code>7，7</code>不在内存当中，需要为其分配新的计数器，但是内存没有空间了。这时将所有计数器减<code>1</code>，然后把值为<code>0</code>的计数器删除，这时候，<code>12</code>和<code>14</code>的计数器就没有了。注意此时不将<code>7</code>的计数器加<code>1</code>,内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="6"><li>接收<code>12</code>，内存又有空间，为其重新分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;</code>。</li></ol></li><li><ol start="7"><li>接收<code>32，32</code>对应计数器加<code>1</code>，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;</code>。</li></ol></li><li><ol start="8"><li>接收<code>7</code>，为其分配计数器，内存状态<code>&lt;32,2&gt;，&lt;12,1&gt;,&lt;7,1&gt;</code>。</li></ol></li><li><ol start="9"><li>接收<code>6</code>，这时候内存满了，把所有计数器减<code>1</code>，然后把值为<code>0</code>的计数器删除,内存状态<code>&lt;32,1&gt;</code>。</li></ol></li><li><ol start="10"><li>接收<code>12</code>，内存又有空间，为其再重新分配计数器，内存状态<code>&lt;32,1&gt;，&lt;12,1&gt;</code>。</li></ol><p>这时候，将内存里最后的数据定为x出现的次数，计数器在内存中将x返回，没有则返回0。很显然这种方法低估了计数问题，32出现了3次，但是最后只返回1次。</p></li></ul></li></ul><h2><span id="算法精确性分析">算法精确性分析</span></h2><p><img src="/article/most-frequent-number-in-stream/1560858227232most-frequent-number-in-stream_.png" alt><br><img src="/article/most-frequent-number-in-stream/1560858254559most-frequent-number-in-stream_.png" alt></p><h2><span id="代码实现">代码实现</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(total = <span class="number">2000</span>)</span>:</span></span><br><span class="line">    data = np.random.zipf(<span class="number">2</span>, total)</span><br><span class="line">    count_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        oldValue = count_map.get(value, <span class="number">0</span>)</span><br><span class="line">        oldValue +=<span class="number">1</span></span><br><span class="line">        count_map[value] = oldValue</span><br><span class="line">    <span class="keyword">return</span> data,count_map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">misra_gries</span><span class="params">(S,k)</span>:</span></span><br><span class="line">    c = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> c:</span><br><span class="line">            c[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> len(c)&lt;k<span class="number">-1</span>:</span><br><span class="line">            c[i]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> list(c):</span><br><span class="line">                c[j]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c[j]==<span class="number">0</span>:</span><br><span class="line">                    c.pop(j)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s, cmap = getData()</span><br><span class="line">    result = misra_gries(s, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    print(result)</span><br><span class="line">    print(result.keys())</span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 空间亚线性算法 </tag>
            
            <tag> 大数据算法篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法之空间亚线性算法(一)</title>
      <link href="/article/reservoir-sampling/"/>
      <url>/article/reservoir-sampling/</url>
      
        <content type="html"><![CDATA[<h2><span id="问题描述">问题描述</span></h2><ul><li>输入：一组数据，大小未知</li><li>输出：这组数据的K个均匀抽取</li><li>要求：仅扫描一次</li><li>总体要求：从N个元素中随机的抽取k个元素，其中N无法确定，保证每个元素抽到的概率相同</li></ul><h2><span id="问题难点">问题难点</span></h2><p>首先明确什么叫均匀抽样，就是每个数据被等概率抽取呗。即当样本总体为n 时候，每个样本被抽取的概率为1/n,如果要抽取k个元素，那么每个样本被抽到的概率为k/n。但是我们实现不知道总体的数量n。如果就只有n=K个元素，可用空间正好也是K，那我们正好把K个数据都保存起来，但是如果n&gt;K呢？要想均匀抽样，概率当然是</p><h2><span id="问题解析">问题解析</span></h2><h3><span id="思路分析">思路分析</span></h3><p>假设我们有一个数据流，分别是1，2，3，起初我们并不知道这个数据流的大小。 我们要从中随机抽取一个数字，如果是均匀的抽取，每个数字被抽到的概率为1/3,首先我们需要新建一个数组，由于我们只需要取一个数据，所以数组的长度为1,现在我们有</p><ul><li>未知数据流 data_stream = [1,2,3]</li><li>样本数组 sample = []  (长度为1)</li></ul><p>我们开始读取数据1</p><ol><li><code>sample : [1]</code>, 假设 这个时候结束，那么样本被抽取的概率为 1，既100%被抽到</li><li>再次读取数据<code>2</code> <code>sample=[1,2]</code>,由于我们只需要一个数据，所以1 和 2 必须淘汰一个，那么如何淘汰呢？假设读到2就已经结束了，那么总体就变成了2个，2个这个时候，那么每个样本被抽取的概率就要变成1/2 才符合要求。这个时候，我们需要让2 以1/2的概率被淘汰，这样1和2被留下的概率就相等，都是1/2 满足要求。</li><li>再次读取数据3 <code>sample=[?,3]</code> 因为在第二步，我们已经淘汰了1和2 所以这里用？表示被留下的那个数 即 1 或者 2。 这个时候，我们应该如何淘汰3 才能让<code>1，2，3</code> 等概率被淘汰呢？<br>现在样本变成了3个，那么如果要满足提议，那必须让3 以1/3的概率留下，让3以2/3概率淘汰,那么这样来看<ul><li>？（1或者2）被留下的概率为(?留下，3淘汰)1/2 * 2/3</li><li>3 被留下的 概率为 1/3</li><li>这样刚好满足题意</li></ul></li></ol><ul><li>依次类推。</li></ul><p>来看证明：<br><img src="/article/reservoir-sampling/1558588073391reservoir-sampling_.png" alt></p><p>这里做个说明：1 - 1/(i+1) = i/(i+1)  表示没有被选中的概率.<br>总结起来就是一句话每个数取到的概率等于取到该数且取不到该数后面所有数的概率。<br>如：取到第10个数的概率等于取到第十个数且取不到第11到第n个数的概率<br>现在我们回到较复杂的情况,也就是如何在一个N个数（开始不知道N是几）中随机取M个数。其实思想是一样的，就是先取出前M个，然后对后面的开始每个以(k/(i))的概率进行替换，这样我们得到的就是所要的结果，证明如下：</p><p><img src="/article/reservoir-sampling/1558588262938reservoir-sampling_.png" alt></p><h4><span id="思路推广">思路推广</span></h4><ul><li>从一个数据流中获取数据，保存在k个数组当中。</li><li>数据流中前K个数值直接保存在数组中</li><li>后面的在来的数据i 以 k/n 的概率 替换数组中的随机一个</li></ul><h2><span id="代码实现">代码实现</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReservoirSampling</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.sample = []</span><br><span class="line">        self.k = k</span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addItem</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        i = len(self.sample)</span><br><span class="line">        <span class="keyword">if</span> i &lt; self.k:</span><br><span class="line">            self.sample.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            M = int(random.uniform(<span class="number">0</span>, self.time + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> M &lt; self.k :</span><br><span class="line">                self.sample[M] = item</span><br><span class="line">        self.time +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSample</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.sample</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self,count_arrray)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [self.sample.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> count_arrray]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(array_item_total, k)</span>:</span></span><br><span class="line">    a = np.array([[i]*array_item_total <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)])<span class="comment">#生成等量的0，1，2</span></span><br><span class="line">    L0 = a[<span class="number">0</span>]</span><br><span class="line">    L1 = a[<span class="number">1</span>]</span><br><span class="line">    L2 = a[<span class="number">2</span>]</span><br><span class="line">    rs = ReservoirSampling(k)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L0:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 1"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L1:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 2"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L2:</span><br><span class="line">        rs.addItem(i)</span><br><span class="line">    print(<span class="string">"finsh 3"</span>)</span><br><span class="line">    l1 = [<span class="string">'value=%d'</span>% x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    plt.pie(rs.count([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]),labels=l1,labeldistance=<span class="number">0.1</span>,autopct=<span class="string">'%1.2f%%'</span>)</span><br><span class="line">    plt.title(<span class="string">"Reservoir sampling"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test(<span class="number">10000</span>,<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>看一下结果<br><img src="/article/reservoir-sampling/1558678959053reservoir-sampling_.png" alt></p><h2><span id="总结">总结</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 空间亚线性算法 </tag>
            
            <tag> 大数据算法篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(4)</title>
      <link href="/article/distributed-redis-data-structure-object/"/>
      <url>/article/distributed-redis-data-structure-object/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="简介">简介</span></h2><p>我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。</p><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p><h2><span id="结构">结构</span></h2><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p><p>举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 “msg” 的对象， 而键值对的值则是一个包含了字符串值 “hello world” 的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2><span id="类型">类型</span></h2><p>对象的 type 属性记录了对象的类型， 这个属性的值可以是表 8-1 列出的常量的其中一个。</p><table border="1" class="docutils"><colgroup><col width="38%"><col width="62%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">类型常量</th><th class="head">对象的名称</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td>字符串对象</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td>列表对象</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td>哈希对象</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td>集合对象</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td>有序集合对象</td></tr></tbody></table><p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，<br>诸如此类。</li></ul><p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键为字符串对象，值为列表对象</span></span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br></pre></td></tr></table></figure><p>表 8-2    不同类型值对象的 <span class="xref std std-ref">TYPE</span> 命令输出</p><table border="1" class="docutils"><colgroup><col width="20%"><col width="35%"><col width="45%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">对象</th><th class="head">对象 <code class="docutils literal"><span class="pre">type</span></code> 属性的值</th><th class="head"><span class="xref std std-ref">TYPE</span> 命令的输出</th></tr></thead><tbody valign="top"><tr class="row-even"><td>字符串对象</td><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">"string"</span></code></td></tr><tr class="row-odd"><td>列表对象</td><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">"list"</span></code></td></tr><tr class="row-even"><td>哈希对象</td><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">"hash"</span></code></td></tr><tr class="row-odd"><td>集合对象</td><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">"set"</span></code></td></tr><tr class="row-even"><td>有序集合对象</td><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">"zset"</span></code></td></tr></tbody></table><h2><span id="编码和底层实现">编码和底层实现</span></h2><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p><p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p><p>表 8-3    对象的编码</p><table border="1" class="docutils"><colgroup><col width="33%"><col width="67%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">编码常量</th><th class="head">编码所对应的底层数据结构</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td><code class="docutils literal"><span class="pre">long</span></code> 类型的整数</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td><code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td>简单动态字符串</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>字典</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td>双端链表</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>压缩列表</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td>整数集合</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td>跳跃表和字典</td></tr></tbody></table><p>每种类型的对象都至少使用了两种不同的编码，表 8-4 列出了每种类型的对象可以使用的编码。</p><table border="1" class="docutils"><colgroup><col width="17%"><col width="28%"><col width="54%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">类型</th><th class="head">编码</th><th class="head">对象</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td>使用整数值实现的字符串对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td>使用 <code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串实现的字符串对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_STRING</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td>使用简单动态字符串实现的字符串对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的列表对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_LIST</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td>使用双端链表实现的列表对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的哈希对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_HASH</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>使用字典实现的哈希对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td>使用整数集合实现的集合对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_SET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td>使用字典实现的集合对象。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td>使用压缩列表实现的有序集合对象。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">REDIS_ZSET</span></code></td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td>使用跳跃表和字典实现的有序集合对象。</td></tr></tbody></table><p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello wrold"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line"><span class="string">"embstr"</span></span><br></pre></td></tr></table></figure><p>表 8-5 列出了不同编码的对象所对应的 <span class="xref std std-ref">OBJECT ENCODING</span> 命令输出。</p><table border="1" class="docutils"><colgroup><col width="35%"><col width="27%"><col width="38%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">对象所使用的底层数据结构</th><th class="head">编码常量</th><th class="head"><span class="xref std std-ref">OBJECT ENCODING</span> 命令输出</th></tr></thead><tbody valign="top"><tr class="row-even"><td>整数</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INT</span></code></td><td><code class="docutils literal"><span class="pre">"int"</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">embstr</span></code> 编码的简单动态字符串（SDS）</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_EMBSTR</span></code></td><td><code class="docutils literal"><span class="pre">"embstr"</span></code></td></tr><tr class="row-even"><td>简单动态字符串</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_RAW</span></code></td><td><code class="docutils literal"><span class="pre">"raw"</span></code></td></tr><tr class="row-odd"><td>字典</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_HT</span></code></td><td><code class="docutils literal"><span class="pre">"hashtable"</span></code></td></tr><tr class="row-even"><td>双端链表</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_LINKEDLIST</span></code></td><td><code class="docutils literal"><span class="pre">"linkedlist"</span></code></td></tr><tr class="row-odd"><td>压缩列表</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_ZIPLIST</span></code></td><td><code class="docutils literal"><span class="pre">"ziplist"</span></code></td></tr><tr class="row-even"><td>整数集合</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_INTSET</span></code></td><td><code class="docutils literal"><span class="pre">"intset"</span></code></td></tr><tr class="row-odd"><td>跳跃表和字典</td><td><code class="docutils literal"><span class="pre">REDIS_ENCODING_SKIPLIST</span></code></td><td><code class="docutils literal"><span class="pre">"skiplist"</span></code></td></tr></tbody></table><p>通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p><p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p><ul><li><p>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</p></li><li><p>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</p></li><li><p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p></li></ul><p>在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8使用@sun.misc.Contended避免伪共享</title>
      <link href="/article/reduce-cache-contention/"/>
      <url>/article/reduce-cache-contention/</url>
      
        <content type="html"><![CDATA[<hr><h2><span id="什么是伪共享">什么是伪共享</span></h2><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p><p>缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p><p>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解缓存行和对象的内存布局。<a href="https://www.jianshu.com/p/900554f11881" target="_blank" rel="noopener">理解CPU Cache</a>和<a href="https://icefrozen.github.io/article/java-mem-objecat/" target="_blank" rel="noopener">Java对象内存布局</a>。</p><p>下面的图说明了伪共享的问题：<br><img src="/article/reduce-cache-contention/1557738129608Reduce-Cache-Contention_.png" alt></p><p>假设在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p><h2><span id="避免伪共享">避免伪共享</span></h2><p>假设有一个类中，只有一个long类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时定义一个VolatileLong类型的数组，然后让多个线程同时并发访问这个数组，这时可以想到，在多个线程同时处理数据时，数组中的多个VolatileLong对象可能存在同一个缓存行中，通过上文可知，这种情况就是伪共享。</p><p>怎么样避免呢？在Java 7之前，可以在属性的前后进行padding，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>文章中结尾对paddign的分析可知，由于都是long类型的变量，这里就是按照声明的顺序分配内存，那么这可以保证在同一个缓存行中只有一个VolatileLong对象。</p><p>在Java 8中，提供了@sun.misc.Contended注解来避免伪共享，原理是在使用此注解的对象或字段的前后各增加128字节大小的padding，使用2倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。具体可以参考<a href="https://link.jianshu.com?t=http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</a>。</p><p>下面用代码来看一下加padding和不加的效果：</p><blockquote><p>运行环境：JDK 1.8，macOS 10.12.4，2.2 GHz Intel Core i7，四核-八线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs = <span class="keyword">new</span> VolatileLong[NUM_THREADS];</span><br><span class="line"><span class="comment">//    private static VolatileLong2[] longs = new VolatileLong2[NUM_THREADS];</span></span><br><span class="line"><span class="comment">//    private static VolatileLong3[] longs = new VolatileLong3[NUM_THREADS];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> VolatileLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        runTest();</span><br><span class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// long padding避免false sharing</span></span><br><span class="line">    <span class="comment">// 按理说jdk7以后long padding应该被优化掉了，但是从测试结果看padding仍然起作用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> q0, q1, q2, q3, q4, q5, q6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jdk8新特性，Contended注解避免false sharing</span></span><br><span class="line"><span class="comment">     * Restricted on user classpath</span></span><br><span class="line"><span class="comment">     * Unlock: -XX:-RestrictContended</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong3</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VolatileLong对象只有一个long类型的字段，VolatileLong2加了padding，下面分别执行看下时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duration = 57293259577</span><br><span class="line">duration = 4679059000</span><br></pre></td></tr></table></figure><p>没加padding时用了大概57秒，加padding后用时大概4.6秒，可见加padding后有效果了。</p><p>在Java8中提供了@sun.misc.Contended来避免伪共享，例如这里的VolatileLong3，在运行时需要设置JVM启动参数<code>-XX:-RestrictContended</code>，运行一下结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration = 4756952426</span><br></pre></td></tr></table></figure><p>结果与加padding的时间差不多。</p><p>下面看一下VolatileLong对象在运行时的内存大小（参考<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>）：</p><p><img src="/article/reduce-cache-contention/1557738622454Reduce-Cache-Contention_.png" alt></p><p>再来看下VolatileLong2对象在运行时的内存大小：</p><p><img src="/article/reduce-cache-contention/1557738646359Reduce-Cache-Contention_.png" alt></p><p>因为多了14个long类型的变量，所以24+8*14=136字节。</p><p>下面再来看下使用@sun.misc.Contended注解后的对象内存大小：</p><p><img src="/article/reduce-cache-contention/1557738659924Reduce-Cache-Contention_.png" alt></p><p>在堆内存中并没有看到对变量进行padding，大小与VolatileLong对象是一样的。</p><p>这就奇怪了，看起来与VolatileLong没什么不一样，但看一下内存的地址，用十六进制算一下，两个VolatileLong对象地址相差24字节，而两个VolatileLong3对象地址相差280字节。这就是前面提到的@sun.misc.Contended注解会在对象或字段的前后各增加128字节大小的padding，那么padding的大小就是256字节，再加上对象的大小24字节，结果就是280字节，所以确实是增加padding了。</p><h2><span id="八线程运行比四线程运行还快">八线程运行比四线程运行还快？</span></h2><p>根据上面的代码，把NUM_THREADS改为8，测试看下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VolatileLong:  44305002641</span><br><span class="line">VolatileLong2: 7100172492</span><br><span class="line">VolatileLong3: 7335024041</span><br></pre></td></tr></table></figure><p>可以看到，加了padding和@sun.misc.Contended注解的运行时间多了不到1倍，而VolatileLong运行的时间比线程数是4的时候还要短，这是为什么呢？</p><p>再说一下，我的CPU是四核八线程，每个核有一个L1 Cache，那么我的环境一共有4个L1 Cache，所以，2个CPU线程会共享同一个L1 Cache；由于VolatileLong对象占用24字节内存，而代码中VolatileLong对象是保存在数组中的，所以内存是连续的，2个VolatileLong对象的大小是48字节，这样一来，对于缓存行大小是64字节来说，每个缓存行只能存放2个VolatileLong对象。</p><p>通过上面的分析可知，伪共享发生在L3 Cache，如果每个核操作的数据不在同一个缓存行中，那么就会避免伪共享的发生，所以，8个线程的情况下其实是CPU线程共享了L1 Cache，所以执行的时间可能比4线程的情况还要短。下面看下执行时4线程和8线程的CPU使用情况：</p><p><img src="/article/reduce-cache-contention/1557741617009Reduce-Cache-Contention_.png" alt></p><p>可以看到，在4线程时，线程被平均分配到了4个核中，这样一来，L1 Cache肯定是不能共享的，这时会发生伪共享；而8线程时，每个核都使用了2个线程，这时L1 Cache是可以共享的，如果线程1和线程2在同一个核心中，线程1修改了L1 的数据，此时L2 可以感知并获取，这样一来就会减少对L3 的穿透，这在一定程度上能减少伪共享的发生，从而时间会变短（也不一定，但总体来说8线程的情况与4线程的运行时间几乎不会向加padding和注解的方式差那么多）。</p><h2><span id="sunmisccontended注解">@sun.misc.Contended注解</span></h2><p>上文中将@sun.misc.Contended注解用在了对象上，@sun.misc.Contended注解还可以指定某个字段，并且可以为字段进行分组，下面通过代码来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Options: </span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:-RestrictContended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println("offset-a: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("a")));</span><br><span class="line">        System.out.println("offset-b: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("b")));</span><br><span class="line">        System.out.println("offset-c: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("c")));</span><br><span class="line">        System.out.println("offset-d: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是使用到了classmexer.jar，可以参考<a href="https://www.jianshu.com/p/91e398d5d17c" target="_blank" rel="noopener">Java对象内存布局</a>中的说明。</p><p>这里在变量b和c中使用了@sun.misc.Contended注解，并将这两个变量分为1组，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset-a: 16</span><br><span class="line">offset-b: 152</span><br><span class="line">offset-c: 160</span><br><span class="line">offset-d: 12</span><br><span class="line">Shallow Size: 296 bytes</span><br><span class="line">Retained Size: 296 bytes</span><br></pre></td></tr></table></figure><p>可见int类型的变量的偏移地址是12，也就是在对象头后面，因为它正好是4个字节，然后是变量a。<code>@sun.misc.Contended</code>注解的变量会加到对象的最后面，这里就是b和c了，那么b的偏移地址是152，之前说过<code>@sun.misc.Contended</code>注解会在变量前后各加128字节，而byte类型的变量a分配完内存后这时起始地址应该是从17开始，因为byte类型占1字节，那么应该补齐到24，所以b的起始地址是24+128=152，而c的前面并不用加128字节，因为b和c被分为了同一组。</p><p>我们算一下c分配完内存后，这时的地址应该到了168，然后再加128字节，最后大小就是296。内存结构如下：</p><p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | c:160~168 | — | 168~296 |</p><p>现在把b和c分配到不同的组中，代码做如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:-RestrictContended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> a;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"b"</span>)</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println("offset-a: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("a")));</span><br><span class="line">        System.out.println("offset-b: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("b")));</span><br><span class="line">        System.out.println("offset-c: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("c")));</span><br><span class="line">        System.out.println("offset-d: " + UNSAFE.objectFieldOffset(ContendedTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        ContendedTest contendedTest = <span class="keyword">new</span> ContendedTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(contendedTest) + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">offset-a: 16</span><br><span class="line">offset-b: 152</span><br><span class="line">offset-c: 288</span><br><span class="line">offset-d: 12</span><br><span class="line">Shallow Size: 424 bytes</span><br><span class="line">Retained Size: 424 bytes</span><br></pre></td></tr></table></figure><p>可以看到，这时b和c中增加了128字节的padding，结构也就变成了：</p><p>| d:12~16 | — | a:16~17 | — | 17~24 | — | 24~152 | — | b:152~160 | — | 160~288 | — | c:288~296 | — | 296~424 |</p><h2><span id="原文地址">原文地址</span></h2><p><img src="https://www.jianshu.com/p/c3c108c3dcfd" alt="原文地址"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/article/java-class-loader/"/>
      <url>/article/java-class-loader/</url>
      
        <content type="html"><![CDATA[<h2><span id="java类加载机制的七个阶段">Java类加载机制的七个阶段</span></h2><p>当我们的Java代码编译完成后，会生成对应的 class 文件。接着我们运行<code>java Demo</code>命令的时候，我们其实是启动了JVM 虚拟机执行 class 字节码文件的内容。而 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：<strong>加载、验证、准备、解析、初始化、使用、卸载。</strong></p><h3><span id="加载">加载</span></h3><p>下面是对于加载过程最为官方的描述。</p><blockquote><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p></blockquote><p>其实加载阶段用一句话来说就是：把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。</p><h3><span id="验证">验证</span></h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：</p><ul><li>**JVM规范校验。**JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 <code>0x cafe bene</code>开头，主次版本号是否在当前虚拟机处理范围之内等。</li><li>**代码逻辑校验。**JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。</li></ul><p>当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。</p><h3><span id="准备重点">准备（重点）</span></h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。</p><h4><span id="内存分配的对象">内存分配的对象。</span></h4><p>Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</p><p>例如下面的代码在准备阶段，只会为 factor 属性分配内存，而不会为 website 属性分配内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> factor = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> String website = <span class="string">"www.cnblogs.com/chanshuyi"</span>;</span><br></pre></td></tr></table></figure><h4><span id="初始化的类型">初始化的类型</span></h4><p>在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。</p><p>例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sector = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final 关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p><h3><span id="解析">解析</span></h3><p>当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。</p><p>其实这个阶段对于我们来说也是几乎透明的，了解一下就好。</p><h3><span id="初始化重点">初始化（重点）</span></h3><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p><ul><li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：</li></ul><ul><li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li></ul><h3><span id="使用">使用</span></h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。</p><h3><span id="卸载">卸载</span></h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。</p><h3><span id="例子">例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello ShuYi."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">书的静态代码块</span><br><span class="line">Hello ShuYi.</span><br></pre></td></tr></table></figure><h3><span id="分析例子">分析例子</span></h3><p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类），我们会进行类的初始化。<br>在我们代码中，我们只知道有一个构造方法，但实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法 和 对象初始化方法</p><ul><li><p>类初始化方法</p><p>编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法<strong>类初始化方法一般在类初始化的时候执行。</strong><br>上面的这个例子，其类初始化方法就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br></pre></td></tr></table></figure></li><li><p>对象初始化方法</p><p>编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法**对象初始化方法一般在实例化类对象的时候执行。**上面这个例子，其对象初始化方法&lt;就是下面这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br></pre></td></tr></table></figure><p>类初始化方法  和 对象初始化方法之后，我们再来看这个例子，我们就不难得出上面的答案了。其实上面的这个例子其实没有执行对象初始化方法,因为我们确实没有进行 Book 类对象的实例化。如果你在 main 方法中增加 new Book() 语句，你会发现对象的初始化方法执行了！</p></li></ul><h2><span id="实战分析">实战分析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爷爷在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> factor = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爸爸~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"儿子在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是儿子~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸的岁数:"</span> + Son.factor);  <span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">爷爷在静态代码块</span><br><span class="line">爸爸在静态代码块</span><br><span class="line">爸爸的岁数:25</span><br></pre></td></tr></table></figure><p>也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？</p><p>**这是因为对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）。**因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p>对面上面的这个例子，我们可以从入口开始分析一路分析下去：</p><ul><li>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。</li><li>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。</li><li>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。</li></ul><p>我们再来看一下一个更复杂点的例子，看看输出结果是啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爷爷在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grandpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爷爷~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爸爸~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"儿子在静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是儿子~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son();  <span class="comment">//入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">爷爷在静态代码块</span><br><span class="line">爸爸在静态代码块</span><br><span class="line">儿子在静态代码块</span><br><span class="line">我是爷爷~</span><br><span class="line">我是爸爸~</span><br><span class="line">我是儿子~`</span><br></pre></td></tr></table></figure><p>让我们仔细来分析一下上面代码的执行流程：</p><ul><li>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。</li><li>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷~」、「我是爸爸~」、「我是儿子~」。</li></ul><p>下面给大家看一个特殊点的例子，有点难哦！</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Book()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"price="</span> + price +<span class="string">",amount="</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"书的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子的输出结果是：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">书的普通代码块</span><br><span class="line">书的构造方法</span><br><span class="line">price=110,amount=0</span><br><span class="line">书的静态代码块</span><br><span class="line">书的静态方法</span><br></pre></td></tr></table></figure><p>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。<br>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。</p><ul><li>当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。</li><li>当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器</li><li>JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器</li></ul><p>对于 Book 类，其类构造方法可以简单表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span></span><br></pre></td></tr></table></figure><p>于是首先执行<code>static Book book = new Book();</code>这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器，收集后的对象构造器 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的普通代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> price = <span class="number">110</span>;</span><br><span class="line">Book()</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的构造方法"</span>);</span><br><span class="line">    System.out.println(<span class="string">"price="</span> + price +<span class="string">", amount="</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。</p><p>当类实例化完成之后，JVM 继续进行类构造器的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Book book = <span class="keyword">new</span> Book();  <span class="comment">//完成类实例化</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"书的静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> amount = <span class="number">112</span>;</span><br></pre></td></tr></table></figure><p>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。</p><ul><li>到这里，类的初始化已经完成，JVM 执行 main 方法的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    staticFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即输出：「书的静态方法」。</p><h2><span id="方法论">方法论</span></h2><p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p><ul><li>**确定类变量的初始值。**在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</li><li>**初始化入口方法。**当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器，之后初始化对象构造器</li><li>**初始化类构造器。**JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</li><li>**初始化对象构造器。**JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</li></ul><p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(2)</title>
      <link href="/article/distributed-redis-data-structure-dict/"/>
      <url>/article/distributed-redis-data-structure-dict/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="结构">结构</span></h2><p>Redis 的 Hash 类型键使用以下两种数据结构作为底层实现:</p><ul><li>字典；</li><li>压缩列表；</li></ul><p>因为压缩列表比字典更节省内存， 所以程序在创建新 Hash 键时， 默认使用压缩列表作为底层实现， 当有需要时， 程序才会将底层实现从压缩列表转换到字典。</p><h2><span id="dict哈希表">Dict哈希表</span></h2><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><ul><li><p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p></li><li><p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p></li><li><p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p></li></ul><p>图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。<br><img src="/article/distributed-redis-data-structure-dict/1561628837627distributed-redis-data-structure-dict_.png" alt></p><h2><span id="dict节点">Dict节点</span></h2><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>举个例子， 图 4-2 就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。</p><p><img src="/article/distributed-redis-data-structure-dict/1561630405037distributed-redis-data-structure-dict_.png" alt></p><h2><span id="dict-结构">Dict 结构</span></h2><p>Redis 中的字典由 dict.h/dict 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><blockquote><p>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。<br>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p></li><li><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p></li></ul><p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：</p><p><img src="/article/distributed-redis-data-structure-dict/1561630558107distributed-redis-data-structure-dict_.png" alt></p><h2><span id="哈希算法以及解决冲突">哈希算法以及解决冲突</span></h2><ul><li>哈希算法</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><ul><li><p>解决冲突</p><p>在哈希表实现中， 当两个不同的键拥有相同的哈希值时， 称这两个键发生碰撞（collision）， 而哈希表实现必须想办法对碰撞进行处理。</p><p>字典哈希表所使用的碰撞解决方法被称之为链地址法： 这种方法使用链表将多个哈希值相同的节点串连在一起， 从而解决冲突问题。</p><p><img src="/article/distributed-redis-data-structure-dict/1561631101522distributed-redis-data-structure-dict_.png" alt></p></li></ul><h2><span id="rehash">rehash</span></h2><h3><span id="rehash-发生的原因">rehash 发生的原因</span></h3><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>其中哈希表的负载因子可以通过公式：</p><p><strong>负载因子 = 哈希表已保存节点数量 / 哈希表大小</strong><br><code>load_factor = ht[0].used / ht[0].size</code><br>计算得出。<br>比如说， 对于一个大小为 4 ， 包含 4 个键值对的哈希表来说， 这个哈希表的负载因子为：</p><p><code>load_factor = 4 / 4 = 1</code><br>又比如说， 对于一个大小为 512 ， 包含 256 个键值对的哈希表来说， 这个哈希表的负载因子为：</p><p><code>load_factor = 256 / 512 = 0.5</code></p><p>根据 <code>BGSAVE</code> 命令或 <code>BGREWRITEAOF</code> 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 <code>BGSAVE</code> 命令或 <code>BGREWRITEAOF</code> 命令的过程中， <code>Redis</code> 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制<code>（copy-on-write）</code>技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p><p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p><h3><span id="rehash-过程">rehash 过程</span></h3><ul><li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p></li><li><p>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；<br>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</p></li><li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p></li><li><p>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。<br>举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：</p></li><li><p>ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。</p></li><li><p>将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。</p></li><li><p>释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</p></li></ul><p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。</p><p><img src="/article/distributed-redis-data-structure-dict/1561631365627distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631373754distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631382607distributed-redis-data-structure-dict_.png" alt></p><p><img src="/article/distributed-redis-data-structure-dict/1561631389393distributed-redis-data-structure-dict_.png" alt></p><h2><span id="渐进式rehash">渐进式rehash</span></h2><p>在上一节，我们了解了字典的 rehash 过程， 需要特别指出的是， rehash 程序并不是在激活之后，就马上执行直到完成的， 而是分多次、渐进式地完成的。</p><p>假设这样一个场景：在一个有很多键值对的字典里， 某个用户在添加新键值对时触发了 rehash 过程， 如果这个 rehash 过程必须将所有键值对迁移完毕之后才将结果返回给用户， 这样的处理方式将是非常不友好的。</p><p>另一方面， 要求服务器必须阻塞直到 rehash 完成， 这对于 Redis 服务器本身也是不能接受的。</p><p>为了解决这个问题， Redis 使用了渐进式（incremental）的 rehash 方式： 通过将 rehash 分散到多个步骤中进行， 从而避免了集中式的计算。</p><p>渐进式 rehash 主要由 <code>_dictRehashStep</code> 和 <code>dictRehashMilliseconds</code> 两个函数进行：</p><p><code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash ；<br><code>dictRehashMilliseconds</code> 则由 Redis 服务器常规任务程序（server cron job）执行，用于对数据库字典进行主动 rehash ；<br><code>_dictRehashStep</code><br>每次执行 <code>_dictRehashStep</code> ， ht[0]-&gt;table 哈希表第一个不为空的索引上的所有节点就会全部迁移到 ht[1]-&gt;table 。</p><p>在 rehash 开始进行之后（d-&gt;rehashidx 不为 -1）， 每次执行一次添加、查找、删除操作， <code>_dictRehashStep</code> 都会被执行一</p><p><img src="/article/distributed-redis-data-structure-dict/1561631651242distributed-redis-data-structure-dict_.png" alt></p><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p><p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p><h2><span id="字典的收缩">字典的收缩</span></h2><p>扩展 rehash 和收缩 rehash 执行完全相同的过程， 一个 rehash 是扩展还是收缩字典， 关键在于新分配的 ht[1]-&gt;table 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查字典的使用率是否低于系统允许的最小比率</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 是的话返回 1 ，否则返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表已用节点数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当哈希表的大小大于 DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    <span class="comment">// 并且字典的填充率低于 REDIS_HT_MINFILL 时</span></span><br><span class="line">    <span class="comment">// 返回 1</span></span><br><span class="line">    <span class="keyword">return</span> (size &amp;&amp; used &amp;&amp; size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; REDIS_HT_MINFILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下， <code>REDIS_HT_MINFILL</code> 的值为 <code>10</code> ， 也即是说， 当字典的填充率低于 <code>10%</code> 时， 程序就可以对这个字典进行收缩操作了。</p><p>字典收缩和字典扩展的一个区别是：</p><ul><li>字典的扩展操作是自动触发的（不管是自动扩展还是强制扩展）；</li><li>而字典的收缩操作则是由程序手动执行。</li></ul><p>因此， 使用字典的程序可以决定何时对字典进行收缩：</p><ul><li>当字典用于实现哈希键的时候， 每次从字典中删除一个键值对， 程序就会执行一次 <code>htNeedsResize</code> 函数， 如果字典达到了收缩的标准， 程序将立即对字典进行收缩；</li><li>当字典用于实现数据库键空间（key space）的时候， 收缩的时机由 redis.c/tryResizeHashTables 函数决定。</li></ul><h2><span id="字典的迭代">字典的迭代</span></h2><p>字典带有自己的迭代器实现 —— 对字典进行迭代实际上就是对字典所使用的哈希表进行迭代：<br>迭代器首先迭代字典的第一个哈希表，然后，如果 rehash 正在进行的话，就继续对第二个哈希表进行迭代。</p><ul><li>当迭代哈希表时，找到第一个不为空的索引，然后迭代这个索引上的所有节点。</li><li>当这个索引迭代完了，继续查找下一个不为空的索引，如此反覆，直到整个哈希表都迭代完为止。</li></ul><p>整个迭代过程可以用伪代码表示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_dict</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代 0 号哈希表</span></span><br><span class="line">    iter_table(ht[0]-&gt;table)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果正在执行 rehash ，那么也迭代 1 号哈希表</span></span><br><span class="line">    if dict.is_rehashing(): iter_table(ht[1]-&gt;table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_table</span><span class="params">(table)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历哈希表上的所有索引</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> table:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 跳过空索引</span></span><br><span class="line">        <span class="keyword">if</span> table[index].empty():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历索引上的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> table[index]:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理节点</span></span><br><span class="line">            do_something_with(node)</span><br></pre></td></tr></table></figure><p>字典的迭代器有两种：</p><ul><li>安全迭代器：在迭代进行过程中，可以对字典进行修改。</li><li>不安全迭代器：在迭代进行过程中，不对字典进行修改。</li></ul><p>以下是迭代器的数据结构定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 字典迭代器</span><br><span class="line"> */</span><br><span class="line">typedef struct dictIterator &#123;</span><br><span class="line"></span><br><span class="line">    dict *d;                // 正在迭代的字典</span><br><span class="line"></span><br><span class="line">    int table,              // 正在迭代的哈希表的号码（<span class="number">0</span> 或者 <span class="number">1</span>）</span><br><span class="line">        index,              // 正在迭代的哈希表数组的索引</span><br><span class="line">        safe;               // 是否安全？</span><br><span class="line"></span><br><span class="line">    dictEntry *entry,       // 当前哈希节点</span><br><span class="line">              *nextEntry;   // 当前哈希节点的后继节点</span><br><span class="line"></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><h2><span id="api">API</span></h2><table border="1" class="docutils"><colgroup><col width="21%"><col width="47%"><col width="32%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictCreate</span></code></td><td>创建一个新的字典。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictAdd</span></code></td><td>将给定的键值对添加到字典里面。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictReplace</span></code></td><td>将给定的键值对添加到字典里面，如果键已经存在于字典，那么用新值取代原有的值。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictFetchValue</span></code></td><td>返回给定键的值。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictGetRandomKey</span></code></td><td>从字典中随机返回一个键值对。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">dictDelete</span></code></td><td>从字典中删除给定键所对应的键值对。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">dictRelease</span></code></td><td>释放给定字典，以及字典中包含的所有键值对。</td><td><span class="math">O(N)</span> ，<code class="docutils literal"><span class="pre">N</span></code> 为字典包含的键值对数量。</td></tr></tbody></table><h3><span id="skiplist与平衡树-哈希表的比较">skiplist与平衡树、哈希表的比较</span></h3><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li></ul><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列之数据结构篇(1)</title>
      <link href="/article/distributed-redis-data-structure-sds-link/"/>
      <url>/article/distributed-redis-data-structure-sds-link/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><blockquote><p>本文转自 <a href="http://redisbook.com/" target="_blank" rel="noopener">redis 的设计与实现</a></p></blockquote><h2><span id="sds">SDS</span></h2><h2><span id="sds-简介">SDS 简介</span></h2><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p><p>举个例子， 如果客户端执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2><span id="sds-结构">SDS 结构</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图 2-1 展示了一个 SDS 示例：</p><ul><li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561604606909distributed-redis-data-structure-sds-link_.png" alt></p><p>图 2-2 展示了另一个 SDS 示例:</p><ul><li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 “Redis” 。</li><li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 buf 数组分配了五字节未使用空间， 所以它的 free 属性的值为 5 （图中使用五个空格来表示五字节的未使用空间）。</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561604660662distributed-redis-data-structure-sds-link_.png" alt></p><h2><span id="sds-结构与c字符串的不同">SDS 结构与C字符串的不同</span></h2><h3><span id="常数获取字符串长度"><strong>常数获取字符串长度</strong></span></h3><p>由于结构当中已经存贮了字符串的长度，所以当需要获取字符串长度的时候，直接返回,时间复杂度O(1)。</p><h3><span id="杜绝缓冲去溢出"><strong>杜绝缓冲去溢出</strong></span></h3><p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性</p><p>当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p><h3><span id="减少字符串修改的分配次数"><strong>减少字符串修改的分配次数</strong></span></h3><p>正如前两个小节所说， 因为 C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。</p><p>因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p><ul><li><p>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</p></li><li><p>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</p></li></ul><p>为了减少空间分配的性能消耗，redis有一下集中策略来管理空间分配</p><h4><span id="空间预分配">空间预分配</span></h4><p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p><p>其中， 额外分配的未使用空间数量由以下公式决定：</p><ul><li><p>如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。</p><blockquote><p>举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。</p></blockquote></li><li><p>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。</p><blockquote><p>举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。</p></blockquote></li></ul><p>通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。</p><h4><span id="惰性空间释放">惰性空间释放</span></h4><p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。</p><p>举个例子， sdstrim 函数接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</p><p>比如对于图 2-14 所示的 SDS 值 s 来说， 执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdstrim(s, "XY");   // 移除 SDS 字符串中的所有 'X' 和 'Y'</span><br></pre></td></tr></table></figure><p><img src="/article/distributed-redis-data-structure-sds-link/1561609102007distributed-redis-data-structure-sds-link_.png" alt></p><p><img src="/article/distributed-redis-data-structure-sds-link/1561609109129distributed-redis-data-structure-sds-link_.png" alt></p><h3><span id="二进制安全"><strong>二进制安全</strong></span></h3><p>所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p><p>这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</p><p>比如说， 使用 SDS 来保存之前提到的特殊数据格式就没有任何问题， 因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束.</p><h2><span id="sds-api">SDS API</span></h2><table border="1" class="docutils"><colgroup><col width="17%"><col width="35%"><col width="49%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsnew</span></code></td><td>创建一个包含给定 C 字符串的 SDS 。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为给定 C 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsempty</span></code></td><td>创建一个不包含任何内容的空 SDS 。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsfree</span></code></td><td>释放给定的 SDS 。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdslen</span></code></td><td>返回 SDS 的已使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code class="docutils literal"><span class="pre">len</span></code> 属性来直接获得，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsavail</span></code></td><td>返回 SDS 的未使用空间字节数。</td><td>这个值可以通过读取 SDS 的 <code class="docutils literal"><span class="pre">free</span></code> 属性来直接获得，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsdup</span></code></td><td>创建一个给定 SDS 的副本（copy）。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为给定 SDS 的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsclear</span></code></td><td>清空 SDS 保存的字符串内容。</td><td>因为惰性空间释放策略，复杂度为 <span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscat</span></code></td><td>将给定 C 字符串拼接到 SDS字符串的末尾。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被拼接 C 字符串的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdscatsds</span></code></td><td>将给定 SDS 字符串拼接到另一个 SDS字符串的末尾。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被拼接 SDS 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscpy</span></code></td><td>将给定的 C 字符串复制到 SDS 里面，覆盖 SDS 原有的字符串。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被复制 C 字符串的长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdsgrowzero</span></code></td><td>用空字符将 SDS 扩展至给定长度。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为扩展新增的字节数。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdsrange</span></code></td><td>保留 SDS 给定区间内的数据，不在区间内的数据会被覆盖或清除。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为被保留数据的字节数。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">sdstrim</span></code></td><td>接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C字符串中出现过的字符。</td><td><span class="math">O(M*N)</span> ， <code class="docutils literal"><span class="pre">M</span></code> 为 SDS 的长度，<code class="docutils literal"><span class="pre">N</span></code> 为给定 C 字符串的长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">sdscmp</span></code></td><td>对比两个 SDS 字符串是否相同。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为两个 SDS 中较短的那个 SDS的长度。</td></tr></tbody></table><h2><span id="链表">链表</span></h2><h2><span id="链表结构">链表结构</span></h2><p>每个链表节点使用一个 adlist.h/listNode 结构来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode</span><br></pre></td></tr></table></figure><p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。</p><p><img src="/article/distributed-redis-data-structure-sds-link/1561609442948distributed-redis-data-structure-sds-link_.png" alt></p><p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>图 3-2 是由一个 list 结构和三个 listNode 结构组成的链表：</li></ul><p><img src="/article/distributed-redis-data-structure-sds-link/1561609514761distributed-redis-data-structure-sds-link_.png" alt></p><h2><span id="链表api">链表API</span></h2><table border="1" class="docutils"><colgroup><col width="20%"><col width="44%"><col width="35%"></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">函数</th><th class="head">作用</th><th class="head">时间复杂度</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetDupMethod</span></code></td><td>将给定的函数设置为链表的节点值复制函数。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetDupMethod</span></code></td><td>返回链表当前正在使用的节点值复制函数。</td><td>复制函数可以通过链表的 <code class="docutils literal"><span class="pre">dup</span></code> 属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetFreeMethod</span></code></td><td>将给定的函数设置为链表的节点值释放函数。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetFree</span></code></td><td>返回链表当前正在使用的节点值释放函数。</td><td>释放函数可以通过链表的 <code class="docutils literal"><span class="pre">free</span></code> 属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSetMatchMethod</span></code></td><td>将给定的函数设置为链表的节点值对比函数。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listGetMatchMethod</span></code></td><td>返回链表当前正在使用的节点值对比函数。</td><td>对比函数可以通过链表的 <code class="docutils literal"><span class="pre">match</span></code>属性直接获得，<span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listLength</span></code></td><td>返回链表的长度（包含了多少个节点）。</td><td>链表长度可以通过链表的  <code class="docutils literal"><span class="pre">len</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listFirst</span></code></td><td>返回链表的表头节点。</td><td>表头节点可以通过链表的 <code class="docutils literal"><span class="pre">head</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listLast</span></code></td><td>返回链表的表尾节点。</td><td>表尾节点可以通过链表的 <code class="docutils literal"><span class="pre">tail</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listPrevNode</span></code></td><td>返回给定节点的前置节点。</td><td>前置节点可以通过节点的 <code class="docutils literal"><span class="pre">prev</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listNextNode</span></code></td><td>返回给定节点的后置节点。</td><td>后置节点可以通过节点的 <code class="docutils literal"><span class="pre">next</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listNodeValue</span></code></td><td>返回给定节点目前正在保存的值。</td><td>节点值可以通过节点的 <code class="docutils literal"><span class="pre">value</span></code> 属性直接获得，<span class="math">O(1)</span> 。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listCreate</span></code></td><td>创建一个不包含任何节点的新链表。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listAddNodeHead</span></code></td><td>将一个包含给定值的新节点添加到给定链表的表头。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listAddNodeTail</span></code></td><td>将一个包含给定值的新节点添加到给定链表的表尾。</td><td><span class="math">O(1)</span></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listInsertNode</span></code></td><td>将一个包含给定值的新节点添加到给定节点的之前或者之后。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listSearchKey</span></code></td><td>查找并返回链表中包含给定值的节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listIndex</span></code></td><td>返回链表在给定索引上的节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listDelNode</span></code></td><td>从链表中删除给定节点。</td><td><span class="math">O(1)</span> 。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listRotate</span></code></td><td>将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头，成为新的表头节点。</td><td><span class="math">O(1)</span></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">listDup</span></code></td><td>复制一个给定链表的副本。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">listRelease</span></code></td><td>释放给定链表，以及链表中的所有节点。</td><td><span class="math">O(N)</span> ， <code class="docutils literal"><span class="pre">N</span></code> 为链表长度。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析系列(2)</title>
      <link href="/article/forbid-foreach-add-or-move/"/>
      <url>/article/forbid-foreach-add-or-move/</url>
      
        <content type="html"><![CDATA[<p>在阿里巴巴Java开发手册中，有这样一条规定：</p><p><img src="/article/forbid-foreach-add-or-move/1555993054426forbid-foreach-add-or-move_.png" alt></p><h3><span id="foreach循环">foreach循环</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型t 元素变量x : 遍历对象obj)&#123; </span><br><span class="line">     引用了x的java语句; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例演示了 普通for循环 和 foreach循环使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用ImmutableList初始化一个List</span></span><br><span class="line">    List&lt;String&gt; userNames = ImmutableList.of(<span class="string">"Hollis"</span>, <span class="string">"hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"H"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"使用for循环遍历List"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userNames.size(); i++) &#123;</span><br><span class="line">        System.out.println(userNames.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"使用foreach遍历List"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用for循环遍历List</span><br><span class="line">Hollis</span><br><span class="line">hollis</span><br><span class="line">HollisChuang</span><br><span class="line">H</span><br><span class="line">使用foreach遍历List</span><br><span class="line">Hollis</span><br><span class="line">hollis</span><br><span class="line">HollisChuang</span><br><span class="line">H</span><br></pre></td></tr></table></figure><p>可以看到，使用foreach语法遍历集合或者数组的时候，可以起到和普通for循环同样的效果，并且代码更加简洁。所以，foreach循环也通常也被称为增强for循环。<br>其实，增强for循环也是Java给我们提供的一个语法糖，如果将以上代码编译后的class文件进行反编译（使用jad工具）的话，可以得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = userNames.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    String userName = (String)iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(userName.equals(<span class="string">"Hollis"</span>))</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>可以发现，原本的增强for循环，其实是依赖了while循环和Iterator实现的。（请记住这种实现方式，后面会用到！）</p><h3><span id="问题重现">问题重现</span></h3><p>规范中指出不让我们在foreach循环中对集合元素做add/remove操作，那么，我们尝试着做一下看看会发生什么问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双括弧语法（double-brace syntax）建立并初始化一个List</span></span><br><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userNames.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userNames.get(i).equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>以上代码，首先使用双括弧语法（double-brace syntax）建立并初始化一个List，其中包含四个字符串，分别是Hollis、hollis、HollisChuang和H。</p><p>然后使用普通for循环对List进行遍历，删除List中元素内容等于Hollis的元素。然后输出List，输出结果如下：</p><pre><code>[hollis, HollisChuang, H]</code></pre><p>以上是哪使用普通的for循环在遍历的同时进行删除，那么，我们再看下，如果使用增强for循环的话会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>以上代码，使用增强for循环遍历元素，并尝试删除其中的Hollis字符串元素。运行以上代码，会抛出以下异常：<code>java.util.ConcurrentModificationException</code><br>之所以会出现这个异常，是因为触发了一个Java集合的错误检测机制——<code>fail-fast</code> 。</p><h3><span id="fail-fast">fail-fast</span></h3><p>接下来，我们就来分析下在增强for循环中add/remove元素的时候会抛出java.util.ConcurrentModificationException的原因，即解释下到底什么是fail-fast进制，fail-fast的原理等。</p><p>fail-fast，即快速失败，它是Java集合的一种错误检测机制。当多个线程对集合（非fail-safe的集合类）进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException（当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常）。</p><p><strong>同时需要注意的是，即使不是多线程环境，如果单线程违反了规则，同样也有可能会抛出改异常。</strong></p><p>那么，在增强for循环进行元素删除，是如何违反了规则的呢？</p><p>要分析这个问题，我们先将增强for循环这个语法糖进行解糖，得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用ImmutableList初始化一个List</span></span><br><span class="line">    List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">"Hollis"</span>);</span><br><span class="line">        add(<span class="string">"hollis"</span>);</span><br><span class="line">        add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">        add(<span class="string">"H"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Iterator iterator = userNames.iterator();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        String userName = (String)iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(userName.equals(<span class="string">"Hollis"</span>))</span><br><span class="line">            userNames.remove(userName);</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(userNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行以上代码，同样会抛出异常。我们来看一下<code>ConcurrentModificationException</code>的完整堆栈：</p><p><img src="/article/forbid-foreach-add-or-move/1555993429782forbid-foreach-add-or-move_.png" alt></p><p>通过异常堆栈我们可以到，异常发生的调用链ForEachDemo的第23行，<code>Iterator.next</code> 调用了 <code>Iterator.checkForComodification</code>方法 ，而异常就是checkForComodification方法中抛出的。</p><p>其实，经过debug后，我们可以发现，如果remove代码没有被执行过，iterator.next这一行是一直没报错的。抛异常的时机也正是remove执行之后的的那一次next方法的调用。</p><p>我们直接看下checkForComodification方法的代码，看下抛出异常的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，<code>modCount != expectedModCount</code>的时候，就会抛出<code>ConcurrentModificationException</code>。</p><p>那么，就来看一下，remove/add 操作室如何导致modCount和expectedModCount不相等的吧。</p><h3><span id="removeadd-做了什么">remove/add 做了什么</span></h3><p>首先，我们要搞清楚的是，到底modCount和expectedModCount这两个变量都是个什么东西。</p><p>通过翻源码，我们可以发现：</p><ul><li>modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。</li><li>expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator方法被调用的时候初始化的。只有通过迭代器对集合进行操作，该值才会改变。</li><li>Itr是一个Iterator的实现，使用ArrayList.iterator方法可以获取到的迭代器就是Itr类的实例。</li></ul><p>他们之间的关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，看到这里，大概很多人都能猜到为什么remove/add 操作之后，会导致expectedModCount和modCount不想等了。</p><p>通过翻阅代码，我们也可以发现，remove方法核心逻辑如下：</p><p><img src="/article/forbid-foreach-add-or-move/1555993489849forbid-foreach-add-or-move_.png" alt></p><p>可以看到，它只修改了modCount，并没有对expectedModCount做任何操作。</p><p>简单总结一下，之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改！</p><h3><span id="正确姿势">正确姿势</span></h3><p>至此，我们介绍清楚了不能在foreach循环体中直接对集合进行add/remove操作的原因。</p><p>但是，很多时候，我们是有需求需要过滤集合的，比如删除其中一部分元素，那么应该如何做呢？有几种方法可供参考：</p><p><strong>1、直接使用普通for循环进行操作</strong></p><p>我们说不能在foreach中进行，但是使用普通的for循环还是可以的，因为普通for循环并没有用到Iterator的遍历，所以压根就没有进行<code>fail-fast</code>的检验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userNames.get(i).equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>这种方案其实存在一个问题，那就是remove操作会改变List中元素的下标，可能存在漏删的情况。<br><strong>2、直接使用Iterator进行操作</strong></p><p>除了直接使用普通for循环以外，我们还可以直接使用Iterator提供的remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">Iterator iterator = userNames.iterator();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p>如果直接使用Iterator提供的remove方法，那么就可以修改到expectedModCount的值。那么就不会再抛出异常了。其实现代码如下：</p><p><img src="/article/forbid-foreach-add-or-move/1555993589126forbid-foreach-add-or-move_.png" alt></p><p><strong>3、使用Java 8中提供的filter过滤</strong></p><p>Java 8中可以把集合转换成流，对于流有一种filter操作， 可以对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">userNames = userNames.stream().filter(userName -&gt; !userName.equals(<span class="string">"Hollis"</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p><strong>4、使用增强for循环其实也可以</strong></p><p>如果，我们非常确定在一个集合中，某个即将删除的元素只包含一个的话， 比如对Set进行操作，那么其实也是可以使用增强for循环的，只要在删除之后，立刻结束循环体，不要再继续进行遍历就可以了，也就是说不让代码执行到下一次的next方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure><p><strong>5、直接使用fail-safe的集合类</strong></p><p>在Java中，除了一些普通的集合类以外，还有一些采用了fail-safe机制的集合类。这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedDeque&lt;String&gt; userNames = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">"Hollis"</span>);</span><br><span class="line">    add(<span class="string">"hollis"</span>);</span><br><span class="line">    add(<span class="string">"HollisChuang"</span>);</span><br><span class="line">    add(<span class="string">"H"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">"Hollis"</span>)) &#123;</span><br><span class="line">        userNames.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h2><span id="总结">总结</span></h2><p>我们使用的增强for循环，其实是Java提供的语法糖，其实现原理是借助Iterator进行元素的遍历。</p><p>但是如果在遍历过程中，不通过Iterator，而是通过集合类自身的方法对集合进行添加/删除操作。那么在Iterator进行下一次的遍历时，经检测发现有一次集合的修改操作并未通过自身进行，那么可能是发生了并发被其他线程执行的，这时候就会抛出异常，来提示用户可能发生了并发修改，这就是所谓的fail-fast机制。</p><p>当然还是有很多种方法可以解决这类问题的。比如使用普通for循环、使用Iterator进行元素删除、使用Stream的filter、使用fail-safe的类等。</p><p>原文链接：<br><img src="https://juejin.im/post/5c8717ad5188257dda56c381" alt="https://juejin.im/post/5c8717ad5188257dda56c381"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程之AQS分析(1)</title>
      <link href="/article/java-AQS/"/>
      <url>/article/java-AQS/</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>谈到并发，不得不谈<code>ReentrantLock</code>；而谈到<code>ReentrantLock</code>，不得不谈<code>AbstractQueuedSynchronized（AQS</code>）！,类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的<code>ReentrantLock/Semaphore/CountDownLatch</code>…。我们以<code>ReentrantLock</code>作为讲解切入点。</p><ul><li>AQS 思维导图</li></ul><p><img src="/article/java-AQS/java-AQS-1626861196646.png" alt></p><h2><span id="aos详解">AOS详解</span></h2><h2><span id="什么是aqs">什么是AQS</span></h2><p>AQS的全称为（AbstractQueuedSynchronizer),是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器</p><h2><span id="aqs与reentrantlock的关系">AQS与ReentrantLock的关系</span></h2><p><code>ReentrantLock</code> 会保证<code>do something</code>在同一时间只有一个线程在执行这段代码，或者说，同一时刻只有一个线程的 <code>lock</code> 方法会返回。其余线程会被挂起，直到获取锁。</p><p>从这里可以看出，其实 <code>ReentrantLock</code> 实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。没错，<code>ReentrantLock</code> 使用的就是 AQS 的独占 API 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// do somethings</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>我们来看 lock的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock 方法是调用的是 <code>sync.lock()</code> 的方法。而<code>Sync</code>是 <code>ReentrantLock</code> 的一个继承了<code>AbstractQueuedSynchronizer</code> 的一个内部类<br>这里的Sync定义了一个抽象类，目的就是要让继承类来实现他的lock方法。<code>ReentrantLock</code>  有公平和非公平的锁机制，所以在该类的代码中，我们可以看到他继承了Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>继承关系如下<br><img src="/article/java-AQS/sync.png" alt></p><h2><span id="aqs-的原理">AQS 的原理</span></h2><p>所以，具体的同步机制就是Sync的具体实现类来管理的。要了解Sync的原理，我们首先要先了解他的父类 <code>AbstractQueuedSynchronizer</code> （AQS）</p><p>AQS核心思想是</p><ul><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</li></ul><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>AQS 的功能可以分为两类：<strong>独占功能</strong>和<strong>共享功能</strong>，它的所有子类中，要么实现并使用了它独占功能的 API，要么使用了共享锁的功能，而不会同时使用两套 API，即便是它最有名的子类 ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套 API 来实现的。</p><h2><span id="abstractqueuedsynchronizer-分析">AbstractQueuedSynchronizer 分析</span></h2><p><code>AbstractQueuedSynchronizer</code> 类图如下<br><img src="/article/java-AQS/AQS.jpg" alt></p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><p><img src="/article/java-AQS/java-AQS-1626861344579.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;<span class="comment">/*... */</span>&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//同步状态</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    状态信息通过protected类型的getState，setState，compareAndSetState进行操作返回同步状态的当前值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置同步状态的值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><h2><span id="sync的实现公平锁和非公平锁">Sync的实现公平锁和非公平锁</span></h2><p><strong>公平锁</strong>：每个线程抢占锁的顺序为先后调用 lock 方法的顺序依次获取锁，类似于排队吃饭。</p><p><strong>非公平锁</strong>：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用 lock 方法的先后顺序无关。</p><h3><span id="公平锁的实现">公平锁的实现</span></h3><p>我们来看一下公平锁的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);   <span class="comment">// 在AbstractQueuedSynchronizer 类当中实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="comment">// 在AbstractQueuedSynchronizer 实现的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表示的是 一个 <code>volatile</code> 修饰的标志位叫做<code>key</code> ，用来表示有没有线程拿走了锁（<code>tryAcquire</code>），当锁不存在的时候，将线程放到一个安全的队列，队列里维护一堆被挂起的线程，当锁被归还时，能通知到这些被挂起的线程，可以来竞争获取锁了。</p><ul><li><p>获取到锁的情景<br>我们来看 <code>tryAcquire</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer 留空了，需要让子类去实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FairSync 子类实现的 获取锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();     <span class="comment">// 拿到标志位</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果队列中没有其他线程  说明没有线程正在占有锁！</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">//修改一下状态位，注意：这里的 acquires 是在 lock 的时候传递来的，从上面的图中可以知道，这个值是写死的 1</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 如果通过 CAS 操作将状态为更新成功则代表当前线程获取锁，因此，将当前线程设置到 AQS 的一个变量中，说明这个线程拿走了锁。</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不为 0 意味着，锁已经被拿走了，但是，因为 ReentrantLock 是重入锁，是可以重复 lock,unlock 的，只要成对出现行。一次。这里还要再判断一次 获取锁的线程是不是当前请求锁的线程。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是的，累加在 state 字段上就可以了。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有获取到锁的情景</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 如果 已经有一个线程获取到了锁，但是没有线程排队</span></span><br><span class="line">    <span class="comment">// 即 AQS head == tail == null</span></span><br><span class="line">    <span class="comment">// 这里就是 tail == null 因此 这里执行enq方法</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 表示目前没有线程争抢 pred 节点 如果有 则执行enq方法</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 因为end 发生 addWaiter 当中，必定是获取锁失败的情况下</span></span><br><span class="line">        <span class="comment">// 所以为tail 为空 表示有线程获取到了锁，所以这里新建了一个</span></span><br><span class="line">        <span class="comment">// 当head 为空的时候 head 会新建一个Node 节点 治理 head = tail = Node(empty)</span></span><br><span class="line">        <span class="comment">// Node 节点 然后在  acquireQueued 方法中获取到锁的线程set到了head 当中 完成更新</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当首节点为新建好之后 会变成如下  Node(empty) -&gt; &lt;- Node 这样</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AQS 节点的变化</p><ul><li><p>当我们只有一个线程进行加锁的时候 如果加锁成功，即是<code>tryAcquire</code> 进行 <code>hasQueuedPredecessors</code> 的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首个线程进行竞争的时候， AQS 的tail 和 head 均为空 则会走判断 h!=t 则表示 加锁成功，直接返回。</span></span><br><span class="line">    <span class="comment">// 当第二个线程来竞争的时候 发现法 statue 不是 0， 则直接进入大 addWaiter 的排队进程中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 head == tail 的时候 证明 头结点已经有一个 在排队了</span></span><br><span class="line">    <span class="comment">// 这里有个问题 h &lt;-&gt; t  h -&gt; next == null 为什么表示 不需要排队，</span></span><br><span class="line">    <span class="comment">// 这里涉及到解锁的过程</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用当前线程去构造一个 <code>Node</code> 对象，<code>mode</code> 是一个表示 <code>Node</code> 类型的字段，仅仅表示这个节点是独占的，还是共享的，或者说，AQS 的这个队列中，哪些节点是独占的，哪些是共享的。(这里 lock 调用的是 AQS 独占的 API，当然，可以写死是独占状态的节点。)</p></li><li><p>创建好节点后，将节点加入到队列尾部，此处，在队列不为空的时候，先尝试通过 cas 方式修改尾节点为最新的节点，如果修改失败，意味着有并发，这个时候才会进入 enq 中死循环，“自旋”方式修改。</p></li><li><p>将线程的节点接入到队里中后，当然还需要做一件事: 将当前线程挂起！这个事，由 acquireQueued 来做。</p></li></ul></li><li><p>Node节点类型<br>在解释 <code>acquireQueued</code> 之前，我们需要先看下 AQS 中队列的内存结构，我们知道，队列由 Node 类型的节点组成，其中至少有两个变量，一个封装线程，一个封装节点类型。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;         <span class="comment">// 节点类型</span></span><br><span class="line">    <span class="keyword">this</span>.thread = thread;           <span class="comment">// 封装的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实际上，它的内存结构是这样的（第一次节点插入时，第一个节点是一个空节点，代表有一个线程已经获取锁，事实上，队列的第一个节点就是代表持有锁的节点）：</p><p><img src="/article/java-AQS/1563765045994java-AQS_.png" alt></p><p>黄色节点为队列默认的头节点，每次有线程竞争失败，进入队列后其实都是插入到队列的尾节点（tail 后面）后面。这个从 enq 方法可以看出来，上文中有提到 enq 方法为将节点插入队列的方法:</p></li><li><p>循环获取锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        仔细看看这个方法是个无限循环，感觉如果p == head &amp;&amp; tryAcquire(arg)条件不满足循环将永远无法结束，当然不会出现死循环，奥秘在于第12行的parkAndCheckInterrupt会把当前线程挂起，从而阻塞住线程的调用栈。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 这里的 表示 他的上一个节点 如果排队成功 那么 node 的上一个节点应该是有的 头结点 始终是个Node(empty)</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前的节点是 head 说明他是队列中第一个“有效的”节点，因此尝试获取，上文中有提到这个类是交给子类去扩展的。</span></span><br><span class="line">                setHead(node);<span class="comment">// 成功后，将上图中的黄色节点移除，Node1 变成头节点。 也就是将头结点变成 empty</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;             <span class="comment">// 这里返回 false  表示上层方法不需要改变 当前线程的 interrupted 状态</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; </span><br><span class="line">                <span class="comment">// 否则，检查前一个节点的状态为，看当前获取锁失败的线程是否需要挂起。</span></span><br><span class="line">                parkAndCheckInterrupt()) </span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment">                上面的方法是调用 LockSupport.park（this）</span></span><br><span class="line"><span class="comment">                如前面所述，LockSupport.park最终把线程交给系统（Linux）内核进行阻塞。当然也不是马上把请求不到锁的线程进行阻塞，还要检查该线程的状态，比如如果该线程处于Cancel状态则没有必要，具体的检查在shouldParkAfterFailedAcquire中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果有异常 </span></span><br><span class="line">            cancelAcquire(node);<span class="comment">// 取消请求，对应到队列操作，就是将当前节点从队列中移除。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code> 节点中，除了存储当前线程，节点类型，队列中前后元素的变量，还有一个叫 <code>waitStatus</code> 的变量，改变量用于描述节点的状态，为什么需要这个状态呢？</p><p>原因是：</p><ul><li>AQS 的队列中，在有并发时，肯定会存取一定数量的节点，每个节点代表了一个线程的状态，有的线程可能“等不及”获取锁了，需要放弃竞争，退出队列，有的线程在等待一些条件满足，满足后才恢复执行（这里的描述很像某个 J.U.C 包下的工具类，ReentrankLock 的 Condition，事实上，Condition 同样也是 AQS 的子类）等等，总之，各个线程有各个线程的状态，但总需要一个变量来描述它，这个变量就叫 waitStatus, 它有四种状态：</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 代表无状态</span></span><br><span class="line"><span class="comment">/** 节点取消  因为超时或中断，该线程已经被取消 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 节点等待触发 线程的后继线程正/已被阻塞，当该线程release或cancel时要重新这个后继线程(unpark)*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 等待条件触发 表明该线程被处于条件队列，就是因为调用了&gt;- Condition.await而被阻塞 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/** 节点状态需要向后传播  传播共享锁*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>只有当前节点的前一个节点为 <code>SIGNAL</code> 时，才能当前节点才能被挂起。</p><ul><li>规则1：如果前继的节点状态为<code>SIGNAL</code>，表明当前节点需要<code>unpark</code>，则返回成功，此时<code>acquireQueued</code>方法的第12行（<code>parkAndCheckInterrupt</code>）将导致线程阻塞</li><li>规则2：如果前继节点状态为<code>CANCELLED</code>(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，返回false，<code>acquireQueued</code>方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</li><li>规则3：如果前继节点状态为非<code>SIGNA</code>L、非<code>CANCELLED</code>，则设置前继的状态为<code>SIGNAL</code>，返回false后进入<code>acquireQueued</code>的无限循环，与规则2同</li><li>总体看来，<code>shouldParkAfterFailedAcquire</code>就是靠前继节点判断当前线程是否应该被阻塞，如果前继节点处于<code>CANCELLED</code>状态，则顺便删除这些节点重新构造队列。</li></ul><p>我们来看一下代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">// 如果前继的节点状态为`SIGNAL`，表明当前节点需要`unpark` 返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前继节点状态为`CANCELLED`(ws&gt;0)，说明前置节点已经被放弃，则回溯到一个非取消的前继节点，</span></span><br><span class="line">        <span class="comment">// 返回false，`acquireQueued`方法的无限循环将递归调用该方法，直至规则1返回true，导致线程阻塞</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前继节点状态为非`SIGNA`L、非`CANCELLED`，则设置前继的状态为`SIGNAL`，返回false后进入`acquireQueued`的无限循环，</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>到此为止，一个线程对于锁的一次竞争才告于段落，结果有两种</p><ul><li>要么成功获取到锁（不用进入到 AQS 队列中</li><li>要么，获取失败，被挂起，等待下次唤醒后继续循环尝试获取锁</li></ul><p>值得注意的是，AQS 的队列为 FIFO 队列，所以，每次被 CPU 假唤醒，且当前线程不是出在头节点的位置，也是会被挂起的。AQS 通过这样的方式，实现了竞争的排队策略</p><ul><li><p>释放锁</p><p>我们来看一下释放锁的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer 当中定义的</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 同样 release 由实现类来实现 这里用是Sync抽象类的实现</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">// 释放锁，成功后，找到 AQS 的头节点，并唤醒它即可：</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Sync 的实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常。</span></span><br><span class="line">      <span class="comment">// 这段可以理解为没有 lock 直接unlock 则会直接报错</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 因为是重入的关系，不是每次释放锁 c 都等于 0，直到最后一次释放锁时，才通知 AQS 不需要再记录哪个线程正在获取锁。</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新状态</span></span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当发现 锁已经需要释放的时候，我们调用 <code>unparkSuccessor</code> 寻找的顺序是从队列尾部开始往前去找的最前面的一个 waitStatus 小于 0 的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">     Node s = node.next;</span><br><span class="line">     <span class="comment">// 从尾到头寻找最后一个节点 表示 s是个沉睡的节点 </span></span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 找到第一个阻塞的节点</span></span><br><span class="line">         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                 s = t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>到此，<code>ReentrantLock</code>的 <code>lock</code> 和 <code>unlock</code> 方法已经基本解析完毕了，唯独还剩下一个非公平锁 <code>NonfairSync</code> 没说，其实，它和公平锁的唯一区别就是获取锁的方式不同，一个是按前后顺序一次获取锁，一个是抢占式的获取锁，那 ReentrantLock 是怎么实现的呢？再看两段代码：</p><h3><span id="非公平锁的实现">非公平锁的实现</span></h3><p>非公平锁的 lock 方法的处理方式是: 在 <code>lock</code> 的时候先直接 <code>cas</code> 修改一次 <code>state</code> 变量（尝试获取锁），成功就返回，不成功再排队，从而达到不排队直接抢占的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Sync 的非公平锁获取方式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 抢占式获取锁 这里是和公平锁的区别</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*!hasQueuedPredecessors() &amp;&amp;*/</span>compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="参考">参考</span></h2><ul><li><a href="https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（上)</a></li><li><a href="https://www.infoq.cn/article/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下)</a></li><li><a href="https://www.jianshu.com/p/279baac48960" target="_blank" rel="noopener">java AQS的实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/27134110" target="_blank" rel="noopener">深入学习java同步器AQS</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></li><li><a href="http://codingdict.com/blog/article/2019/4/26/934.html" target="_blank" rel="noopener">Java 多线程 AQS</a></li><li><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS（一篇就够了）</a></li><li><a href="https://blog.csdn.net/Viscu/article/details/86192135" target="_blank" rel="noopener">JDK源码系列 AbstractQueuedSynchronizer源码剖析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳定性保证</title>
      <link href="/article/spikability-applications-ability-to/"/>
      <url>/article/spikability-applications-ability-to/</url>
      
        <content type="html"><![CDATA[<p>我最近参与讨论了很多有关应用程序如何处理高负载的能力，这个为的核心在于如何在,如何在不浪费大量的特定资源的情况下保持程序的稳定性，而这些特定的资源只会流量峰值的时候起作用。</p><p>很多应用服务，这样的典型case 十分差常见，例如：<br>博客应用程序可能会在每次发文后出现峰值。再比如，博客应用程序可能会在每次发布的帖子上出现峰值。<br>像Groupon或One Kings Lane这样的日交易比较活跃的网站，每当发布一个新产品时，都会经历巨大的流量高峰。<br>而One Kings Lane 的优势在于他们确切的知道流量峰值的出现时间：每天早上8点。让我们使用日常交易网站作为例子，因为它是一个众所周知的问题。</p><h2><span id="解决方案1更多资源">解决方案1:更多资源</span></h2><p>解决这个问题的一个方法是总是有过剩的容量等待峰值。如果您能够估计出在任何给定的一天中您同时拥有的最大流量，那么就可以保持足够的服务器运行来处理最大负载。有了这个解决方案，总是可以利用超出本日最大值的额外容量来预防即将今天的峰值来临。</p><h2><span id="解决方案2峰值时禁用某些特性俗称降级">解决方案2:峰值时禁用某些特性（俗称降级）</span></h2><p>当流量峰值出现的时候，超过了你应用程序的负载能力，可以选择禁用某些特性或者使用应用程序的“轻量级”备份版本，Groupon 和 Google 都推荐这么做。这之所以有效，是因为他以牺牲了应用的部分功能的代价，来降低应用的负载，所以这并不是最佳的选择</p><h2><span id="解决方案3自动伸缩俗称扩容">解决方案3:自动伸缩（俗称扩容）</span></h2><p>当流量激增时，可以通过快速自动地启动新的服务器来处理他们。看起来很棒了，但实施起来确实困难重重。首先，设置自动缩放系统需要花费大量的精力。其次，它必须能够非常迅速地利用这些额外的资源，如果太慢，你的系统可能已经崩溃了。再次，自动扩展程序决定是时候销毁那些额外的实例之前，还有可能出现资源利用不充分的问题。如果你的峰值出现在随机时间，你最终会一直向上和向下伸缩。</p><h2><span id="解决方案4使用消息队列">解决方案4:使用消息队列</span></h2><p>消息队列作用之一就是流量削峰。当负载教轻的时，队列总是空的。当负载峰值，队列开始被逐步填满，而我们的应用程序可以稳步的按照自己的处理速度来逐步处理这些消息，当让如果队列持续增长，我们也可以通过启动更多的服务器也就是消费方来消耗队列。<br>这不仅避免了不必要的费资也不必禁用站点/应用程序的任何功能。<br>至于消息队列还能解决什么问题，可以参考我另一篇博文<a href="https://jasonlees.netlify.com/article/why-mq/" target="_blank" rel="noopener">MQ可以解决哪些实际问题?</a></p><p>原文地址</p><ul><li><a href="%5Bspikability-applications-ability-to%5D(https://blog.iron.io/spikability-applications-ability-to/)">Spikability – An Application’s Ability to Handle Unknown and/or Inconsistent Load</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 稳定性 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ可以解决哪些实际问题?</title>
      <link href="/article/why-mq/"/>
      <url>/article/why-mq/</url>
      
        <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。消息中间件到底该如何使用，何时使用这是一个问题，胡乱地使用消息中间件增加了系统的复杂度，如果用不好消息中间件还不如不用。</p><h2><span id="1-消息队列通讯模式">1. 消息队列通讯模式</span></h2><h3><span id="点对点通讯">点对点通讯：</span></h3><p>点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。</p><h3><span id="多点广播">多点广播：</span></h3><p>MQ适用于不同类型的应用。其中重要的，也是正在发展中的是&quot;多点广播&quot;应用，即能够将消息发送到多个目标站点(DestinationList)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。</p><h3><span id="发布订阅publishsubscribe模式">发布/订阅(Publish/Subscribe)模式：</span></h3><p>发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQEventBroker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。</p><h3><span id="群集cluster">群集(Cluster)：</span></h3><p>为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。</p><h2><span id="使用消息队列的理由">使用消息队列的理由</span></h2><ul><li>解耦</li><li>冗余</li><li>扩展性</li><li>灵活性 &amp; 峰值处理能力</li><li>可恢复性</li><li>送达保证</li><li>排序保证</li><li>缓冲</li><li>理解数据流</li><li>异步通讯</li></ul><h3><span id="解耦">解耦</span></h3><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h3><span id="冗余">冗余</span></h3><p>有时在处理数据的时候处理过程会失败。除非数据被持久化，否则将永远丢失。<span>消息队列</span>把数据进行持久化直到它们已经被完全处理，<span>通过这一方式规避了数据丢失风险。在<span>被许多消息队列所采用的</span>&quot;插入</span>-获取-删除&quot;范式中，在把一个消息从队列中删除之前，需要你的处理过程明确的指出该消息已经被处理完毕，确保你的数据被安全的保存直到你使用完毕。</p><h3><span id="扩展性">扩展性</span></h3><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的；只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p><h2><span id="灵活性-amp-峰值处理能力">灵活性 &amp; 峰值处理能力</span></h2><p>当你的应用上了Hacker News的首页，你将发现访问流量攀升到一个不同寻常的水平。在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。请查看我们<a href="http://blog.iron.io/2012/06/spikability-applications-ability-to.html" target="_blank" rel="noopener">关于峰值处理能力的博客文章</a>了解更多此方面的信息。</p><h3><span id="可恢复性">可恢复性</span></h3><p>当体系的一部分组件失效，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。而这种允许重试或者延后处理请求的能力通常是造就一个略感不便的用户和一个沮丧透顶的用户之间的区别。</p><h3><span id="送达保证">送达保证</span></h3><p>消息队列提供的冗余机制保证了消息能被实际的处理，只要一个进程读取了该队列即可。在此基础上，IronMQ提供了一个&quot;只送达一次&quot;保证。无论有多少进程在从队列中领取数据，每一个消息只能被处理一次。这之所以成为可能，是因为获取一个消息只是&quot;预定&quot;了这个消息，暂时把它移出了队列。除非客户端明确的表示已经处理完了这个消息，否则这个消息会被放回队列中去，在一段可配置的时间之后可再次被处理。</p><h3><span id="排序保证">排序保证</span></h3><p>在许多情况下，数据处理的顺序都很重要。消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。<span><span style="line-height:21px;">IronMO保证消息浆糊通过FIFO（先进先出）的顺序来处理，因此消息在队列中的位置就是从队列中检索<span style="font-family:'微软雅黑', Verdana, sans-serif, '宋体';line-height:21px;">他们</span>的位置。</span></span></p><h3><span id="缓冲">缓冲</span></h3><p><span><span style="line-height:21px;">在任何重要的系统中，都会有需要不同的处理时间的元素。例如,加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行–写入队列的处理会尽可能的快速，而不受从队列读的预备处理的约束。该缓冲有助于控制和优化数据流经过系统的速度。</span></span></p><h3><span id="理解数据流">理解数据流</span></h3><p>在一个分布式系统里，要得到一个关于用户操作会用多长时间及其原因的总体印象，是个巨大的挑战。消息系列通过消息被处理的频率，来方便的辅助确定那些表现不佳的处理过程或领域，这些地方的数据流都不够优化。</p><h3><span id="异步通信">异步通信</span></h3><p>很多时候，你不想也不需要立即处理消息。消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它。你想向队列中放入多少消息就放多少，然后在你乐意的时候再去处理它们。</p><h2><span id="2消息队列应用场景">2.消息队列应用场景</span></h2><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。</p><h3><span id="异步处理">异步处理</span></h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种</p><span style="color:#ff0000;"> 1.串行的方式；2.并行方式</span><ol><li>串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。<br><img src="/article/why-mq/1554865262348why-mq_.png" alt></li></ol><ol start="2"><li>并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间<br><img src="/article/why-mq/1554865317050why-mq_.png" alt></li></ol><p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p><p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）</p><p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p><p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="/article/why-mq/1554865377893why-mq_.png" alt></p><p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。</p><h3><span id="应用解耦">应用解耦</span></h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="/article/why-mq/1554865447767why-mq_.png" alt></p><p>传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合</p><p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：<br><img src="/article/why-mq/1554865489619why-mq_.png" alt></p><p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p><p>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作</p><p>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p><h3><span id="流量削锋">流量削锋</span></h3><p>流量削锋也是消息队列中的常用场景，<span style="color:#ff0000;">一般在秒杀或团抢活动中使用广泛</span>。</p><p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。</p><p>a、可以控制活动的人数</p><p>b、可以缓解短时间内高流量压垮应用<br><img src="/article/why-mq/1554865555458why-mq_.png" alt></p><p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。</p><p>秒杀业务根据消息队列中的请求信息，再做后续处理</p><h3><span id="日志处理">日志处理</span></h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下<br><img src="/article/why-mq/1554865583034why-mq_.png" alt></p><p>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列</p><p>Kafka消息队列，负责日志数据的接收，存储和转发</p><p>日志处理应用：订阅并消费kafka队列中的日志数据</p><h3><span id="消息通讯">消息通讯</span></h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在<span style="color:#ff0000;">纯的消息通讯</span>。比如实现点对点消息队列，或者聊天室等<br><span style="color:#ff0000;">点对点通讯：</span><br><img src="/article/why-mq/1554865619033why-mq_.png" alt></p><p>客户端A和客户端B使用同一队列，进行消息通讯。</p><p><span style="color:#ff0000;">聊天室通讯：</span><br><img src="/article/why-mq/1554865634868why-mq_.png" alt></p><p>客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</p><p>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p><h2><span id="3-消息中间件示例">3. 消息中间件示例</span></h2><h3><span id="电商系统">电商系统</span></h3><p><img src="/article/why-mq/1554865663446why-mq_.png" alt></p><p>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。</p><p>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）</p><p>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。</p><p>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p><h3><span id="日志收集系统">日志收集系统</span></h3><p><img src="/article/why-mq/1554865773681why-mq_.png" alt></p><p>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p><p>Zookeeper注册中心，提出负载均衡和地址查找服务</p><p>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列</p><p>Kafka集群：接收，路由，存储，转发等消息处理</p><p>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据</p><p>以下是新浪kafka日志处理应用案例：转自（<a href="http://cloud.51cto.com/art/201507/484338.htm%EF%BC%89" target="_blank" rel="noopener">http://cloud.51cto.com/art/201507/484338.htm）</a></p><p><img src="/article/why-mq/1554865925768why-mq_.png" alt></p><p><span>(1)Kafka</span>：接收用户日志的消息队列</p><p><span>(2)Logstash</span>：做日志解析，统一成JSON输出给Elasticsearch</p><p><span>(3)Elasticsearch</span>：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能</p><p><span>(4)Kibana</span>：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因</p><h2><span id="4jms消息服务">4.JMS消息服务</span></h2><p>讲消息队列就不得不提JMS 。JMS（JAVA Message Service，java消息服务）API是一个消息服务的标准/规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>在EJB架构中，有消息bean可以无缝的与JM消息服务集成。在J2EE架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。</p><h3><span id="消息模型">消息模型</span></h3><p>在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。</p><h4><span id="p2p模式">P2P模式</span></h4><p><img src="/article/why-mq/1554865986120why-mq_.png" alt></p><p>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点</p><p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</p><p>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</p><p>接收者在成功接收消息之后需向队列应答成功</p><p>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。</p><h4><span id="pubsub模式">Pub/Sub模式</span></h4><p><img src="/article/why-mq/1554866112435why-mq_.png" alt>S</p><p>包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p>Pub/Sub的特点</p><p>每个消息可以有多个消费者</p><p>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</p><p>为了消费消息，订阅者必须保持运行的状态</p><p>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p><p>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</p><h3><span id="消息消费">消息消费</span></h3><p>在JMS中，消息的产生和消费都是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。</p><p>（1）同步</p><p>订阅者或接收者通过receive方法来接收消息，receive方法在接收到消息之前（或超时之前）将一直阻塞；</p><p>（2）异步</p><p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><p>JNDI：Java命名和目录接口,是一种标准的Java命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。</p><p>JNDI在JMS中起到查找和访问发送目标或消息来源的作用。</p><h2><span id="5常用消息队列"><strong>5.常用消息队列</strong></span></h2><p>一般商用的容器，比如WebLogic，JBoss，都支持JMS标准，开发上很方便。但免费的比如Tomcat，Jetty等则需要使用第三方的消息中间件。本部分内容介绍常用的消息中间件（Active MQ,Rabbit MQ，Zero MQ,Kafka）以及他们的特点。</p><h3><span id="activemq">ActiveMQ</span></h3><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p><p><strong>ActiveMQ特性如下：</strong></p><ul><li>多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li> 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性</li><li> 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</li><li> 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群，客户端-服务器，点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider，进行测试</li></ul><h3><span id="rabbitmq">RabbitMQ</span></h3><p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。结构图如下：</p><p><img src="/article/why-mq/1554866238609why-mq_.png" alt></p><p><strong>几个重要概念：</strong></p><ul><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>producer：消息生产者，就是投递消息的程序。</li><li>consumer：消息消费者，就是接受消息的程序。</li><li>channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p><strong>消息队列的使用过程，如下：</strong></p><ul><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ul><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。</p><h3><span id="zeromq">ZeroMQ</span></h3><p>号称史上最快的消息队列，它实际类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。</p><p>引用官方的说法： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入<a href="http://lib.csdn.net/base/linux" title="Linux知识库" target="_blank" rel="noopener">Linux</a>内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一<br>层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”</p><p><strong>特点是：</strong></p><ul><li><p>高性能，非持久化</p></li><li><p>跨平台：支持Linux、Windows、OS X等</p></li><li><p>多语言支持； C、C++、Java、.NET、Python等30多种开发语言</p></li><li><p>可单独部署或集成到应用中使用</p></li><li><p>可作为Socket通信库使用</p></li></ul><p>与RabbitMQ相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，更像一个底层的网络通讯库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。支持“Request-Reply “，”Publisher-Subscriber“，”Parallel Pipeline”三种基本模型和扩展模型。</p><p><strong>ZeroMQ高性能设计要点：</strong></p><p>1、无锁的队列模型</p><p>   对于跨线程间的交互（用户端和session）之间的数据交换通道pipe，采用无锁的队列<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库" target="_blank" rel="noopener">算法</a>CAS；在pipe两端注册有异步事件，在读或者写消息到pipe的时，会自动触发读写事件。</p><p>2、批量处理的算法</p><p>   对于传统的消息处理，每个消息在发送和接收的时候，都需要系统的调用，这样对于大量的消息，系统的开销比较大，zeroMQ对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。</p><p>3、多核下的线程绑定，无须CPU切换</p><p>   区别于传统的多线程并发模式，信号量或者临界区， zeroMQ充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的CPU切换开销。</p><h3><span id="kafka">Kafka</span></h3><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。</p><p><strong>Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：</strong></p><ul><li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）</li><li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息</li><li>支持通过Kafka服务器和消费机集群来分区消息</li><li>支持Hadoop并行数据加载</li></ul><p><strong>Kafka相关概念</strong></p><ul><li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker[5]</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer：负责发布消息到Kafka broker</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li></ul><p><span style="color:#990000;">一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用。</span></p><h2><span id="6使用消息队列需要考虑的问题">6.使用消息队列需要考虑的问题</span></h2><h3><span id="你也许并不需要消息队列">你也许并不需要消息队列</span></h3><p>消息队列是一个能让你获得容错性，分布式，解耦等架构能力的系统。纸上谈兵的话，它看起来还不错。</p><p>或许消息列队在你的应用中有不少适用的场景。你可以看下这篇关于消息队列优点的文章，看看到底有哪些合适的场景。但可不要因为说&quot;能解耦那太好了”就轻易使用它。我们来看一个例子——你希望你的邮件发送和订单处理互相解耦。</p><p>因此你发送一个消息到消息队列里，然后邮件处理系统取出这个消息并发送邮件。那你在一个独立的单classpath的应用中怎么实现呢？让你的订单处理服务依赖于一个邮件服务，然后调用sendEmail()方法，而不是sendToMQ()方法。如果你使用了消息队列，你需要定义一个两个系统都能识别的消息格式 ；如果你不使用消息队列，那么你得定义一个方法签名。它们有什么本质的区别吗？其实没有。</p><p>不过你可能还有别的消费者想要对某个指定的消息进行额外的处理？这的确是可能发生的，而并不只是针对我们这里说到的这个项目而已。尽管确有可能，但相比添加另一个方法调用而言，它可能并不值当。耦合？是的。不过这个耦合并没有什么不方便的。</p><p>那我应该如何处理峰值流量？你可以通过消息队列将请求放到一个持久化队列中，然后再一并处理它们。这是一个非常有用的特性，不过它也受限于几个 因素——你的请求是在UI后台处理，还是需要即时响应？serlvet容器的线程池某种程度上可以当作是一个队列，用户最终会拿到响应，但是得需要等待（如果线程的超时时间过短的话，请求可能会丢失）。</p><p>你可以使用一个内存队列来存储那些较重的请求（得在UI后台进行处理）。不过注意了，你的队列并不是默认高可用的。比如说，如果一个消息队列节点挂掉了，你的消息就丢失了。因此，不去使用应用节点内的内存队列，而是去使用一个消息队列，这可能并没有什么优势。</p><p>消息队列使得我们可以进行异步处理——这的确是个有用的特性。你不希望在用户等待的时候做一些很重的操作。不过你也可以使用一个内存队列，或者简单地启动一个新的线程（比如Spring的@Async注解）。这样又有另一个问题——如果消息丢失的话是否有问题？如果你应用处理请求的节点挂了，你可以进行恢复吗？你会发现这事会经常发生，如果不保证所有消息都处理到的话，很难保证功能的正确性。因此，仅将较重的调用进行异步处理是比较可取的。</p><p>把消息放到队列以便让另一个组件来进行处理，对于这个场景，如果消息丢失是无法接受的 ，这也有一个很简单的解决方案——数据库。你可以把一条processed=false的数据存储到数据库中。然后再运行一个调度作业，将所有未处理的记录挑选出来，异步地进行处理。当处理完成的时候，将标记设为true。我经常用这个方法，包括在一些大型的线上系统中，它也工作得挺好的。</p><p>这样你还能不断地对你的应用节点进行扩展，只要它们的内存中没有任何的持久化状态的话。不管你是否使用了消息队列都可以（临时的内存处理队列并不属于持久化状态）。</p><p>为什么我要给经常用到的消息队列提供一些备选方案？因为如果你由于不恰当的原因选择了它，那么消息队列可能会成为一个负担。它们并非如想像中那样容易使用。首先，它有一个学习曲线。一般来说，你集成的组件切分得越多，就越容易出现问题。其次，还有一个设置及配置的成本。比如说，当消息队列需要在一个集群中运行的话，比如说多个数据中心，那么这就变得复杂了。</p><p>高可用性并不是上来就有的——默认它是不会打开的。还有就是你的应用节点如何连接到消息队列？通过一个刷新的连接池，或者使用短生命周期的DNS记录，还是通过一个负载均衡器？你的队列可能还有许多配置项，大小是多少，行为是怎样的（消费者需不需要确认接受，要不要通知处理失败，多个消费者能够取到同一个消息吗，消息有没有TTL，等等）同时还有网络及消息传递的开销，尤其是现在大家都喜欢用XML或者JSON来传输消息。如果你过度地使用了消息队列，那么它会增加你系统的延时。</p><p>最后一点，但并不是最次要的——如果出现问题的话，使用消息队列会让问题跟踪变得异常困难。你没法在IDE中看到所谓的调用层次，因为一旦你发送消息到队列里了，你就得自己去查找它在哪里处理的了。这可不是听起来那么简单的。你看到了吧，它会给你增加许多的复杂性，以及许多需要注意的东西。</p><p>通常而言，在某些上下文中，消息队列还是非常有用的。当它们的确适合的话，我也会在项目中使用它们——比方说，我们不想丢失消息，但又希望能快速地进行处理。我也见过它在一些不太常见的场景中使用的情况，比如说只有一个应用节点来进行消费，不管是哪个节点投递过来的消息。你还可以看下stackoverflow上的这个问题。还有一些使用场景就是，或许你的确需要进行多语言间的通信，又或者你的数据流已经过于复杂了，不使用新的消息消费者而是增加新方法调用的话代价会很大。</p><p>我想说的是那句老掉牙的真理“杀鸡焉用牛刀”。如果你不是很确定已经没有别的更容易管理和维护的方法，一定要使用消息队列的话，最好不要使用它。不要因为”万一它有用呢“而去用它——只有你确实觉得需要的话再去使用。因为很有可能，就像这里说到的这个项目一样，消息队列其实是没有必要的。</p><h3><span id="62如何避免消息丢失">6.2如何避免消息丢失</span></h3><p>选择能够支持消息持久化的MQ方案。如：ActiveMQ、RabbitMQ等，给消息一个处理状态如：process=false。</p><p>还可以使用缓存方案做：如Redis，它本身也是支持持久化的。</p><h2><span id="7本文参考资料来源">7.本文参考资料来源</span></h2><ul><li>消息队列MQ的原理及实现方法：<a href="http://blog.csdn.net/lzq_csdn_th/article/details/51945408" target="_blank" rel="noopener">http://blog.csdn.net/lzq_csdn_th/article/details/51945408</a></li><li>关于消息队列的使用：<a href="http://www.cnblogs.com/linjiqin/p/5720865.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/5720865.html</a></li><li>消息队列使用的四种场景介绍：<a href="http://blog.csdn.net/cws1214/article/details/52922267" target="_blank" rel="noopener">http://blog.csdn.net/cws1214/article/details/52922267</a></li><li>使用消息队列的十个理由：<a href="http://www.oschina.net/translate/top-10-uses-for-message-queue?p=2" target="_blank" rel="noopener">http://www.oschina.net/translate/top-10-uses-for-message-queue?p=2</a></li><li>国外的一款消息队列IronMQ：<a href="http://iron.io/products/mq?rc=blog_mq_t10" target="_blank" rel="noopener">http://iron.io/products/mq?rc=blog_mq_t10</a></li><li>你可能并不需要消息队列：<a href="http://kb.cnblogs.com/page/212710/" target="_blank" rel="noopener">http://kb.cnblogs.com/page/212710/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解java泛型</title>
      <link href="/article/Generics/"/>
      <url>/article/Generics/</url>
      
        <content type="html"><![CDATA[<h2><span id="泛型是什么">泛型是什么</span></h2><p>一说到泛型，大伙肯定不会陌生，我们代码里面有很多类似这样的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list=<span class="keyword">new</span> ArrayList&lt;T&gt;</span><br></pre></td></tr></table></figure><p>ArrayList就是个泛型类，我们通过设定不同的类型，可以往集合里面存储不同类型的数据类型（而且只能存储设定的数据类型，这是泛型的优势之一）。“泛型”简单的意思就是泛指的类型（参数化类型）。想象下这样的场景：如果我们现在要写一个容器类（支持数据增删查询的），我们写了支持String类型的，后面还需要写支持Integer类型的。然后呢？Doubel、Float、各种自定义类型？这样重复代码太多了，而且这些容器的算法都是一致的。我们可以通过泛指一种类型T,来代替我们之前需要的所有类型，把我们需要的类型作为参数传递到容器里面，这样我们算法只需要写一套就可以适应所有的类型。最典型的的例子就是ArrayList了，这个集合我们无论传递什么数据类型，它都能很好的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    elements[size++]=item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码灵活性很高，所有的类型都可以向上转型为Object类，这样我们就可以往里面存储各种类型的数据了。的确Java在泛型出现之前，也是这么做的。但是这样的有一个问题：如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。例如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyList myList=<span class="keyword">new</span> MyList();</span><br><span class="line">myList.add(<span class="string">"A"</span>);</span><br><span class="line">myList.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));</span><br><span class="line">System.out.println((String)myList.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>我们在这个集合里面存储了多个类型（某些情况下容器可能会存储多种类型的数据），如果数据量较多，转型的时候难免会出现异常，而这些都是无法在编译期得知的。而泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。</p><h2><span id="java泛型介绍">Java泛型介绍</span></h2><p>下面我们来介绍Java泛型的相关内容，下面会介绍以下几个方面：</p><ul><li>Java泛型类</li><li>Java泛型方法</li><li>Java泛型接口</li><li>Java泛型擦除及其相关内容</li><li>Java泛型通配符</li></ul><h3><span id="java泛型类">Java泛型类</span></h3><p>类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于&lt;K,V&gt;,&lt;T,E,K&gt;等。这样我们就可以在类里面使用定义的类型参数。<br>泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了</p><h3><span id="java泛型方法">Java泛型方法</span></h3><p>前面我们介绍的泛型是作用于整个类的，现在我们来介绍泛型方法。泛型方法既可以存在于泛型类中，也可以存在于普通的类中。<font color="red">如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。</font>下面我们通过例子来看一下泛型方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getData</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 泛型方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">PrinterInfo</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataHolder&lt;String&gt; dataHolder=<span class="keyword">new</span> DataHolder&lt;&gt;();</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">1</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="string">"AAAAA"</span>);</span><br><span class="line">dataHolder.PrinterInfo(<span class="number">8.88f</span>);</span><br></pre></td></tr></table></figure><p>我们来看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">AAAAA</span><br><span class="line">8.88</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们看到我们是在一个泛型类里面定义了一个泛型方法printInfo。通过传入不同的数据类型，我们都可以打印出来。在这个方法里面，我们定义了类型参数E。这个E和泛型类里面的T两者之间是没有关系的。</p><p>这个泛型方法依然可以传入Double、Float等类型的数据。泛型方法里面的类型参数T和泛型类里面的类型参数是不一样的类型，从上面的调用方式，我们也可以看出，泛型方法printInfo不受我们DataHolder中泛型类型参数是String的影响。<br>我们来总结下泛型方法的几个基本特征：</p><ul><li>public与返回值中间非常重要，可以理解为声明此方法为泛型方法。</li><li>只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</li><li>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</li><li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</li></ul><h3><span id="java泛型接口">Java泛型接口</span></h3><p>Java泛型接口的定义和Java泛型类基本相同，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处有两点需要注意：</p><ul><li>泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    即：class DataHolder implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment">    * 如果不声明泛型，如：class DataHolder implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。例子如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子我们看到，实现类里面的所有T的地方都需要实现为String。</p><h3><span id="java泛型擦除及其相关内容">Java泛型擦除及其相关内容</span></h3><p>我们下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; class1=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">Class&lt;?&gt; class2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">System.out.println(class1);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class2);<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(class1.equals(class2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们看输出发现，class1和class2居然是同一个类型ArrayList，在运行时我们传入的类型变量String和Integer都被丢掉了。Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。我们来看一个更彻底的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">House</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>, <span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用代码及输出</span></span><br><span class="line">    List&lt;Table&gt; tableList = <span class="keyword">new</span> ArrayList&lt;Table&gt;();</span><br><span class="line">    Map&lt;Room, Table&gt; maps = <span class="keyword">new</span> HashMap&lt;Room, Table&gt;();</span><br><span class="line">    House&lt;Room&gt; house = <span class="keyword">new</span> House&lt;Room&gt;();</span><br><span class="line">    Particle&lt;Long, Double&gt; particle = <span class="keyword">new</span> Particle&lt;Long, Double&gt;();</span><br><span class="line">    System.out.println(Arrays.toString(tableList.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(maps.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(house.getClass().getTypeParameters()));</span><br><span class="line">    System.out.println(Arrays.toString(particle.getClass().getTypeParameters()));</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">[E]</span></span><br><span class="line"><span class="comment">[K, V]</span></span><br><span class="line"><span class="comment">[Q]</span></span><br><span class="line"><span class="comment">[POSITION, MOMENTUM]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面的代码里，我们想在运行时获取类的类型参数，但是我们看到返回的都是“形参”。在运行期我们是获取不到任何已经声明的类型信息的。</p><p><font color="red">注意： 编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。<br></font></p><p>泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。下面的例子中，可以把泛型参数T当作HasF类型来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extend关键字后后面的类型信息决定了泛型参数能保留的信息。Java类型擦除只会擦除到HasF类型。</p><h4><span id="java泛型擦除的原理">Java泛型擦除的原理</span></h4><p>我们通过例子来看一下，先看一个非泛型的版本：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = (String) holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SimpleHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class SimpleHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们给出一个泛型的版本，从字节码的角度来看看:</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//GenericHolder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericHolder&lt;String&gt; holder = <span class="keyword">new</span> GenericHolder&lt;&gt;();</span><br><span class="line">        holder.setObj(<span class="string">"Item"</span>);</span><br><span class="line">        String s = holder.getObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenericHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T obj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericHolder</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn       </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: aload_1       </span><br><span class="line">       2: putfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #3                  // class GenericHolder</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #4                  // Method "&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1      </span><br><span class="line">       <span class="number">8</span>: aload_1       </span><br><span class="line">       9: ldc           #5                  // String Item</span><br><span class="line">      11: invokevirtual #6                  // Method setObj:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">14</span>: aload_1       </span><br><span class="line">      15: invokevirtual #7                  // Method getObj:()Ljava/lang/Object;</span><br><span class="line">      18: checkcast     #8                  // class java/lang/String</span><br><span class="line">      <span class="number">21</span>: astore_2      </span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译过程中，类型变量的信息是能拿到的。所以，set方法在编译器可以做类型检查，非法类型不能通过编译。但是对于get方法，由于擦除机制，运行时的实际引用类型为Object类型。<font color="red">为了“还原”返回结果的类型，编译器在get之后添加了类型转换。所以，在GenericHolder.class文件main方法主体第18行有一处类型转换的逻辑。它是编译器自动帮我们加进去的。</font></p><p>所以在泛型类对象读取和写入的位置为我们做了处理，为代码添加约束。</p><h4><span id="java泛型擦除的缺陷及补救措施">Java泛型擦除的缺陷及补救措施</span></h4><p>泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。类似下面的代码都是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        T[] array = (T) <span class="keyword">new</span> Object[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们有什么办法来补救呢？下面介绍几种方法来一一解决上面出现的问题。</p><h5><span id="类型判断问题">类型判断问题</span></h5><p>我们可以通过下面的代码来解决泛型的类型信息由于擦除无法进行类型判断的问题：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类型判断封装类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericType</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Class&lt;?&gt; classType;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        classType=type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classType.isInstance(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法我们可以这样调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericType&lt;A&gt; genericType=new GenericType&lt;&gt;(A.class);</span><br><span class="line">System.out.println(&quot;------------&quot;);</span><br><span class="line">System.out.println(genericType.isInstance(new A()));</span><br><span class="line">System.out.println(genericType.isInstance(new B()));</span><br></pre></td></tr></table></figure><p>我们通过记录类型参数的Class对象，然后通过这个Class对象进行类型判断。</p><h5><span id="创建类型实例">创建类型实例</span></h5><p>泛型代码中不能new T()的原因有两个，一是因为擦除，不能确定类型；而是无法确定T是否包含无参构造函数。为了避免这两个问题，我们使用显式的工厂模式：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法来创建实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creater</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T instance;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends Factory&lt;T&gt;&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    instance=f.create();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer integer=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过工厂模式+泛型方法来创建实例对象，上面代码中我们创建了一个IntegerFactory工厂，用来创建Integer实例，以后代码有变动的话，我们可以添加新的工厂类型即可。<br>调用代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creater&lt;Integer&gt; creater=new Creater&lt;&gt;();</span><br><span class="line">System.out.println(creater.newInstance(new IntegerFactory()));</span><br></pre></td></tr></table></figure><h5><span id="创建泛型数组">创建泛型数组</span></h5><p>一般不建议创建泛型数组。尽量使用ArrayList来代替泛型数组。但是在这里还是给出一种创建泛型数组的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithTypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用的还是传参数类型，利用类型的newInstance方法创建实例的方式。</p><h3><span id="java泛型的通配符">Java泛型的通配符</span></h3><h4><span id="上界通配符lt-extends-tgt">上界通配符&lt;? extends T&gt;</span></h4><p>我们先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在我们定义一个盘子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们定义一个水果盘子，理论上水果盘子里，当然可以存在苹果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>你会发现这段代码无法进行编译。装苹果的盘子”无法转换成“装水果的盘子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert from Plate&lt;Apple&gt; to Plate&lt;Fruit&gt;</span><br></pre></td></tr></table></figure><p>从上面代码我们知道，就算容器中的类型之间存在继承关系，但是Plate和Plate两个容器之间是不存在继承关系的。 在这种情况下，Java就设计成Plate&lt;? extend Fruit&gt;来让两个容器之间存在继承关系。我们上面的代码就可以进行赋值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());</span><br></pre></td></tr></table></figure><pre><code>我们通过一个更加详细的例子来看一下上界的界限：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面这个类层次中，Plate&lt;? extend Fruit&gt;，覆盖下面的蓝色部分：</p><p><img src="/article/Generics/1554717847002Generics_.png" alt></p><p>如果我们往盘子里面添加数据，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.set(new Fruit());</span><br><span class="line">p.set(new Apple());</span><br></pre></td></tr></table></figure><p>你会发现无法往里面设置数据，按道理说我们将泛型类型设置为? extend Fruit。按理说我们往里面添加Fruit的子类应该是可以的。但是Java编译器不允许这样操作。<font color="red">&lt;? extends Fruit&gt;会使往盘子里放东西的set()方法失效。但取东西get()方法还有效</font><br>原因是：</p><p>Java编译期只知道容器里面存放的是Fruit和它的派生类，具体是什么类型不知道，可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在后面看到Plate&lt; Apple &gt;赋值以后，盘子里面没有标记为“苹果”。只是标记了一个占位符“CAP#1”，来表示捕获一个Fruit或者Fruit的派生类，具体是什么类型不知道。所有调用代码无论往容器里面插入Apple或者Meat或者Fruit编译器都不知道能不能和这个“CAP#1”匹配，所以这些操作都不允许。<br>但是上界通配符是允许读取操作的。例如代码：</p><p>但是上界通配符是允许读取操作的。例如代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit fruit=p.get();</span><br><span class="line">Object object=p.get();</span><br></pre></td></tr></table></figure><p>这个我们很好理解，由于上界通配符设定容器中只能存放Fruit及其派生类，那么获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。</p><h4><span id="下界通配符lt-super-tgt">下界通配符&lt;? super T&gt;</span></h4><p>下界通配符的意思是容器中只能存放T及其T的基类类型的数据。我们还是以上面类层次的来看，&lt;? super Fruit&gt;覆盖下面的红色部分：</p><p><img src="/article/Generics/1554718229543Generics_.png" alt></p><p>原因是：</p><p>下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。</p><h4><span id="pecs原则">PECS原则</span></h4><p>最后简单介绍下Effective Java这本书里面介绍的PECS原则。<br><font color="red"></font><br><font color="red"><br></font></p><p><font color="red">*   上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。</font></p><p>*   <font color="red">下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。<br></font></p><h4><span id="ltgt无限通配符">&lt;?&gt;无限通配符</span></h4><p>无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。但它是有作用的，原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。举个例子，在List类型的引用中，不能向其中添加Object, 而List类型的引用就可以添加Object类型的变量。</p><font color="red">最后提醒一下的就是，List与List并不等同，List是List的子类。还有不能往List&lt;?&gt; list里添加任意对象，除了null。</font><font color="red"></font>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 替换PermGem 为 Meta Space</title>
      <link href="/article/java-meta-space-instand-of-perm-space/"/>
      <url>/article/java-meta-space-instand-of-perm-space/</url>
      
        <content type="html"><![CDATA[<h2><span id="背景">背景</span></h2><p><a target="_blank"></a></p><h3><span id="永久代permgen在哪里">永久代（PermGen）在哪里？</span></h3><p>根据，hotspot jvm结构如下(虚拟机栈和本地方法栈合一起了)：</p><p><img src="/article/java-meta-space-instand-of-perm-space/1553223919610java-meta-space-instand-of-perm-space_.png" alt></p><p><span style="color:#ff0000;">上图引自网络，但有个问题：方法区和heap堆都是线程共享的内存区域。</span></p><p><strong><span style="color:#ff0000;">关于方法区和永久代：</span></strong></p><p>在HotSpot JVM中，这次讨论的**<span style="color:#ff0000;">永久代</span>**，就是上图的方法区（JVM规范中称为方法区）。<a href="https://www.baidu.com/s?wd=%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">《Java虚拟机规范》</a>只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。</p><h3><span id="jdk8永久代的废弃">JDK8永久代的废弃</span></h3><p>JDK8 永久代变化如下图：</p><p><img src="/article/java-meta-space-instand-of-perm-space/1553223971295java-meta-space-instand-of-perm-space_.png" alt></p><ol><li><p><a href="https://www.baidu.com/s?wd=%E6%96%B0%E7%94%9F%E4%BB%A3&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新生代</a>：Eden+From Survivor+To Survivor</p></li><li><p>老年代：OldGen</p></li><li><p><span style="color:#ff0000;">永久代（方法区的实现） : PermGen-----&gt;替换为Metaspace(本地内存中)</span></p></li></ol><p> </p><p>###二、为什么废弃永久代（PermGen）</p><h3><span id="官方说明">官方说明</span></h3><p>参照JEP122：<a href="http://openjdk.java.net/jeps/122%EF%BC%8C%E5%8E%9F%E6%96%87%E6%88%AA%E5%8F%96%EF%BC%9A" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122，原文截取：</a></p><h2><span id="motivation">Motivation</span></h2><blockquote><p>This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p></blockquote><blockquote><p> 即：<span style="color:#ff0000;">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</span><br><a target="_blank"></a></p></blockquote><h3><span id="现实使用中易出问题">现实使用中易出问题</span></h3><p>由于永久代内存经常不够用或发生内存泄露，爆出异常_java.lang.OutOfMemoryError: PermGen_</p><p>##三、深入理解元空间（Metaspace）</p><h3><span id="元空间的内存大小">元空间的内存大小</span></h3><p>元空间是方法区的在HotSpot jvm 中的实现，<span style="color:#000000;">方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 </span></p><p><span style="color:#ff0000;">元空间的本质和永久代类似，都是对JVM规范中方法区的实现</span>。<span style="font-size:12px;"><span style="color:#333333;">不过**<span style="color:#ff0000;">元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</span>**</span></span>，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。<br><a target="_blank"></a></p><h3><span id="常用配置参数">常用配置参数</span></h3><ol><li>MetaspaceSize</li></ol><blockquote><p>初始化的Metaspace大小，<span style="color:#ff0000;">控制元空间发生GC的阈值</span>。GC后，动态增加或降低<span style="color:#ff0000;">MetaspaceSize</span>。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用<a href="http://lib.csdn.net/base/javase" title="Java SE知识库" target="_blank" rel="noopener">Java</a> -XX:+PrintFlagsInitial命令查看本机的初始化参数</p></blockquote><ol start="2"><li><span style="color:#ff0000;">MaxMetaspaceSize</span></li></ol><blockquote><p>限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。</p></blockquote><ol start="3"><li><span style="color:#ff0000;">MinMetaspaceFreeRatio</span></li></ol><blockquote><p>当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。</p></blockquote><ol start="4"><li><span style="color:#ff0000;">MaxMetasaceFreeRatio</span></li></ol><blockquote><p>当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。</p></blockquote><ol start="5"><li>MaxMetaspaceExpansion</li></ol><blockquote><p>Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。</p></blockquote><ol start="6"><li>MinMetaspaceExpansion</li></ol><blockquote><p>Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。</p></blockquote><h3><span id="元空间的另一个优势">元空间的另一个优势</span></h3><ul><li><p>共享元空间</p><p>HotSpot的永久代：原来的jar包及你自己项目的class存放的内存空间，这部分空间是固定的，启动参数里面permSize确定，如果你的jar包很多，经常会遇到永久代溢出，且每个项目都会占用自己的permGen空间，改成用元空间后，各个项目会共享同样的class内存空间。</p></li><li><p>提高GC的性能</p><ul><li>Full GC中，元数据指向元数据的那些指针都不用再扫描了。很多复杂的元数据扫描的代码（尤其是CMS里面的那些）都删除了。</li><li>元空间只有少量的指针指向Java堆。这包括：类的元数据中指向java/lang/Class实例的指针;数组类的元数据中，指向java/lang/Class集合的指针。</li><li>没有元数据压缩的开销</li><li>减少了根对象的扫描（不再扫描虚拟机里面的已加载类的字典以及其它的内部哈希表）减少了Full GC的时间</li><li>G1回收器中，并发标记阶段完成后可以进行类的卸载</li><li></li></ul></li></ul><h2><span id="四-总结">四 总结</span></h2><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/article/my_blog_begin/"/>
      <url>/article/my_blog_begin/</url>
      
        <content type="html"><![CDATA[<h2><span id="hexo">Hexo</span></h2><hr><p>Hexo被称为是最佳的静态博客程序之一，然而其繁琐的环境搭建、构建，发布过程，让很多人望之却步.转而使用了传统的WordPress等博客程序，抛开维护成本不说，本着折腾一切的心态<br>最终研究出了一套完善的自动部署方案。</p><h2><span id="如何实现优雅的发布">如何实现优雅的发布</span></h2><hr><p>就目前而言，Hexo发布的方式有以下几种：</p><ul><li>原始方式，即在本地搭建相关环境，编写md文件后，手动hexo g生成静态文件，然后通过hexo deploy发布到Github Pages；</li><li>利用Github + Webhook来实现自动发布</li><li>使用第三方的Hexo-Client、Hexo-Admin等程序<br>使用Travis CI持续部署Hexo。</li><li>使用Netlify进行优雅地持续部署。详见：<a href="https://www.netlify.com" target="_blank" rel="noopener">https://www.netlify.com</a></li></ul><h2><span id="我的部署方案">我的部署方案</span></h2><hr><p>我的部署方案主要是基于第三种的。</p><ul><li><p>简要流程</p><ol><li>使用Github登陆Netlify。</li><li>使用StaticGen一键初始化Hexo仓库。</li><li>将Hexo源码仓库Clone到本地，调整网站配置，编写文章。</li><li>本地无需Nodejs、NPM、Hexo环境，修改完成后Push到Github，Netlify检测到仓库变更后实现自动部署。</li></ol><p>在Netlify整个部署过程中, 你只需要提交代码, 其余的master部署预览(包括MR的预览), HTTPS证书, 静态资源的优化与CDN加速, 部署消息通知。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(7)</title>
      <link href="/article/java-gc1-gc/"/>
      <url>/article/java-gc1-gc/</url>
      
        <content type="html"><![CDATA[<h2><span id="g1-概要">G1 概要</span></h2><h3><span id="g1-的特点">G1 的特点</span></h3><h4><span id="garbage-first">Garbage First</span></h4><p>G1的设计原则是&quot;首先收集尽可能多的垃圾(Garbage First)&quot;。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</p><h4><span id="空间整理">空间整理</span></h4><p>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</p><h4><span id="动态扩展空间">动态扩展空间</span></h4><p>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</p><h4><span id="局部回收">局部回收</span></h4><p>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</p><h3><span id="g1-内存模型">G1 内存模型</span></h3><h4><span id="region-分区">Region (分区)</span></h4><p><img src="/article/java-gc1-gc/1556095002973java-gc1-gc_.png" alt></p><p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p><p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p><h4><span id="card-table">Card Table</span></h4><p>为了支持高频率的新生代的回收，虚拟机使用一种叫做卡表（Card Table）的数据结构，卡表作为一个比特位的集合，每一个比特位可以用来表示某一区域中的所有对象是否持有新生代对象的引用。</p><p>在每个Region内部又被分成了若干个大小为512 Byte卡片(Card Page)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p><p>基于卡表（Card Table）的设计，通常将堆空间划分为一系列2次幂大小的卡页（Card Page）。</p><p>首先，计算对象引用所在卡页的卡表索引号。将地址右移9位，相当于用地址除以512（2的9次方）。可以这么理解，假设卡表卡页的起始地址为0，那么卡表项0、1、2对应的卡页起始地址分别为0、512、1024（卡表项索引号乘以卡页512字节）。</p><p>其次，通过卡表索引号，设置对应卡标识为dirty。</p><p><img src="/article/java-gc1-gc/1556097761564java-gc1-gc_.png" alt></p><h4><span id="remember-set-rset">Remember Set (RSet)</span></h4><p>我们知道判断对象是否存活需要从GC ROOTS结点出发，从GC ROOTS结点可达的对象就是存活的。在YGC时，老年代中的对象是不回收的，也就意味着GC ROOTS里面应包含了老年代中的对象。但扫描整个老年代会很耗费时间，势必影响整个GC的性能！。所以在CMS中使用了Card Table的结构，里面记录了老年代对象到新生代引用。Card Table的结构是一个连续的byte[]数组，扫描Card Table的时间比扫描整个老年代的代价要小很多！</p><p>G1也参照了这个思路，不过采用了一种新的数据结构 Remembered Set 简称Rset。RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。每个Region都有一个对应的Rset。</p><p><img src="/article/java-gc1-gc/1556095318179java-gc1-gc_.png" alt></p><h4><span id="per-region-table">Per Region Table</span></h4><p>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常&quot;受欢迎&quot;，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p><ul><li>稀少：直接记录引用对象的卡片索引</li><li>细粒度：记录引用对象的分区索引</li><li>粗粒度：只记录引用情况，每个分区对应一个比特位</li></ul><p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p><h4><span id="humongous-region-大对象区间">Humongous Region (大对象区间)</span></h4><p>正因为无论是 Young Generation 还是 Old Generation，在 GC 的时候都会有 object 拷贝。Young Generation 一方面是将 object 从 Eden 拷贝到 Survivor ，另一方面是拷贝晋升的 object 到 Old 区。这种拷贝过程对特别大的 object 来说就很不经济。</p><p>G1 中 Region 大小最小是 1MB，最大是 32MB。具体多大会根据 Heap 大小做设置，它是尽力去保证整个 Heap 被划分为大约 2048 个 Region。比如如果 Heap 有 16G，算下来 16G / 2048 = 8MB 即一个 Region 大概是 8MB。当然 2048 个 Region 也不是绝对的，如果 Heap 特别大或者特别小，Region 总数是可以超过或小于 2048。Region 总数也能通过参数精确设置 <code>-XX:G1HeapRegionSize=n</code>。</p><p>回到 Humongous Object，G1 中内存占用超过当前单个 Region 50% 的 Object 就叫 Humongous Object，G1 对他们有单独的处理。</p><p>Humongous Object 分配时会根据这个 object 大小，在 available regions 中找足够放下这个 object 的连续的数个 region，专门分配给这个 Humongous object 使用。如果找不到这么个连续的 region，G1 会直接使用 fail-safe 的 FGC 来清理并 compact heap。</p><p>理解这里不先进行 YGC 或 OGC 的原因是 YGC 和 OGC 很多过程都是 concurrent 的，这个时候 Humongous Object 无法分配内存，无法让应用线程继续运行，必须执行完全的 STW 收集一次内存才行。</p><p>正因为无论是 Young Generation 还是 Old Generation，在 GC 的时候都会有 object 拷贝。Young Generation 一方面是将 object 从 Eden 拷贝到 Survivor ，另一方面是拷贝晋升的 object 到 Old 区。这种拷贝过程对特别大的 object 来说就很不经济。</p><p>G1 中 Region 大小最小是 1MB，最大是 32MB。具体多大会根据 Heap 大小做设置，它是尽力去保证整个 Heap 被划分为大约 2048 个 Region。比如如果 Heap 有 16G，算下来 16G / 2048 = 8MB 即一个 Region 大概是 8MB。当然 2048 个 Region 也不是绝对的，如果 Heap 特别大或者特别小，Region 总数是可以超过或小于 2048。Region 总数也能通过参数精确设置 -XX:G1HeapRegionSize=n。</p><p>回到 Humongous Object，G1 中内存占用超过当前单个 Region 50% 的 Object 就叫 Humongous Object，G1 对他们有单独的处理。</p><p>Humongous Object 分配时会根据这个 object 大小，在 available regions 中找足够放下这个 object 的连续的数个 region，专门分配给这个 Humongous object 使用。如果找不到这么个连续的 region，G1 会直接使用 fail-safe 的 FGC 来清理并 compact heap。</p><p>理解这里不先进行 YGC 或 OGC 的原因是 YGC 和 OGC 很多过程都是 concurrent 的，这个时候 Humongous Object 无法分配内存，无法让应用线程继续运行，必须执行完全的 STW 收集一次内存才行。</p><h2><span id="g1-回收过程">G1 回收过程</span></h2><h3><span id="g1-收集的四个过程">G1 收集的四个过程</span></h3><ol><li>年轻代收集</li><li>并发收集，和应用线程同时执行</li><li>混合式垃圾收集</li><li>必要时的 Full GC</li></ol><h4><span id="young-gc年轻代收集">Young GC（年轻代收集）</span></h4><p>年轻代是由Eden和Survivor两个区间组成的，那么当Eden区间无法在分配空间时，Young GC被触发了。GC需要把所有的存活对象从Eden区间移动到Survivor区间(拷贝算法),原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中,从而晋级到新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉，被放入空闲队列当中去</p><p>在每一次年轻代回收暂停期间，G1 GC计算当前年轻代大小需要扩展或者压缩的总量，例如增加或者删除空闲区间、统计RSet大小、当前最大可用年轻代、当前最小可用年轻代、设置停顿目标等。因此，我们可以认为这个过程在回收停顿结束后是一个重新调整年轻代的过程。可以通过<code>-XX:+PrintGCDetails</code>选项的运行来查看具体数据。</p><p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量<code>-XX:TargetSurvivorRatio</code>(默认50%)、最大任期阈值<code>-XX:MaxTenuringThreshold</code>(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p><h4><span id="concurrent-mark-start-并发收集阶段">concurrent-mark-start （并发收集阶段）</span></h4><p>这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p><ul><li><p>并发标记触发条件</p><ul><li>整个堆的使用率达到了阈值 （IHOP：<code>InitiatingHeapOccupancyPercent</code>).</li><li>晋升空间（old regions）达到阈值（<code>G1ReservePercent</code>）</li><li>大对象的分配</li></ul></li><li><p>并发标记的过程</p><ul><li><p>Initial Mark 初始标记</p><p>负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要STW。<br>事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p></li><li><p>Root Region Scanning 根区域扫描<br>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p></li><li><p>Concurrent Marking 并发标记<br>并发标记依赖于 <a href>STAB</a><br>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p></li><li><p>重新标记（remark eq final mark）</p><p>重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数<code>-XX:ParallelGCThread</code>可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p></li><li><p>清理阶段（clean up）</p><p>紧挨着重新标记阶段的清除(Clean)阶段也是STW的。清理阶段真正回收的内存很小，截止到这个阶段,G1垃圾收集器主要是标记处哪些老年代分区可以回收，将老年代按照它们的存活度（liveness）从小到大排列。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p><p>1、RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数<code>-XX:+PrintAdaptiveSizePolicy</code>可以开启打印启发式算法决策细节；</p><p>2、整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；</p><p>3、识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</p></li></ul></li></ul><p>经过global concurrent marking，collector就知道哪些Region有存活的对象。并将那些完全可回收的Region(没有存活对象)收集起来加入到可分配Region队列，实现对该部分内存的回收。对于有存活对象的Region，G1会根据统计模型找处收益最高、开销不超过用户指定的上限的若干Region进行对象回收。这些选中被回收的Region组成的集合就叫做collection set 简称Cset！</p><p>在MIXGC中的Cset是选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。</p><p>在YGC中的Cset是选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。</p><p>YGC与MIXGC都是采用多线程复制清除，整个过程会STW。 G1的低延迟原理在于其回收的区域变得精确并且范围变小了。</p><h4><span id="mixed-gc">Mixed GC</span></h4><ul><li>Mixed GC 何时触发<br>remark 阶段完毕后，G1 就完成了对整个 heap 的标记，能知道整个 heap 中有哪些 object 是 live 的。在接下来的几次 YGC 中，会从待收集的所有 Region 中依次选出 GC 效率最高的 Region 组成本次回收的 CSet，来执行 GC，也即 Mixed GC. “GC 效率最高” 一般是有两个指标，一个是 Region 内 live object 多少，live object 占空间最少的 Region，GC 效率越高。即 Garbage 越多的 Region，GC 效率越高。这也是 Garbage First 的由来。 下图是一个mixed gc 的时序图</li></ul><p><img src="/article/java-gc1-gc/1557030961130java-gc1-gc_.png" alt></p><h4><span id="full-gc">FULL GC</span></h4><p>转移失败的担保机制 Full GC</p><p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p><p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p><p>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区<br>从老年代分区转移存活对象时，无法找到可用的空闲分区<br>分配巨型对象时在老年代无法找到足够的连续分区<br>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p><h2><span id="参考">参考:</span></h2><p><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://zhuanlan.zhihu.com/p/52841787" target="_blank" rel="noopener">G1 收集器原理理解与分析</a></p><p>G1读书笔记<br>g1 的四个阶段</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(3)</title>
      <link href="/article/Java-garbage-collection-analysis-3/"/>
      <url>/article/Java-garbage-collection-analysis-3/</url>
      
        <content type="html"><![CDATA[<h2><span id="概诉">概诉</span></h2><p>上一篇介绍了GC的各种垃圾收集器的算法，本节详细讨论几个细节问题。</p><h2><span id="gc-roots详解">GC Roots详解</span></h2><p>GC ROOTs包含了那些对象</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中 JNI （即 native 方法）引用的对象。</li><li>分代回收算法中非当前GC年代的其他对象。</li></ol><h2><span id="如何识别垃圾对象">如何识别“垃圾对象”？</span></h2><h3><span id="为什么需要引用">为什么需要引用？</span></h3><p>如前所述：在最早的JVM实现里，使用“跟踪回收”算法从GC ROOTS出发，按照广度或者深度方式遍历所有与GC ROOTS可达的对象，针对那些GC不可达的垃圾对象进行回收。但随着Java的演进，针对最早这种比较简单的GC方式逐渐暴露出一些不能覆盖的情景，比如：某些场景下使用方希望在回收具体对象的同时还能辅助回收这个对象绑定的一些资源（比如socket、堆外内存等）、某些场景下希望使用的堆内缓存组件能尽量缓存更多的数据但又不会导致OOM。考虑到上述类似的使用场景，从JDK 1.2开始，JDK引入了<code>软引用（SoftReference）、弱引用（WeakReference）、幻象引用（PhantomReference）、Final引用（FinalReference</code>）四种新的引用来支持一些新的特性。</p><p>对象创建时，可以通过不同的引用来对对象进行封装，GC时，当真正的业务对象除了这个引用外没有其他GC ROOTS可达的时候，JVM会根据引用类型和GC类型（是否是Full GC）来对这个“真实对象”进行一些特殊处理，<br>比如：回收这个对象绑定的其他资源、比如根据GC类型来觉得是否本次要把对象进行回收等。</p><p><img src="https://coldwalker.com/images/gc_intro/1119937-20190130111221088-1473128563.png" alt="a5b1bd167692a29a29d2e09a75211e0c.png"></p><h3><span id="gc如何识别和处理引用">GC如何识别和处理引用？</span></h3><p>“真实对象”创建时，可以通过Reference来对“真实对象”进行封装引用，然后通过一些方法保证这个引用GC ROOTS可达（比如封装完“真实对象”后将这个引用加入到一个静态链表中），JVM垃圾回收器硬编码识别</p><ul><li>SoftReference，</li><li>WeakReference，</li><li>PhantomReference，</li><li>Final引用（FinalReference）</li></ul><p>这些具体的类，GC过程中，识别查找到引用对象没有被其他强引用使用的Reference，然后添加到Reference类的pending链表，这个pending链表由GC来维护，通过Reference类的一个静态的pending变量（链表头）和一个实例变量discovered（链表下一节点）来实现；Reference有一个高优先级的ReferenceHandler线程，这个线程不停的从pending链表中取出待处理的Reference进行处理：有的放到Reference各自的ReferenceQueue队列里供使用者进行处理（如：PhantomReference和WeakReference）、有的直接调用固定的处理方法进行清理（如：Cleaner）。</p><h3><span id="reference类">Reference类：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T referent; <span class="comment">// 引用所指向的真实对象</span></span><br><span class="line">    <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue; <span class="comment">//引用处理列表</span></span><br><span class="line">    <span class="comment">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">    *     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">    *   otherwise:   NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM ，指向pending链表下一个节点</span></span><br><span class="line"><span class="comment">    * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment">    * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment">    * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="keyword">null</span>;  <span class="comment">//静态的链表头</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">            <span class="comment">// so that we don't get into trouble later in the run loop if there's</span></span><br><span class="line">            <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">            ensureClassInitialized(InterruptedException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//死循环执行</span></span><br><span class="line">                tryHandlePending(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">        Reference&lt;Object&gt; r;</span><br><span class="line">        Cleaner c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span><br><span class="line">                    <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span><br><span class="line">                    c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                    <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                    <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// retry if waited</span></span><br><span class="line">                    <span class="keyword">return</span> waitForNotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">            <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">            <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">            <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span><br><span class="line">            <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fast path for cleaners</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.clean();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类加载完就起好最高优先级的ReferenceHandler</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">            tgn != <span class="keyword">null</span>;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">        Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">        <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">        * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceQueue可以由使用方通过Reference的构造方法指定传入，如果没有指定，从pending链表取出的Reference都enqueue到全局的一个ENQUEUED队列中。ReferenceQueue的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new reference-object queue.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceQueue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends S&gt; r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> Null&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> Null&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">            <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">            head = r;</span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="引用种类">引用种类</span></h3><h4><span id="强引用">强引用</span></h4><p>最常见的引用方式。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>上面的obj就是一个指向Object对象的强引用<br>强引用如果有到GC ROOTS的路径，那么这个引用指向的对象在GC时不能被回收。</p><blockquote><p>在实际使用中，除了强引用，可能还需要一些其他特殊类型的引用，比如有些缓存对象，是可以在内存不足时来回收的，这样通过丰富的引用类型，能让内存在实际使用时更灵活，整体业务稳定性更好。jdk 1.2后，对引用概念进行了扩充，增加了其他4种类型的引用，在java.lang.ref包下，分别为：<code>SoftReference、WeakReference、PhantomReference、FinalReference</code>。</p></blockquote><h4><span id="软引用softreference">软引用（SoftReference）</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; str = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><p>软引用是比强引用稍弱的一种引用，普通的GC并不会回收软引用，只有在即将OOM的时候（也就是最后一次Full GC）的时候才会回收软引用指向的对象。所以，软引用比较适合用来实现不是特别重要的缓存，比如guava cache就支持软引用类型的存储值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果只是普通增量GC，不回收软引用</span></span><br><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//否则，触发Full GC，但还不回收软引用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果还是内存不够时，会触发一次回收所有软引用的Full GC，再不行就OOM</span></span><br><span class="line">gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                    <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                    size             <span class="comment">/* size */</span>,</span><br><span class="line">                    is_tlab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                    number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="弱引用weakreference">弱引用（WeakReference）</span></h4><p>弱引用比软引用的引用级别更低一些，GC时，如果一个对象从GC ROOTS出发，只有弱引用指向没有其他（强引用或软引用）指向时，这个对象就会在本次GC被回收掉。</p><p>弱引用最常见的使用情景是WeakHashMap，WeakHashMap里面的Entry是一个弱引用，这个弱引用指向Map的Key，如果这个Key没有被其他”强引用“或者”软引用“引用时，GC会干掉这个Key对象，同时将这个Entry对象放入WeakHashMap的ReferenceQueue中等待被处理，当WeakHashMap的get、put等方法被调用时，会通过expungeStaleEntries方法把这个ReferenceQueue的Entry对象的value置空并调整Entry链表摘取当前Entry，这样下次GC时就能回收掉value的对象了。</p><blockquote><p>一般在需要控制内存使用但又想尽量用到更多内存的场景下使用。比如tomcat的ConcurrentCache就用到了WeakHashMap来作为分级缓存，可以在内存充足的情况下，缓存尽量多的数据，同时又不会导致OOM。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates new entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">        <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="幻象引用phantomreference">幻象引用（PhantomReference）</span></h4><p>幻象引用是比弱引用的级别更低的一种，和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。<br>PhantomReference的回收处理过程如下：</p><p>GC时，高优先级的ReferenceHandler线程将这个PhantomReference放到它自身的静态ReferenceQueue中，然后PhantomReference的实现子类一般会有一个线程在不断轮询这个ReferenceQueue，从queue中取出PhantomReference并调用它自己实现的清理方法来释放它所指向对象的占用的一些特定资源并把PhantomReference自身从ReferenceQueue中干掉，这样下次GC时这个幻象引用本身和它指向的对象也能够被GC掉。</p><p>实际场景中，一般幻象引用用于对象需要被清理时，除了指向的对象本身外，还需要额外释放这个对象占用的其他资源的场景。比如DB连接池使用PhantomReference来释放底层的socket资源，比如DirectByteBuffer使用PhantomReference来释放底层占用的堆外内存。</p><ul><li>举例：</li></ul><p>DirectByteBuffer使用PhantomReference管理堆外内存释放的过程如下：</p><ul><li>每个DirectByteBuffer在生成时会绑定一个Cleaner对象，这个Cleaner对象是一个PhantomReference</li><li>当JVM GC时发现那些除了Cleaner幻象引用外已没有其他引用的DirectByteBuffer时，就会把这些Cleaner对象放到Reference这个类的pending列表里.</li><li>Reference类维护了一条ReferenceHandler的高优先级线程，这条线程会不断去轮询待处理的pending列表，如果是Cleaner对象就调用这个对象的clean方法进行清理（<em>这里需要注意的是：Cleaner是一种特殊的PhantomReference，它实际的清理工作是由ReferenceHandler线程直接执行的，不需要自己再维护一个清理的线程</em>）</li><li>clean方法里其实是调用初始化Cleaner时绑定的Deallocator间接使用unsafe.freeMemory来进行堆外内存的释放和Bits里全局堆外内存使用量的更新。</li></ul><h4><span id="final引用phantomreference">Final引用（PhantomReference）</span></h4><p>FinalReference &amp; Finalizer</p><p>在java.lang.ref包下，除了上面四种引用，还有一个非公开的FinalReference引用以及它的一个子类Finalizer。实际上，FinalReference 代表的正是 Java 中的强引用，如这样的代码 :<br><code>Bean bean = new Bean();</code></p><p>在虚拟机的实现过程中，实际采用了 FinalReference 类对其进行引用。而 Finalizer，除了作为一个实现类外，更是在虚拟机中实现一个 FinalizerThread，以使虚拟机能够在所有的强引用被解除后实现内存清理。</p><ul><li><p>Finalizer的工作过程：<br>GC过程中，当一个强引用对象bean没有了引用被标记为可回收时，如果这个bean对象的类定义了finalize方法，那么这个对象被绑定到一个Finalizer引用上，这个Finalizer引用会被前面讲过的ReferenceHandler线程将引用自身加入到Finalizer静态的ReferenceQueue中，同时Finalizer对象自带的静态的优先级为8（比普通线程优先级高但比ReferenceHandler优先级低）的FinalizerThread线程会轮询这个ReferenceQueue中的Finalizer引用，然后调用它的runFinalizer方法，最终调到了绑定的那个bean对象的finalize方法，当finalize方法的逻辑都执行完后，这个bean对象才会在下次GC时被回收。</p></li><li><p>这里有几个需要注意的点：</p><ul><li><p>1. 在CPU资源比较紧张的情况下，由于FinalizerThread线程优先级较低，可能由于得不到时间片而导致finalize的方法执行延迟或者缓慢。最终可能导致bean对象真正占用的资源释放不确定性提高，另外也可能会导致由于bean对象无法回收导致Full GC甚至OOM。</p></li><li><p>2. 底层的bean对象至少需要2次GC才会被回收。第一次GC只是标记后将处理任务提交给FinalizerThread线程去执行，当FinalizerThread执行完finalize方法后才会在下次GC时回收bean对象，FinalizerThread执行期间可能经历多次GC。</p></li><li><p>3. 和PhantomReference不同，由于Finalizer引用最终的释放依赖对象的finalize方法的实现，在finalize里实际上可以访问到引用的对象本身，所以如果在finalize方法里让其他对象又引用了当前对象，这样会导致这个本应该被回收的对象复活。</p></li></ul></li></ul><p>高优先级的ReferenceHandler线程将Finalizer引用加入到Finalizer类的静态ReferenceQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FinalizerThread线程处理：<ul><li>1. 将当前Finalizer引用从ReferenceQueue里删除</li><li>2. 执行Finalizer引用的runFinalizer来触发bean对象的清除操作</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (running) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                    Finalizer f = (Finalizer)queue.remove();</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                        <span class="comment">// ignore and continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jla.invokeFinalize实际调用了bean对象的finalize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span><br><span class="line">            remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object finalizee = <span class="keyword">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span><br><span class="line"><span class="comment">                the chances of false retention with a conservative GC */</span></span><br><span class="line">                finalizee = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>finalize方法里将其他引用指向bean对象本身，导致bean对象复活</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Other.ref = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在PhantomReference实现中，由于get方法默认返回null，因此PhantomReference创建后就不能再访问它的referent，因此不存在死对象复活的问题。所以，尽量使用PhantomReference来替代原来Finalizer的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="gc过程是如何具体处理引用">GC过程是如何具体处理引用?</span></h2><p>GC时，各垃圾收集器都会在过程中，先找到当前回收代中那些”指向的referent除了当前引用外没有其他强引用使用了”的引用，然后对所有类型的Reference（soft、weak、phantom、final）进行进一步筛选和排除处理，最后，在GC的最后阶段，将待处理的Reference入队到Reference的pendingList等待ReferHandler线程来善后。</p><h3><span id="发现引用">发现引用</span></h3><ul><li><strong>“引用发现”这个过程的主要工作：_找出当前回收代中的可能需要被回收的这些引用。</strong><br>如ParNew垃圾回收器中的Ref»发现-标记»过程（parNewGeneration.cpp）：<br>先处理roots触发，引用到的对象都拷贝到to space，然后通过par_scan_state.evacuate_followers_closure().do_void()在to space里遍历全部年轻代存活对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_roots(_gen-&gt;level(),</span><br><span class="line">                         <span class="keyword">true</span>,  <span class="comment">// Process younger gens, if any,</span></span><br><span class="line">                                <span class="comment">// as strong roots.</span></span><br><span class="line">                         <span class="keyword">false</span>, <span class="comment">// no scope; this is parallel code</span></span><br><span class="line">                         GenCollectedHeap::SO_ScavengeCodeCache,</span><br><span class="line">                         GenCollectedHeap::StrongAndWeakRoots,</span><br><span class="line">                         &amp;par_scan_state.to_space_root_closure(),</span><br><span class="line">                         &amp;par_scan_state.older_gen_closure(),</span><br><span class="line">                         &amp;cld_scan_closure);</span><br><span class="line"></span><br><span class="line">  par_scan_state.end_strong_roots();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "evacuate followers".</span></span><br><span class="line">  par_scan_state.evacuate_followers_closure().do_void();</span><br></pre></td></tr></table></figure><ul><li>EvacuateFollowersClosureGeneral::do_void方法主要执行父类DefNewGeneration的oop_since_save_marks_iterate方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DefNewGeneration::                                         \</span><br><span class="line">    oop_since_save_marks_iterate##nv_suffix(OopClosureType* cl) &#123;   \</span><br><span class="line">    cl-&gt;set_generation(<span class="keyword">this</span>);                                     \</span><br><span class="line">    eden()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">    to()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);            \</span><br><span class="line">    from()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">    cl-&gt;reset_generation();                                       \</span><br><span class="line">    save_marks();                                                 \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>.space的oop_since_save_marks_iterate会调用每一个对象的oop_iterate</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">void</span> ContiguousSpace::                                                    \</span><br><span class="line">     oop_since_save_marks_iterate##nv_suffix(OopClosureType* blk) &#123;            \</span><br><span class="line">       HeapWord* t;                                                            \</span><br><span class="line">       HeapWord* p = saved_mark_word();                                        \</span><br><span class="line">       <span class="keyword">assert</span>(p != NULL, <span class="string">"expected saved mark"</span>);                               \</span><br><span class="line">                                                                               \</span><br><span class="line">       <span class="keyword">const</span> intx interval = PrefetchScanIntervalInBytes;                      \</span><br><span class="line">       <span class="keyword">do</span> &#123;                                                                    \</span><br><span class="line">         t = top();                                                            \</span><br><span class="line">         <span class="keyword">while</span> (p &lt; t) &#123;                                                       \</span><br><span class="line">           Prefetch::write(p, interval);                                       \</span><br><span class="line">           debug_only(HeapWord* prev = p);                                     \</span><br><span class="line">           oop m = oop(p);                                                     \</span><br><span class="line">           p += m-&gt;oop_iterate(blk);                                           \</span><br><span class="line">         &#125;                                                                     \</span><br><span class="line">       &#125; <span class="keyword">while</span> (t &lt; top());                                                    \</span><br><span class="line">                                                                               \</span><br><span class="line">       set_saved_mark_word(p);                                                 \</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">``` </span><br><span class="line">+ .oop是堆上对象的基类，它的oop\_iterate实际上会调到对应类的oop\_oop\_iterate##nv\_suffix方法，对于引用类型的对象，会走到InstanceRefKlass的op\_oop\_iterate##nv_suffix的方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    inline <span class="keyword">int</span> oopDesc::oop_iterate(OopClosureType* blk) &#123;                     \</span><br><span class="line">       SpecializationStats::record_call();                                      \</span><br><span class="line">       return klass()-&gt;oop_oop_iterate##nv_suffix(this, blk);               \</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>InstanceRefKlass的oop_oop_iterate##nv_suffix会调用InstanceRefKlass_SPECIALIZED_OOP_ITERATE这个语句块。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InstanceRefKlass::                                                          \</span><br><span class="line">    oop_oop_iterate##nv_suffix(oop obj, OopClosureType* closure) &#123;                  \</span><br><span class="line">    <span class="comment">/* Get size before changing pointers */</span>                                       \</span><br><span class="line">    SpecializationStats::record_iterate_call##nv_suffix(SpecializationStats::irk);\</span><br><span class="line">                                                                                    \</span><br><span class="line">    int size = InstanceKlass::oop_oop_iterate##nv_suffix(obj, closure);           \</span><br><span class="line">                                                                                    \</span><br><span class="line">    <span class="keyword">if</span> (UseCompressedOops) &#123;                                                      \</span><br><span class="line">        InstanceRefKlass_SPECIALIZED_OOP_ITERATE(narrowOop, nv_suffix, contains);   \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        InstanceRefKlass_SPECIALIZED_OOP_ITERATE(oop, nv_suffix, contains);         \</span><br><span class="line">    &#125;                                                                             \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在InstanceRefKlass_SPECIALIZED_OOP_ITERATE这个语句块中，这里会执行最终的»引用发现»discover_reference方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define InstanceRefKlass_SPECIALIZED_OOP_ITERATE(T, nv_suffix, contains)        \</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;is_gc_marked() &amp;&amp; (rp != NULL) &amp;&amp;                            \</span><br><span class="line">        rp-&gt;discover_reference(obj, reference_type())) &#123;                        \</span><br><span class="line">        <span class="keyword">return</span> size;                                                              \</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>discover_reference方法中，只收集那些还“存活的”、“reference是在当前回收代的”、“引用的真实对象还不确定是否被其他强引用的”的引用，会真正操作Reference的discovered字段来维护»发现»的引用链表。</p><p>PS：这里“发现”引用的阶段有两种情况需要考虑：</p><ul><li><p>1. 如果是引用指向的对象先被GC扫描到被强引用了，那么引用以及它所指向的对象都不会被“发现”（而是随后连同引用和指向对象都被copy到To区）。</p></li><li><p>2. 如果是引用本身先被GC扫描到，那么这里的“发现”阶段还是会把引用先加入到discovered链表中并将引用搬到To区（但不动引用指向的对象），等GC后，在后面“处理”引用的阶段会遍历这个discovered链表，找出那些除了自己外还有其他“强引用”指向referent对象的引用（这个referent对象由于有强引用已经被copy到To区了），然后从discovered链表删除自己并更新引用指向的对象地址，这样后续就不用再处理了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool ReferenceProcessor::discover_reference(oop obj, ReferenceType rt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//只收集那些“引用的真实对象暂时还不确定是否被其他强引用的”的引用</span></span><br><span class="line">    <span class="comment">// We only discover references whose referents are not (yet)</span></span><br><span class="line">      <span class="comment">// known to be strongly reachable.</span></span><br><span class="line">      <span class="keyword">if</span> (is_alive_non_header() != NULL) &#123;</span><br><span class="line">        verify_referent(obj);</span><br><span class="line">        <span class="keyword">if</span> (is_alive_non_header()-&gt;do_object_b(java_lang_ref_Reference::referent(obj))) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// referent is reachable</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将找到的各种引用加入到收集的引用列表</span></span><br><span class="line">    <span class="keyword">if</span> (_discovery_is_mt) &#123;</span><br><span class="line">        add_to_discovered_list_mt(*list, obj, discovered_addr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We do a raw store here: the field will be visited later when processing</span></span><br><span class="line">        <span class="comment">// the discovered references.</span></span><br><span class="line">        oop current_head = list-&gt;head();</span><br><span class="line">        <span class="comment">// The last ref must have its discovered field pointing to itself.</span></span><br><span class="line">        oop next_discovered = (current_head != NULL) ? current_head : obj;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">assert</span>(discovered == NULL, <span class="string">"control point invariant"</span>);</span><br><span class="line">        oop_store_raw(discovered_addr, next_discovered);</span><br><span class="line">        list-&gt;set_head(obj);</span><br><span class="line">        list-&gt;inc_length(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">          gclog_or_tty-&gt;print_cr(<span class="string">"Discovered reference ("</span> INTPTR_FORMAT <span class="string">": %s)"</span>,</span><br><span class="line">                                    (<span class="keyword">void</span> *)obj, obj-&gt;klass()-&gt;internal_name());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="处理引用">处理引用</span></h3><p>针对之前»发现»的引用，GC过程还会通过ReferenceProcessor的process_discovered_references来对所有类型的Reference（soft、weak、phantom、final）进行处理，处理步骤分成3个阶段，主要工作：根据GC策略来过滤软引用、过滤GC后那些referent还存活的引用 、根据不同引用类型决定是否马上解除对referent的引用（如弱引用、软引用和Cleaner在这里直接清理了对referent的引用，而幻象引用和Final引用这里先不清除，因为后面还需要用到）。</p><p>还是是ParNew回收器为例，GC时，在完成“引用发现”后，会通过process_discovered_references方法对引用进行处理，最后GC完成内存回收后再将Reference加入到pending列表中以便后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ParNewGeneration::collect(bool   full,</span><br><span class="line">                                bool   clear_all_soft_refs,</span><br><span class="line">                                size_t size,</span><br><span class="line">                                bool   is_tlab) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">//处理引用</span></span><br><span class="line">       <span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">        <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">        stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                                  &amp;evacuate_followers, &amp;task_executor,</span><br><span class="line">                                                  _gc_timer, gc_tracer.gc_id());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread_state_set.flush();</span><br><span class="line">            gch-&gt;set_par_threads(<span class="number">0</span>);  <span class="comment">// 0 ==&gt; non-parallel.</span></span><br><span class="line">            gch-&gt;save_marks();</span><br><span class="line">            stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                                      &amp;evacuate_followers, NULL,</span><br><span class="line">                                                      _gc_timer, gc_tracer.gc_id());</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">//通过将当前引用列表附到原来的pending链表以便ReferenceHandler线程的善后处理</span></span><br><span class="line">        rp-&gt;set_enqueuing_is_done(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">            <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">            rp-&gt;enqueue_discovered_references(&amp;task_executor);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rp-&gt;enqueue_discovered_references(NULL);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>GC完成时，处理”被发现“的引用的方法process_discovered_references主要实现在referenceProcessor.cpp的process_discovered_reflist中，包括三个阶段。</p><ul><li>1. 第一个阶段只处理软引用：因为软引用普通GC时是不能回收处理的，所以需要从discovered链表中移除所有不存活但是还不能被回收的软引用；</li><li>2. 第二阶段处理所有引用：从discoverd链表移除那些GC时»发现»阶段还不确定referent有没有被其他强引用但现在GC遍历完了确定»有被强引用»的引用。</li><li>3. 第三阶段处理剩下引用的referent：根据clear_referent的值决定是否将对referent的引用解除，方便下一次GC时回收referent。 （比如Final和Phantom是先不解除引用的，因为后续还要用；Weak是可以解除的）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ReferenceProcessor::process_discovered_reflist(</span><br><span class="line">       DiscoveredList               refs_lists[],</span><br><span class="line">       ReferencePolicy*             policy,</span><br><span class="line">       bool                         clear_referent,</span><br><span class="line">       BoolObjectClosure*           is_alive,</span><br><span class="line">       OopClosure*                  keep_alive,</span><br><span class="line">       VoidClosure*                 complete_gc,</span><br><span class="line">       AbstractRefProcTaskExecutor* task_executor)&#123;  </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// Phase 1 (soft refs only):</span></span><br><span class="line">        <span class="comment">// . Traverse the list and remove any SoftReferences whose</span></span><br><span class="line">        <span class="comment">//   referents are not alive, but that should be kept alive for</span></span><br><span class="line">        <span class="comment">//   policy reasons. Keep alive the transitive closure of all</span></span><br><span class="line">        <span class="comment">//   such referents.</span></span><br><span class="line">       <span class="keyword">if</span> (policy != NULL) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">           <span class="function">RefProcPhase1Task <span class="title">phase1</span><span class="params">(*<span class="keyword">this</span>, refs_lists, policy, <span class="keyword">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">           task_executor-&gt;execute(phase1);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">             process_phase1(refs_lists[i], policy,</span><br><span class="line">                            is_alive, keep_alive, complete_gc);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// policy == NULL</span></span><br><span class="line">         <span class="keyword">assert</span>(refs_lists != _discoveredSoftRefs,</span><br><span class="line">                <span class="string">"Policy must be specified for soft references."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// Phase 2:</span></span><br><span class="line">       <span class="comment">// . Traverse the list and remove any refs whose referents are alive.</span></span><br><span class="line">       <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">         <span class="function">RefProcPhase2Task <span class="title">phase2</span><span class="params">(*<span class="keyword">this</span>, refs_lists, !discovery_is_atomic()</span> <span class="comment">/*marks_oops_alive*/</span>)</span>;</span><br><span class="line">         task_executor-&gt;execute(phase2);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">           process_phase2(refs_lists[i], is_alive, keep_alive, complete_gc);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">          <span class="comment">// Phase 3:</span></span><br><span class="line">       <span class="comment">// . Traverse the list and process referents as appropriate.</span></span><br><span class="line">       <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">         <span class="function">RefProcPhase3Task <span class="title">phase3</span><span class="params">(*<span class="keyword">this</span>, refs_lists, clear_referent, <span class="keyword">true</span> <span class="comment">/*marks_oops_alive*/</span>)</span></span>;</span><br><span class="line">         task_executor-&gt;execute(phase3);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">           process_phase3(refs_lists[i], clear_referent,</span><br><span class="line">                          is_alive, keep_alive, complete_gc);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>处理完引用后，GC回收完内存后，在结束阶段会通过ReferenceProcessor的enqueue_discovered_references方法来将处理过的引用通过pending链表来进行入队列，这样ReferenceHandler才能把队列里的Reference对象从pending链表取出后写入到ReferenceQueue或者进行clean（Cleaner）操作。enqueue_discovered_references会根据是否使用压缩指针选择不同的enqueue_discovered_ref_helper()模板函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool ReferenceProcessor::enqueue_discovered_references(AbstractRefProcTaskExecutor* task_executor) &#123;</span><br><span class="line">   NOT_PRODUCT(verify_ok_to_handle_reflists());</span><br><span class="line">   <span class="keyword">if</span> (UseCompressedOops) &#123;</span><br><span class="line">     <span class="keyword">return</span> enqueue_discovered_ref_helper&lt;narrowOop&gt;(<span class="keyword">this</span>, task_executor);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> enqueue_discovered_ref_helper&lt;oop&gt;(<span class="keyword">this</span>, task_executor);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>pending_list_addr是Reference类的pending链表的首元素地址，enqueue_discovered_reflists过程会把符合的引用加入到这个链表，ReferenceHandler则从pending链表取出引用后放入ReferenceQueue或直接处理（Cleaner）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">enqueue_discovered_ref_helper</span><span class="params">(ReferenceProcessor* ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        AbstractRefProcTaskExecutor* task_executor)</span> </span>&#123;</span><br><span class="line">    T* pending_list_addr = (T*)java_lang_ref_Reference::pending_list_addr();</span><br><span class="line">    T old_pending_list_value = *pending_list_addr;</span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(pending_list_addr, oopDesc::load_decode_heap_oop(pending_list_addr));</span><br><span class="line">    ref-&gt;enqueue_discovered_reflists((HeapWord*)pending_list_addr, task_executor);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ref-&gt;disable_discovery();</span><br><span class="line">    <span class="keyword">return</span> old_pending_list_value != *pending_list_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多线程和单线程处理方式，由-XX:+ParallelRefProcEnabled控制，默认单线程，实际处理代码在enqueue_discovered_reflist中，主要逻辑如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ReferenceProcessor::enqueue_discovered_reflist(DiscoveredList&amp; refs_list,</span><br><span class="line">                                                         HeapWord* pending_list_addr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pending_list_uses_discovered_field()) &#123; <span class="comment">// New behavior</span></span><br><span class="line">    <span class="comment">// Walk down the list, self-looping the next field</span></span><br><span class="line">    <span class="comment">// so that the References are not considered active.</span></span><br><span class="line">    <span class="keyword">while</span> (obj != next_d) &#123;</span><br><span class="line">    obj = next_d;</span><br><span class="line">    <span class="keyword">assert</span>(obj-&gt;is_instanceRef(), <span class="string">"should be reference object"</span>);</span><br><span class="line">    next_d = java_lang_ref_Reference::discovered(obj);</span><br><span class="line">    <span class="keyword">if</span> (TraceReferenceGC &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print_cr(<span class="string">"        obj "</span> INTPTR_FORMAT <span class="string">"/next_d "</span> INTPTR_FORMAT,</span><br><span class="line">                                (<span class="keyword">void</span> *)obj, (<span class="keyword">void</span> *)next_d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(java_lang_ref_Reference::next(obj) == NULL,</span><br><span class="line">            <span class="string">"Reference not active; should not be discovered"</span>);</span><br><span class="line">    <span class="comment">// Self-loop next, so as to make Ref not active.</span></span><br><span class="line">    java_lang_ref_Reference::set_next_raw(obj, obj);</span><br><span class="line">    <span class="keyword">if</span> (next_d != obj) &#123;</span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(java_lang_ref_Reference::discovered_addr(obj), next_d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is the last object.</span></span><br><span class="line">        <span class="comment">// Swap refs_list into pending_list_addr and</span></span><br><span class="line">        <span class="comment">// set obj's discovered to what we read from pending_list_addr.</span></span><br><span class="line">        oop old = oopDesc::atomic_exchange_oop(refs_list.head(), pending_list_addr);</span><br><span class="line">        <span class="comment">// Need post-barrier on pending_list_addr. See enqueue_discovered_ref_helper() above.</span></span><br><span class="line">        java_lang_ref_Reference::set_discovered_raw(obj, old); <span class="comment">// old may be NULL</span></span><br><span class="line">        oopDesc::bs()-&gt;write_ref_field(java_lang_ref_Reference::discovered_addr(obj), old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://coldwalker.com/images/gc_intro/image-20180819185503111.png" alt="04dd63008299487f05620952f0bd5dff.png"></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(2)</title>
      <link href="/article/Java-garbage-collection-analysis-2/"/>
      <url>/article/Java-garbage-collection-analysis-2/</url>
      
        <content type="html"><![CDATA[<h3><span id="为什么需要gc">为什么需要GC？</span></h3><p>当程序创建对象、数组等引用类型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何引用变量引用时，这块内存就变成垃圾，等待垃圾回收机制进行回收。在C和C++中，垃圾的回收是由程序员来手动执行，虽然实时性比较好，但由于内存分配和回收代码繁琐，较容易出错，内存泄露问题比较常见。于是一些语言如Java、python、Go等，通过程序实现了自动化内存管理来解决垃圾回收问题，从而降低了在这些语言中内存使用的门槛。另外，由于GC有一定的滞后性，在一些实时性较高或者内存吃紧的（单片机开发）软件中，还是有不少采用人工回收垃圾的案例。</p><p><em>GC的一些特点：</em><br>1. GC只负责回收内存中的对象，不回收物理资源（如文件流、socket等）。<br>2. 程序无法精确控制GC的运行，GC只会在合适的时候进行。</p><p><em>PS：1其实也是由于2的GC的不确定性导致的，比如一个socket占用了某个端口，当使用完后GC并不会立刻回收这个socket，当需要再用到这个端口的socket时，就会报错。</em></p><h3><span id="gc实现的两种常见方式">GC实现的两种常见方式</span></h3><h4><span id="引用计数reference-counting">引用计数（Reference Counting）</span></h4><p>引用计数的实现比较简单，核心就是给每一个对象增加一个引用计数器，当另一个对象引用当前对象时就给当前对象的引用计数+1，当有对象不再引用当前对象时，就将引用计数-1，当前对象的引用计数变成0时，递归地将该对象引用的子对象的引用计数-1，并把当前对象使用的内存区域释放到空闲链表中。<br><img src="https://coldwalker.com/images/gc_intro/refcount.gif" alt="6efac91db597f7d968d53f68c99e32d4.gif"></p><p><em>引用计数算法的优点：</em></p><ol><li><p>引用归0时可立即回收垃圾，实时性好。</p></li><li><p>应用执行和垃圾回收“自然、依次”发生，GC开销分布在各次应用执行中，最大暂停时间消减（虽然GC次数增加）。</p></li><li><p>执行效率高，“事件触发”机制避免了整堆扫描标记的耗时。</p></li></ol><p><em>引用计数算法的缺点：</em></p><ol><li><p>循环引用问题无法解决，导致垃圾回收不彻底。</p></li><li><p>需要额外的存储空间来存放每一个对象的引用计数。</p></li><li><p>频繁的计数增减带来的高并发和本身需要的操作原子性的开销较大。</p></li><li><p>引用计数归0时，可能会级联删除大量对象，造成GC耗时不平稳。</p></li></ol><p><em>以上可知，基于引用计数的GC在实时性和执行效率方面有较大优势，类似 python、perl、swift等语言都使用引用计数算法来实现GC。但由于引用计数GC存在高并发时的性能较低等问题，因此，对性能要求较高的系统在实现时一般不会采用引用计数算法，而是使用和应用隔离的“跟踪回收”方式来实现GC。</em></p><h4><span id="跟踪回收">跟踪回收</span></h4><p>跟踪回收是一种独立于应用程序外的GC方式，定期运行来检查垃圾。跟踪回收通过被称为“GC ROOTS”的对象开始，不断通过深度或者广度遍历的方式来跟踪标记所有”可达的对象“，然后其他“GC ROOTS不可达对象”的未标记对象就被视为垃圾，会被统一回收。跟踪回收是目前被广泛使用的技术，如：Java、Go、.net等都使用跟踪的方式来进行垃圾回收。</p><p><em>跟踪回收的GC方式在具体的算法实现上，主要包括以下几种垃圾回收算法：</em></p><h5><span id="标记-清除mark-sweep">标记-清除（mark-sweep)</span></h5><p>标记清除算法主要分两个阶段：</p><ol><li><p>第一阶段，从GC ROOTS开始进行遍历，标记所有可直达或间接到达的对象为“使用中”。</p></li><li><p>第二阶段，扫描整体内存，对上一阶段标记的“使用中”的对象进行回收。<br><img src="https://coldwalker.com/images/gc_intro/A73996FF-5E0A-42D5-AE6B-73D25A1FD000.jpg" alt="3ded3d0575a91f8dfde31dc446642d56.jpeg"></p></li></ol><p>原始的标记-清除算法有不少问题，比如：</p><ol><li><p>GC期间，整个业务线程都会被挂起，暂停时间较长。</p></li><li><p>内存容易出现碎片，多次GC后可用连续内存问题明显。</p></li><li><p>GC的STW（Stop The World）的时间和heap大小正相关。</p></li></ol><p>因此在标记-清除算法的基础上，又产生了很多基于标记-清除的衍生算法来优化这些问题。比如：</p><h6><span id="并发的标记-清除算法">并发的标记-清除算法</span></h6><p>标记-清除过程实际上大部分时间Collector（GC线程）是可以和Mutator（应用程序线程）并发执行，大部分的工作都在并发阶段完成，真正需要暂停应用线程的阶段只需要来解决并发过程中变化的那部分对象即可，从而并不需要整个回收阶段都block住应用线程。比如CMS垃圾回收器除了Init-Mark阶段和Final-Mark阶段外，其他阶段都是可以并发执行的。</p><h6><span id="标记整理算法">标记–整理算法</span></h6><p>针对内存容易出现碎片的问题，衍生的Mark-Compact算法通过将sweep过程替换成compact过程，每次GC都会对内存进行一次移动整理。</p><p><em>标记-整理算法一般分3部分：</em></p><p>a. 先在mark阶段标记存活对象。<br>b. 遍历heap计算出存活对象将要移动到的新位置。<br>c. 将存活对象真正移动到新位置并更新存活对象中被指向移动对象的指针。<br><img src="https://coldwalker.com/images/gc_intro/CD89A12E-1A37-4269-B102-66ADB27404BB.jpg" alt="a0da00148bc1a9638f5ea4256f3c0b1e.jpeg"></p><p>由过程可知，标记-整理算法的compact阶段的耗时是和存活对象的多少成正比的。而且虽然解决了碎片的问题，但实际需要多次遍历heap、移动对象、更新指针，所以耗时上会比标记-清除算法要更长一些。所以默认情况下一些垃圾回收器CMS并不直接使用mark-compact算法，而是当由于存在碎片导致发生Full GC时才会使用基于mark-compact算法来进行内存整理。</p><blockquote><p>PS：当然从另一个方面看，mark-compact阶段由于解决了内存碎片问题，在应用线程申请内存的时候就可以用“指针碰撞”（pointer bumping）方式来快速完成内存分配，如果碎片较多，“指针碰撞”就会较大概率导致多次指针挪动，就不适合了，这样就只能使用分配速度更慢的类似freelist的方式来进行内存的管理和分配。</p></blockquote><h5><span id="复制-收集copying-gc">复制-收集（Copying GC)</span></h5><p>由于标记-清除算法存在碎片化的问题，标记-整理算法又由于需要多次遍历heap效率较低，因此“复制-收集”算法采用了一个空间换时间的方式来解决上面的问题。“复制-收集”算法的工作过程如下：</p><ol><li><p>将可用内存分成大小相等的两块，from space和 to space。</p></li><li><p>同一时刻只有from space会被使用。</p></li><li><p>GC时，将from space内存活的对象拷贝到to space</p></li><li><p>拷贝完成后，from space和to space交换身份<br><img src="https://coldwalker.com/images/gc_intro/E583CCB7-47DF-4CE4-8945-8AC2E8135706.jpg" alt="1290c3eb4092bd52de293fbe1be152cb.jpeg"></p></li></ol><blockquote><p>由“复制-收集”算法的实现可知，虽然这种算法比较简单高效，而且没有碎片问题。但一个比较明显的代价就是：应用程序实际可用的内存会被减半。另外，“复制-收集”算法很大一部分工作在于将存活对象移动到to space，因此它的时间开销和存活对象的数量成正比。</p></blockquote><p><em>上面介绍了主流几种“跟踪回收”类GC的具体实现算法，每一种算法都有其擅长和不足的地方，因此在实际的GC算法选择中，会根据不同的场景和特性选择不同的算法实现，从而将每种算法“扬长避短”。后面我会再继续分析现代化的GC如何进一步优化这些算法过程。</em></p><hr><h4><span id="标记-压缩-mark-compact">标记-压缩 （Mark-Compact）</span></h4><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。<br><img src="/article/Java-garbage-collection-analysis-2/1562814680550Java-garbage-collection-analysis-2_.png" alt></p><h3><span id="垃圾回收器">垃圾回收器</span></h3><p>GC算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。新生代垃圾收集器有Serial、ParNew、Parallel Scavenge、G1，属于老年代的垃圾收集器有CMS、Serial Old、Parallel Old和G1。其中的G1是一种既可以对新生代对象也可以对老年代对象进行回收的垃圾收集器。大部分垃圾回收器之间能相互配合来发挥各自的优势。</p><p><img src="https://coldwalker.com/images/gc_intro/6073827-904b301be72b9f5a.jpg.png" alt="85a94c88d8d3662165484268f0449723.png"></p><h6><span id="serial收集器">Serial收集器</span></h6><p>Serial收集器是最古老、最基本的一种垃圾回收器，采用单线程来进行垃圾回收。新生代回收采用复制算法，回收的整个过程会暂停业务线程（STW）。</p><blockquote><p><em>Serial收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：简单高效，拥有很高的单线程收集效率<br>应用：Client模式下的默认新生代收集器<br>参数控制：-XX:+UseSerialGC</p></blockquote><p><img src="https://coldwalker.com/images/gc_intro/6073827-42feae7608310929.png" alt="56c88d3322821a6d6af5909213e888a5.png"></p><h6><span id="parnew收集器">ParNew收集器</span></h6><p>ParNew收集器也是一个新生代垃圾回收器，可以看成是Serial收集器的多线程版本，也是采用复制算法来进行收集，回收整个过程也是暂停业务线程（STW）的，但由于是多线程并行执行的，所以在多CPU机器上一般会比Serial收集器快很多。</p><blockquote><p><em>ParNew收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：在CPU多的情况下，拥有比Serial更好的效果。单CPU环境下Serial效果更好<br>应用：许多运行在Server模式下的虚拟机中首选的新生代收集器<br>参数控制：<br>-XX:+UseParNewGC<br>-XX:ParallelGCThreads (限制线程数量)</p></blockquote><p><img src="https://coldwalker.com/images/gc_intro/img_97ff89bcbbc18cd50ba5287850435f43.png" alt="97ff89bcbbc18cd50ba5287850435f43.png"></p><h6><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h6><p>和ParNew收集器类似，Parallel Scavenge收集器也是一个新生代垃圾回收器，但和ParNew收集器不同的是Parallel Scavenge收集器更多关注的是可控制的吞吐量，支持自适应调节策略。</p><blockquote><p>吞吐量 = 运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)</p></blockquote><p>Parallel Scavenge收集器提供几个参数控制垃圾回收的执行：</p><p>-XX:MaxGCPauseMillis<br>最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。</p><p>-XX:GCTimeRatio<br>垃圾回收时间与总时间占比（默认是99%）。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。</p><p>-XX:UseAdaptiveSizePolicy<br>开启动态自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整上面两个参数以提供最合适的停顿时间或者最大吞吐量。</p><blockquote><p><em>Parallel Scavenge收集器的特性总结：</em><br>收集过程：暂停所有线程<br>算法：复制算法<br>优点：在CPU多的情况下，拥有比Serial更好的效果；对暂停时间和吞吐量能精细化控制。<br>应用：指定使用<br>参数控制：-XX:+UseParallelGC</p></blockquote><h6><span id="serial-old收集器">Serial Old收集器</span></h6><p>老年代的收集器，与上面的Serial一样是单线程回收，不同的是算法用的是标记-整理（Mark-Compact），整个过程和Serial收集器一样都会暂停业务线程。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br><img src="https://coldwalker.com/images/gc_intro/serial-old.png" alt="0207d0a7741701cf070520c4f97f065e.png"></p><h6><span id="parallel-old收集器">Parallel Old收集器</span></h6><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，JDK 1.6开始推出的，它使用多线程和“标记-整理”算法进行垃圾回收。通常与Parallel Scavenge收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。<br><img src="https://coldwalker.com/images/gc_intro/parallel-old.png" alt="754b629778258dd09ede56a2a9f304b2.png"></p><h6><span id="cms收集器">CMS收集器</span></h6><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的多线程并发收集器，基于“标记-清除”算法实现。CMS垃圾回收器将垃圾回收分成多个阶段，某些阶段可以和业务线程并发执行，这些并发阶段主要来做一些准备工作，这些准备工作能缩小最终的暂停阶段（Init-Mark和Remark）的时间，而且在暂停业务线程的两个阶段也由于多线程并行暂停时间控制也较好，是目前对用户响应时间敏感的且堆大小适中（太大、太小都不好）的应用广泛采用的年老代垃圾回收器。默认配合ParNew回收器作为新生代垃圾回收器。</p><blockquote><p><em>CMS收集器的7个阶段：</em><br>初始标记（CMS initial mark）<br>并发标记（CMS concurrent mark）<br>并发预清理（CMS concurrent-preclean）<br>并发可取消的预清理 （CMS concurrent-abortable-preclean）<br>重新标记（CMS remark）<br>并发清除（CMS concurrent sweep）<br>并发重置（CMS concurrent-reset）</p></blockquote><p><img src="/article/Java-garbage-collection-analysis-2/1552636717386Java-garbage-collection-analysis-2_.png" alt></p><p><em>PS：这个盗的图稍微有点问题，从jdk 1.8开始，initial mark阶段也是多线程并行执行的，可以通过-XX:+CMSParallelInitialMarkEnabled参数控制。</em></p><p><strong>CMS收集器的特性总结：</strong></p><ul><li><p>收集过程：部分阶段和业务线程并发执行，部分阶段暂停所有业务线程</p></li><li><p>算法：标记-清除算法</p></li><li><p>优点：并发收集、低停顿</p></li><li><p>缺点：清除算法会产生空间碎片、并发阶段会降低吞吐量、无法即时处理并发阶段产生的“浮动垃圾”</p></li><li><p>应用：指定使用</p></li><li><p>参数控制：</p><blockquote><p>-XX:+UseConcMarkSweepGC（是否采用CMS回收器）<br>-XX:+UseCMSInitiatingOccupancyOnly（JVM是否基于运行时收集的数据来启动CMS垃圾收集周期还是只根据初始设置来启动）<br>-XX:CMSInitiatingOccupancyFraction=80 （old区在使用了n%的后开始启动CMS backgroud GC）<br>-XX:ConcGCThreads=4 （并发CMS阶段采用多线程时使用的线程数）<br>-XX:+CMSConcurrentMTEnabled （并发阶段是否采用多线程）<br>-XX:+CMSParallelInitialMarkEnabled （初始标记阶段是否采用多线程并行执行）<br>-XX:+CMSParallelRemarkEnabled （重新标记阶段是否采用多线程并行执行）<br>-XX:+UseCMSCompactAtFullCollection （是否允许Full GC时采用整理算法）<br>-XX:CMSFullGCsBeforeCompaction=0 （采用整理算法前需要Full GC次数达到一定阈值）<br>-XX:+CMSClassUnloadingEnabled （GC过程也对永久代进行垃圾回收）<br>-XX:ExplicitGCInvokesConcurrent （允许显示的系统GC调用）<br>-XX:+CMSScavengeBeforeRemark （CMS重新标记阶段之前是否尝试对年轻代进行一次回收，能有效降低remark的时间）<br>-XX:+CMSIncrementalMode （增量模式，基本不开启，cpu资源少时可尝试）<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses （当有系统GC调用时，永久代也被包括进CMS垃圾回收的范围内）</p></blockquote></li></ul><h6><span id="g1收集器">G1收集器</span></h6><p>G1（Garbage First）收集器在JDK 1.7版本正式启用，在JDK 9中，G1被提议设置为默认垃圾收集器。应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：</p><ul><li><p>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</p></li><li><p>G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p></li></ul><p>与前面介绍回收器只能工作在年轻代或者年老代不同的是，G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p><img src="https://coldwalker.com/images/gc_intro/2184951-715388c6f6799bd9.png" alt="ba1807ea0d2b5304a7ad7ba2eb73f1f1.png"></p><blockquote><p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p></blockquote><p>G1收集器有三种GC模式：</p><ul><li><p>Young GC：</p><p>发生在年轻代的Region，所有eden类型的Region被分配完时，触发Young GC，将存活对象从eden的Region拷贝到survior类型的Region或者晋升到old Region，然后根据历史统计信息和用户定义的暂停时间来动态调整eden Region和survivor Region的个数，从而尽量让下一次GC的回收时间满足用户期望。和ParNew一样YGC采用的“复制-收集”算法。</p></li><li><p>Mixed GC：</p><p>STW阶段，类似CMS一样当old类型的Region占用达到一定阈值的时候，G1会触发一次全局“标记”动作，统计得出收集收益高的老年代Region。“标记”工作完成后，在每次YGC之后或者再次发生Mixed GC前，JVM会检查整个堆的垃圾占比是否达到G1HeapWastePercent的阈值，如果达到了，下次就会触发一次Mixed GC（<em>一次标记后可能会分多次进行Mixed GC</em>）。</p><p>Mixed GC并不仅仅是一次老年代GC，不仅进行正常的YGC回收整个young区，同时也会选择部分old Region也进行回收，和YGC一样，Mixed GC也是采用的“复制-收集”算法作为清除策略，因此整个G1垃圾回收不会存在和CMS一样的内存碎片问题。Mixed GC步骤包括 “标记”和“回收”两部分。</p></li><li><p>Full gc：</p><p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。</p></li></ul><p>其中YGC和ParNew等回收器的过程类似，比较简单，采用的是»复制-收集»算法，Mixed GC部分过程和CMS也比较相似，略有不同，Mixed GC分为»标记»和»回收»两大阶段。</p><p>Mixed GC的“标记”过程如下：</p><ol><li><p><strong>initial mark（初始标记）</strong>：会暂停所有线程，标记出所有可以直接从GC roots可以到达的对象，这是在Young GC的暂停收集阶段顺带进行的。因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p></li><li><p><strong>concurrent-root-region-scan（扫描根引用区）</strong>：找出所有的GC Roots的Region, 然后从这些Region开始标记可到达的对象，是一个并发阶段。</p></li><li><p><strong>concurrent marking（并发标记</strong>）：和CMS的并发标记阶段类似，这个阶段G1递归寻找整个堆的存活对象，是和业务线程并发执行的。</p></li><li><p><strong>remark（最终标记）</strong>：STW的阶段，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p></li><li><p><strong>clean up（清理阶段</strong>）：marking的最后一个阶段，G1统计各个Region的活跃性，完全没有存活对象的Region直接放入空闲可用Region列表中，然后会找出mixed GC的Region候选列表。</p></li></ol><p>Mixed GC的“回收”过程如下：</p><ol><li><p>选择所有young regions进行年轻代回收年轻代回收。</p></li><li><p>选取标记阶段之前标记出来的老年代的垃圾最多的部分区块，结合用户“期望”的GC Pause耗时相关，选取收益最大的部分Region进行回收，整个老年代标记完后可能会分多次Mixed GC执行，直到标记后的垃圾分区占比低于“堆废物占比”，之后再恢复到常规的年轻代垃圾收集，然后当堆的使用满足“触发标记周期阈值”会最终再次启动并发周期，进行下一轮循环。</p></li></ol><p><strong>G1常用参数</strong></p><ul><li><p>-XX:G1HeapRegionSize=n</p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p></li><li><p>-XX:MaxGCPauseMillis=200</p><p>为所需的最长暂停时间设置目标值。默认值是 200 毫秒。指定的值不适用于您的堆大小。</p></li><li><p>-XX:G1NewSizePercent=5</p><p>设置要用作年轻代大小最小值的堆百分比。默认值是 Java 堆的 5%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了</p></li><li><p>-XX:DefaultMinNewGenPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1MaxNewSizePercent=60</p><p>设置要用作年轻代大小最大值的堆大小百分比。默认值是 Java 堆的 60%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了 -XX:DefaultMaxNewGenPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:ParallelGCThreads=n</p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p></li><li><p>-XX:ConcGCThreads=n</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p></li><li><p>-XX:InitiatingHeapOccupancyPercent=45</p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p></li><li><p>-XX:G1MixedGCLiveThresholdPercent=65</p><p>为混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%。这是一个实验性的标志。有关示例，请参见“如何解锁实验性虚拟机标志”。此设置取代了</p></li><li><p>-XX:G1OldCSetRegionLiveThresholdPercent 设置。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1HeapWastePercent=10</p><p>设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，Java HotSpot VM 不会启动混合垃圾回收周期。默认值是 10%。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1MixedGCCountTarget=8</p><p>设置标记周期完成后，对存活数据上限为 G1MixedGCLIveThresholdPercent 的旧区域执行混合垃圾回收的目标次数。默认值是 8 次混合垃圾回收。混合回收的目标是要控制在此目标次数以内。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1OldCSetRegionThresholdPercent=10</p><p>设置混合垃圾回收期间要回收的最大旧区域数。默认值是 Java 堆的 10%。Java HotSpot VM build 23 中没有此设置。</p></li><li><p>-XX:G1ReservePercent=10</p><p>设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%。增加或减少百分比时，请确保对总的 Java 堆调整相同的量。Java HotSpot VM build 23 中没有此设置。</p></li></ul><hr><p><em>参考：</em><br><a href="http://120.52.51.16/www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf" target="_blank" rel="noopener">垃圾回收统一理论</a><br><a href="http://www.math.grin.edu/~rebelsky/Courses/CS302/99S/Presentations/GC/" target="_blank" rel="noopener">Introduction to Garbage Collection</a><br><a href="https://hllvm-group.iteye.com/group/topic/38223" target="_blank" rel="noopener">R大：并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a><br><a href="https://hllvm-group.iteye.com/group/topic/39402" target="_blank" rel="noopener">R大：请教Weak Reference及其在HotSpot GC中的行为</a><br><a href="https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html" target="_blank" rel="noopener">垃圾优先型垃圾回收器调优</a><br><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All" target="_blank" rel="noopener">G1: One Garbage Collector To Rule Them All</a><br><a href="http://imushan.com/2018/08/19/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reference/" target="_blank" rel="noopener">JDK源码阅读-Reference</a><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析(2)-GC方式介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收详解(1)</title>
      <link href="/article/Java_garbage_collection_analysis/"/>
      <url>/article/Java_garbage_collection_analysis/</url>
      
        <content type="html"><![CDATA[<h3><span id="java虚拟机内存管理">Java虚拟机内存管理</span></h3><p>Java虚拟机把内存分为几个不同的数据区，如下：</p><p><img src="/article/Java_garbage_collection_analysis/1.png" alt></p><h4><span id="java栈">Java栈</span></h4><p>JVM规范要求：每个Java线程拥有自己私有独享的JVM栈，JVM栈随着线程启动产生，线程结束而消亡。栈区内存由编译器自动分配释放，线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），栈以帧为单位保存线程的状态，栈帧负责存储局部变量变量表、操作数栈、动态链接和方法返回地址等信息。</p><h5><span id="栈帧">栈帧</span></h5><ul><li><p>栈帧的概念</p><blockquote><p>用来存储数据和部分过程结果的数据结构，也用来处理动态连接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束。栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表(局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。</p></blockquote></li><li><p>拟机把内存分为几个不同的数据区，如下：</p><p><img src="/article/Java_garbage_collection_analysis/2.png" alt></p></li></ul><h6><span id="1局部变量表">1.局部变量表</span></h6><p>局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。</p><p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)<br>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了。</p><p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储。</p><h6><span id="2-操作数栈">2. 操作数栈</span></h6><p>操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p><p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p><p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p><h6><span id="3动态连接">3.动态连接</span></h6><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。</p><p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。</p><p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p><h6><span id="4方法返回">4.方法返回</span></h6><p>当一个方法开始执行时，可能有两种方式退出该方法：</p><ul><li><p>正常完成出口</p></li><li><p>异常完成出口</p></li></ul><p>正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</p><p>异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p><p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出。<br>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。</p><p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。<br>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p><h5><span id="jvm栈的限制">JVM栈的限制</span></h5><p>虽然JVM栈拥有存取速度快，无并发等优势，但它更多的是一种运行时的单位，代表的是程序处理的逻辑。但也存在一些缺陷。<br>1. 由于JVM栈的压栈入栈操作是LIFO（Last-In-First-Out）的，导致的一个问题是：限制了某一个方法的栈帧的生命周期不能超过其调用者。这样对于多线程共享的变量无法在栈中实现。<br>2. 另外的一个问题是：栈帧中的数据大小在编译期必须确定，对于需要大小动态变化的对象无法很好支持。因此JVM栈中主要存放一些大小确定的基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。</p><p><em>因此需要新的内存管理策略-堆管理。</em></p><h4><span id="java堆">Java堆</span></h4><p>Java堆是被所有线程共享的一块内存区域，负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放，在Java中，堆的内存由JVM来自动管理。<br><em>一个典型的java对象的创建过程和在堆中分配过程如下：</em><br><img src="/article/Java_garbage_collection_analysis/1552013740412Java_garbage_collection_analysis_.png" alt></p><h3><span id="堆内存分配方式">堆内存分配方式</span></h3><h4><span id="堆内存">堆内存</span></h4><p>堆内存分配方式分为“指针碰撞”与“空闲列表”两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h5><span id="指针碰撞bump-the-pointer">指针碰撞（Bump the Pointer）</span></h5><p>如果堆内存是完全工整的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。比如ParNew、Serial、G1这种带整理的垃圾回收器，由它们负责回收的区域就采用“指针碰撞”方式来进行内存分配。</p><p><img src="/article/Java_garbage_collection_analysis/1552014318198Java_garbage_collection_analysis_.png" alt></p><h5><span id="空闲列表free-list">空闲列表（free list)</span></h5><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。像CMS垃圾回收器回收后并不对内存进行整理，因此老年代会存在较多的碎片，这样当需要在老年代进行内存分配是，采用的是“空闲列表”的方式。</p><p><img src="/article/Java_garbage_collection_analysis/1552014402454Java_garbage_collection_analysis_.png" alt></p><h4><span id="堆内存分配并发问题">堆内存分配并发问题</span></h4><p>由于堆内存是多线程共享的，因此不管哪种堆分配方式，都不可避免的存在并发问题。JVM主要采用两种方案来解决并发问题：</p><h5><span id="同步处理">同步处理</span></h5><p>JVM采用CAS（Compare and Swap）乐观锁 + 重试机制 来保证多线程更新free list的原子性。</p><h5><span id="tlabthread-local-allocation-buffer">TLAB（Thread Local Allocation Buffer）</span></h5><p>JVM运行中，内存分配是一个比较频繁的动作，同步处理带来的失败重试会对分配性能有较大影响，因此，从java 1.6开始引入了TLAB技术，可以通过-XX:+/-UseTLAB来开启或者关闭（默认是开启的）。TLAB线程的一块私有内存，在线程初始化时，从堆中申请一块指定大小的内存。当前线程需要申请内存时，先从自己的TLAB中分配，容量不够时再通过同步处理从Eden区申请。这样从TLAB中分配时没有并发问题，能大幅提升分配效率。</p><h5><span id="tlab上分配过程">TLAB上分配过程</span></h5><p>TLAB的管理是依靠三个指针：start、end、top。start与end标记了Eden中被该TLAB管理的区域，该区域不会被其他线程分配内存所使用，top是分配指针，开始时指向start的位置，随着内存分配的进行，慢慢向end靠近，当撞上end时触发TLAB refill。每次</p><p>内存中Eden的结构大体为：<br><img src="/article/Java_garbage_collection_analysis/1552014552034Java_garbage_collection_analysis_.png" alt><br>TLAB中分配规则（开启UseTLAB情况下）：</p><ol><li><p>TLAB剩余空间大于待分配对象大小，直接在TLAB上分配返回。</p></li><li><p>如果TLAB剩余空间放不下对象，同时TLAB剩余空间大小 大于允许的浪费阈值（refill_waste），那么本次放弃在TLAB上分配，直接在eden区进行慢分配，TLAB剩余空间留着下次继续使用。</p></li><li><p>如果TLAB剩余空间放不下对象，同时TLAB剩余空间大小 小于允许的浪费阈值，那么进入到“慢分配”过程：<br>a. 丢弃当前TLAB。<br>b. 从eden区裸空间重新分配一个新TLAB，然后对象再在新TLAB上分配。（这里从eden区新申请TLAB时，如果eden区空间不够，会触发YGC。）</p></li></ol><p><img src="/article/Java_garbage_collection_analysis/1552014605838Java_garbage_collection_analysis_.png" alt></p><p><em>几点需要注意的地方：</em></p><ol><li><p>开启TLAB情况下，TLAB占用eden区空间比较小，默认只有Eden空间的1%，可以通过 _-XX:TLABWasteTargetPercent_来调整。</p></li><li><p>默认情况下，TLAB大小和refill_waste阈值都是由JVM在运行时根据“历史统计信息”动态计算出来的，比如一个线程内存分配申请很频繁，可能该线程的TLAB就会更大。如果不想让系统自动调整，可以通过JVM参数来控制：</p><ul><li><p>-XX:-ResizeTLAB （禁用TLAB size的动态调整策略）</p></li><li><p>-XX:TLABSize （指定固定的TLAB size）</p></li><li><p>TLABRefillWasteFraction （可浪费阈值，默认是64：可浪费1/64的TLAB空间)</p></li></ul></li></ol><h3><span id="栈上分配">栈上分配</span></h3><p>以上可知，一般情况下JVM中对象都是在堆中进行内存分配，但是在堆中分配内存虽然有TLAB类似的技术能降低同步带来的开销，但还是存在较多在TLAB上分配不了的情况，另外，堆中分配的对象在生命周期结束后需要专门的垃圾回收器来清理，和栈中内存“方法退出即可销毁”的分配回收相比效率较低。</p><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。为提升第二阶段的执行速度，引入了JIT技术（Just-in-time Compilation），JIT其中主要的工作包括：</p><ul><li><p>“热点代码检测”；</p></li><li><p>热点代码编译优化（逃逸分析、锁消除、锁膨胀、方法内联、空值检查消除等）；</p></li><li><p>缓存热点代码编译后的机器指令；</p></li></ul><p><em>其中编译优化中采用的一种重要技术“逃逸分析”就是优化部分堆上分配为“栈上分配”的基础优化。</em></p><h4><span id="逃逸分析">逃逸分析</span></h4><p>逃逸分析(Escape Analysis)是一种代码分析，通过动态分析对象的作用域，可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸。</p><ul><li><p>方法逃逸 方法中定义的对象被外部方法引用（如：作为调用参数或者返回值被其他方法引用到）；</p></li><li><p>线程逃逸 对象可以被其他线程访问到（如：实例变量、类变量等）</p></li></ul><p>通过 -XX:+DoEscapeAnalysis 参数来控制“逃逸分析”是否开启，jdk 1.8下默认开启。</p><p><em>对于“无法逃逸”的对象，JIT编译器可以对代码进行优化，主要有以下几种优化方式：</em></p><h5><span id="同步消除">同步消除</span></h5><p>线程同步的消耗较大，通过“逃逸分析”，如果确定一个对象不会被其他线程访问到，那对这个对象的读写就不会存在并发问题，因此可以清除该对象的同步锁。</p><p><em>如下示例：该对象的同步锁在编译优化阶段去掉了，提升执行性能。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        System.out.println(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>通过 -XX:+EliminateLocks 参数来控制“同步消除”是否开启，jdk 1.8下默认开启。</em></p><h5><span id="标量替换">标量替换</span></h5><p>JIT经过“逃逸分析”发现一个对象只在方法内部使用不会被外界访问时，会在编译优化过程中把这个对象的成员变量拆解成若干个原始数据类型的标量来进行替代，这个过程就是“标量替换”。通过这种方式就能间接实现堆上对象不用在堆上分配而是通过替代的标量在栈上分配了。</p><p><em>如下示例：经过标量替换后，User对象被替换成两个标量了，从而避免在堆上进行分配。</em></p><pre><code class="language-java">    public void sayHi() {        User user = new User(1, 14100L);        System.out.println(&quot;Say Hi to:&quot; + user.uid + &quot;,&quot; + user.staffNum);    }    class User {        private int uid;        private long staffNum;    }        public void sayHi() {        int uid = 1;        long staffNum = 14100L;        System.out.println(&quot;Say Hi to:&quot; + uid + &quot;,&quot; + staffNum);    }</code></pre><p><em>通过 -XX:+EliminateAllocations 参数来控制“标量替换”是否开启，jdk 1.8下默认开启。</em></p><h5><span id="栈上分配">栈上分配</span></h5><p>如果确定一个对象不会逃逸出方法之外，那么让对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧的出栈而销毁。目前JVM没有实现真正的“栈上分配”，而是通过“标量替换”来间接实现的。</p><h3><span id="总结">总结</span></h3><p>由以上整理可知，虚拟机对象分配流程大概如下：首先如果开启栈上分配，JVM会先进行栈上分配，如果没有开启栈上分配或则不符合条件的则会进行TLAB分配，如果TLAB分配不成功，再尝试在eden区分配，如果对象满足了直接进入老年代的条件，那就直接分配在老年代。在eden区和老年代分配主要通过“指针碰撞”和“空闲列表”两种方式实现，通过CAS解决堆上“非TLAB方式分配”的并发问题。</p><p><img src="/article/Java_garbage_collection_analysis/1552015190523Java_garbage_collection_analysis_.png" alt></p><hr><p><em>参考:</em><br><a href="https://coldwalker.com/2019/02/gc_object_alloc_process/" target="_blank" rel="noopener">Java垃圾回收浅析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析系列（1）</title>
      <link href="/article/java-hash-map/"/>
      <url>/article/java-hash-map/</url>
      
        <content type="html"><![CDATA[<h2><span id="map-类继承图">MAP 类继承图</span></h2><p><img src="/article/java-hash-map/1557200957110java-hash-map_.png" alt></p><h3><span id="hashmap">HashMap：</span></h3><ul><li>KV结构，高效</li><li>无序</li><li>key为null，但是只允许有一个key为null，再次说明，</li><li>HashMap不是线程安全的。</li></ul><h3><span id="linkedhashmap">LinkedHashMap：</span></h3><p>LinkedHashMap是HashMap的子类，它将保持记录的插入顺序。</p><h3><span id="treemap">TreeMap：</span></h3><p>TreeMap实现了SortedMap接口，很明显，他将对插入的记录排序，</p><h2><span id="hashmap-内部结构">HashMap 内部结构</span></h2><p>首先来看一下HashMap内部结构是什么样子的。通过观察源码，可以发现HashMap在实现上使用了数组+链表+红黑树三种数据结构</p><p><img src="/article/java-hash-map/1557201231442java-hash-map_.png" alt></p><p>HashMap是通过计算key的hashCode来找到记录的存储位置的，那因为hash函数不会台完美的原因，势必要造成多个记录的key的hashCode一样的情况，上图展示了这种情况，完美情况下，我们希望每一个数组位置上仅有一个记录，但是很多情况下一个数组位置上会落入多个记录，也就是哈希冲突。<br>解决哈希冲突的方法主要有开发地址和链地址，HashMap采用了后者，将hashCode相同的记录放在同一个数组位置上，多个hashCode相同的记录被存储在一条链表上，我们知道，链表上的查询复杂的为O(N)，当这个N很大的时候也就成了瓶颈，所以HashMap在链表的长度大于8的时候就会将链表转换为红黑树这种数据结构，红黑树的查询效率高达O(lgN)，也就是说，复杂度降了一个数量级，完全可以适用于实际生产环境。下面是链表节点数据结构的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//哈希值，HashMap用这个值来确定记录的位置</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">//记录key</span></span><br><span class="line">        V value; <span class="comment">//记录value</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">//链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是上面图中展示的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>这个table就是存储数据的数组，上面图中的每个黑色的球是一个Node。下面展示了几个重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="keyword">int</span> threshold;    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;   </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，HashMap的哈希桶table的大小必须为2的n次方，也就是说必须为合数，初始大小为16，下文中将会说明为什么一定要是2的n次方。size字段的意思是当前记录数量，loadFactor是负载因子，默认为0.75，而threshold是作为扩容的阈值而存在的，它是由负载银子决定的。下面的方法是返回与给定数值最接近的2的n次方的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2><span id="hashmap如何确定记录的table位置">HashMap如何确定记录的table位置</span></h2><p>下面的方法hash展示了HashMap是如何计算记录的hashCode值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的hash方法仅仅是第一步，它只是计算出了hashCode值，但是还可以确定table中的index，接下来的一步需要做的就是根据hashCode来定位index，也就是需要对hashCode取模（hashCode % length），length是table的长度，但是我们知道，取模运算是较为复杂的计算，是非常耗时的计算，那有没有方法不通过取模计算而达到取模的效果呢，答案是肯定的，上文中提到，table的长度必然是2的n次方，这点很重要，HashMap通过设定table的长度为2的n次方，在取模的时候就可以通过下面的算法来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = hashCode &amp; (length -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在length总是2的n次方的前提下，上面的算法等效于hashCode%length，但是现在通过使用&amp;代替了%，而&amp;的效率要远比%高</p><h2><span id="hashmap插入元素的过程详解">HashMap插入元素的过程详解</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>过程的详细分析</p><ul><li>首先判断table是否为null或者长度为0，如果是，那么调用方法resize来初始化table，resize的细节将在下文中进行分析，这个方法用来对HashMap的table数组扩容，它将发生在初始化table以及table中的记录数量达到阈值之后。</li><li>然后计算记录的hashCode，以及根据上文中提到的方法来计算记录在table中的index，如果发现index未知上为null，则调用newNode来创建一个新的链表节点，然后放在table的index位置上，此时表面没有哈希冲突。</li><li>如果table的index位置不为空，那么说明造成了哈希冲突，这时候如果记录和index位置上的记录相等，则直接覆盖，否则继续判断</li><li>如果index位置上的节点TreeNode，如果是，那么说明此时的index位置上是一颗红黑树，需要调用putTreeVal方法来将这新的记录插入到红黑树中去。否则走下面的逻辑。</li><li>如果index位置上的节点类型不是TreeNode，那么说明此位置上的哈希冲突还没有达到阈值，还是一个链表结构，那么就根据插入链表插入新节点的算法来找到合适的位置插入，这里面需要注意的是，新插入的记录会覆盖老的记录，如果这个新的记录是首次插入，那么就会插入到该index位置上链表的最尾部，这里面还需要一次判断，如果插入了新的节点之后达到了阈值，那么就需要调用方法+treeifyBin来讲链表转化为红黑树。</li><li>在插入完成之后，哈希桶中记录的数量是否达到了哈希桶设置的阈值，如果达到了，那么就需要调用方法resize来扩容。</li></ul><h2><span id="hashmap扩容resize方法详解">HashMap扩容resize方法详解</span></h2><p>上文分析了HashMap的put方法的细节，其中提到，当初始化table以及记录数量达到阈值之时会触发HashMap的扩容，而扩容是通过方法resize来进行的，下面来分析一下resize方法是如何工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面展示了resize方法的细节，可以看到扩容的实现时较为复杂的，但是我们知道所谓扩容，就是新申请一个较大容量的数组table，然后将原来的table中的内容都重新计算哈希落到新的数组table中来，然后将老的table释放掉。这里面有两个关键点，一个是新哈希数组的申请以及老哈希数组的释放，另外一个是重新计算记录的哈希值以将其插入到新的table中去。首先第一个问题是，扩容会扩大到多少，通过观察上面的代码可以确定，每次扩容都会扩大table的容量为原来的两倍，当然有一个最大值，如果HashMap的容量已经达到最大值了，那么就不会再进行扩容操作了。第二个问题是HashMap是如何在扩容之后将记录从老的table迁移到新的table中来的。上文中已经提到，table的长度确保是2的n次方，那么有意思的是，每次扩容容量变为原来的两倍，那么一个记录在新table中的位置要么就和原来一样，要么就需要迁移到(oldCap + index)的位置上。下面简单来证明一下这个算法的正确性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设原来的table大小为4，那么扩容之后会变为8，那么对于一个元素A来说，如果他的hashCode值为3，那么他在原来的table</span><br><span class="line">上的位置为(3 &amp; 3) = 3,那么新位置呢？(3 &amp; 7) = 3,这种情况下元素A的index和原来的index是一致的不用变。再来看一个</span><br><span class="line">元素B，他的hashCode值为47，那么在原来table中的位置为(47 &amp; 3) = 3，在新table中的位置为(47 &amp; 7) = 7，也就</span><br><span class="line">是（3 + 4），正好偏移了oldCap个单位。</span><br></pre></td></tr></table></figure><p>之所以可以这么算是因为<br>还是上面的两个元素A和B，哈希值分别为<code>3</code>和<code>47</code>，在table长度为4的情况下，因为<code>3</code> 二进制为 <code>11</code>，所以A和B会有两位参与运算来<br>获得index，A和B的二进制分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 ： 11</span><br><span class="line">47： 101111</span><br></pre></td></tr></table></figure><p>在table的length为4的前提下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3-&gt; 11 &amp; 11 = 3</span><br><span class="line">47-&gt; 000011 &amp; 101111 = 3</span><br></pre></td></tr></table></figure><p>在扩容后，length变为8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3-&gt; 011 &amp; 111 = 3</span><br><span class="line">47-&gt; 10111 &amp; 00111 = 7</span><br></pre></td></tr></table></figure><p>对于<code>3</code>来说，新增的参与运算的位为<code>0</code>，所以index不变，而对于47来说，新增的参与运算的位为<code>1</code>，所以<br><code>index</code>需要变为(<code>index</code> + <code>oldCap</code>)</p><h2><span id="hashmap获取记录操作详解">HashMap获取记录操作详解</span></h2><p>首先，因为可能会发生哈希冲突，所以我们需要获取的记录可能会存储在一个链表上，也可能存储在一棵红黑树上，这需要实际判断，所以，获取操作首先应该就算记录的hashCode，然后根据hashCode来计算在table中的index，然后判断该数组位置上是一条链表还是一棵红黑树，如果是链表，那么就遍历链表来找到我们需要的记录，否则如果是一棵红黑树，那么就通过遍历这棵红黑树找到我们需要的记录.</p><p>当然，寻找记录可能会找不到，因为可能我们获取的记录根本就不存在，那么就要返回null暗示用户，当然，HashMap返回null不仅可以代表没有这个记录的信息之外，还可以代表该记录key对应着的value就是null，所以你不能通过HashMap是否返回null来判断HashMap中是否有相应的记录，如果你有类似的需求，你应该调用HashMap的方法：containsKey，这个方法将在下文中进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先会获得当前table的一个快照，然后根据需要查找的记录的key的hashCode来定位到table中的index，如果该位置为null，说明没有没有记录落到该位置上，也就不存在我们查找的记录，直接返回null。如果该位置不为null，说明至少有一个记录落到该位置上来，那么就判断该位置的第一个记录是否使我们查找的记录，如果是则直接返回，否则，根据该index上是一条链表还是一棵红黑树来分别查找我们需要的记录，找到则返回记录，否则返回null。下面来看一下如何判断HashMap中是否有一个记录的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法调用了getNode来从table中获得一个Node，返回null，说明不存在该记录，否则存在，containsKey方法和get方法都是通过调用getNode方法来进行的，但是他们的区别在于get方法在判断得到的Node不为null的情况下任然可能返回null，因为Node的value可能为null，所以应该在合适的时候调用合适的方法。</p><h2><span id="hashmap删除记录详解">HashMap删除记录详解</span></h2><p>现在来看一下HashMap是如何实现删除一个记录的。下面首先展示了相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过记录的hashCode来找到他在table中的index，因为最后需要返回被删除节点的值，所以需要记录被删除的节点。当然记录被删除的节点也是有意义的，比如对于table中的index位置上为一条链表的情况来说，我们只需要记住需要删除的Node，然后真正删除的时候就可以只需要操作该node就可以了，当然对于链表的相关操作详解将在另外的篇章中进行。以及红黑树等高级数据结构的分析总结也会在新的篇章中介绍，目前只需要知道HashMap通过在合适的时候使用不同的数据结构来达到高效的目的就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(2)-- Java对象内存布局</title>
      <link href="/article/java-mem-objecat/"/>
      <url>/article/java-mem-objecat/</url>
      
        <content type="html"><![CDATA[<h1><span id="java对象内存布局">Java对象内存布局</span></h1><p>我们知道在Java中基本数据类型的大小，例如int类型占4个字节、long类型占8个字节，那么Integer对象和Long对象会占用多少内存呢？本文介绍一下Java对象在堆中的内存结构以及对象大小的计算。</p><h2><span id="对象的内存布局">对象的内存布局</span></h2><p>一个Java对象在内存中包括对象头、实例数据和补齐填充3个部分：</p><p><img src="/article/java-mem-objecat/1552620309961java-mem-objecat_.png" alt></p><h3><span id="对象头">对象头</span></h3><ul><li><strong>Mark Word</strong>：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；</li><li><strong>Class Pointer</strong>：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节；</li><li><strong>Length</strong>：如果是数组对象，还有一个保存数组长度的空间，占4个字节；</li></ul><h3><span id="对象实际数据">对象实际数据</span></h3><p>对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）。</p><table><thead><tr><th>Primitive Type</th><th>Memory Required(bytes)</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr></tbody></table><p><em>对于reference类型来说，在32位系统上占用4bytes, 在64位系统上占用8bytes。</em></p><h3><span id="对齐填充">对齐填充</span></h3><p>Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。例如，一个包含两个属性的对象：int和byte，这个对象需要占用8+4+1=13个字节，这时就需要加上大小为3字节的padding进行8字节对齐，最终占用大小为16个字节。</p><p>注意：以上对64位操作系统的描述是未开启指针压缩的情况，关于指针压缩会在下文中介绍。</p><h2><span id="对象头分析">对象头分析</span></h2><h3><span id="对象头占用空间大小">对象头占用空间大小</span></h3><p>这里说明一下32位系统和64位系统中对象所占用内存空间的大小：</p><ul><li>在32位系统下，存放Class Pointer的空间大小是4字节，MarkWord是4字节，对象头为8字节;</li><li>在64位系统下，存放Class Pointer的空间大小是8字节，MarkWord是8字节，对象头为16字节;</li><li>64位开启指针压缩的情况下，存放Class Pointer的空间大小是4字节，<code>MarkWord</code>是8字节，对象头为12字节;</li><li>如果是数组对象，对象头的大小为：数组对象头8字节+数组长度4字节+对齐4字节=16字节。其中对象引用占4字节（未开启指针压缩的64位为8字节），数组<code>MarkWord</code>为4字节（64位未开启指针压缩的为8字节）;</li><li>静态属性不算在对象大小内。</li></ul><h3><span id="对象头分析">对象头分析</span></h3><p>HotSpot虚拟机的对象头(Object Header)包括两部分信息</p><ul><li><p>第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p></li><li><p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p></li></ul><p>在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示：</p><p><img src="/article/java-mem-objecat/java-mem-objecat-223902.png" alt></p><p>在 64 位系统及 64 位 JVM 下，开启指针压缩，那么头部存放 Class 指针的空间大小还是4字节，而 Mark Word 区域会变大，变成 8 字节，也就是头部最少为 12 字节，如下表所示：</p><p><img src="/article/java-mem-objecat/java-mem-objecat-224343.png" alt></p><p>这里几个概念</p><ul><li>unused：未使用的</li><li>epoch: 验证偏向锁有效性的时间戳</li><li>cmd_free : cms垃圾收集器相关 可不用关心</li></ul><p>关于偏向锁和重量解锁等相关的，这里不做讨论， 感兴趣的请参见我另外一篇博文<a href="https://icefrozen.github.io/article/java-synchronized/" target="_blank" rel="noopener">深入分析synchronized原理和锁膨胀过程</a></p><h3><span id="直观的观察">直观的观察</span></h3><p>我们使用JOL 工具来查看一下一个对象的真是内存布局。有关<a href="https://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">JOL</a>的信息。</p><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LayOutDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        objectLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========Object layout==========="</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        String s = ClassLayout.parseInstance(obj).toPrintable();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加入JVM参数<ul><li>-XX:-UseCompressedClassPointers</li><li>-XX:-UseCompressedOops</li></ul></li></ul><blockquote><p>这里是关闭类指针压缩和成员变量的指针压缩，关于指针压缩后面或详细分析，为了使得我们的实验不受到指针压缩的硬性，我们默认项关闭这两个指针压缩选项。</p></blockquote><ul><li>执行并得到输出如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">    <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">2</span>c ad <span class="number">0</span>d (<span class="number">00000000</span> <span class="number">00101100</span> <span class="number">10101101</span> <span class="number">00001101</span>) (<span class="number">229452800</span>)</span><br><span class="line">    <span class="number">12</span>    <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure><p>我们来分析一下</p><table><thead><tr><th>OFFSET</th><th>SIZE</th><th>TYPE DESCRIPTION</th><th>VALUE</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>(object header)</td><td>01 00 00 00 (<code>00000001</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (1)</td></tr><tr><td>4</td><td>4</td><td>(object header)</td><td>00 00 00 00 (<code>00000000</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (0)</td></tr><tr><td>8</td><td>4</td><td>(object header)</td><td>00 2c ad 0d (<code>00000000</code> <code>00101100</code> <code>10101101</code> <code>00001101</code>) (229452800)</td></tr><tr><td>12</td><td>4</td><td>(object header)</td><td>01 00 00 00 (<code>00000001</code> <code>00000000</code> <code>00000000</code> <code>00000000</code>) (1)</td></tr></tbody></table><p>按照大小端重新排列一下得到：<br><strong>由于我们是64位的系统，所以，我们的前8个字节位mark （64bit）结构如下</strong></p><p><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</code></p><p>可以做如下划分：</p><table><thead><tr><th>0 - 55（56bit）</th><th>cms_free</th><th>分带年龄</th><th>偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>00000000 00000000 00000000 00000000 00000000 00000000 00000000</td><td>0</td><td>0000</td><td>0</td><td>01</td></tr></tbody></table><p>后面8个字节如下(Class Pointer)表示对象的类的指针。</p><p><code>00001101 10101101 00101100 00000000 00000001 00000000 00000000 00000000</code></p><ul><li>这里我们看到mark word 是无所状态，但是并没存贮hashcode。这是因为，如果我们要存入hashcode，必须要执行一次hascode代码，我们修改上述代码为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"=========Object layout==========="</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(<span class="string">"hash code:"</span> + hashCode + <span class="string">":"</span> + Integer.toBinaryString(hashCode));</span><br><span class="line">        String s = ClassLayout.parseInstance(obj).toPrintable();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash code:<span class="number">1581781576</span>:<span class="number">1011110010010000001001001001000</span></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">48</span> <span class="number">12</span> <span class="number">48</span> (<span class="number">00000001</span> <span class="number">01001000</span> <span class="number">00010010</span> <span class="number">01001000</span>) (<span class="number">1209157633</span>)</span><br><span class="line">    <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01011110</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">94</span>)</span><br><span class="line">    <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">7</span>c <span class="number">1</span>c <span class="number">0</span>e (<span class="number">00000000</span> <span class="number">01111100</span> <span class="number">00011100</span> <span class="number">00001110</span>) (<span class="number">236747776</span>)</span><br><span class="line">    <span class="number">12</span>    <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure><p>我们依然按照上面的来划分得到：</p><table><thead><tr><th>0 - 23</th><th>24-55（56bit） hashcode</th><th>cms_free</th><th>分带年龄</th><th>偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>00000000 00000000 00000000</td><td>0<code>1011110 01001000 00010010 01001000</code></td><td>0</td><td>0000</td><td>0</td><td>01</td></tr></tbody></table><p>而：<code>hash code:1581781576:1011110010010000001001001001000</code><br>由此我们可以得到结论 在对象头的 24-55 位的bit 存放的是 hashcode值。</p><h2><span id="指针压缩">指针压缩</span></h2><p>从上文的分析中可以看到，64位JVM消耗的内存会比32位的要多大约1.5倍，这是因为对象指针在64位JVM下有更宽的寻址。对于那些将要从32位平台移植到64位的应用来说，平白无辜多了1/2的内存占用，这是开发者不愿意看到的。</p><p>从JDK 1.6 update14开始，64位的JVM正式支持了 -XX:+UseCompressedOops 这个可以压缩指针，起到节约内存占用的新参数。</p><p>我们刚才在启动的虚拟机上增加了两个选项：</p><ul><li>UseCompressedOops：普通对象指针压缩</li><li>UseCompressedClassPointers：类指针压缩</li></ul><h3><span id="什么是oop">什么是OOP？</span></h3><p>OOP的全称为：Ordinary Object Pointer，就是普通对象指针。启用CompressOops后，会压缩的对象：</p><ul><li>每个Class的属性指针（静态成员变量）；</li><li>每个对象的属性指针；</li><li>普通对象数组的每个元素指针。</li></ul><p>当然，压缩也不是所有的指针都会压缩，对一些特殊类型的指针，JVM是不会优化的，例如指向PermGen的Class对象指针、本地变量、堆栈元素、入参、返回值和NULL指针不会被压缩。</p><h3><span id="启用指针压缩"> 启用指针压缩</span></h3><p>在Java程序启动时增加JVM参数：<code>-XX:+UseCompressedOops</code>来启用。</p><p><em>注意：32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。</em></p><p>本文中使用的是JDK 1.8，默认该参数就是开启的。</p><h3><span id="usecompressedclasspointers-与-usecompressedoops">UseCompressedClassPointers 与 UseCompressedOops</span></h3><p>由于UseCompressedClassPointers的开启是依赖于UseCompressedOops的开启。因此，要使UseCompressedClassPointers起作用，得先开启UseCompressedOops，并且开启UseCompressedOops 也默认开启UseCompressedClassPointers，关闭UseCompressedOops 默认关闭UseCompressedClassPointers。</p><p>如果开启了  UseCompressedClassPointers 但是关闭额 UseCompressedOops</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCompressedClassPointers -XX:-UseCompressedOops</span><br><span class="line"><span class="comment">// java 虚拟机会报错</span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: UseCompressedClassPointers <span class="keyword">requires</span> UseCompressedOops</span></span><br></pre></td></tr></table></figure><h3><span id="观察开启指针压缩时的对象大小">观察开启指针压缩时的对象大小</span></h3><p>增加 <code>-XX:+UseCompressedClassPointers -XX:+UseCompressedOops</code><br>再次运行 objectLayout 方法<br>得到输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><p>我们看到了有这么一句话 loss due to the next object alignment<br>表示的是 从12 开始 有4个B 用于对齐。所有开启针织压缩后 对于类指针由8个字节压缩到了4个字节。</p><h3><span id="其他方式查看对象大小">其他方式查看对象大小</span></h3><blockquote><p>我们也可以使用<a href="http://www.javamex.com/" target="_blank" rel="noopener">http://www.javamex.com/</a>中提供的<a href="http://www.javamex.com/classmexer/classmexer-0_03.zip" target="_blank" rel="noopener">classmexer.jar</a>来计算对象的大小。 具体用法需加上-javaagent 参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行环境：JDK 1.8，Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line"></span><br><span class="line">[](#基本数据类型 &quot;基本数据类型&quot;)基本数据类型</span><br><span class="line">---</span><br><span class="line">对于基本数据类型来说，是比较简单的，因为我们已经知道每个基本数据类型的大小。代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line">  * VM options:</span><br><span class="line">  * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span><br><span class="line">  * -XX:+UseCompressedOops</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class TestObjectSize &#123;</span><br><span class="line">    int a;</span><br><span class="line">    long b;</span><br><span class="line">    static int c;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        TestObjectSize testObjectSize = new TestObjectSize();</span><br><span class="line">        // 打印对象的shallow size</span><br><span class="line">        System.out.println(&quot;Shallow Size: &quot; \+ MemoryUtil.memoryUsageOf(testObjectSize) + &quot; bytes&quot;);</span><br><span class="line">        // 打印对象的 retained size</span><br><span class="line">        System.out.println(&quot;Retained Size: &quot; \+ MemoryUtil.deepMemoryUsageOf(testObjectSize) + &quot; bytes&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：在运行前需要设置javaagent参数，在JVM启动参数中添加<code>-javaagent:/path_to_agent/classmexer.jar</code>来运行。</em></p><p>有关Shallow Size和Retained Size请参考<a href="http://blog.csdn.net/e5945/article/details/7708253" target="_blank" rel="noopener">http://blog.csdn.net/e5945/article/details/7708253</a>。</p><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>运行查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>根据上文的分析可以知道，64位开启指针压缩的情况下：</p><ul><li>对象头大小=Class Pointer的空间大小为4字节+<code>MarkWord</code>为8字节=12字节；</li><li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）<br>在MAT中分析的结果如下：<br><img src="/article/java-mem-objecat/%5B!%5Bdump1.png%5D(/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/dump1.png)%5D(/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/dump1.png)java-mem-objecat_.png" alt></li></ul><p>所以大小是24字节。其实这里并没有padding，因为正好是24字节。如果我们把<code>long b;</code>换成<code>int b;</code>之后，再来看一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>大小并没有变化，说明这里做了padding，并且padding的大小是4字节。<br>这里的Shallow Size和Retained Size是一样的，因为都是基本数据类型。</p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>如果要关闭指针压缩，在JVM参数中添加<code>-XX:-UseCompressedOops</code>来关闭，再运行上述代码查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><p>分析一下在64位未开启指针压缩的情况下：</p><ul><li>对象头大小=Class Pointer的空间大小为8字节+<code>MarkWord</code>为8字节=16字节；</li><li>实际数据大小=int类型4字节+long类型8字节=12字节（静态变量不在计算范围之内）；</li></ul><p>这里计算后大小为16+12=28字节，这时候就需要padding来补齐了，所以padding为4字节，最后的大小就是32字节。</p><p>我们再把<code>long b;</code>换成<code>int b;</code>之后呢？通过上面的计算结果可以知道，实际数据大小就应该是int类型4字节+int类型4字节=8字节，对象头大小为16字节，那么不需要做padding，对象的大小为24字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure><h3><span id="数组类型">数组类型</span></h3><p>64位系统中，数组对象的对象头占用24 bytes，启用压缩后占用16字节。比普通对象占用内存多是因为需要额外的空间存储数组的长度。基础数据类型数组占用的空间包括数组对象头以及基础数据类型数据占用的内存空间。由于对象数组中存放的是对象的引用，所以数组对象的Shallow Size=数组对象头+length _引用指针大小，Retained Size=Shallow Size+length_每个元素的Retained Size。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">16</span> bytes</span><br><span class="line">Retained Size: <span class="number">80</span> bytes</span><br></pre></td></tr></table></figure><p>Shallow Size比较简单，这里对象头大小为12字节， 实际数据大小为4字节，所以Shallow Size为16。</p><p>对于Retained Size来说，要计算数组占用的大小，对于数组来说，它的对象头部多了一个用来存储数组长度的空间，该空间大小为4字节，所以<em><em>数组对象的大小=引用对象头大小12字节+存储数组长度的空间大小4字节+数组的长度</em>数组中对象的Retained Size+padding大小</em>*</p><p>下面分析一下上述代码中的<code>long[] arr = new long[6];</code>，它是一个长度为6的long类型的数组，由于long类型的大小为8字节，所以数组中的实际数据是6*8=48字节，那么数组对象的大小=12+4+6*8+0=64，最终的Retained Size=Shallow Size + 数组对象大小=16+64=80。</p><p>通过MAT查看如下：<br><img src="/article/java-mem-objecat/1552621324467java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">96</span> bytes</span><br></pre></td></tr></table></figure><p>这个结果大家应该能自己分析出来了，因为这时引用对象头为16字节，那么数组的大小=<code>16+4+6*8+4=72</code>，（这里最后一个4是padding），所以Retained Size=Shallow Size + 数组对象大小=<code>24+72=96</code>。<br>通过MAT查看如下：</p><p><img src="/article/java-mem-objecat/1552621398448java-mem-objecat_.png" alt></p><h3><span id="包装类型">包装类型</span></h3><p>包装类（Boolean/Byte/Short/Character/Integer/Long/Double/Float）占用内存的大小等于对象头大小加上底层基础数据类型的大小。</p><p>包装类型的Retained Size占用情况如下：</p><table><thead><tr><th>Numberic Wrappers</th><th>+useCompressedOops</th><th>-useCompressedOops</th></tr></thead><tbody><tr><td>Byte, Boolean</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Short, Character</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Integer, Float</td><td>16 bytes</td><td>24 bytes</td></tr><tr><td>Long, Double</td><td>24 bytes</td><td>24 bytes</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    Boolean a = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line">    Byte b = <span class="keyword">new</span> Byte(<span class="string">"1"</span>);</span><br><span class="line">    Short c = <span class="keyword">new</span> Short(<span class="string">"1"</span>);</span><br><span class="line">    Character d = <span class="keyword">new</span> Character(<span class="string">'a'</span>);</span><br><span class="line">    Integer e = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Float f = <span class="keyword">new</span> Float(<span class="number">2.5</span>);</span><br><span class="line">    Long g = <span class="keyword">new</span> Long(<span class="number">123L</span>);</span><br><span class="line">    Double h = <span class="keyword">new</span> Double(<span class="number">2.5</span>D);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">48</span> bytes</span><br><span class="line">Retained Size: <span class="number">192</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621628680java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">80</span> bytes</span><br><span class="line">Retained Size: <span class="number">272</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621649963java-mem-objecat_.png" alt></p><h3><span id="string类型">String类型</span></h3><p>在JDK1.7及以上版本中，<code>java.lang.String</code>中包含2个属性，一个用于存放字符串数据的char[], 一个int类型的hashcode, 部分源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    /\*\* Cache the hash code <span class="keyword">for</span> the string */</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在关闭指针压缩时，一个String对象的大小为：</p><ul><li><p><strong>Shallow Size=对象头大小16字节+int类型大小4字节+数组引用大小8字节+padding4字节=32字节</strong>；</p></li><li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p></li></ul><p>在开启指针压缩时，一个String对象的大小为：</p><ul><li><p><strong>Shallow Size=对象头大小12字节+int类型大小4字节+数组引用大小4字节+padding4字节=24字节</strong>；</p></li><li><p><strong>Retained Size=Shallow Size+char数组的Retained Size</strong>。</p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * VM options:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * -javaagent:/Users/sangjian/dev/source-files/classmexer-0_03/classmexer.jar</span></span><br><span class="line"><span class="comment"> * -XX:+UseCompressedOops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectSize</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"test"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestObjectSize testObjectSize = <span class="keyword">new</span> TestObjectSize();</span><br><span class="line">        <span class="comment">// 打印对象的shallow size</span></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span> + MemoryUtil.memoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="comment">// 打印对象的 retained size</span></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(testObjectSize) + <span class="string">" bytes"</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="开启指针压缩的情况">开启指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shallow Size: <span class="number">16</span> bytes</span><br><span class="line">Retained Size: <span class="number">64</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552621814345java-mem-objecat_.png" alt></p><h4><span id="关闭指针压缩的情况">关闭指针压缩的情况</span></h4><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shallow Size: <span class="number">24</span> bytes</span><br><span class="line">Retained Size: <span class="number">88</span> bytes</span><br></pre></td></tr></table></figure><p>MAT中的结果如下：</p><p><img src="/article/java-mem-objecat/1552622306091java-mem-objecat_.png" alt></p><h3><span id="其他引用类型的大小">其他引用类型的大小</span></h3><p>根据上面的分析，可以计算出一个对象在内存中的占用空间大小情况，其他的引用类型可以参考分析计算过程来计算内存的占用情况。</p><h2><span id="关于padding">关于padding</span></h2><p>思考这样一个问题，是不是padding都加到对象的后面呢，如果对象头占12个字节，对象中只有1个long类型的变量，那么该long类型的变量的偏移起始地址是在12吗？用下面一段代码测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用Unsafe类来查看变量的偏移地址，运行后结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>如果是换成int类型的变量呢？结果是12。</p><p>现在一般的CPU一次直接操作的数据可以到64位，也就是8个字节，那么字长就是64，而long类型本身就是占64位，如果这时偏移地址是12，那么需要分两次读取该数据，而如果偏移地址从16开始只需要通过一次读取即可。int类型的数据占用4个字节，所以可以从12开始。</p><p>把上面的代码修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">byte</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line"></span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("b")));</span><br><span class="line"></span><br><span class="line">        System.out.println(UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("c")));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p>在本例中，如果变量的大小小于等于4个字节，那么在分配内存的时候会先优先分配，因为这样可以减少padding，比如这里的b和c变量；如果这时达到了16个字节，那么其他的变量按照类型所占内存的大小降序分配。</p><p>再次修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM options: -javaagent:D:\\source-files\\classmexer.jar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ALL"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> a;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">long</span> g;</span><br><span class="line">    <span class="keyword">double</span> h;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println("field a --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("a")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field b --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("b")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field c --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("c")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field d --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("d")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field e --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("e")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field f --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("f")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field g --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("g")));</span><br><span class="line"></span><br><span class="line">        System.out.println("field h --&gt; "+ UNSAFE.objectFieldOffset(PaddingTest.class.getDeclaredField("h")));</span><br><span class="line"></span><br><span class="line">        PaddingTest paddingTest = <span class="keyword">new</span> PaddingTest();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Shallow Size: "</span>+ MemoryUtil.memoryUsageOf(paddingTest));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Retained Size: "</span> + MemoryUtil.deepMemoryUsageOf(paddingTest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">field a --&gt; <span class="number">40</span></span><br><span class="line">field b --&gt; <span class="number">41</span></span><br><span class="line">field c --&gt; <span class="number">36</span></span><br><span class="line">field d --&gt; <span class="number">38</span></span><br><span class="line">field e --&gt; <span class="number">12</span></span><br><span class="line">field f --&gt; <span class="number">32</span></span><br><span class="line">field g --&gt; <span class="number">16</span></span><br><span class="line">field h --&gt; <span class="number">24</span> </span><br><span class="line">Shallow Size: <span class="number">48</span></span><br><span class="line">Retained Size: <span class="number">48</span></span><br></pre></td></tr></table></figure><p>可以看到，先分配的是int类型的变量e，因为它正好是4个字节，其余的都是先从g和h变量开始分配的，因为这两个变量是long类型和double类型的，占64位，最后分配的是a和b，它们只占一个字节。</p><p>如果分配到最后，这时字节数不是8的倍数，则需要padding。这里实际的大小是42字节，所以padding6字节，最终占用48字节。</p><h2><span id="原文地址">原文地址</span></h2><p><img src="http://www.ideabuffer.cn/2017/05/06/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" alt="http://www.ideabuffer.cn/2017/05/06/Java对象内存布局/"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存模型篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
